{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"src/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"src/images/logo.png","path":"images/logo.png","modified":0,"renderable":0},{"_id":"src/images/wx.png","path":"images/wx.png","modified":0,"renderable":0},{"_id":"themes/vue/source/css/benchmark.styl","path":"css/benchmark.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/search.styl","path":"css/search.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/page.styl","path":"css/page.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/images/check.png","path":"images/check.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/feed.png","path":"images/feed.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/down.png","path":"images/down.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/github.png","path":"images/github.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons.png","path":"images/icons.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/menu.png","path":"images/menu.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/search.png","path":"images/search.png","modified":0,"renderable":1},{"_id":"themes/vue/source/js/common.js","path":"js/common.js","modified":0,"renderable":1},{"_id":"themes/vue/source/js/smooth-scroll.min.js","path":"js/smooth-scroll.min.js","modified":0,"renderable":1},{"_id":"themes/vue/source/js/vue.min.js","path":"js/vue.min.js","modified":0,"renderable":1},{"_id":"src/images/zfb.jpg","path":"images/zfb.jpg","modified":0,"renderable":0},{"_id":"themes/vue/source/js/vue.js","path":"js/vue.js","modified":0,"renderable":1}],"Cache":[{"_id":"src/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481537919000},{"_id":"src/.DS_Store","hash":"a9477ae80b4a8b9a37448eb9e155a3a0653a7f54","modified":1481560645000},{"_id":"src/index.md","hash":"fd945de1e31344f0d8be59bcc87e3f5fda468e11","modified":1481458830000},{"_id":"themes/vue/.DS_Store","hash":"ff0949507754415a293af4cdbc9f6b2b0d8647c1","modified":1481560550000},{"_id":"themes/vue/_config.yml","hash":"c9f052730c4dfc964557e250f92d30aa8d4697e2","modified":1481458830000},{"_id":"src/_posts/012-release.md","hash":"5eaddce1a3a6544568c6cd965c27ed2329926d1e","modified":1481458830000},{"_id":"src/_posts/011-component.md","hash":"9ad67d44196fdc224c27e14b67fa4f83ffac7fd5","modified":1481458830000},{"_id":"src/_posts/1.0.0-release.md","hash":"f530bc04b8a0635fdbc8f2659fb1129cf02c233b","modified":1481458830000},{"_id":"src/_posts/announcing-2.0.md","hash":"32c4bd9cfa02cf9bd79232b4718e4d42d85e14c3","modified":1481458830000},{"_id":"src/_posts/vue-011-release.md","hash":"2be60f8115795ffb2047b6a2d4e18fe2477cd517","modified":1481458830000},{"_id":"src/_posts/vue-cli.md","hash":"20c913472a116c717f0a9d3d8fd174764fd5b417","modified":1481458830000},{"_id":"src/_posts/common-gotchas.md","hash":"fdc42c53acb3bd180bf0ad12b9cc8b9916a0a46f","modified":1481458830000},{"_id":"src/_posts/vue-next.md","hash":"c0e00533cc21804792410fe34b1b9f4903683612","modified":1481458830000},{"_id":"src/_posts/march-update.md","hash":"35317ee656c5ff190db107fdb48f57c3761c0bb8","modified":1481458830000},{"_id":"src/_posts/why-no-template-url.md","hash":"b62a1f01eaa924cf3aa3d1bd5f7e721604fe8cca","modified":1481458830000},{"_id":"src/about/index.md","hash":"6a004205a610870e47155f0370c30de0260304dc","modified":1481548181000},{"_id":"src/_posts/vuejs-010-release.md","hash":"d89462ea33e99c8869a7d1445a2c7a26c95146bb","modified":1481458830000},{"_id":"src/about/guide.md","hash":"0ec5708597e323ab43c9af6d0395fc87b4105686","modified":1481548159000},{"_id":"src/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1481560645000},{"_id":"src/images/logo.png","hash":"a11b8d7ae3fe9792cda482165b51a0dc9f5dd929","modified":1480756089000},{"_id":"src/study/.DS_Store","hash":"0c49eb67a65f113283609ac835e1c2deb02a74c0","modified":1481560535000},{"_id":"src/support-me/index.md","hash":"ca75bc802622118e50389cdd6b783579de0c65bd","modified":1481549114000},{"_id":"themes/vue/layout/index.ejs","hash":"5802c3aaa8e2107d23b9e5eedd83e2cf9885b4f6","modified":1481547593000},{"_id":"themes/vue/layout/layout.ejs","hash":"c6f84c523d3ea8ef7951ca7b404898e6912f176f","modified":1481547897000},{"_id":"themes/vue/layout/.DS_Store","hash":"b2974a5f3ab04d291ce2cf4a27b6c962d2f73287","modified":1481560535000},{"_id":"themes/vue/layout/page.ejs","hash":"77aaf41759bcc0b54dc3a3b4e346746c0a3bad72","modified":1481546933000},{"_id":"themes/vue/layout/post.ejs","hash":"aa03915a3540de78cfe8fe1c8f9e897974bf35a0","modified":1481458830000},{"_id":"themes/vue/source/.DS_Store","hash":"6bb10a6a927a3485cca1d10341685ec53965dfcf","modified":1481560535000},{"_id":"src/images/wx.png","hash":"f7210ddec02195aedb4d7c2e351fe63f4c4c6b01","modified":1480770057000},{"_id":"themes/vue/layout/partials/ad.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481458830000},{"_id":"themes/vue/layout/partials/ga.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481458830000},{"_id":"src/study/java/one.md","hash":"e113474ca826f86a2df1db08c0e87a51bfce0461","modified":1481601111000},{"_id":"src/study/java/index.md","hash":"dc67c3a22b1fff0721be333f51d7fb01a9e7c6b2","modified":1481601354000},{"_id":"src/study/java/two.md","hash":"7b7d340301ef7dd3494644670d495648d12b4311","modified":1481601111000},{"_id":"src/study/java/three.md","hash":"d0569ac38b51a10b4b974b1d0022c6c1b0434fda","modified":1481601111000},{"_id":"src/study/java/zero.md","hash":"dd4b860be0f786f7aea4d761e73b91f34fd5b079","modified":1481601111000},{"_id":"src/study/linux/index.md","hash":"ada86d06bf3bdd615b4935ae109a67dff7a6704c","modified":1481619862000},{"_id":"src/study/linux/one.md","hash":"6413f39cef6c5d0d1c30ad3123677865666ab763","modified":1481546322000},{"_id":"src/study/linux/three.md","hash":"c8c903a8af139a733f307ca2e911fb46785fc530","modified":1481619504000},{"_id":"src/study/linux/two.md","hash":"eeff5a7fdf1b505a1e59207f9afdff2ce27c422a","modified":1481619862000},{"_id":"src/study/nodejs/index.md","hash":"4796db523cee09a5bf95c176f609a2418b0c43ec","modified":1481546768000},{"_id":"src/study/nodejs/one.md","hash":"b0649785a06c2f1d26b934822deb9921cb6039a0","modified":1481546891000},{"_id":"src/v2/cookbook/adding-instance-properties.md","hash":"3765600e670a0536d0485c611337b142ba65879f","modified":1481458830000},{"_id":"src/v2/cookbook/index.md","hash":"feaa6cea9fe7d45f60098f35009ae8d7187d430d","modified":1481458830000},{"_id":"src/v2/api/index.md","hash":"5d1beeee2baac74db11b7bbb062f519be5dc5b86","modified":1481458830000},{"_id":"src/v2/examples/commits.md","hash":"b4c7d92180e53fb51095353bc21503401c57547d","modified":1481458830000},{"_id":"src/v2/examples/elastic-header.md","hash":"f15fc680591e1082727663839b3662cb8d92413e","modified":1481458830000},{"_id":"src/v2/examples/hackernews.md","hash":"e72b3396e17e52e13087403397fcf326f06848f5","modified":1481458830000},{"_id":"src/v2/examples/firebase.md","hash":"021f95fe1f7be65699aeaccb2c91b9c1bd3531fb","modified":1481458830000},{"_id":"src/v2/examples/grid-component.md","hash":"bb498208c576861777413e2a10087f0dee03d219","modified":1481458830000},{"_id":"src/v2/examples/index.md","hash":"7307fc55acd813ce226f03f882d5432d2c649fdd","modified":1481458830000},{"_id":"src/v2/examples/modal.md","hash":"3e118b1d2fe7ea6262ecf2db32f48c4d43065a41","modified":1481458830000},{"_id":"src/v2/examples/select2.md","hash":"b40500abe603b82d19497d418bb3bfcce82b9203","modified":1481458830000},{"_id":"src/v2/examples/svg.md","hash":"095e947cdd93e1fa499e75566e35eea4e3dd64c6","modified":1481458830000},{"_id":"src/v2/examples/todomvc.md","hash":"28a7ca6a39a9ded9e04cdc9a61162d688c90dad4","modified":1481458830000},{"_id":"src/v2/examples/tree-view.md","hash":"54e7458811f288582ac0a4b4e89c55add510d237","modified":1481458830000},{"_id":"src/v2/guide/class-and-style.md","hash":"4cfd448521a8427f9007c9fb117718653bd830e4","modified":1481458830000},{"_id":"src/v2/guide/comparison.md","hash":"c1c454fe79b247726dec10a5b9918f14559c1bcf","modified":1481458830000},{"_id":"src/v2/guide/components.md","hash":"19194cd89200e6c69f8cf36163a916fce60a3dbb","modified":1481458830000},{"_id":"src/v2/guide/computed.md","hash":"bd587008fedd4f0f7449f95bd531750714728a5d","modified":1481458830000},{"_id":"src/v2/guide/conditional.md","hash":"535b85f93e0f564aa5804f7973457e2bd2fefd65","modified":1481458830000},{"_id":"src/v2/guide/deployment.md","hash":"163bf416590a98a293178b877d98e58bd8a91bfa","modified":1481458830000},{"_id":"src/v2/guide/custom-directive.md","hash":"55702028a8a44cd1ddabe54c6e9894774e0874cd","modified":1481458830000},{"_id":"src/v2/guide/events.md","hash":"605cc162d2c43f3a09d208279eac062e953ab9ac","modified":1481458830000},{"_id":"src/v2/guide/forms.md","hash":"55c41389bcf05ff1a7732d32c46ffc52ff8aa2b1","modified":1481458830000},{"_id":"src/v2/guide/index.md","hash":"96128d8bcccf2dd9102039244230d246a4ee8b5e","modified":1481458830000},{"_id":"src/v2/guide/installation.md","hash":"8216ea691a5ab3b9078558be1aa0205da7fca001","modified":1481458830000},{"_id":"src/v2/guide/join.md","hash":"286fb63a728c441ef7aed62b3f39fb48f9c766f4","modified":1481458830000},{"_id":"src/v2/guide/instance.md","hash":"f9410b6be577b00ece55f26772a562252b9cd3ed","modified":1481458830000},{"_id":"src/v2/guide/list.md","hash":"106be4cd7e51ee294f390e72aa8ee309e71cd045","modified":1481458830000},{"_id":"src/v2/guide/migration-vue-router.md","hash":"49e8807c4830fcb89140d4eb9b0a1e31e797a159","modified":1481458830000},{"_id":"src/v2/guide/migration-vuex.md","hash":"745d2c9bb84306acb247fd740f54fc16da3e18cf","modified":1481458830000},{"_id":"src/v2/guide/mixins.md","hash":"6cf61d1685dbb320aabc773312fb945fa4e68282","modified":1481458830000},{"_id":"src/v2/guide/plugins.md","hash":"05428c187536ff6eaf74997807e194e2a5f31469","modified":1481458830000},{"_id":"src/v2/guide/migration.md","hash":"d4e1e083752ae1f6ee01bdd6e96f2626bde8fd1d","modified":1481458830000},{"_id":"src/v2/guide/reactivity.md","hash":"43b2aeb5d4fb15becc7e00c8e7bbfe85124a8b57","modified":1481458830000},{"_id":"src/v2/guide/render-function.md","hash":"263672bbb3e2db048e62153a87b65e529fd009a7","modified":1481458830000},{"_id":"src/v2/guide/routing.md","hash":"2edc7254838645b73614e37a93884b1e02ff7ff9","modified":1481458830000},{"_id":"src/v2/guide/single-file-components.md","hash":"f2010cefc56d3a926b1558c8b0a812dbdbacb0b9","modified":1481458830000},{"_id":"src/v2/guide/state-management.md","hash":"a681cb5b3a5e273dad4e13866684cc5e7d7615d6","modified":1481458830000},{"_id":"src/v2/guide/ssr.md","hash":"48c9874e239316d6226b26fa2c67b5ef409a4cec","modified":1481458830000},{"_id":"src/v2/guide/syntax.md","hash":"52d4ab629aad2d79526448705a549e7202b05f6d","modified":1481458830000},{"_id":"src/v2/guide/transitioning-state.md","hash":"9352ad741a6d03b55f8885bda115769ca394e0fc","modified":1481458830000},{"_id":"src/v2/guide/unit-testing.md","hash":"c4fd7ab9054f8114b5803563c7174b5cbc8bb832","modified":1481458830000},{"_id":"src/v2/guide/transitions.md","hash":"0a11612d0c7b0a0926d5bc49a8dd89ec32b4d848","modified":1481458830000},{"_id":"themes/vue/layout/partials/community_dropdown.ejs","hash":"70c14574e6d9864743e8a7e70341fc1588ac6b53","modified":1481604177000},{"_id":"themes/vue/layout/partials/contributors.ejs","hash":"cdab8ca978571e78ad2a49bfbe7094d457ac0b29","modified":1481543877000},{"_id":"themes/vue/layout/partials/header.ejs","hash":"f4bf4e2172838abb985a1a5881ec8aa3a6d9da86","modified":1481543304000},{"_id":"themes/vue/layout/partials/language_dropdown.ejs","hash":"6d9ce9bf41e257d8d790f05430737ac14429f5db","modified":1481458830000},{"_id":"themes/vue/layout/partials/ecosystem_dropdown.ejs","hash":"4a8feff8e2e153a17d70c9bb8e6a990082c74214","modified":1481458830000},{"_id":"themes/vue/layout/partials/main_menu.ejs","hash":"fea710c99c7d30fcf51b65c1191fdb69dbb4eda9","modified":1481548044000},{"_id":"themes/vue/layout/partials/sidebar.ejs","hash":"32fc054a91a982a02f0db2cbf860f9268bb97b6f","modified":1481547135000},{"_id":"themes/vue/layout/partials/sponsors.ejs","hash":"2e14987740a3c3ff5ff5c3f1b3a1b86890b8cef2","modified":1481458830000},{"_id":"themes/vue/source/css/_common.styl","hash":"b7fc6a54a23efdcfa154e2c95a6f8177bd18ab43","modified":1481458830000},{"_id":"themes/vue/source/css/_header.styl","hash":"b6dbced753e1a6ce0087478e46255a7d28e0f999","modified":1481458830000},{"_id":"themes/vue/source/css/_demo.styl","hash":"952a576a1887e056d70c98386b9d4eb7949ee3d2","modified":1481458830000},{"_id":"themes/vue/source/css/_migration.styl","hash":"5ea4f20818827c0d57a36a3006b736366c3b446f","modified":1481458830000},{"_id":"themes/vue/source/css/_sidebar.styl","hash":"cf214c13aa0d286de019ed16633a21a0ed5660df","modified":1481458830000},{"_id":"themes/vue/source/css/_settings.styl","hash":"c25843e8e63122df3f37f7583832ac577079d84b","modified":1481458830000},{"_id":"themes/vue/source/css/_sponsor.styl","hash":"6a4e1503b1e4f0e98e1e008ba846036fee3199aa","modified":1481458830000},{"_id":"themes/vue/source/css/_syntax.styl","hash":"edb004001fe151bebfdf63bbc250ba75777b5468","modified":1481458830000},{"_id":"themes/vue/source/css/benchmark.styl","hash":"95d4607b2b59623a673e131e1a267d0311fe89e6","modified":1481458830000},{"_id":"themes/vue/source/css/index.styl","hash":"0e7d5b0d0a07a4ada74072c8d471c16c121a59c0","modified":1481458830000},{"_id":"themes/vue/source/css/search.styl","hash":"5117f05598154cfc84da04ec1a257bd186653ba2","modified":1481458830000},{"_id":"themes/vue/source/css/page.styl","hash":"97a967a9718e5fd41136eeb115064ad3b0fa23bc","modified":1481458830000},{"_id":"themes/vue/source/images/check.png","hash":"682cf89e1802afb1dfddf07a6aed828a45b824af","modified":1481458830000},{"_id":"themes/vue/source/images/feed.png","hash":"0a746dab71dca2025f63584dbd222dc5e0707ba8","modified":1481458830000},{"_id":"themes/vue/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1481560574000},{"_id":"themes/vue/source/images/down.png","hash":"42505e12d686cf580f793bd9193acbac1e3e3a91","modified":1481458830000},{"_id":"themes/vue/source/images/github.png","hash":"238f0619c61c38ce6b589177caf66c525358062e","modified":1481007947000},{"_id":"themes/vue/source/images/icons.png","hash":"91225ef7011e59dbe6b4b9f2666133fb5e1bc976","modified":1481458830000},{"_id":"themes/vue/source/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1481458830000},{"_id":"themes/vue/source/images/logo.png","hash":"191c79a779be9e301b0f9af00bdbf606c2c20e6f","modified":1480776275000},{"_id":"themes/vue/source/images/search.png","hash":"12d664cc51b8d53c9214830bc9b92fb340526a7b","modified":1481458830000},{"_id":"themes/vue/source/js/common.js","hash":"ead9592d106a121200ef4c3d9634f78be89a70c6","modified":1481458830000},{"_id":"themes/vue/source/js/smooth-scroll.min.js","hash":"86d3196a003a5cdc673a4c6ebb75db3ceee1a1a7","modified":1481458830000},{"_id":"themes/vue/source/js/vue.min.js","hash":"cda36ef24ebbeedae37311d6e14187081ef2b4cc","modified":1481458830000},{"_id":"src/images/zfb.jpg","hash":"93442d2b05ac8ddfbd0ed2a9f0f5b17fa6b2633f","modified":1480769943000},{"_id":"themes/vue/source/js/vue.js","hash":"9f0baea28019a11d56b0a0b77f03d66578266790","modified":1481458830000},{"_id":"public/javaImprove/index.html","hash":"0ed7682ee310ebe97b2a3d2512580f0fe911104b","modified":1481620434783},{"_id":"public/javaImprove/two.html","hash":"2ed0b4cc7aaca040ceea63517d7336c9c519954d","modified":1481620435111},{"_id":"public/atom.xml","hash":"434062b9aeb4fe600cb5854f165cb4586e43613e","modified":1481620435174},{"_id":"public/index.html","hash":"435087565420ed1392bdb144e91067b7822c22fc","modified":1481620435194},{"_id":"public/about/guide.html","hash":"1ab6855845ffd905816c0e2fcc0eb44e4656d2d7","modified":1481620435194},{"_id":"public/support-me/index.html","hash":"45440c9e6f972392ec9713fd78814c6c69414592","modified":1481620435194},{"_id":"public/study/java/index.html","hash":"9986fcd34ed5bdcd44fa7dbf27be26afc72f7c98","modified":1481620435194},{"_id":"public/study/linux/index.html","hash":"ce44052fafd3ee3433721e4d4572b1d64f11d08a","modified":1481620435194},{"_id":"public/study/linux/one.html","hash":"0c2af24088b738635991c9025051f1c858a2e0d1","modified":1481620435194},{"_id":"public/study/nodejs/index.html","hash":"b349bb7463534889832fce3300f79aaa54680dba","modified":1481620435194},{"_id":"public/v2/cookbook/index.html","hash":"3de16f50e79da55d5dc2a891a747b54f387e30b1","modified":1481620435195},{"_id":"public/v2/examples/commits.html","hash":"972cb2a3637354326822511690ac7df895968236","modified":1481620435195},{"_id":"public/v2/examples/elastic-header.html","hash":"499d501c1896e76de0b1ce16028b3e62e2553513","modified":1481620435195},{"_id":"public/v2/examples/hackernews.html","hash":"ef302d39ee91360920a0e3bb60d7417cdbe88555","modified":1481620435195},{"_id":"public/v2/examples/firebase.html","hash":"ec51cfa7171865fc250aecb0d3f0fd993613a8fd","modified":1481620435195},{"_id":"public/v2/examples/grid-component.html","hash":"66ed535a94ddc97ce0d72039f3f4101bb9e702cf","modified":1481620435195},{"_id":"public/v2/examples/index.html","hash":"523bdddc936bab457afca282a903be71f8d9f2b6","modified":1481620435195},{"_id":"public/v2/examples/select2.html","hash":"fcba14baca0918212eaf38b22cb21f067eda1464","modified":1481620435195},{"_id":"public/v2/examples/modal.html","hash":"532dc8c3f78a8ddab8a02ec288066945e893642b","modified":1481620435195},{"_id":"public/v2/examples/svg.html","hash":"3fadd8d44aef4f0dd249f4ae69421812e00dcfa2","modified":1481620435195},{"_id":"public/v2/examples/todomvc.html","hash":"d9f0a954f76908c692dd1b05425bbfa4587be266","modified":1481620435195},{"_id":"public/v2/examples/tree-view.html","hash":"924b7cbd80f4e92e8aa1a8d3190216acedd5e7a9","modified":1481620435195},{"_id":"public/2015/10/28/why-no-template-url/index.html","hash":"70e5480c4ad5e3c24e48e1c78845f772c54a4249","modified":1481620435195},{"_id":"public/2014/11/09/vue-011-release/index.html","hash":"96eec28f654c6b5e7702a486f0eed6f28a389834","modified":1481620435195},{"_id":"public/2014/07/29/vue-next/index.html","hash":"af0af72ff4277313253647721367ba8fa596d408","modified":1481620435195},{"_id":"public/archives/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435195},{"_id":"public/archives/page/2/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435195},{"_id":"public/archives/2014/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435195},{"_id":"public/archives/2014/03/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435195},{"_id":"public/archives/2014/07/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/archives/2014/11/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/archives/2014/12/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/archives/2015/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/archives/2015/06/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/archives/2015/10/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/archives/2015/12/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/archives/2016/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/archives/2016/02/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/archives/2016/03/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/archives/2016/04/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/page/2/index.html","hash":"c6c5c7ef24e5b5c46cd901c608ee13997c7d2018","modified":1481620435196},{"_id":"public/about/index.html","hash":"4f7aff53fa5c7e4a3fb55f84ae2642576bec549b","modified":1481620435196},{"_id":"public/study/java/one.html","hash":"527f8f74c914a76ae7325c6164a169312c93334d","modified":1481620435196},{"_id":"public/study/java/two.html","hash":"ed3145ec2e986661f77c446a40a7b3bffe257052","modified":1481620435196},{"_id":"public/study/java/three.html","hash":"6c032c6331e2805c4fc0c01cbcb678f085c73076","modified":1481620435196},{"_id":"public/study/java/zero.html","hash":"919fc0a6041bcfe0e0f96595398b5eb691993b4e","modified":1481620435196},{"_id":"public/study/linux/three.html","hash":"66b802070e9a22fd8a1d318bef63edccdc7a888b","modified":1481620435196},{"_id":"public/study/linux/two.html","hash":"6e13b818f4cfdbe5780fc96bc6b7ebc99cecaaf5","modified":1481620435196},{"_id":"public/study/nodejs/one.html","hash":"aff7a1806145ea1337b0cae185de25246a286cff","modified":1481620435196},{"_id":"public/v2/cookbook/adding-instance-properties.html","hash":"a2288dbab7227fb364a08c7921216091959f4c2a","modified":1481620435196},{"_id":"public/v2/api/index.html","hash":"2d947aeec64a564a69645690ca3b0e3adc4e5717","modified":1481620435196},{"_id":"public/v2/guide/class-and-style.html","hash":"62e3e7fe2948cbae1661f9c72a48b68e2c3286ac","modified":1481620435196},{"_id":"public/v2/guide/comparison.html","hash":"53bd89b8e561e00ab6cc7da62a81f713a0712fac","modified":1481620435196},{"_id":"public/v2/guide/components.html","hash":"3e46c61b105f6dbde97e1f69913e58e5f9261918","modified":1481620435196},{"_id":"public/v2/guide/computed.html","hash":"0ea5a5fbefe4e7a3988cd1cd07b85d594d9d7c5f","modified":1481620435197},{"_id":"public/v2/guide/conditional.html","hash":"e079427d6eb56f870aa5753198b6197430a17865","modified":1481620435197},{"_id":"public/v2/guide/deployment.html","hash":"097279215f18c747c35f8faae64f0ec55d710ba5","modified":1481620435197},{"_id":"public/v2/guide/custom-directive.html","hash":"e070e004051e9133c33451ba101963d78e67f907","modified":1481620435197},{"_id":"public/v2/guide/forms.html","hash":"4ac53799f2bbf84ab002aefbde4cf148ee0aa8b7","modified":1481620435197},{"_id":"public/v2/guide/events.html","hash":"9bb290c12abbdb8f195680d4215228baee26efd4","modified":1481620435197},{"_id":"public/v2/guide/index.html","hash":"58f941872659e2e4ae04412e25423b02f38149bd","modified":1481620435197},{"_id":"public/v2/guide/installation.html","hash":"99ec5d9b127274ee6612bc8904b7a91d3e888cfb","modified":1481620435197},{"_id":"public/v2/guide/join.html","hash":"d0d322bc10fc19a7948a906292a4a4fb93e7b309","modified":1481620435197},{"_id":"public/v2/guide/instance.html","hash":"917cbfa6801c3b0773f3d2091a05a4d7d9226f36","modified":1481620435197},{"_id":"public/v2/guide/list.html","hash":"f59e4e3af6db124db5056f1d5dc683c5ca00557c","modified":1481620435197},{"_id":"public/v2/guide/migration-vue-router.html","hash":"5da40b4ff3136c517030dcc3a946a058bc207ca2","modified":1481620435197},{"_id":"public/v2/guide/migration-vuex.html","hash":"f95208fb363e9cb537a7820f0fdbfe09a4ad3f0e","modified":1481620435197},{"_id":"public/v2/guide/mixins.html","hash":"b5cc6a6832ff3e789bbd2691779e4457c57550ab","modified":1481620435197},{"_id":"public/v2/guide/plugins.html","hash":"ddfa2e6de4300c05be9f030ebb8be6caed36b5f9","modified":1481620435197},{"_id":"public/v2/guide/migration.html","hash":"1ff41538809a140c2b9ddc331c6ca93339362434","modified":1481620435197},{"_id":"public/v2/guide/reactivity.html","hash":"77458e713e0e15c87dac1b2a5376fc760aa4ca32","modified":1481620435197},{"_id":"public/v2/guide/render-function.html","hash":"1eba11d1bb62409423d46fa401810e5817ba65c8","modified":1481620435197},{"_id":"public/v2/guide/routing.html","hash":"216f8e03e46d4e6d945dcb69d728e298701340b1","modified":1481620435197},{"_id":"public/v2/guide/single-file-components.html","hash":"1d2bc7acc89a4571203f471d5175a8ee280b8976","modified":1481620435197},{"_id":"public/v2/guide/state-management.html","hash":"c1e0b30c3262e740417c0649d63be61ffc46f3a2","modified":1481620435197},{"_id":"public/v2/guide/ssr.html","hash":"1599c49d24ff4208f9a320f66dbbbd6905aafe34","modified":1481620435197},{"_id":"public/v2/guide/transitioning-state.html","hash":"1c34a50370ab541dee8d25cc757a28cdd88e6ad2","modified":1481620435197},{"_id":"public/v2/guide/syntax.html","hash":"d47dfdfb170dae20715dead3c8162a9ee10201b6","modified":1481620435197},{"_id":"public/v2/guide/unit-testing.html","hash":"9c64e9fd45330091e2ce5dd11e39c41ec702bf03","modified":1481620435197},{"_id":"public/v2/guide/transitions.html","hash":"e171fe5f2e6e3a0f92305369684e3dab3259fdb2","modified":1481620435197},{"_id":"public/2016/04/27/announcing-2.0/index.html","hash":"e393a6c2c0bdae113c687838a4f54606bbeaa1b5","modified":1481620435197},{"_id":"public/2016/02/06/common-gotchas/index.html","hash":"c3741491a33498a360f801477b2e2cd820bf8131","modified":1481620435198},{"_id":"public/2016/03/14/march-update/index.html","hash":"2d05feba58c5c0d5da31b0c82ff30b4e5d19806c","modified":1481620435198},{"_id":"public/2015/12/28/vue-cli/index.html","hash":"b0a65b01c8510f9149f0f63b76214292ef8ed6bc","modified":1481620435198},{"_id":"public/2015/10/26/1.0.0-release/index.html","hash":"70751b324ed2734beb875f9c26dfbbe6becccb1a","modified":1481620435198},{"_id":"public/2015/06/11/012-release/index.html","hash":"3ab8ccede90fe6ae80ab94ace41ccd5096f07f95","modified":1481620435198},{"_id":"public/2014/12/08/011-component/index.html","hash":"975ca710586df419b31a6d687959d6aef12cc9ea","modified":1481620435198},{"_id":"public/2014/03/22/vuejs-010-release/index.html","hash":"ce0a563ae9673b0ce53a80f7be9d10e42a5ce7dc","modified":1481620435198},{"_id":"public/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481620435198},{"_id":"public/images/logo.png","hash":"191c79a779be9e301b0f9af00bdbf606c2c20e6f","modified":1481620435206},{"_id":"public/images/check.png","hash":"682cf89e1802afb1dfddf07a6aed828a45b824af","modified":1481620435206},{"_id":"public/images/feed.png","hash":"0a746dab71dca2025f63584dbd222dc5e0707ba8","modified":1481620435206},{"_id":"public/images/down.png","hash":"42505e12d686cf580f793bd9193acbac1e3e3a91","modified":1481620435206},{"_id":"public/images/github.png","hash":"238f0619c61c38ce6b589177caf66c525358062e","modified":1481620435206},{"_id":"public/images/icons.png","hash":"91225ef7011e59dbe6b4b9f2666133fb5e1bc976","modified":1481620435206},{"_id":"public/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1481620435206},{"_id":"public/images/search.png","hash":"12d664cc51b8d53c9214830bc9b92fb340526a7b","modified":1481620435206},{"_id":"public/images/wx.png","hash":"f7210ddec02195aedb4d7c2e351fe63f4c4c6b01","modified":1481620435753},{"_id":"public/css/benchmark.css","hash":"3424ee8c27052da2ab9f544027f49e1550385e9d","modified":1481620435770},{"_id":"public/css/index.css","hash":"6ac49413e4fbbdf86f69032fe26693377585d0ec","modified":1481620435770},{"_id":"public/css/search.css","hash":"ac9a0e8c8da7919174caea15d9704c192ea3a2c4","modified":1481620435770},{"_id":"public/css/page.css","hash":"93706b0e38dcc6e0293cb8da794b623fd68c34c6","modified":1481620435770},{"_id":"public/js/common.js","hash":"ead9592d106a121200ef4c3d9634f78be89a70c6","modified":1481620435770},{"_id":"public/js/smooth-scroll.min.js","hash":"86d3196a003a5cdc673a4c6ebb75db3ceee1a1a7","modified":1481620435770},{"_id":"public/js/vue.min.js","hash":"cda36ef24ebbeedae37311d6e14187081ef2b4cc","modified":1481620435770},{"_id":"public/js/vue.js","hash":"9f0baea28019a11d56b0a0b77f03d66578266790","modified":1481620435770},{"_id":"public/images/zfb.jpg","hash":"93442d2b05ac8ddfbd0ed2a9f0f5b17fa6b2633f","modified":1481620435781}],"Category":[],"Data":[],"Page":[{"index":true,"_content":"","source":"index.md","raw":"index: true\n---\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"index.html","title":"","comments":1,"layout":"page","_id":"ciwnajuux0000jl2dak57bile","content":"","excerpt":"","more":""},{"title":"贡献者","type":"about","order":0,"_content":"\n<!--## Guide 翻译贡献-->\n\n<!--### Essentials  基础-->\n\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | --- | ----->\n<!--1 |  installation.md | 安装 | [dingyiming](https://github.com/dingyiming)  | [ATLgo](https://github.com/ATLgo) [70data](https://github.com/70data)-->\n<!--2 |  index.md |  介绍 | [hijiangtao](https://github.com/hijiangtao) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)-->\n<!--3 |  instance.md | 实例 | [dingyiming](https://github.com/dingyiming) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)-->\n<!--4 |  syntax.md  | 模板语法 | [daix6](https://github.com/daix6) | [70data](https://github.com/70data)-->\n<!--5 |  computed.md | 计算属 性 | [dingyiming](https://github.com/dingyiming) [70data](https://github.com/70data) | [70data](https://github.com/70data)-->\n<!--6 |  class-and-style.md | Class 与 Style 绑定 | [595074187](https://github.com/595074187) | [70data](https://github.com/70data)-->\n<!--7 |  conditional.md  | 条件渲染 | [dingyiming](https://github.com/dingyiming) | [hgcoder](https://github.com/hgcoder)-->\n<!--8 |  list.md |  列表渲染 | [tingtien](https://github.com/tingtien) | [hgcoder](https://github.com/hgcoder)-->\n<!--9 |  events.md | 事件处理器 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--10 |  forms.md  | 表单控件绑定 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--11 |  components.md |  组件 | [ezreally](https://github.com/ezreally) | [cuiyongjian](https://github.com/cuiyongjian)-->\n\n<!--### Advanced  进阶-->\n\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | ----->\n<!--12 |  transitions.md | 过渡: 进入, 离开, 和 列表 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf) [StoneQI](https://github.com/StoneQI)-->\n<!--13 |  transitioning-state.md | 过渡状态 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--14 |  render-function.md |  Render 函数 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--15 |  reactivity.md |  深入响应式原理 | [veaba](https://github.com/veaba) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--16 |  custom-directive.md |  自定义指令 | [harrytospring](https://github.com/harrytospring) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--17 |  mixins.md |  混合 | [harrytospring](https://github.com/harrytospring) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--18 |  plugins.md |  插件 | [hgcoder](https://github.com/hgcoder) | [hgcoder](https://github.com/hgcoder)-->\n<!--19 |  single-file-components.md |  单文件组件 | [ATLgo](https://github.com/ATLgo) | [zhouzihanntu](https://github.com/zhouzihanntu)-->\n<!--20 |  routing.md | 路由 | [dingyiming](https://github.com/dingyiming) | [mlyknown](https://github.com/mlyknown)-->\n<!--21 |  state-management.md |  状态管理 | [dear-lizhihua](https://github.com/dear-lizhihua) | [mlyknown](https://github.com/mlyknown)-->\n<!--22 |  unit-testing.md | 单元测试 | [70data](https://github.com/70data) | [mlyknown](https://github.com/mlyknown)-->\n<!--23 |  ssr.md |  服务端渲染 | [dingyiming](https://github.com/dingyiming) | [yongbolv](https://github.com/yongbolv)-->\n\n<!--### Migration  迁移-->\n\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- |  ------------- | --- | --- | --- | ----->\n<!--24 |  migration.md | 1.x迁移 | [harrytospring](https://github.com/harrytospring) | [yongbolv](https://github.com/yongbolv)-->\n<!--27 |  migration-vue-router.md | vue-router 0.7.x 迁移 | [forzajuve10](https://github.com/forzajuve10) | [yizhixiaolongxia](https://github.com/yizhixiaolongxia)-->\n\n<!--### Meta  更多-->\n\n<!--序号 | 对应文档文件名 | 中文标题 |  翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | ----->\n<!--25 |  comparison.md |   对比其他框架 | [yongbolv](https://github.com/yongbolv) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--26 |  join.md |  加入 Vue.js 社区 | [daix6](https://github.com/daix6) | [zhouzihanntu](https://github.com/zhouzihanntu)-->\n\n<!--## API翻译贡献-->\n\n<!--序号 | 对应小节名称 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- |  ------------- | --- | --- | --- | --- | ----->\n<!--1 |  Global Config | 全局配置 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--2 |  Global API | 全局 API | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--3 |  Options / Data | 选项 / 数据 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--4 |  Options / DOM | 选项 / DOM | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--5 |  Options / Lifecycle Hooks | 选项 / 生命周期钩子 | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--6 |  Options / Assets | 选项 / 资源 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--7 |  Options / Misc | 选项 / 杂项 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--8 |  Instance Properties | 实例属性 | [coolzjy](https://github.com/coolzjy) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--9 |  Instance Methods / Data | 实例方法 / 数据 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--10 |  Instance Methods / Events | 实例方法 / 事件 | [mlyknown](https://github.com/mlyknown) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--11 |   Instance Methods / Lifecycle | 实例方法 / 生命周期 |  [mlyknown](https://github.com/mlyknown)| [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--12 |  Directives | 指令| [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--13 |  Special Attributes | 特殊元素 | [70data](https://github.com/70data) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--14 |  Built-In Components | 内置的组件  | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--15 |  VNode Interface | VNode 接口  | [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)-->\n<!--16 |  Server-Side Rendering | 服务端渲染| [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)-->\n\n<!--## 示例翻译-->\n\n<!--翻译贡献者 ： [lindazhang102](https://github.com/lindazhang102)-->\n\n\n<!--## 感谢所有参与翻译的朋友们！-->\n","source":"about/index.md","raw":"---\ntitle: 贡献者\ntype: about\norder: 0\n---\n\n<!--## Guide 翻译贡献-->\n\n<!--### Essentials  基础-->\n\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | --- | ----->\n<!--1 |  installation.md | 安装 | [dingyiming](https://github.com/dingyiming)  | [ATLgo](https://github.com/ATLgo) [70data](https://github.com/70data)-->\n<!--2 |  index.md |  介绍 | [hijiangtao](https://github.com/hijiangtao) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)-->\n<!--3 |  instance.md | 实例 | [dingyiming](https://github.com/dingyiming) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)-->\n<!--4 |  syntax.md  | 模板语法 | [daix6](https://github.com/daix6) | [70data](https://github.com/70data)-->\n<!--5 |  computed.md | 计算属 性 | [dingyiming](https://github.com/dingyiming) [70data](https://github.com/70data) | [70data](https://github.com/70data)-->\n<!--6 |  class-and-style.md | Class 与 Style 绑定 | [595074187](https://github.com/595074187) | [70data](https://github.com/70data)-->\n<!--7 |  conditional.md  | 条件渲染 | [dingyiming](https://github.com/dingyiming) | [hgcoder](https://github.com/hgcoder)-->\n<!--8 |  list.md |  列表渲染 | [tingtien](https://github.com/tingtien) | [hgcoder](https://github.com/hgcoder)-->\n<!--9 |  events.md | 事件处理器 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--10 |  forms.md  | 表单控件绑定 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--11 |  components.md |  组件 | [ezreally](https://github.com/ezreally) | [cuiyongjian](https://github.com/cuiyongjian)-->\n\n<!--### Advanced  进阶-->\n\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | ----->\n<!--12 |  transitions.md | 过渡: 进入, 离开, 和 列表 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf) [StoneQI](https://github.com/StoneQI)-->\n<!--13 |  transitioning-state.md | 过渡状态 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--14 |  render-function.md |  Render 函数 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--15 |  reactivity.md |  深入响应式原理 | [veaba](https://github.com/veaba) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--16 |  custom-directive.md |  自定义指令 | [harrytospring](https://github.com/harrytospring) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--17 |  mixins.md |  混合 | [harrytospring](https://github.com/harrytospring) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--18 |  plugins.md |  插件 | [hgcoder](https://github.com/hgcoder) | [hgcoder](https://github.com/hgcoder)-->\n<!--19 |  single-file-components.md |  单文件组件 | [ATLgo](https://github.com/ATLgo) | [zhouzihanntu](https://github.com/zhouzihanntu)-->\n<!--20 |  routing.md | 路由 | [dingyiming](https://github.com/dingyiming) | [mlyknown](https://github.com/mlyknown)-->\n<!--21 |  state-management.md |  状态管理 | [dear-lizhihua](https://github.com/dear-lizhihua) | [mlyknown](https://github.com/mlyknown)-->\n<!--22 |  unit-testing.md | 单元测试 | [70data](https://github.com/70data) | [mlyknown](https://github.com/mlyknown)-->\n<!--23 |  ssr.md |  服务端渲染 | [dingyiming](https://github.com/dingyiming) | [yongbolv](https://github.com/yongbolv)-->\n\n<!--### Migration  迁移-->\n\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- |  ------------- | --- | --- | --- | ----->\n<!--24 |  migration.md | 1.x迁移 | [harrytospring](https://github.com/harrytospring) | [yongbolv](https://github.com/yongbolv)-->\n<!--27 |  migration-vue-router.md | vue-router 0.7.x 迁移 | [forzajuve10](https://github.com/forzajuve10) | [yizhixiaolongxia](https://github.com/yizhixiaolongxia)-->\n\n<!--### Meta  更多-->\n\n<!--序号 | 对应文档文件名 | 中文标题 |  翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | ----->\n<!--25 |  comparison.md |   对比其他框架 | [yongbolv](https://github.com/yongbolv) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--26 |  join.md |  加入 Vue.js 社区 | [daix6](https://github.com/daix6) | [zhouzihanntu](https://github.com/zhouzihanntu)-->\n\n<!--## API翻译贡献-->\n\n<!--序号 | 对应小节名称 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- |  ------------- | --- | --- | --- | --- | ----->\n<!--1 |  Global Config | 全局配置 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--2 |  Global API | 全局 API | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--3 |  Options / Data | 选项 / 数据 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--4 |  Options / DOM | 选项 / DOM | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--5 |  Options / Lifecycle Hooks | 选项 / 生命周期钩子 | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--6 |  Options / Assets | 选项 / 资源 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--7 |  Options / Misc | 选项 / 杂项 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--8 |  Instance Properties | 实例属性 | [coolzjy](https://github.com/coolzjy) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--9 |  Instance Methods / Data | 实例方法 / 数据 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--10 |  Instance Methods / Events | 实例方法 / 事件 | [mlyknown](https://github.com/mlyknown) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--11 |   Instance Methods / Lifecycle | 实例方法 / 生命周期 |  [mlyknown](https://github.com/mlyknown)| [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--12 |  Directives | 指令| [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--13 |  Special Attributes | 特殊元素 | [70data](https://github.com/70data) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--14 |  Built-In Components | 内置的组件  | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--15 |  VNode Interface | VNode 接口  | [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)-->\n<!--16 |  Server-Side Rendering | 服务端渲染| [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)-->\n\n<!--## 示例翻译-->\n\n<!--翻译贡献者 ： [lindazhang102](https://github.com/lindazhang102)-->\n\n\n<!--## 感谢所有参与翻译的朋友们！-->\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-12T13:09:41.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciwnajuwe0002jl2dkkwmmb9h","content":"<!--## Guide 翻译贡献-->\n<!--### Essentials  基础-->\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | --- | ----->\n<!--1 |  installation.md | 安装 | [dingyiming](https://github.com/dingyiming)  | [ATLgo](https://github.com/ATLgo) [70data](https://github.com/70data)-->\n<!--2 |  index.md |  介绍 | [hijiangtao](https://github.com/hijiangtao) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)-->\n<!--3 |  instance.md | 实例 | [dingyiming](https://github.com/dingyiming) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)-->\n<!--4 |  syntax.md  | 模板语法 | [daix6](https://github.com/daix6) | [70data](https://github.com/70data)-->\n<!--5 |  computed.md | 计算属 性 | [dingyiming](https://github.com/dingyiming) [70data](https://github.com/70data) | [70data](https://github.com/70data)-->\n<!--6 |  class-and-style.md | Class 与 Style 绑定 | [595074187](https://github.com/595074187) | [70data](https://github.com/70data)-->\n<!--7 |  conditional.md  | 条件渲染 | [dingyiming](https://github.com/dingyiming) | [hgcoder](https://github.com/hgcoder)-->\n<!--8 |  list.md |  列表渲染 | [tingtien](https://github.com/tingtien) | [hgcoder](https://github.com/hgcoder)-->\n<!--9 |  events.md | 事件处理器 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--10 |  forms.md  | 表单控件绑定 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--11 |  components.md |  组件 | [ezreally](https://github.com/ezreally) | [cuiyongjian](https://github.com/cuiyongjian)-->\n<!--### Advanced  进阶-->\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | ----->\n<!--12 |  transitions.md | 过渡: 进入, 离开, 和 列表 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf) [StoneQI](https://github.com/StoneQI)-->\n<!--13 |  transitioning-state.md | 过渡状态 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--14 |  render-function.md |  Render 函数 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--15 |  reactivity.md |  深入响应式原理 | [veaba](https://github.com/veaba) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--16 |  custom-directive.md |  自定义指令 | [harrytospring](https://github.com/harrytospring) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--17 |  mixins.md |  混合 | [harrytospring](https://github.com/harrytospring) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--18 |  plugins.md |  插件 | [hgcoder](https://github.com/hgcoder) | [hgcoder](https://github.com/hgcoder)-->\n<!--19 |  single-file-components.md |  单文件组件 | [ATLgo](https://github.com/ATLgo) | [zhouzihanntu](https://github.com/zhouzihanntu)-->\n<!--20 |  routing.md | 路由 | [dingyiming](https://github.com/dingyiming) | [mlyknown](https://github.com/mlyknown)-->\n<!--21 |  state-management.md |  状态管理 | [dear-lizhihua](https://github.com/dear-lizhihua) | [mlyknown](https://github.com/mlyknown)-->\n<!--22 |  unit-testing.md | 单元测试 | [70data](https://github.com/70data) | [mlyknown](https://github.com/mlyknown)-->\n<!--23 |  ssr.md |  服务端渲染 | [dingyiming](https://github.com/dingyiming) | [yongbolv](https://github.com/yongbolv)-->\n<!--### Migration  迁移-->\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- |  ------------- | --- | --- | --- | ----->\n<!--24 |  migration.md | 1.x迁移 | [harrytospring](https://github.com/harrytospring) | [yongbolv](https://github.com/yongbolv)-->\n<!--27 |  migration-vue-router.md | vue-router 0.7.x 迁移 | [forzajuve10](https://github.com/forzajuve10) | [yizhixiaolongxia](https://github.com/yizhixiaolongxia)-->\n<!--### Meta  更多-->\n<!--序号 | 对应文档文件名 | 中文标题 |  翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | ----->\n<!--25 |  comparison.md |   对比其他框架 | [yongbolv](https://github.com/yongbolv) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--26 |  join.md |  加入 Vue.js 社区 | [daix6](https://github.com/daix6) | [zhouzihanntu](https://github.com/zhouzihanntu)-->\n<!--## API翻译贡献-->\n<!--序号 | 对应小节名称 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- |  ------------- | --- | --- | --- | --- | ----->\n<!--1 |  Global Config | 全局配置 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--2 |  Global API | 全局 API | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--3 |  Options / Data | 选项 / 数据 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--4 |  Options / DOM | 选项 / DOM | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--5 |  Options / Lifecycle Hooks | 选项 / 生命周期钩子 | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--6 |  Options / Assets | 选项 / 资源 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--7 |  Options / Misc | 选项 / 杂项 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--8 |  Instance Properties | 实例属性 | [coolzjy](https://github.com/coolzjy) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--9 |  Instance Methods / Data | 实例方法 / 数据 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--10 |  Instance Methods / Events | 实例方法 / 事件 | [mlyknown](https://github.com/mlyknown) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--11 |   Instance Methods / Lifecycle | 实例方法 / 生命周期 |  [mlyknown](https://github.com/mlyknown)| [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--12 |  Directives | 指令| [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--13 |  Special Attributes | 特殊元素 | [70data](https://github.com/70data) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--14 |  Built-In Components | 内置的组件  | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--15 |  VNode Interface | VNode 接口  | [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)-->\n<!--16 |  Server-Side Rendering | 服务端渲染| [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)-->\n<!--## 示例翻译-->\n<!--翻译贡献者 ： [lindazhang102](https://github.com/lindazhang102)-->\n<!--## 感谢所有参与翻译的朋友们！-->\n","excerpt":"","more":"<!--## Guide 翻译贡献-->\n<!--### Essentials  基础-->\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | --- | ----->\n<!--1 |  installation.md | 安装 | [dingyiming](https://github.com/dingyiming)  | [ATLgo](https://github.com/ATLgo) [70data](https://github.com/70data)-->\n<!--2 |  index.md |  介绍 | [hijiangtao](https://github.com/hijiangtao) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)-->\n<!--3 |  instance.md | 实例 | [dingyiming](https://github.com/dingyiming) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)-->\n<!--4 |  syntax.md  | 模板语法 | [daix6](https://github.com/daix6) | [70data](https://github.com/70data)-->\n<!--5 |  computed.md | 计算属 性 | [dingyiming](https://github.com/dingyiming) [70data](https://github.com/70data) | [70data](https://github.com/70data)-->\n<!--6 |  class-and-style.md | Class 与 Style 绑定 | [595074187](https://github.com/595074187) | [70data](https://github.com/70data)-->\n<!--7 |  conditional.md  | 条件渲染 | [dingyiming](https://github.com/dingyiming) | [hgcoder](https://github.com/hgcoder)-->\n<!--8 |  list.md |  列表渲染 | [tingtien](https://github.com/tingtien) | [hgcoder](https://github.com/hgcoder)-->\n<!--9 |  events.md | 事件处理器 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--10 |  forms.md  | 表单控件绑定 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--11 |  components.md |  组件 | [ezreally](https://github.com/ezreally) | [cuiyongjian](https://github.com/cuiyongjian)-->\n<!--### Advanced  进阶-->\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | ----->\n<!--12 |  transitions.md | 过渡: 进入, 离开, 和 列表 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf) [StoneQI](https://github.com/StoneQI)-->\n<!--13 |  transitioning-state.md | 过渡状态 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--14 |  render-function.md |  Render 函数 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--15 |  reactivity.md |  深入响应式原理 | [veaba](https://github.com/veaba) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--16 |  custom-directive.md |  自定义指令 | [harrytospring](https://github.com/harrytospring) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--17 |  mixins.md |  混合 | [harrytospring](https://github.com/harrytospring) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--18 |  plugins.md |  插件 | [hgcoder](https://github.com/hgcoder) | [hgcoder](https://github.com/hgcoder)-->\n<!--19 |  single-file-components.md |  单文件组件 | [ATLgo](https://github.com/ATLgo) | [zhouzihanntu](https://github.com/zhouzihanntu)-->\n<!--20 |  routing.md | 路由 | [dingyiming](https://github.com/dingyiming) | [mlyknown](https://github.com/mlyknown)-->\n<!--21 |  state-management.md |  状态管理 | [dear-lizhihua](https://github.com/dear-lizhihua) | [mlyknown](https://github.com/mlyknown)-->\n<!--22 |  unit-testing.md | 单元测试 | [70data](https://github.com/70data) | [mlyknown](https://github.com/mlyknown)-->\n<!--23 |  ssr.md |  服务端渲染 | [dingyiming](https://github.com/dingyiming) | [yongbolv](https://github.com/yongbolv)-->\n<!--### Migration  迁移-->\n<!--序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- |  ------------- | --- | --- | --- | ----->\n<!--24 |  migration.md | 1.x迁移 | [harrytospring](https://github.com/harrytospring) | [yongbolv](https://github.com/yongbolv)-->\n<!--27 |  migration-vue-router.md | vue-router 0.7.x 迁移 | [forzajuve10](https://github.com/forzajuve10) | [yizhixiaolongxia](https://github.com/yizhixiaolongxia)-->\n<!--### Meta  更多-->\n<!--序号 | 对应文档文件名 | 中文标题 |  翻译贡献者 | 校对主要贡献者-->\n<!------- | ------------- | --- | --- | --- | ----->\n<!--25 |  comparison.md |   对比其他框架 | [yongbolv](https://github.com/yongbolv) | [yangzj1992](https://github.com/yangzj1992)-->\n<!--26 |  join.md |  加入 Vue.js 社区 | [daix6](https://github.com/daix6) | [zhouzihanntu](https://github.com/zhouzihanntu)-->\n<!--## API翻译贡献-->\n<!--序号 | 对应小节名称 | 中文标题 | 翻译贡献者 | 校对主要贡献者-->\n<!------- |  ------------- | --- | --- | --- | --- | ----->\n<!--1 |  Global Config | 全局配置 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--2 |  Global API | 全局 API | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--3 |  Options / Data | 选项 / 数据 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--4 |  Options / DOM | 选项 / DOM | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--5 |  Options / Lifecycle Hooks | 选项 / 生命周期钩子 | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--6 |  Options / Assets | 选项 / 资源 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--7 |  Options / Misc | 选项 / 杂项 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--8 |  Instance Properties | 实例属性 | [coolzjy](https://github.com/coolzjy) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--9 |  Instance Methods / Data | 实例方法 / 数据 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--10 |  Instance Methods / Events | 实例方法 / 事件 | [mlyknown](https://github.com/mlyknown) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--11 |   Instance Methods / Lifecycle | 实例方法 / 生命周期 |  [mlyknown](https://github.com/mlyknown)| [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--12 |  Directives | 指令| [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--13 |  Special Attributes | 特殊元素 | [70data](https://github.com/70data) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--14 |  Built-In Components | 内置的组件  | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)-->\n<!--15 |  VNode Interface | VNode 接口  | [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)-->\n<!--16 |  Server-Side Rendering | 服务端渲染| [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)-->\n<!--## 示例翻译-->\n<!--翻译贡献者 ： [lindazhang102](https://github.com/lindazhang102)-->\n<!--## 感谢所有参与翻译的朋友们！-->\n"},{"title":"参与指南","type":"about","order":1,"_content":"\n\n## 参与要求\n\n暂时只能向我发送邮件","source":"about/guide.md","raw":"---\ntitle: 参与指南\ntype: about\norder: 1\n---\n\n\n## 参与要求\n\n暂时只能向我发送邮件","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-12T13:09:19.000Z","path":"about/guide.html","comments":1,"layout":"page","_id":"ciwnajuwh0004jl2d207bog1t","content":"<h2 id=\"参与要求\"><a href=\"#参与要求\" class=\"headerlink\" title=\"参与要求\"></a>参与要求</h2><p>暂时只能向我发送邮件</p>\n","excerpt":"","more":"<h2 id=\"参与要求\"><a href=\"#参与要求\" class=\"headerlink\" title=\"参与要求\"></a>参与要求</h2><p>暂时只能向我发送邮件</p>\n"},{"_content":"# 支持我继续坚持分享\n\n<a href=\"https://www.patreon.com/evanyou\" target=\"_blank\">\n  <img style=\"width:120px\" src=\"/images/zfb.jpg\">\n  <span>支付宝向我转账~</span>\n</a>\n\n<a href=\"https://www.paypal.me/evanyou\" target=\"_blank\">\n  <img style=\"width:120px\" src=\"/images/wx.png\">\n  <span>微信向我转账~</span>\n</a>\n\n## 当前赞助商\n\n<p style=\"text-align: center; padding-top: 30px; margin-bottom: 0\"><a href=\"https://github.com/cleverfan/\"><img src=\"/images/github.png\" style=\"width: 300px\"></a></p>\n\n\n\n这个网站是用来记录并分享的，如果你觉得我写的文章对你有帮助，并且愿意支持我继续分享更多的知识。\n\n<!--Vue.js 是采用 MIT 许可的开源项目，使用完全免费。不过，如果没有资金的支持，维护和开发新功能是不可能持续的。你可以通过 [Patreon](https://www.patreon.com/evanyou) 或 [PayPal](https://www.paypal.me/evanyou) 来赞助。-->\n\n<!--如果你是企业经营者并且将 Vue 用在商业产品中，那么赞助 Vue 有商业上的益处：**可以让你的产品保持健康并得到积极的维护**，也能帮助你在 Vue 社区里曝光，从而更容易地吸引到 Vue 开发者。-->\n\n<!--如果你是企业经营者，并且使用 Vue.js 来开发核心产品，我也可以做顾问。[在 Twitter 上联系我。](https://twitter.com/youyuxi)-->\n\n如果可以用捐助来表示你的谢意——比如间或给我买杯咖啡 :)\n","source":"support-me/index.md","raw":"# 支持我继续坚持分享\n\n<a href=\"https://www.patreon.com/evanyou\" target=\"_blank\">\n  <img style=\"width:120px\" src=\"/images/zfb.jpg\">\n  <span>支付宝向我转账~</span>\n</a>\n\n<a href=\"https://www.paypal.me/evanyou\" target=\"_blank\">\n  <img style=\"width:120px\" src=\"/images/wx.png\">\n  <span>微信向我转账~</span>\n</a>\n\n## 当前赞助商\n\n<p style=\"text-align: center; padding-top: 30px; margin-bottom: 0\"><a href=\"https://github.com/cleverfan/\"><img src=\"/images/github.png\" style=\"width: 300px\"></a></p>\n\n\n\n这个网站是用来记录并分享的，如果你觉得我写的文章对你有帮助，并且愿意支持我继续分享更多的知识。\n\n<!--Vue.js 是采用 MIT 许可的开源项目，使用完全免费。不过，如果没有资金的支持，维护和开发新功能是不可能持续的。你可以通过 [Patreon](https://www.patreon.com/evanyou) 或 [PayPal](https://www.paypal.me/evanyou) 来赞助。-->\n\n<!--如果你是企业经营者并且将 Vue 用在商业产品中，那么赞助 Vue 有商业上的益处：**可以让你的产品保持健康并得到积极的维护**，也能帮助你在 Vue 社区里曝光，从而更容易地吸引到 Vue 开发者。-->\n\n<!--如果你是企业经营者，并且使用 Vue.js 来开发核心产品，我也可以做顾问。[在 Twitter 上联系我。](https://twitter.com/youyuxi)-->\n\n如果可以用捐助来表示你的谢意——比如间或给我买杯咖啡 :)\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-12T13:25:14.000Z","path":"support-me/index.html","title":"","comments":1,"layout":"page","_id":"ciwnajuwk0006jl2d9bxbm28d","content":"<h1 id=\"支持我继续坚持分享\"><a href=\"#支持我继续坚持分享\" class=\"headerlink\" title=\"支持我继续坚持分享\"></a>支持我继续坚持分享</h1><p><a href=\"https://www.patreon.com/evanyou\" target=\"_blank\"><br>  <img style=\"width:120px\" src=\"/images/zfb.jpg\"><br>  <span>支付宝向我转账~</span><br></a></p>\n<p><a href=\"https://www.paypal.me/evanyou\" target=\"_blank\"><br>  <img style=\"width:120px\" src=\"/images/wx.png\"><br>  <span>微信向我转账~</span><br></a></p>\n<h2 id=\"当前赞助商\"><a href=\"#当前赞助商\" class=\"headerlink\" title=\"当前赞助商\"></a>当前赞助商</h2><p style=\"text-align: center; padding-top: 30px; margin-bottom: 0\"><a href=\"https://github.com/cleverfan/\" target=\"_blank\" rel=\"external\"><img src=\"/images/github.png\" style=\"width: 300px\"></a></p>\n\n\n\n<p>这个网站是用来记录并分享的，如果你觉得我写的文章对你有帮助，并且愿意支持我继续分享更多的知识。</p>\n<!--Vue.js 是采用 MIT 许可的开源项目，使用完全免费。不过，如果没有资金的支持，维护和开发新功能是不可能持续的。你可以通过 [Patreon](https://www.patreon.com/evanyou) 或 [PayPal](https://www.paypal.me/evanyou) 来赞助。-->\n<!--如果你是企业经营者并且将 Vue 用在商业产品中，那么赞助 Vue 有商业上的益处：**可以让你的产品保持健康并得到积极的维护**，也能帮助你在 Vue 社区里曝光，从而更容易地吸引到 Vue 开发者。-->\n<!--如果你是企业经营者，并且使用 Vue.js 来开发核心产品，我也可以做顾问。[在 Twitter 上联系我。](https://twitter.com/youyuxi)-->\n<p>如果可以用捐助来表示你的谢意——比如间或给我买杯咖啡 :)</p>\n","excerpt":"","more":"<h1 id=\"支持我继续坚持分享\"><a href=\"#支持我继续坚持分享\" class=\"headerlink\" title=\"支持我继续坚持分享\"></a>支持我继续坚持分享</h1><p><a href=\"https://www.patreon.com/evanyou\" target=\"_blank\"><br>  <img style=\"width:120px\" src=\"/images/zfb.jpg\"><br>  <span>支付宝向我转账~</span><br></a></p>\n<p><a href=\"https://www.paypal.me/evanyou\" target=\"_blank\"><br>  <img style=\"width:120px\" src=\"/images/wx.png\"><br>  <span>微信向我转账~</span><br></a></p>\n<h2 id=\"当前赞助商\"><a href=\"#当前赞助商\" class=\"headerlink\" title=\"当前赞助商\"></a>当前赞助商</h2><p style=\"text-align: center; padding-top: 30px; margin-bottom: 0\"><a href=\"https://github.com/cleverfan/\"><img src=\"/images/github.png\" style=\"width: 300px\"></a></p>\n\n\n\n<p>这个网站是用来记录并分享的，如果你觉得我写的文章对你有帮助，并且愿意支持我继续分享更多的知识。</p>\n<!--Vue.js 是采用 MIT 许可的开源项目，使用完全免费。不过，如果没有资金的支持，维护和开发新功能是不可能持续的。你可以通过 [Patreon](https://www.patreon.com/evanyou) 或 [PayPal](https://www.paypal.me/evanyou) 来赞助。-->\n<!--如果你是企业经营者并且将 Vue 用在商业产品中，那么赞助 Vue 有商业上的益处：**可以让你的产品保持健康并得到积极的维护**，也能帮助你在 Vue 社区里曝光，从而更容易地吸引到 Vue 开发者。-->\n<!--如果你是企业经营者，并且使用 Vue.js 来开发核心产品，我也可以做顾问。[在 Twitter 上联系我。](https://twitter.com/youyuxi)-->\n<p>如果可以用捐助来表示你的谢意——比如间或给我买杯咖啡 :)</p>\n"},{"title":"万物皆对象(下)","type":"javaImprove","order":2,"_content":"\n## **对象的强引用，软引用，弱引用和虚引用**\n  \n  Java中是JVM负责内存的分配和回收，这样虽然使用方便，程序不用再像使用c那样操心内存，但同时也是它的缺点(不够灵活)。为了解决内存操作不灵活这个问题，可以采用软引用等方法。\n\n先介绍一下这四种引用：\n\n- 强引用\n\n > 以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n\n- 软引用（SoftReference）\n\n  > 如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n   \n   > 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n \n- 弱引用（WeakReference）\n    > 如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 \n   \n   >  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n\n- 虚引用（PhantomReference）\n    > \"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n    \n    > 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n在实际开发中，弱引用和虚引用不常用，用得比较多的是软引用，因为它可以加速jvm的回收。\n\n软引用的使用方式：\n\n![这里写图片描述](http://img.blog.csdn.net/20161127203117708) \n\n关于软引用，我之后会单独写一篇文章，所以这里先一笔带过。\n\n## **对象的复制**\n\njava除了用new来创建对象，还可以通过clone来复制对象。\n\n那么这两种方式有什么相同和不同呢？ \n\n- new\n\n>new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。\n\n- clone\n>clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。\n\n\n如何利用clone的方式来得到一个对象呢？\n\n看代码：\n\n>![这里写图片描述](http://img.blog.csdn.net/20161127204300965)\n\n>对Person类做了一些修改\n\n看实现代码：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127204359354)\n\n这样就得到了一个和原来一样的新对象。\n\n\n## **深复制和浅复制**\n\n但是，细心并且善于思考的人可能一经发现了一个问题。\n\nage是一个基本数据类型，支架clone没什么问题，但是name可是一个String类型的啊。我们clone后的对象里的name和原来对象的name是不是指向同一个字符串常量呢？\n\n做个试验：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127205753811) \n\n> 果然，是同一个对象。如果你不能理解，那么看这个图。\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127210126755)\n\n> 其实如果只是String还好，因为String的不可变性，当你随便修改一个值的时候，他们就会指向不同的地址了，但是除了String，其他都是可变的。这就危险了。\n\n\n上面的这种情况，就是浅克隆。这种方式在你的属性列表中有其他对象的引用的时候其实是很危险的。所以，我们需要深克隆。也就是说我们需要将这个对象里的对象也clone一份。怎么做呢？\n\n在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。\n```\n//使用该工具类的对象必须要实现 Serializable 接口，否则是没有办法实现克隆的。\npublic class CloneUtils {\n\n    public static <T extends Serializable> T clone(T   obj){\n        T cloneObj = null;\n        try {\n            //写入字节流\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            ObjectOutputStream obs = new   ObjectOutputStream(out);\n            obs.writeObject(obj);\n            obs.close();\n\n            //分配内存，写入原始对象，生成新对象\n            ByteArrayInputStream ios = new  ByteArrayInputStream(out.toByteArray());\n            ObjectInputStream ois = new ObjectInputStream(ios);\n            //返回生成的新对象\n            cloneObj = (T) ois.readObject();\n            ois.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return cloneObj;\n    }\n}\n```\n使用该工具类的对象只要实现 Serializable 接口就可实现对象的克隆，无须继承 Cloneable 接口实现 clone() 方法。\n\n测试一下：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127211824152)\n\n> 很完美\n\n>这个时候，Person类实现了Serializable接口\n\n是否使用复制，深复制还是浅复制看情况来使用。\n\n\n> 关于序列化与反序列化以后会讲。\n\n\n----------\n这篇文章到这里就暂时告一段落了，后续有补充的话我会继续补充，有错误的话，我也会及时改正。欢迎大家提出问题。\n\n> 事例代码放在github：https://github.com/CleverFan/JavaImprove\n","source":"study/java/one.md","raw":"---\ntitle: 万物皆对象(下)\ntype: javaImprove\norder: 2\n---\n\n## **对象的强引用，软引用，弱引用和虚引用**\n  \n  Java中是JVM负责内存的分配和回收，这样虽然使用方便，程序不用再像使用c那样操心内存，但同时也是它的缺点(不够灵活)。为了解决内存操作不灵活这个问题，可以采用软引用等方法。\n\n先介绍一下这四种引用：\n\n- 强引用\n\n > 以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n\n- 软引用（SoftReference）\n\n  > 如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n   \n   > 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n \n- 弱引用（WeakReference）\n    > 如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 \n   \n   >  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n\n- 虚引用（PhantomReference）\n    > \"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n    \n    > 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n在实际开发中，弱引用和虚引用不常用，用得比较多的是软引用，因为它可以加速jvm的回收。\n\n软引用的使用方式：\n\n![这里写图片描述](http://img.blog.csdn.net/20161127203117708) \n\n关于软引用，我之后会单独写一篇文章，所以这里先一笔带过。\n\n## **对象的复制**\n\njava除了用new来创建对象，还可以通过clone来复制对象。\n\n那么这两种方式有什么相同和不同呢？ \n\n- new\n\n>new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。\n\n- clone\n>clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。\n\n\n如何利用clone的方式来得到一个对象呢？\n\n看代码：\n\n>![这里写图片描述](http://img.blog.csdn.net/20161127204300965)\n\n>对Person类做了一些修改\n\n看实现代码：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127204359354)\n\n这样就得到了一个和原来一样的新对象。\n\n\n## **深复制和浅复制**\n\n但是，细心并且善于思考的人可能一经发现了一个问题。\n\nage是一个基本数据类型，支架clone没什么问题，但是name可是一个String类型的啊。我们clone后的对象里的name和原来对象的name是不是指向同一个字符串常量呢？\n\n做个试验：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127205753811) \n\n> 果然，是同一个对象。如果你不能理解，那么看这个图。\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127210126755)\n\n> 其实如果只是String还好，因为String的不可变性，当你随便修改一个值的时候，他们就会指向不同的地址了，但是除了String，其他都是可变的。这就危险了。\n\n\n上面的这种情况，就是浅克隆。这种方式在你的属性列表中有其他对象的引用的时候其实是很危险的。所以，我们需要深克隆。也就是说我们需要将这个对象里的对象也clone一份。怎么做呢？\n\n在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。\n```\n//使用该工具类的对象必须要实现 Serializable 接口，否则是没有办法实现克隆的。\npublic class CloneUtils {\n\n    public static <T extends Serializable> T clone(T   obj){\n        T cloneObj = null;\n        try {\n            //写入字节流\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            ObjectOutputStream obs = new   ObjectOutputStream(out);\n            obs.writeObject(obj);\n            obs.close();\n\n            //分配内存，写入原始对象，生成新对象\n            ByteArrayInputStream ios = new  ByteArrayInputStream(out.toByteArray());\n            ObjectInputStream ois = new ObjectInputStream(ios);\n            //返回生成的新对象\n            cloneObj = (T) ois.readObject();\n            ois.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return cloneObj;\n    }\n}\n```\n使用该工具类的对象只要实现 Serializable 接口就可实现对象的克隆，无须继承 Cloneable 接口实现 clone() 方法。\n\n测试一下：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127211824152)\n\n> 很完美\n\n>这个时候，Person类实现了Serializable接口\n\n是否使用复制，深复制还是浅复制看情况来使用。\n\n\n> 关于序列化与反序列化以后会讲。\n\n\n----------\n这篇文章到这里就暂时告一段落了，后续有补充的话我会继续补充，有错误的话，我也会及时改正。欢迎大家提出问题。\n\n> 事例代码放在github：https://github.com/CleverFan/JavaImprove\n","date":"2016-12-13T03:51:51.000Z","updated":"2016-12-13T03:51:51.000Z","path":"study/java/one.html","comments":1,"layout":"page","_id":"ciwnajuxl000fjl2dwc5dcxub","content":"<h2 id=\"对象的强引用，软引用，弱引用和虚引用\"><a href=\"#对象的强引用，软引用，弱引用和虚引用\" class=\"headerlink\" title=\"对象的强引用，软引用，弱引用和虚引用\"></a><strong>对象的强引用，软引用，弱引用和虚引用</strong></h2><p>  Java中是JVM负责内存的分配和回收，这样虽然使用方便，程序不用再像使用c那样操心内存，但同时也是它的缺点(不够灵活)。为了解决内存操作不灵活这个问题，可以采用软引用等方法。</p>\n<p>先介绍一下这四种引用：</p>\n<ul>\n<li><p>强引用</p>\n<blockquote>\n<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>软引用（SoftReference）</p>\n<blockquote>\n<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>弱引用（WeakReference）</p>\n<blockquote>\n<p>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>\n<p> 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>虚引用（PhantomReference）</p>\n<blockquote>\n<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>\n<p>虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n</blockquote>\n</li>\n</ul>\n<p>在实际开发中，弱引用和虚引用不常用，用得比较多的是软引用，因为它可以加速jvm的回收。</p>\n<p>软引用的使用方式：</p>\n<p><img src=\"http://img.blog.csdn.net/20161127203117708\" alt=\"这里写图片描述\"> </p>\n<p>关于软引用，我之后会单独写一篇文章，所以这里先一笔带过。</p>\n<h2 id=\"对象的复制\"><a href=\"#对象的复制\" class=\"headerlink\" title=\"对象的复制\"></a><strong>对象的复制</strong></h2><p>java除了用new来创建对象，还可以通过clone来复制对象。</p>\n<p>那么这两种方式有什么相同和不同呢？ </p>\n<ul>\n<li>new</li>\n</ul>\n<blockquote>\n<p>new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</p>\n</blockquote>\n<ul>\n<li>clone<blockquote>\n<p>clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p>\n</blockquote>\n</li>\n</ul>\n<p>如何利用clone的方式来得到一个对象呢？</p>\n<p>看代码：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127204300965\" alt=\"这里写图片描述\"></p>\n<p>对Person类做了一些修改</p>\n</blockquote>\n<p>看实现代码：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127204359354\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>这样就得到了一个和原来一样的新对象。</p>\n<h2 id=\"深复制和浅复制\"><a href=\"#深复制和浅复制\" class=\"headerlink\" title=\"深复制和浅复制\"></a><strong>深复制和浅复制</strong></h2><p>但是，细心并且善于思考的人可能一经发现了一个问题。</p>\n<p>age是一个基本数据类型，支架clone没什么问题，但是name可是一个String类型的啊。我们clone后的对象里的name和原来对象的name是不是指向同一个字符串常量呢？</p>\n<p>做个试验：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127205753811\" alt=\"这里写图片描述\"> </p>\n<p>果然，是同一个对象。如果你不能理解，那么看这个图。</p>\n<p><img src=\"http://img.blog.csdn.net/20161127210126755\" alt=\"这里写图片描述\"></p>\n<p>其实如果只是String还好，因为String的不可变性，当你随便修改一个值的时候，他们就会指向不同的地址了，但是除了String，其他都是可变的。这就危险了。</p>\n</blockquote>\n<p>上面的这种情况，就是浅克隆。这种方式在你的属性列表中有其他对象的引用的时候其实是很危险的。所以，我们需要深克隆。也就是说我们需要将这个对象里的对象也clone一份。怎么做呢？</p>\n<p>在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//使用该工具类的对象必须要实现 Serializable 接口，否则是没有办法实现克隆的。</div><div class=\"line\">public class CloneUtils &#123;</div><div class=\"line\"></div><div class=\"line\">    public static &lt;T extends Serializable&gt; T clone(T   obj)&#123;</div><div class=\"line\">        T cloneObj = null;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            //写入字节流</div><div class=\"line\">            ByteArrayOutputStream out = new ByteArrayOutputStream();</div><div class=\"line\">            ObjectOutputStream obs = new   ObjectOutputStream(out);</div><div class=\"line\">            obs.writeObject(obj);</div><div class=\"line\">            obs.close();</div><div class=\"line\"></div><div class=\"line\">            //分配内存，写入原始对象，生成新对象</div><div class=\"line\">            ByteArrayInputStream ios = new  ByteArrayInputStream(out.toByteArray());</div><div class=\"line\">            ObjectInputStream ois = new ObjectInputStream(ios);</div><div class=\"line\">            //返回生成的新对象</div><div class=\"line\">            cloneObj = (T) ois.readObject();</div><div class=\"line\">            ois.close();</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return cloneObj;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用该工具类的对象只要实现 Serializable 接口就可实现对象的克隆，无须继承 Cloneable 接口实现 clone() 方法。</p>\n<p>测试一下：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127211824152\" alt=\"这里写图片描述\"></p>\n<p>很完美</p>\n<p>这个时候，Person类实现了Serializable接口</p>\n</blockquote>\n<p>是否使用复制，深复制还是浅复制看情况来使用。</p>\n<blockquote>\n<p>关于序列化与反序列化以后会讲。</p>\n</blockquote>\n<hr>\n<p>这篇文章到这里就暂时告一段落了，后续有补充的话我会继续补充，有错误的话，我也会及时改正。欢迎大家提出问题。</p>\n<blockquote>\n<p>事例代码放在github：<a href=\"https://github.com/CleverFan/JavaImprove\" target=\"_blank\" rel=\"external\">https://github.com/CleverFan/JavaImprove</a></p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"对象的强引用，软引用，弱引用和虚引用\"><a href=\"#对象的强引用，软引用，弱引用和虚引用\" class=\"headerlink\" title=\"对象的强引用，软引用，弱引用和虚引用\"></a><strong>对象的强引用，软引用，弱引用和虚引用</strong></h2><p>  Java中是JVM负责内存的分配和回收，这样虽然使用方便，程序不用再像使用c那样操心内存，但同时也是它的缺点(不够灵活)。为了解决内存操作不灵活这个问题，可以采用软引用等方法。</p>\n<p>先介绍一下这四种引用：</p>\n<ul>\n<li><p>强引用</p>\n<blockquote>\n<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>软引用（SoftReference）</p>\n<blockquote>\n<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>弱引用（WeakReference）</p>\n<blockquote>\n<p>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>\n<p> 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>虚引用（PhantomReference）</p>\n<blockquote>\n<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>\n<p>虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n</blockquote>\n</li>\n</ul>\n<p>在实际开发中，弱引用和虚引用不常用，用得比较多的是软引用，因为它可以加速jvm的回收。</p>\n<p>软引用的使用方式：</p>\n<p><img src=\"http://img.blog.csdn.net/20161127203117708\" alt=\"这里写图片描述\"> </p>\n<p>关于软引用，我之后会单独写一篇文章，所以这里先一笔带过。</p>\n<h2 id=\"对象的复制\"><a href=\"#对象的复制\" class=\"headerlink\" title=\"对象的复制\"></a><strong>对象的复制</strong></h2><p>java除了用new来创建对象，还可以通过clone来复制对象。</p>\n<p>那么这两种方式有什么相同和不同呢？ </p>\n<ul>\n<li>new</li>\n</ul>\n<blockquote>\n<p>new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</p>\n</blockquote>\n<ul>\n<li>clone<blockquote>\n<p>clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p>\n</blockquote>\n</li>\n</ul>\n<p>如何利用clone的方式来得到一个对象呢？</p>\n<p>看代码：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127204300965\" alt=\"这里写图片描述\"></p>\n<p>对Person类做了一些修改</p>\n</blockquote>\n<p>看实现代码：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127204359354\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>这样就得到了一个和原来一样的新对象。</p>\n<h2 id=\"深复制和浅复制\"><a href=\"#深复制和浅复制\" class=\"headerlink\" title=\"深复制和浅复制\"></a><strong>深复制和浅复制</strong></h2><p>但是，细心并且善于思考的人可能一经发现了一个问题。</p>\n<p>age是一个基本数据类型，支架clone没什么问题，但是name可是一个String类型的啊。我们clone后的对象里的name和原来对象的name是不是指向同一个字符串常量呢？</p>\n<p>做个试验：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127205753811\" alt=\"这里写图片描述\"> </p>\n<p>果然，是同一个对象。如果你不能理解，那么看这个图。</p>\n<p><img src=\"http://img.blog.csdn.net/20161127210126755\" alt=\"这里写图片描述\"></p>\n<p>其实如果只是String还好，因为String的不可变性，当你随便修改一个值的时候，他们就会指向不同的地址了，但是除了String，其他都是可变的。这就危险了。</p>\n</blockquote>\n<p>上面的这种情况，就是浅克隆。这种方式在你的属性列表中有其他对象的引用的时候其实是很危险的。所以，我们需要深克隆。也就是说我们需要将这个对象里的对象也clone一份。怎么做呢？</p>\n<p>在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//使用该工具类的对象必须要实现 Serializable 接口，否则是没有办法实现克隆的。</div><div class=\"line\">public class CloneUtils &#123;</div><div class=\"line\"></div><div class=\"line\">    public static &lt;T extends Serializable&gt; T clone(T   obj)&#123;</div><div class=\"line\">        T cloneObj = null;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            //写入字节流</div><div class=\"line\">            ByteArrayOutputStream out = new ByteArrayOutputStream();</div><div class=\"line\">            ObjectOutputStream obs = new   ObjectOutputStream(out);</div><div class=\"line\">            obs.writeObject(obj);</div><div class=\"line\">            obs.close();</div><div class=\"line\"></div><div class=\"line\">            //分配内存，写入原始对象，生成新对象</div><div class=\"line\">            ByteArrayInputStream ios = new  ByteArrayInputStream(out.toByteArray());</div><div class=\"line\">            ObjectInputStream ois = new ObjectInputStream(ios);</div><div class=\"line\">            //返回生成的新对象</div><div class=\"line\">            cloneObj = (T) ois.readObject();</div><div class=\"line\">            ois.close();</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return cloneObj;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用该工具类的对象只要实现 Serializable 接口就可实现对象的克隆，无须继承 Cloneable 接口实现 clone() 方法。</p>\n<p>测试一下：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127211824152\" alt=\"这里写图片描述\"></p>\n<p>很完美</p>\n<p>这个时候，Person类实现了Serializable接口</p>\n</blockquote>\n<p>是否使用复制，深复制还是浅复制看情况来使用。</p>\n<blockquote>\n<p>关于序列化与反序列化以后会讲。</p>\n</blockquote>\n<hr>\n<p>这篇文章到这里就暂时告一段落了，后续有补充的话我会继续补充，有错误的话，我也会及时改正。欢迎大家提出问题。</p>\n<blockquote>\n<p>事例代码放在github：<a href=\"https://github.com/CleverFan/JavaImprove\">https://github.com/CleverFan/JavaImprove</a></p>\n</blockquote>\n"},{"title":"开始","type":"javaImprove","order":0,"_content":"\n恩，大概就是这样","source":"study/java/index.md","raw":"---\ntitle: 开始\ntype: javaImprove\norder: 0\n---\n\n恩，大概就是这样","date":"2016-12-13T03:55:54.000Z","updated":"2016-12-13T03:55:54.000Z","path":"study/java/index.html","comments":1,"layout":"page","_id":"ciwnajuxm000gjl2dvcdql7p5","content":"<p>恩，大概就是这样</p>\n","excerpt":"","more":"<p>恩，大概就是这样</p>\n"},{"title":"封装","type":"javaImprove","order":3,"_content":"\n> 如果你认为封装仅仅是private + getter and setter，那你就大错特错了！\n\n## **什么是封装**\n\n对于面向对象的特点，我想大家都可以倒背如流了：封装，继承，多态。很多人对这些特点的理解仅仅停留在表面。以为封装就是变量私有化，然后对外提供接口，而不知为什么要这样做。\n\n封装，简单的来讲就是将变量的属性私有化，在java里就是用private修饰符修饰，这样在外部产生的对象就不能直接访问到这个变量。想要对变量进行操作或者访问，就需要在类里提供外部访问的接口，也就是我们熟知的get和set方法。\n\n这就是大部分人对封装的理解。知道有封装这回事，知道怎么用，却不知道为什么要用，甚至觉得这是多此一举。因为明明`person.name`就可以访问到变量，为什么非要`person.getName()`呢？\n\n## **任性的使用public**\n\n我们先来看一下不使用封装的情况。\n\n首先，有两个类，Man和Women:\n\n``` java\n//Man\npublic class Man {\n    public String name; //名字\n    public Woman wife;  //男人嘛，都有妻子\n    public double money;//男人嘛，多赚点钱\n\n\t//还可以结个婚\n    public void marry(Woman woman){\n        this.wife = woman;\n        woman.marry(this);\n    }\n}\n//Women\npublic class Woman {\n    public String name; //名字\n    public Man husband; //得有一个丈夫\n\t//也可以结个婚\n    public void marry(Man man){\n        this.husband = man;\n    }\n}\n```\n代码很精简，看着很舒服，测试一下。\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161128181621627) \n\n> 哎哟，看起来还不错。\n\n这个时候，来了一个小偷，这小偷不干别的，就偷别人的钱和老婆。\n\n``` java\n//小偷\npublic class Thief {\n    private double stealMoney = 0;\n    private List<Woman> womens = new ArrayList<>();\n\n    //偷钱\n    public void stealMoney(Man man){\n        stealMoney += man.money;\n        man.money = 0;\n        System.out.println(\"哈哈，偷到钱了\");\n    }\n    //偷老婆，最可气的是，偷了你的老婆还把凤姐丢给了你\n    public void stealWife(Man man){\n        womens.add(man.wife);\n        Woman woman = new Woman();\n        woman.name = \"凤姐\";\n        man.wife = woman;\n        System.out.println(\"哈哈哈，又偷了一个妹纸\");\n    }\n}\n```\n\n有一天，来了这么一个小偷：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161128182205942)\n\n>傻了吧？你老婆呢？你钱呢？哈哈哈哈哈哈哈哈哈\n\n就这样，小偷偷走了你的钱和你的老婆并丢给了你一个凤姐，而你，却无能为力。\n\n你觉得必须要改变一下了！！\n\n## **封装前来报到** \n\n封装觉得你有点惨，于是过来帮了一下你：\n\n``` java\n//PackageMan\npublic class PackageMan {\n    private String name; //私有化名字\n    private PackageWoman wife;//必须私有！！必须！\n    private double money; //私有，统统私有！\n    //我们先写个构造函数，为了方便\n    public PackageMan(String name, double money) {\n        this.name = name;\n        this.money = money;\n    }\n    //结婚\n    public void marry(PackageWoman woman){\n        this.wife = woman;\n        woman.marry(this);\n    }\n\n    //各种getter和setter\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public PackageWoman getWife() {\n        return wife;\n    }\n\n    public double getMoney() {\n        return money;\n    }\n}\n\n//PackageWoman\npublic class PackageWoman {\n    private String name;\n    private PackageMan husband;\n\n    public void marry(PackageMan man){\n        this.husband = man;\n    }\n\n    public PackageWoman(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public PackageMan getHusband() {\n        return husband;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n看起来有点眼花缭乱，这样真的有效么？\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161128183404652)\n\n> 恩，看起来还行，就是代码长了点，赶紧给我来个小偷测试一下！\n\n什么？你想测试一下，不好意思，测试不了，因为小偷已经死在测试的路上了。因为我们根本没有对外提供设置money和wife的方法，所以小偷可以知道你有多少钱，知道你有一个漂亮的老婆，但是他却无能为力，因为他只能看着。\n\n细心的人也许发现了，这里面有一个很严重的问题：\n\n没错，小偷不能把我们的money清空了，也不能将我们的wife换成别人了。但是，如果我们要自己换呢？我的钱这辈子就这么点？还不能花？我还不能离婚了？（咳咳。。不鼓励离婚哈，就是举个例子，别打我）\n\n## **这才是封装厉害的地方**\n\n如何解决上面的问题呢？私有化外部访问不到，自己也没法改变数据，提供set方法又会让所有人都能改，和不私有没什么区别，好纠结啊。\n\n\n等等，你刚刚说 “所有人“？真的是所有人么？\n\n我们来看看：\n\n``` java\npublic void setMoney(PackageMan man,double money) {\n    if (man == this) {\n        this.money = money;\n    } else {\n        System.out.println(\"喂，110吗？\"+man.getName()+\"抢钱！\");\n    }\n}\n```\n\n这样呢？只有你自己可以修改，别人都不可以，测试一下：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161128184912423) \n\n> 这样就可以了，自己可以修改，但是别人不可以。\n\n但是你老婆不满意了，凭什么只有你自己能改？我也想改！\n\n这种要求，还是应该满足一下的，怎么做呢？\n\n``` java\npublic void setMoney(Object o,double money) {\n    if (o == this || o == this.wife) {\n        this.money = money;\n    } else {\n        System.out.println(\"喂，110吗？有人抢钱！\");\n    }\n}\n```\n\n这样就可以了。\n\n当然，爱思考的人肯定发现了，我把抢钱的那句话修改了，没有获取修改人的名字，因为传入的是Objects对象。当然，你也可以再写点代码，判断一下传进来的是什么，然后抢转为相应的类型，再调用相应的方法。\n\n除此之外，就没有别的办法了么？当然有，具体怎么做，我们下一篇文章再做分解。下一篇文章《重新认识java（三） ---- 面向对象之继承》不定期更新。\n\n> 仔细思考一下你会发现，我特么竟然是在骗你！因为当你提供了set函数以后，小偷又可以偷你的东西了。仔细看一下之前小偷是怎么偷你东西的你就知道了。\n\n> 没错，就是通过你自己。小偷通过你自己改变了你自己。听起来有点扯，但是事实上就是这样的。\n\n> 那么，有没有一种办法让小偷在只得到”你自己“的情况下怎么样都不能改变“你的属性值”，而只有你自己能改变呢？\n\n> 大家可以自己想想，具体的解决办法，我们在之后的文章里揭晓。敬请期待。\n\n## **总结一下**\n\n以上就是面向对象的封装，封装不仅仅只是private + getter and setter。使用封装可以对setter进行更深层次的定制。你可以对可以执行setter方法的对象做规定，也可以对数据作要求，还可以做类型转换等等一系列你可以想到的。\n\n使用封装不仅仅是安全，更可以简化操作。不要觉得用了封装多了好多代码，看起来乱糟糟的。这只是因为我举得例子太小了。如果你写你个大的系统，一开始你的这样定义类的\n\n``` java\npublic int age;\n```\n\n你的程序里大概有100处这样的语句：\n\n``` java\np.age = 10;\n```\n\n这个时候，突然要求你把数据类型变了，改成：\n\n``` java\npublic String age;\n```\n你是不是要把那100处数据都加个双引号呢？这是不是很麻烦？\n\n如果你用了封装，你只需要这样：\n\n``` java\npublic void setAge(int age){\n\tthis.age = String.valueOf(age);\n}\n\n```\n然后就搞定了，是不是简化了操作？\n\n我只是举个例子，实际开发中也不会出现改变数据类型这么操蛋的事。。\n\n\n封装还有一个好处是模块化。当你参与一个很多人实现的大型系统中，你不可能知道所有的类是怎样实现的。你只需要知道这个类给我提供了哪些方法，我需要传入什么数据，我能得到什么结果。至于怎么得到的，关我x事？\n\n所以说，如果你写的代码还没有用封装，改过来吧。不是因为大家都用所以你也应该用，而是这确实可以给你提供极大的便利。\n\n结束~\n\n----------\n本文同步更新在 ： blog.clevercfan.cn\n有什么疑问或者错误可以给我留言\n\n下篇文章见~","source":"study/java/two.md","raw":"---\ntitle: 封装\ntype: javaImprove\norder: 3\n---\n\n> 如果你认为封装仅仅是private + getter and setter，那你就大错特错了！\n\n## **什么是封装**\n\n对于面向对象的特点，我想大家都可以倒背如流了：封装，继承，多态。很多人对这些特点的理解仅仅停留在表面。以为封装就是变量私有化，然后对外提供接口，而不知为什么要这样做。\n\n封装，简单的来讲就是将变量的属性私有化，在java里就是用private修饰符修饰，这样在外部产生的对象就不能直接访问到这个变量。想要对变量进行操作或者访问，就需要在类里提供外部访问的接口，也就是我们熟知的get和set方法。\n\n这就是大部分人对封装的理解。知道有封装这回事，知道怎么用，却不知道为什么要用，甚至觉得这是多此一举。因为明明`person.name`就可以访问到变量，为什么非要`person.getName()`呢？\n\n## **任性的使用public**\n\n我们先来看一下不使用封装的情况。\n\n首先，有两个类，Man和Women:\n\n``` java\n//Man\npublic class Man {\n    public String name; //名字\n    public Woman wife;  //男人嘛，都有妻子\n    public double money;//男人嘛，多赚点钱\n\n\t//还可以结个婚\n    public void marry(Woman woman){\n        this.wife = woman;\n        woman.marry(this);\n    }\n}\n//Women\npublic class Woman {\n    public String name; //名字\n    public Man husband; //得有一个丈夫\n\t//也可以结个婚\n    public void marry(Man man){\n        this.husband = man;\n    }\n}\n```\n代码很精简，看着很舒服，测试一下。\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161128181621627) \n\n> 哎哟，看起来还不错。\n\n这个时候，来了一个小偷，这小偷不干别的，就偷别人的钱和老婆。\n\n``` java\n//小偷\npublic class Thief {\n    private double stealMoney = 0;\n    private List<Woman> womens = new ArrayList<>();\n\n    //偷钱\n    public void stealMoney(Man man){\n        stealMoney += man.money;\n        man.money = 0;\n        System.out.println(\"哈哈，偷到钱了\");\n    }\n    //偷老婆，最可气的是，偷了你的老婆还把凤姐丢给了你\n    public void stealWife(Man man){\n        womens.add(man.wife);\n        Woman woman = new Woman();\n        woman.name = \"凤姐\";\n        man.wife = woman;\n        System.out.println(\"哈哈哈，又偷了一个妹纸\");\n    }\n}\n```\n\n有一天，来了这么一个小偷：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161128182205942)\n\n>傻了吧？你老婆呢？你钱呢？哈哈哈哈哈哈哈哈哈\n\n就这样，小偷偷走了你的钱和你的老婆并丢给了你一个凤姐，而你，却无能为力。\n\n你觉得必须要改变一下了！！\n\n## **封装前来报到** \n\n封装觉得你有点惨，于是过来帮了一下你：\n\n``` java\n//PackageMan\npublic class PackageMan {\n    private String name; //私有化名字\n    private PackageWoman wife;//必须私有！！必须！\n    private double money; //私有，统统私有！\n    //我们先写个构造函数，为了方便\n    public PackageMan(String name, double money) {\n        this.name = name;\n        this.money = money;\n    }\n    //结婚\n    public void marry(PackageWoman woman){\n        this.wife = woman;\n        woman.marry(this);\n    }\n\n    //各种getter和setter\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public PackageWoman getWife() {\n        return wife;\n    }\n\n    public double getMoney() {\n        return money;\n    }\n}\n\n//PackageWoman\npublic class PackageWoman {\n    private String name;\n    private PackageMan husband;\n\n    public void marry(PackageMan man){\n        this.husband = man;\n    }\n\n    public PackageWoman(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public PackageMan getHusband() {\n        return husband;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n看起来有点眼花缭乱，这样真的有效么？\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161128183404652)\n\n> 恩，看起来还行，就是代码长了点，赶紧给我来个小偷测试一下！\n\n什么？你想测试一下，不好意思，测试不了，因为小偷已经死在测试的路上了。因为我们根本没有对外提供设置money和wife的方法，所以小偷可以知道你有多少钱，知道你有一个漂亮的老婆，但是他却无能为力，因为他只能看着。\n\n细心的人也许发现了，这里面有一个很严重的问题：\n\n没错，小偷不能把我们的money清空了，也不能将我们的wife换成别人了。但是，如果我们要自己换呢？我的钱这辈子就这么点？还不能花？我还不能离婚了？（咳咳。。不鼓励离婚哈，就是举个例子，别打我）\n\n## **这才是封装厉害的地方**\n\n如何解决上面的问题呢？私有化外部访问不到，自己也没法改变数据，提供set方法又会让所有人都能改，和不私有没什么区别，好纠结啊。\n\n\n等等，你刚刚说 “所有人“？真的是所有人么？\n\n我们来看看：\n\n``` java\npublic void setMoney(PackageMan man,double money) {\n    if (man == this) {\n        this.money = money;\n    } else {\n        System.out.println(\"喂，110吗？\"+man.getName()+\"抢钱！\");\n    }\n}\n```\n\n这样呢？只有你自己可以修改，别人都不可以，测试一下：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161128184912423) \n\n> 这样就可以了，自己可以修改，但是别人不可以。\n\n但是你老婆不满意了，凭什么只有你自己能改？我也想改！\n\n这种要求，还是应该满足一下的，怎么做呢？\n\n``` java\npublic void setMoney(Object o,double money) {\n    if (o == this || o == this.wife) {\n        this.money = money;\n    } else {\n        System.out.println(\"喂，110吗？有人抢钱！\");\n    }\n}\n```\n\n这样就可以了。\n\n当然，爱思考的人肯定发现了，我把抢钱的那句话修改了，没有获取修改人的名字，因为传入的是Objects对象。当然，你也可以再写点代码，判断一下传进来的是什么，然后抢转为相应的类型，再调用相应的方法。\n\n除此之外，就没有别的办法了么？当然有，具体怎么做，我们下一篇文章再做分解。下一篇文章《重新认识java（三） ---- 面向对象之继承》不定期更新。\n\n> 仔细思考一下你会发现，我特么竟然是在骗你！因为当你提供了set函数以后，小偷又可以偷你的东西了。仔细看一下之前小偷是怎么偷你东西的你就知道了。\n\n> 没错，就是通过你自己。小偷通过你自己改变了你自己。听起来有点扯，但是事实上就是这样的。\n\n> 那么，有没有一种办法让小偷在只得到”你自己“的情况下怎么样都不能改变“你的属性值”，而只有你自己能改变呢？\n\n> 大家可以自己想想，具体的解决办法，我们在之后的文章里揭晓。敬请期待。\n\n## **总结一下**\n\n以上就是面向对象的封装，封装不仅仅只是private + getter and setter。使用封装可以对setter进行更深层次的定制。你可以对可以执行setter方法的对象做规定，也可以对数据作要求，还可以做类型转换等等一系列你可以想到的。\n\n使用封装不仅仅是安全，更可以简化操作。不要觉得用了封装多了好多代码，看起来乱糟糟的。这只是因为我举得例子太小了。如果你写你个大的系统，一开始你的这样定义类的\n\n``` java\npublic int age;\n```\n\n你的程序里大概有100处这样的语句：\n\n``` java\np.age = 10;\n```\n\n这个时候，突然要求你把数据类型变了，改成：\n\n``` java\npublic String age;\n```\n你是不是要把那100处数据都加个双引号呢？这是不是很麻烦？\n\n如果你用了封装，你只需要这样：\n\n``` java\npublic void setAge(int age){\n\tthis.age = String.valueOf(age);\n}\n\n```\n然后就搞定了，是不是简化了操作？\n\n我只是举个例子，实际开发中也不会出现改变数据类型这么操蛋的事。。\n\n\n封装还有一个好处是模块化。当你参与一个很多人实现的大型系统中，你不可能知道所有的类是怎样实现的。你只需要知道这个类给我提供了哪些方法，我需要传入什么数据，我能得到什么结果。至于怎么得到的，关我x事？\n\n所以说，如果你写的代码还没有用封装，改过来吧。不是因为大家都用所以你也应该用，而是这确实可以给你提供极大的便利。\n\n结束~\n\n----------\n本文同步更新在 ： blog.clevercfan.cn\n有什么疑问或者错误可以给我留言\n\n下篇文章见~","date":"2016-12-13T03:51:51.000Z","updated":"2016-12-13T03:51:51.000Z","path":"study/java/two.html","comments":1,"layout":"page","_id":"ciwnajuxq000hjl2d6fjpj4rp","content":"<blockquote>\n<p>如果你认为封装仅仅是private + getter and setter，那你就大错特错了！</p>\n</blockquote>\n<h2 id=\"什么是封装\"><a href=\"#什么是封装\" class=\"headerlink\" title=\"什么是封装\"></a><strong>什么是封装</strong></h2><p>对于面向对象的特点，我想大家都可以倒背如流了：封装，继承，多态。很多人对这些特点的理解仅仅停留在表面。以为封装就是变量私有化，然后对外提供接口，而不知为什么要这样做。</p>\n<p>封装，简单的来讲就是将变量的属性私有化，在java里就是用private修饰符修饰，这样在外部产生的对象就不能直接访问到这个变量。想要对变量进行操作或者访问，就需要在类里提供外部访问的接口，也就是我们熟知的get和set方法。</p>\n<p>这就是大部分人对封装的理解。知道有封装这回事，知道怎么用，却不知道为什么要用，甚至觉得这是多此一举。因为明明<code>person.name</code>就可以访问到变量，为什么非要<code>person.getName()</code>呢？</p>\n<h2 id=\"任性的使用public\"><a href=\"#任性的使用public\" class=\"headerlink\" title=\"任性的使用public\"></a><strong>任性的使用public</strong></h2><p>我们先来看一下不使用封装的情况。</p>\n<p>首先，有两个类，Man和Women:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Man</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> String name; <span class=\"comment\">//名字</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Woman wife;  <span class=\"comment\">//男人嘛，都有妻子</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> money;<span class=\"comment\">//男人嘛，多赚点钱</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//还可以结个婚</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Woman woman)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.wife = woman;</div><div class=\"line\">        woman.marry(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Women</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Woman</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> String name; <span class=\"comment\">//名字</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Man husband; <span class=\"comment\">//得有一个丈夫</span></div><div class=\"line\">\t<span class=\"comment\">//也可以结个婚</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Man man)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.husband = man;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码很精简，看着很舒服，测试一下。</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161128181621627\" alt=\"这里写图片描述\"> </p>\n<p>哎哟，看起来还不错。</p>\n</blockquote>\n<p>这个时候，来了一个小偷，这小偷不干别的，就偷别人的钱和老婆。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//小偷</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thief</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> stealMoney = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;Woman&gt; womens = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//偷钱</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stealMoney</span><span class=\"params\">(Man man)</span></span>&#123;</div><div class=\"line\">        stealMoney += man.money;</div><div class=\"line\">        man.money = <span class=\"number\">0</span>;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"哈哈，偷到钱了\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//偷老婆，最可气的是，偷了你的老婆还把凤姐丢给了你</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stealWife</span><span class=\"params\">(Man man)</span></span>&#123;</div><div class=\"line\">        womens.add(man.wife);</div><div class=\"line\">        Woman woman = <span class=\"keyword\">new</span> Woman();</div><div class=\"line\">        woman.name = <span class=\"string\">\"凤姐\"</span>;</div><div class=\"line\">        man.wife = woman;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"哈哈哈，又偷了一个妹纸\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有一天，来了这么一个小偷：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161128182205942\" alt=\"这里写图片描述\"></p>\n<p>傻了吧？你老婆呢？你钱呢？哈哈哈哈哈哈哈哈哈</p>\n</blockquote>\n<p>就这样，小偷偷走了你的钱和你的老婆并丢给了你一个凤姐，而你，却无能为力。</p>\n<p>你觉得必须要改变一下了！！</p>\n<h2 id=\"封装前来报到\"><a href=\"#封装前来报到\" class=\"headerlink\" title=\"封装前来报到\"></a><strong>封装前来报到</strong></h2><p>封装觉得你有点惨，于是过来帮了一下你：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//PackageMan</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PackageMan</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name; <span class=\"comment\">//私有化名字</span></div><div class=\"line\">    <span class=\"keyword\">private</span> PackageWoman wife;<span class=\"comment\">//必须私有！！必须！</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> money; <span class=\"comment\">//私有，统统私有！</span></div><div class=\"line\">    <span class=\"comment\">//我们先写个构造函数，为了方便</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PackageMan</span><span class=\"params\">(String name, <span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//结婚</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(PackageWoman woman)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.wife = woman;</div><div class=\"line\">        woman.marry(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//各种getter和setter</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PackageWoman <span class=\"title\">getWife</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> wife;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getMoney</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> money;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//PackageWoman</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PackageWoman</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\">    <span class=\"keyword\">private</span> PackageMan husband;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(PackageMan man)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.husband = man;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PackageWoman</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PackageMan <span class=\"title\">getHusband</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> husband;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看起来有点眼花缭乱，这样真的有效么？</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161128183404652\" alt=\"这里写图片描述\"></p>\n<p>恩，看起来还行，就是代码长了点，赶紧给我来个小偷测试一下！</p>\n</blockquote>\n<p>什么？你想测试一下，不好意思，测试不了，因为小偷已经死在测试的路上了。因为我们根本没有对外提供设置money和wife的方法，所以小偷可以知道你有多少钱，知道你有一个漂亮的老婆，但是他却无能为力，因为他只能看着。</p>\n<p>细心的人也许发现了，这里面有一个很严重的问题：</p>\n<p>没错，小偷不能把我们的money清空了，也不能将我们的wife换成别人了。但是，如果我们要自己换呢？我的钱这辈子就这么点？还不能花？我还不能离婚了？（咳咳。。不鼓励离婚哈，就是举个例子，别打我）</p>\n<h2 id=\"这才是封装厉害的地方\"><a href=\"#这才是封装厉害的地方\" class=\"headerlink\" title=\"这才是封装厉害的地方\"></a><strong>这才是封装厉害的地方</strong></h2><p>如何解决上面的问题呢？私有化外部访问不到，自己也没法改变数据，提供set方法又会让所有人都能改，和不私有没什么区别，好纠结啊。</p>\n<p>等等，你刚刚说 “所有人“？真的是所有人么？</p>\n<p>我们来看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMoney</span><span class=\"params\">(PackageMan man,<span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (man == <span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"喂，110吗？\"</span>+man.getName()+<span class=\"string\">\"抢钱！\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样呢？只有你自己可以修改，别人都不可以，测试一下：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161128184912423\" alt=\"这里写图片描述\"> </p>\n<p>这样就可以了，自己可以修改，但是别人不可以。</p>\n</blockquote>\n<p>但是你老婆不满意了，凭什么只有你自己能改？我也想改！</p>\n<p>这种要求，还是应该满足一下的，怎么做呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMoney</span><span class=\"params\">(Object o,<span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span> || o == <span class=\"keyword\">this</span>.wife) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"喂，110吗？有人抢钱！\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就可以了。</p>\n<p>当然，爱思考的人肯定发现了，我把抢钱的那句话修改了，没有获取修改人的名字，因为传入的是Objects对象。当然，你也可以再写点代码，判断一下传进来的是什么，然后抢转为相应的类型，再调用相应的方法。</p>\n<p>除此之外，就没有别的办法了么？当然有，具体怎么做，我们下一篇文章再做分解。下一篇文章《重新认识java（三） —- 面向对象之继承》不定期更新。</p>\n<blockquote>\n<p>仔细思考一下你会发现，我特么竟然是在骗你！因为当你提供了set函数以后，小偷又可以偷你的东西了。仔细看一下之前小偷是怎么偷你东西的你就知道了。</p>\n<p>没错，就是通过你自己。小偷通过你自己改变了你自己。听起来有点扯，但是事实上就是这样的。</p>\n<p>那么，有没有一种办法让小偷在只得到”你自己“的情况下怎么样都不能改变“你的属性值”，而只有你自己能改变呢？</p>\n<p>大家可以自己想想，具体的解决办法，我们在之后的文章里揭晓。敬请期待。</p>\n</blockquote>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a><strong>总结一下</strong></h2><p>以上就是面向对象的封装，封装不仅仅只是private + getter and setter。使用封装可以对setter进行更深层次的定制。你可以对可以执行setter方法的对象做规定，也可以对数据作要求，还可以做类型转换等等一系列你可以想到的。</p>\n<p>使用封装不仅仅是安全，更可以简化操作。不要觉得用了封装多了好多代码，看起来乱糟糟的。这只是因为我举得例子太小了。如果你写你个大的系统，一开始你的这样定义类的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> age;</div></pre></td></tr></table></figure>\n<p>你的程序里大概有100处这样的语句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">p.age = <span class=\"number\">10</span>;</div></pre></td></tr></table></figure>\n<p>这个时候，突然要求你把数据类型变了，改成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> String age;</div></pre></td></tr></table></figure>\n<p>你是不是要把那100处数据都加个双引号呢？这是不是很麻烦？</p>\n<p>如果你用了封装，你只需要这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.age = String.valueOf(age);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后就搞定了，是不是简化了操作？</p>\n<p>我只是举个例子，实际开发中也不会出现改变数据类型这么操蛋的事。。</p>\n<p>封装还有一个好处是模块化。当你参与一个很多人实现的大型系统中，你不可能知道所有的类是怎样实现的。你只需要知道这个类给我提供了哪些方法，我需要传入什么数据，我能得到什么结果。至于怎么得到的，关我x事？</p>\n<p>所以说，如果你写的代码还没有用封装，改过来吧。不是因为大家都用所以你也应该用，而是这确实可以给你提供极大的便利。</p>\n<p>结束~</p>\n<hr>\n<p>本文同步更新在 ： blog.clevercfan.cn<br>有什么疑问或者错误可以给我留言</p>\n<p>下篇文章见~</p>\n","excerpt":"","more":"<blockquote>\n<p>如果你认为封装仅仅是private + getter and setter，那你就大错特错了！</p>\n</blockquote>\n<h2 id=\"什么是封装\"><a href=\"#什么是封装\" class=\"headerlink\" title=\"什么是封装\"></a><strong>什么是封装</strong></h2><p>对于面向对象的特点，我想大家都可以倒背如流了：封装，继承，多态。很多人对这些特点的理解仅仅停留在表面。以为封装就是变量私有化，然后对外提供接口，而不知为什么要这样做。</p>\n<p>封装，简单的来讲就是将变量的属性私有化，在java里就是用private修饰符修饰，这样在外部产生的对象就不能直接访问到这个变量。想要对变量进行操作或者访问，就需要在类里提供外部访问的接口，也就是我们熟知的get和set方法。</p>\n<p>这就是大部分人对封装的理解。知道有封装这回事，知道怎么用，却不知道为什么要用，甚至觉得这是多此一举。因为明明<code>person.name</code>就可以访问到变量，为什么非要<code>person.getName()</code>呢？</p>\n<h2 id=\"任性的使用public\"><a href=\"#任性的使用public\" class=\"headerlink\" title=\"任性的使用public\"></a><strong>任性的使用public</strong></h2><p>我们先来看一下不使用封装的情况。</p>\n<p>首先，有两个类，Man和Women:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Man</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> String name; <span class=\"comment\">//名字</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Woman wife;  <span class=\"comment\">//男人嘛，都有妻子</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> money;<span class=\"comment\">//男人嘛，多赚点钱</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//还可以结个婚</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Woman woman)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.wife = woman;</div><div class=\"line\">        woman.marry(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Women</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Woman</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> String name; <span class=\"comment\">//名字</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Man husband; <span class=\"comment\">//得有一个丈夫</span></div><div class=\"line\">\t<span class=\"comment\">//也可以结个婚</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Man man)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.husband = man;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码很精简，看着很舒服，测试一下。</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161128181621627\" alt=\"这里写图片描述\"> </p>\n<p>哎哟，看起来还不错。</p>\n</blockquote>\n<p>这个时候，来了一个小偷，这小偷不干别的，就偷别人的钱和老婆。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//小偷</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thief</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> stealMoney = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;Woman&gt; womens = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//偷钱</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stealMoney</span><span class=\"params\">(Man man)</span></span>&#123;</div><div class=\"line\">        stealMoney += man.money;</div><div class=\"line\">        man.money = <span class=\"number\">0</span>;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"哈哈，偷到钱了\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//偷老婆，最可气的是，偷了你的老婆还把凤姐丢给了你</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stealWife</span><span class=\"params\">(Man man)</span></span>&#123;</div><div class=\"line\">        womens.add(man.wife);</div><div class=\"line\">        Woman woman = <span class=\"keyword\">new</span> Woman();</div><div class=\"line\">        woman.name = <span class=\"string\">\"凤姐\"</span>;</div><div class=\"line\">        man.wife = woman;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"哈哈哈，又偷了一个妹纸\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有一天，来了这么一个小偷：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161128182205942\" alt=\"这里写图片描述\"></p>\n<p>傻了吧？你老婆呢？你钱呢？哈哈哈哈哈哈哈哈哈</p>\n</blockquote>\n<p>就这样，小偷偷走了你的钱和你的老婆并丢给了你一个凤姐，而你，却无能为力。</p>\n<p>你觉得必须要改变一下了！！</p>\n<h2 id=\"封装前来报到\"><a href=\"#封装前来报到\" class=\"headerlink\" title=\"封装前来报到\"></a><strong>封装前来报到</strong></h2><p>封装觉得你有点惨，于是过来帮了一下你：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//PackageMan</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PackageMan</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name; <span class=\"comment\">//私有化名字</span></div><div class=\"line\">    <span class=\"keyword\">private</span> PackageWoman wife;<span class=\"comment\">//必须私有！！必须！</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> money; <span class=\"comment\">//私有，统统私有！</span></div><div class=\"line\">    <span class=\"comment\">//我们先写个构造函数，为了方便</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PackageMan</span><span class=\"params\">(String name, <span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//结婚</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(PackageWoman woman)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.wife = woman;</div><div class=\"line\">        woman.marry(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//各种getter和setter</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PackageWoman <span class=\"title\">getWife</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> wife;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getMoney</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> money;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//PackageWoman</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PackageWoman</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\">    <span class=\"keyword\">private</span> PackageMan husband;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(PackageMan man)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.husband = man;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PackageWoman</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PackageMan <span class=\"title\">getHusband</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> husband;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看起来有点眼花缭乱，这样真的有效么？</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161128183404652\" alt=\"这里写图片描述\"></p>\n<p>恩，看起来还行，就是代码长了点，赶紧给我来个小偷测试一下！</p>\n</blockquote>\n<p>什么？你想测试一下，不好意思，测试不了，因为小偷已经死在测试的路上了。因为我们根本没有对外提供设置money和wife的方法，所以小偷可以知道你有多少钱，知道你有一个漂亮的老婆，但是他却无能为力，因为他只能看着。</p>\n<p>细心的人也许发现了，这里面有一个很严重的问题：</p>\n<p>没错，小偷不能把我们的money清空了，也不能将我们的wife换成别人了。但是，如果我们要自己换呢？我的钱这辈子就这么点？还不能花？我还不能离婚了？（咳咳。。不鼓励离婚哈，就是举个例子，别打我）</p>\n<h2 id=\"这才是封装厉害的地方\"><a href=\"#这才是封装厉害的地方\" class=\"headerlink\" title=\"这才是封装厉害的地方\"></a><strong>这才是封装厉害的地方</strong></h2><p>如何解决上面的问题呢？私有化外部访问不到，自己也没法改变数据，提供set方法又会让所有人都能改，和不私有没什么区别，好纠结啊。</p>\n<p>等等，你刚刚说 “所有人“？真的是所有人么？</p>\n<p>我们来看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMoney</span><span class=\"params\">(PackageMan man,<span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (man == <span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"喂，110吗？\"</span>+man.getName()+<span class=\"string\">\"抢钱！\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样呢？只有你自己可以修改，别人都不可以，测试一下：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161128184912423\" alt=\"这里写图片描述\"> </p>\n<p>这样就可以了，自己可以修改，但是别人不可以。</p>\n</blockquote>\n<p>但是你老婆不满意了，凭什么只有你自己能改？我也想改！</p>\n<p>这种要求，还是应该满足一下的，怎么做呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMoney</span><span class=\"params\">(Object o,<span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span> || o == <span class=\"keyword\">this</span>.wife) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"喂，110吗？有人抢钱！\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就可以了。</p>\n<p>当然，爱思考的人肯定发现了，我把抢钱的那句话修改了，没有获取修改人的名字，因为传入的是Objects对象。当然，你也可以再写点代码，判断一下传进来的是什么，然后抢转为相应的类型，再调用相应的方法。</p>\n<p>除此之外，就没有别的办法了么？当然有，具体怎么做，我们下一篇文章再做分解。下一篇文章《重新认识java（三） —- 面向对象之继承》不定期更新。</p>\n<blockquote>\n<p>仔细思考一下你会发现，我特么竟然是在骗你！因为当你提供了set函数以后，小偷又可以偷你的东西了。仔细看一下之前小偷是怎么偷你东西的你就知道了。</p>\n<p>没错，就是通过你自己。小偷通过你自己改变了你自己。听起来有点扯，但是事实上就是这样的。</p>\n<p>那么，有没有一种办法让小偷在只得到”你自己“的情况下怎么样都不能改变“你的属性值”，而只有你自己能改变呢？</p>\n<p>大家可以自己想想，具体的解决办法，我们在之后的文章里揭晓。敬请期待。</p>\n</blockquote>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a><strong>总结一下</strong></h2><p>以上就是面向对象的封装，封装不仅仅只是private + getter and setter。使用封装可以对setter进行更深层次的定制。你可以对可以执行setter方法的对象做规定，也可以对数据作要求，还可以做类型转换等等一系列你可以想到的。</p>\n<p>使用封装不仅仅是安全，更可以简化操作。不要觉得用了封装多了好多代码，看起来乱糟糟的。这只是因为我举得例子太小了。如果你写你个大的系统，一开始你的这样定义类的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> age;</div></pre></td></tr></table></figure>\n<p>你的程序里大概有100处这样的语句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">p.age = <span class=\"number\">10</span>;</div></pre></td></tr></table></figure>\n<p>这个时候，突然要求你把数据类型变了，改成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> String age;</div></pre></td></tr></table></figure>\n<p>你是不是要把那100处数据都加个双引号呢？这是不是很麻烦？</p>\n<p>如果你用了封装，你只需要这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.age = String.valueOf(age);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后就搞定了，是不是简化了操作？</p>\n<p>我只是举个例子，实际开发中也不会出现改变数据类型这么操蛋的事。。</p>\n<p>封装还有一个好处是模块化。当你参与一个很多人实现的大型系统中，你不可能知道所有的类是怎样实现的。你只需要知道这个类给我提供了哪些方法，我需要传入什么数据，我能得到什么结果。至于怎么得到的，关我x事？</p>\n<p>所以说，如果你写的代码还没有用封装，改过来吧。不是因为大家都用所以你也应该用，而是这确实可以给你提供极大的便利。</p>\n<p>结束~</p>\n<hr>\n<p>本文同步更新在 ： blog.clevercfan.cn<br>有什么疑问或者错误可以给我留言</p>\n<p>下篇文章见~</p>\n"},{"title":"继承","type":"javaImprove","order":4,"_content":"\n> 学习一个新知识的第一步，就是要知道它是什么，然后要知道为什么要用它，最后要知道如何使用它。这篇文章，我们重新认识一下java中的继承。\n\n## **继承是个什么东西**\n\n我们先来看一下上一篇文章中的代码：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161129160404250)![这里写图片描述](http://img.blog.csdn.net/20161129160417453) \n\n 你会发现，这两个类中都有name属性，都有marry方法。一个人，不可能只有名字吧。他还有年龄，地址，手机号码，身份证号码，身高，体重巴拉巴拉的。除了男人和女人，还有小孩，老人，教师。。。\n\n如果我们每个类里都写一遍name，age。。。也许你还没写完程序，自己就先累死了。不用我说，大家也应该知道了，没错，我们需要继承的帮助。\n\n我们把相同的属性抽取出来，定义一个新的类Person，然后让男人，女人都去继承它，从而获得Person的属性，这样，就大大简化了我们的工作。\n\n我们来尝试一下。\n\n``` java\n//父类\npublic class Person {\n    protected String name;\n    protected int age;\n\n    public void eat(){\n        System.out.println(\"i am eating\");\n    }\n}\n//Man类 继承Person\npublic class Man extends Person {\n    private boolean hasBeard;\n\n    public void showMan(){\n        System.out.println(\"i am a man\");\n    }\n\n    public boolean isHasBeard() {\n        return hasBeard;\n    }\n}\n//woman类 继承Person\npublic class Woman extends Person{\n    private boolean hasLongHair;\n\n    public void shouWoman(){\n        System.out.println(\"i am a woman\");\n    }\n\n    public boolean isHasLongHair() {\n        return hasLongHair;\n    }\n}\n```\n简单的继承我想大家都懂，我就不多说占用篇幅了。\n \n## **继承的特点**\n\n我们已经知道了什么是继承，那么继承有没有什么限制呢？\n\n### **1.java中只支持单继承**\n也就是说，一个类只能够有一个父类。但是java支持“多重继承”。\n\n单继承：\n\n``` java\nclass A(){}\nclass B extends A (){} \n```\n多重继承：\n\n``` java\nclass A{}\nclass B extends A {} \nclass C extends B {} \n```\n\n> 为什么java不支持多继承呢？因为容易造成不必要的混乱。比如说：\n>\n> - **结构复杂化**：如果是单一继承，一个类的父类是什么，父类的父类是什么，都很明确，因为只有单一的继承关系，然而如果是多重继承的话，一个类有多个父类，这些父类又有自己的父类，那么类之间的关系就很复杂了。\n- **优先顺序模糊**：假如我有A，C类同时继承了基类，B类继承了A类，然后D类又同时继承了B和C类，所以D类继承父类的方法的顺序应该是D、B、A、C还是D、B、C、A，或者是其他的顺序，很不明确。\n- **功能冲突**：因为多重继承有多个父类，所以当不同的父类中有相同的方法是就会产生冲突。如果B类和C类同时又有相同的方法时，D继承的是哪个方法就不明确了，因为存在两种可能性。\n\n> 当然，多继承的这些问题很多语言已经解决了，比如c++，python等，但并不是所有的语言都有必要去解决这个问题。java的类虽然不能实现多继承，但是java的接口支持多实现，这个我们讲到接口的时候再说。\n\n>对多继承感兴趣的可以google一下mixin（混入），还可以去看一下基于java8的mixin实现（大多数都是线程不安全的，不要随便用）。  \n\n### **2.子类拥有父类非private的属性，方法**\n也就是说，父类的属性或者方法如果是peivate的，那么子类是不能继承它的。讲到这里，就必须得提一下四个修饰符了：\n\n| ---- |本类 | 同包（无关类或子类）|不同包（子类）|不同包（无关类）\n| --------- |:----:| :-----:|:--:|:-:\n| private | ✅ | |\n| default | ✅ | ✅ |\n| protected| ✅ | ✅|✅\n|public|✅|✅|✅|✅\n\n在java中，protected关键字大展身手的地方就是在继承中。《thinking in java》中是这样介绍protected的：\n\n> 在理想世界中，仅靠关键字private已经足够了。但在实际项目中，经常会想要将某些事物尽可能堆这个世界隐藏起来，但仍然允许导出的类的成员访问他们。关键字protected就是起这个作用的。它指明”就类用户而言，这是privated，但是对于任何一个继承于此类的导出类或其他任何一个位于同一个包内的类来说，他却是可以访问的”\n\n怎么理解呢？写个代码你就明白了\n\n``` java\n\npackage cn.pkgA\nclass A {\n\tprotected String name；\n}\nclass B extends A{}\nclass C {\n\tB b = new B();\n\tb.name;//可以访问到\n}\npackage cn.pkgB\n\nclass C {\n\tB b = new B();\n\tb.name;//访问不到\n}\n\n\n```\n\n### **3.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。**\n\n如果子类只能有父类的属性和方法，那要子类还有什么用？？\n\n### **4.子类可以用自己的方式实现父类的方法。**\n\n这个叫做函数重写（覆盖），我们一会会重点分析。\n\n\n## **构造器**\n\n除了被peivate修饰的方法和变量之外，父类的构造器也不能被子类继承。\n\n但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的当属列表。\n\n如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。\n\n我们给Person类添加一个构造器：\n\n``` java\npublic class Person {\n    protected String name;\n    protected int age;\n\n    public void eat(){\n        System.out.println(\"i am eating\");\n    }\n\t//带参数的构造器\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n这个时候，如果你不给子类添加构造器并在第一行写入super（name，age），则会报错：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161129165450586) \n\n在子类添加如下方法后错误消失：\n\n``` java\npublic Man(String name, int age/*, boolean hasBeard*/) {\n    super(name, age);\n    //this.hasBeard = hasBeard;\n}\n\n//注释掉的地方可有可无\n```\n为什么会有这个要求呢？你一会就知道了，先卖个关子。\n\n\n## **重写与重载**\n\n### **重写**\n重写又叫覆盖，发生在继承关系下的子类中。我们上面说过，子类可以用自己的方式实现父类的方法，重写不能改变参数列表，也不能缩小方法的访问权限，如果父类方法抛出异常，子类抛出的异常不能比父类的异常“大”，也不能抛出新的异常。\n\n我们Person类中有一个方法：\n\n``` java\n    public void eat(){\n        System.out.println(\"i am eating\");\n    }\n```\n有一个子类修道成仙了，不吃饭，于是他可以在他自己的类里这样改\n``` java\n\t@Override  //这个是注解，表明这个方法是重写了父类的方法，最好写上\n    public void eat(){\n        System.out.println(\"i don't eat\");\n    }\n```\n\n这里提一下，子类重写父类方法不能缩小父类方法的访问权限但扩大是可以的。比如说父类有一个protected方法，子类重写它的时候不能改为private，但是可以改成public。\n\n这里还有一个不大不小的坑。如果你的父类方法是peivate的，比如：\n\n``` java\n    private void eat(){\n        System.out.println(\"i am eating\");\n    }\n```\n\n你可以在子类中这样写：\n\n``` java\n    public void eat(){\n        System.out.println(\"i don't eat\");\n    }\n```\n但是，这不是重写！！！！因为父类方法是私有的，所以子类根本没有得到eat()这个方法，子类的eat()方法是你重新定义的一个和父类没有半毛钱的函数。\n\n### **重载**\n把重载放到这里讲只是因为它和重写有的然傻傻分不清楚，重载和继承没有任何关系（当然，继承之间也存在重载，也就是说，继承可以重载，但是重载不一定继承），它发生在类本身。重载方法的特点是方法名相同而参数列表不同。\n\n比如这样：\n\n``` java\npublic void count(int a , int b){\n\tSystem.out.println(\"a+b=\" + (a+b));\n}\n\npublic void count(int a , int b,int c){\n\tSystem.out.println(\"a+b=\" + (a+b+c));\n}\n\npublic void count(int a , int b ,double c){\n\tSystem.out.println(\"a+b=\" + (a+b+c));\n}\n\n```\n函数重载的特点：\n\n - 被重载的方法**必须**改变参数列表(参数个数或类型或顺序不一样)；\n - 被重载的方法可以改变返回类型；\n - 被重载的方法可以改变访问修饰符；\n - 被重载的方法可以声明新的或更广的检查异常（区别于重写）；\n - 方法能够在同一个类中或者在一个子类中被重载。\n\n注意：参数列表必须不同！\n\n\n## **继承的缺点**\n\n - 继承是一种强耦合关系，父类变，子类就必须变。\n - 继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n\n提醒！慎用继承！\n\n如果你知道高手写代码都想着怎么解耦你就知道这个缺点室友多么讨厌了。\n\n你可能会问，我不用继承用什么？别急，接下来的几篇文章会告诉你。\n\n## **昨天的遗留问题**\n\n看了上一篇文章的人可能还记得那个遗留问题。我们现在来解决一下：\n\n``` java\n//父类\npublic class Person {\n    protected String name;\n    \n    public void marry(Person p){\n        System.out.println(\"marry\");\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n//man类\npublic class Man extends Person {\n    private Woman wife;\n    private double money;\n\n    @Override\n    public void marry(Person p) {\n        this.wife = (Woman)p;\n        p.marry(this);\n    }\n\t//只有自己和妻子可以用钱\n    public void setMoney(Person p,double money) {\n        if (p == this || p == this.wife)\n            this.money = money;\n        else\n            System.out.println(p.getName()+\"抢钱！\");\n    }\n\n    public double getMoney() {\n        return money;\n    }\n}\n//woman类\npublic class Woman extends Person{\n    private boolean hasLongHair;\n    private Man husband;\n\n    @Override\n    public void marry(Person p) {\n        this.husband = (Man)p;\n    }\n}\n```\n\n我们来看一下效果：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161129215239122) \n\n>看起来还不错，不是么。\n\n当然，我更喜欢这么做\n\n``` java\npublic void setMoney(Person p,double money) {\n\t  if (p == this || p == this.wife)\n\t      this.money = money;\n\t  else if(money > this.money)\n\t\t  this.money = money;\n\t  else  \n\t      System.out.println(p.getName()+\"抢钱！\");\n}\n```\n \n\n## **总结**\n\n继承还有很多知识点，比如向上转型和向下转型（上面解决上一篇问题的代码就用到了这个知识点），在继承中，对象是怎么初始化的，静态代码块的使用，final关键字的使用等等。\n\n但是我打算先放一放再讲，等写完组合，聚合和多态再来讨论这些知识会更好一点。\n\n下一篇《重新认识java（四） ---  组合、聚合与继承的爱恨情仇》敬请期待。\n\n\n----------\n有错误或者我没讲到的地方或者更好的思路请及时与我联系！","source":"study/java/three.md","raw":"---\ntitle: 继承\ntype: javaImprove\norder: 4\n---\n\n> 学习一个新知识的第一步，就是要知道它是什么，然后要知道为什么要用它，最后要知道如何使用它。这篇文章，我们重新认识一下java中的继承。\n\n## **继承是个什么东西**\n\n我们先来看一下上一篇文章中的代码：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161129160404250)![这里写图片描述](http://img.blog.csdn.net/20161129160417453) \n\n 你会发现，这两个类中都有name属性，都有marry方法。一个人，不可能只有名字吧。他还有年龄，地址，手机号码，身份证号码，身高，体重巴拉巴拉的。除了男人和女人，还有小孩，老人，教师。。。\n\n如果我们每个类里都写一遍name，age。。。也许你还没写完程序，自己就先累死了。不用我说，大家也应该知道了，没错，我们需要继承的帮助。\n\n我们把相同的属性抽取出来，定义一个新的类Person，然后让男人，女人都去继承它，从而获得Person的属性，这样，就大大简化了我们的工作。\n\n我们来尝试一下。\n\n``` java\n//父类\npublic class Person {\n    protected String name;\n    protected int age;\n\n    public void eat(){\n        System.out.println(\"i am eating\");\n    }\n}\n//Man类 继承Person\npublic class Man extends Person {\n    private boolean hasBeard;\n\n    public void showMan(){\n        System.out.println(\"i am a man\");\n    }\n\n    public boolean isHasBeard() {\n        return hasBeard;\n    }\n}\n//woman类 继承Person\npublic class Woman extends Person{\n    private boolean hasLongHair;\n\n    public void shouWoman(){\n        System.out.println(\"i am a woman\");\n    }\n\n    public boolean isHasLongHair() {\n        return hasLongHair;\n    }\n}\n```\n简单的继承我想大家都懂，我就不多说占用篇幅了。\n \n## **继承的特点**\n\n我们已经知道了什么是继承，那么继承有没有什么限制呢？\n\n### **1.java中只支持单继承**\n也就是说，一个类只能够有一个父类。但是java支持“多重继承”。\n\n单继承：\n\n``` java\nclass A(){}\nclass B extends A (){} \n```\n多重继承：\n\n``` java\nclass A{}\nclass B extends A {} \nclass C extends B {} \n```\n\n> 为什么java不支持多继承呢？因为容易造成不必要的混乱。比如说：\n>\n> - **结构复杂化**：如果是单一继承，一个类的父类是什么，父类的父类是什么，都很明确，因为只有单一的继承关系，然而如果是多重继承的话，一个类有多个父类，这些父类又有自己的父类，那么类之间的关系就很复杂了。\n- **优先顺序模糊**：假如我有A，C类同时继承了基类，B类继承了A类，然后D类又同时继承了B和C类，所以D类继承父类的方法的顺序应该是D、B、A、C还是D、B、C、A，或者是其他的顺序，很不明确。\n- **功能冲突**：因为多重继承有多个父类，所以当不同的父类中有相同的方法是就会产生冲突。如果B类和C类同时又有相同的方法时，D继承的是哪个方法就不明确了，因为存在两种可能性。\n\n> 当然，多继承的这些问题很多语言已经解决了，比如c++，python等，但并不是所有的语言都有必要去解决这个问题。java的类虽然不能实现多继承，但是java的接口支持多实现，这个我们讲到接口的时候再说。\n\n>对多继承感兴趣的可以google一下mixin（混入），还可以去看一下基于java8的mixin实现（大多数都是线程不安全的，不要随便用）。  \n\n### **2.子类拥有父类非private的属性，方法**\n也就是说，父类的属性或者方法如果是peivate的，那么子类是不能继承它的。讲到这里，就必须得提一下四个修饰符了：\n\n| ---- |本类 | 同包（无关类或子类）|不同包（子类）|不同包（无关类）\n| --------- |:----:| :-----:|:--:|:-:\n| private | ✅ | |\n| default | ✅ | ✅ |\n| protected| ✅ | ✅|✅\n|public|✅|✅|✅|✅\n\n在java中，protected关键字大展身手的地方就是在继承中。《thinking in java》中是这样介绍protected的：\n\n> 在理想世界中，仅靠关键字private已经足够了。但在实际项目中，经常会想要将某些事物尽可能堆这个世界隐藏起来，但仍然允许导出的类的成员访问他们。关键字protected就是起这个作用的。它指明”就类用户而言，这是privated，但是对于任何一个继承于此类的导出类或其他任何一个位于同一个包内的类来说，他却是可以访问的”\n\n怎么理解呢？写个代码你就明白了\n\n``` java\n\npackage cn.pkgA\nclass A {\n\tprotected String name；\n}\nclass B extends A{}\nclass C {\n\tB b = new B();\n\tb.name;//可以访问到\n}\npackage cn.pkgB\n\nclass C {\n\tB b = new B();\n\tb.name;//访问不到\n}\n\n\n```\n\n### **3.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。**\n\n如果子类只能有父类的属性和方法，那要子类还有什么用？？\n\n### **4.子类可以用自己的方式实现父类的方法。**\n\n这个叫做函数重写（覆盖），我们一会会重点分析。\n\n\n## **构造器**\n\n除了被peivate修饰的方法和变量之外，父类的构造器也不能被子类继承。\n\n但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的当属列表。\n\n如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。\n\n我们给Person类添加一个构造器：\n\n``` java\npublic class Person {\n    protected String name;\n    protected int age;\n\n    public void eat(){\n        System.out.println(\"i am eating\");\n    }\n\t//带参数的构造器\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n这个时候，如果你不给子类添加构造器并在第一行写入super（name，age），则会报错：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161129165450586) \n\n在子类添加如下方法后错误消失：\n\n``` java\npublic Man(String name, int age/*, boolean hasBeard*/) {\n    super(name, age);\n    //this.hasBeard = hasBeard;\n}\n\n//注释掉的地方可有可无\n```\n为什么会有这个要求呢？你一会就知道了，先卖个关子。\n\n\n## **重写与重载**\n\n### **重写**\n重写又叫覆盖，发生在继承关系下的子类中。我们上面说过，子类可以用自己的方式实现父类的方法，重写不能改变参数列表，也不能缩小方法的访问权限，如果父类方法抛出异常，子类抛出的异常不能比父类的异常“大”，也不能抛出新的异常。\n\n我们Person类中有一个方法：\n\n``` java\n    public void eat(){\n        System.out.println(\"i am eating\");\n    }\n```\n有一个子类修道成仙了，不吃饭，于是他可以在他自己的类里这样改\n``` java\n\t@Override  //这个是注解，表明这个方法是重写了父类的方法，最好写上\n    public void eat(){\n        System.out.println(\"i don't eat\");\n    }\n```\n\n这里提一下，子类重写父类方法不能缩小父类方法的访问权限但扩大是可以的。比如说父类有一个protected方法，子类重写它的时候不能改为private，但是可以改成public。\n\n这里还有一个不大不小的坑。如果你的父类方法是peivate的，比如：\n\n``` java\n    private void eat(){\n        System.out.println(\"i am eating\");\n    }\n```\n\n你可以在子类中这样写：\n\n``` java\n    public void eat(){\n        System.out.println(\"i don't eat\");\n    }\n```\n但是，这不是重写！！！！因为父类方法是私有的，所以子类根本没有得到eat()这个方法，子类的eat()方法是你重新定义的一个和父类没有半毛钱的函数。\n\n### **重载**\n把重载放到这里讲只是因为它和重写有的然傻傻分不清楚，重载和继承没有任何关系（当然，继承之间也存在重载，也就是说，继承可以重载，但是重载不一定继承），它发生在类本身。重载方法的特点是方法名相同而参数列表不同。\n\n比如这样：\n\n``` java\npublic void count(int a , int b){\n\tSystem.out.println(\"a+b=\" + (a+b));\n}\n\npublic void count(int a , int b,int c){\n\tSystem.out.println(\"a+b=\" + (a+b+c));\n}\n\npublic void count(int a , int b ,double c){\n\tSystem.out.println(\"a+b=\" + (a+b+c));\n}\n\n```\n函数重载的特点：\n\n - 被重载的方法**必须**改变参数列表(参数个数或类型或顺序不一样)；\n - 被重载的方法可以改变返回类型；\n - 被重载的方法可以改变访问修饰符；\n - 被重载的方法可以声明新的或更广的检查异常（区别于重写）；\n - 方法能够在同一个类中或者在一个子类中被重载。\n\n注意：参数列表必须不同！\n\n\n## **继承的缺点**\n\n - 继承是一种强耦合关系，父类变，子类就必须变。\n - 继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n\n提醒！慎用继承！\n\n如果你知道高手写代码都想着怎么解耦你就知道这个缺点室友多么讨厌了。\n\n你可能会问，我不用继承用什么？别急，接下来的几篇文章会告诉你。\n\n## **昨天的遗留问题**\n\n看了上一篇文章的人可能还记得那个遗留问题。我们现在来解决一下：\n\n``` java\n//父类\npublic class Person {\n    protected String name;\n    \n    public void marry(Person p){\n        System.out.println(\"marry\");\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n//man类\npublic class Man extends Person {\n    private Woman wife;\n    private double money;\n\n    @Override\n    public void marry(Person p) {\n        this.wife = (Woman)p;\n        p.marry(this);\n    }\n\t//只有自己和妻子可以用钱\n    public void setMoney(Person p,double money) {\n        if (p == this || p == this.wife)\n            this.money = money;\n        else\n            System.out.println(p.getName()+\"抢钱！\");\n    }\n\n    public double getMoney() {\n        return money;\n    }\n}\n//woman类\npublic class Woman extends Person{\n    private boolean hasLongHair;\n    private Man husband;\n\n    @Override\n    public void marry(Person p) {\n        this.husband = (Man)p;\n    }\n}\n```\n\n我们来看一下效果：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161129215239122) \n\n>看起来还不错，不是么。\n\n当然，我更喜欢这么做\n\n``` java\npublic void setMoney(Person p,double money) {\n\t  if (p == this || p == this.wife)\n\t      this.money = money;\n\t  else if(money > this.money)\n\t\t  this.money = money;\n\t  else  \n\t      System.out.println(p.getName()+\"抢钱！\");\n}\n```\n \n\n## **总结**\n\n继承还有很多知识点，比如向上转型和向下转型（上面解决上一篇问题的代码就用到了这个知识点），在继承中，对象是怎么初始化的，静态代码块的使用，final关键字的使用等等。\n\n但是我打算先放一放再讲，等写完组合，聚合和多态再来讨论这些知识会更好一点。\n\n下一篇《重新认识java（四） ---  组合、聚合与继承的爱恨情仇》敬请期待。\n\n\n----------\n有错误或者我没讲到的地方或者更好的思路请及时与我联系！","date":"2016-12-13T03:51:51.000Z","updated":"2016-12-13T03:51:51.000Z","path":"study/java/three.html","comments":1,"layout":"page","_id":"ciwnajuxr000ijl2d7892xvll","content":"<blockquote>\n<p>学习一个新知识的第一步，就是要知道它是什么，然后要知道为什么要用它，最后要知道如何使用它。这篇文章，我们重新认识一下java中的继承。</p>\n</blockquote>\n<h2 id=\"继承是个什么东西\"><a href=\"#继承是个什么东西\" class=\"headerlink\" title=\"继承是个什么东西\"></a><strong>继承是个什么东西</strong></h2><p>我们先来看一下上一篇文章中的代码：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161129160404250\" alt=\"这里写图片描述\"><img src=\"http://img.blog.csdn.net/20161129160417453\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p> 你会发现，这两个类中都有name属性，都有marry方法。一个人，不可能只有名字吧。他还有年龄，地址，手机号码，身份证号码，身高，体重巴拉巴拉的。除了男人和女人，还有小孩，老人，教师。。。</p>\n<p>如果我们每个类里都写一遍name，age。。。也许你还没写完程序，自己就先累死了。不用我说，大家也应该知道了，没错，我们需要继承的帮助。</p>\n<p>我们把相同的属性抽取出来，定义一个新的类Person，然后让男人，女人都去继承它，从而获得Person的属性，这样，就大大简化了我们的工作。</p>\n<p>我们来尝试一下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//父类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">protected</span> String name;</div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"i am eating\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Man类 继承Person</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasBeard;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showMan</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"i am a man\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHasBeard</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> hasBeard;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//woman类 继承Person</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Woman</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasLongHair;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shouWoman</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"i am a woman\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHasLongHair</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> hasLongHair;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>简单的继承我想大家都懂，我就不多说占用篇幅了。</p>\n<h2 id=\"继承的特点\"><a href=\"#继承的特点\" class=\"headerlink\" title=\"继承的特点\"></a><strong>继承的特点</strong></h2><p>我们已经知道了什么是继承，那么继承有没有什么限制呢？</p>\n<h3 id=\"1-java中只支持单继承\"><a href=\"#1-java中只支持单继承\" class=\"headerlink\" title=\"1.java中只支持单继承\"></a><strong>1.java中只支持单继承</strong></h3><p>也就是说，一个类只能够有一个父类。但是java支持“多重继承”。</p>\n<p>单继承：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>()</span>&#123;&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> ()</span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>多重继承：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;&#125; </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>为什么java不支持多继承呢？因为容易造成不必要的混乱。比如说：</p>\n<ul>\n<li><strong>结构复杂化</strong>：如果是单一继承，一个类的父类是什么，父类的父类是什么，都很明确，因为只有单一的继承关系，然而如果是多重继承的话，一个类有多个父类，这些父类又有自己的父类，那么类之间的关系就很复杂了。</li>\n<li><strong>优先顺序模糊</strong>：假如我有A，C类同时继承了基类，B类继承了A类，然后D类又同时继承了B和C类，所以D类继承父类的方法的顺序应该是D、B、A、C还是D、B、C、A，或者是其他的顺序，很不明确。</li>\n<li><strong>功能冲突</strong>：因为多重继承有多个父类，所以当不同的父类中有相同的方法是就会产生冲突。如果B类和C类同时又有相同的方法时，D继承的是哪个方法就不明确了，因为存在两种可能性。</li>\n</ul>\n<p>当然，多继承的这些问题很多语言已经解决了，比如c++，python等，但并不是所有的语言都有必要去解决这个问题。java的类虽然不能实现多继承，但是java的接口支持多实现，这个我们讲到接口的时候再说。</p>\n<p>对多继承感兴趣的可以google一下mixin（混入），还可以去看一下基于java8的mixin实现（大多数都是线程不安全的，不要随便用）。  </p>\n</blockquote>\n<h3 id=\"2-子类拥有父类非private的属性，方法\"><a href=\"#2-子类拥有父类非private的属性，方法\" class=\"headerlink\" title=\"2.子类拥有父类非private的属性，方法\"></a><strong>2.子类拥有父类非private的属性，方法</strong></h3><p>也就是说，父类的属性或者方法如果是peivate的，那么子类是不能继承它的。讲到这里，就必须得提一下四个修饰符了：</p>\n<table>\n<thead>\n<tr>\n<th>—-</th>\n<th style=\"text-align:center\">本类</th>\n<th style=\"text-align:center\">同包（无关类或子类）</th>\n<th style=\"text-align:center\">不同包（子类）</th>\n<th style=\"text-align:center\">不同包（无关类）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>private</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>default</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n</tr>\n<tr>\n<td>protected</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n</tr>\n<tr>\n<td>public</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n</tr>\n</tbody>\n</table>\n<p>在java中，protected关键字大展身手的地方就是在继承中。《thinking in java》中是这样介绍protected的：</p>\n<blockquote>\n<p>在理想世界中，仅靠关键字private已经足够了。但在实际项目中，经常会想要将某些事物尽可能堆这个世界隐藏起来，但仍然允许导出的类的成员访问他们。关键字protected就是起这个作用的。它指明”就类用户而言，这是privated，但是对于任何一个继承于此类的导出类或其他任何一个位于同一个包内的类来说，他却是可以访问的”</p>\n</blockquote>\n<p>怎么理解呢？写个代码你就明白了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">package</span> cn.pkgA</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">protected</span> String name；</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span></span>&#123;&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</div><div class=\"line\">\tB b = <span class=\"keyword\">new</span> B();</div><div class=\"line\">\tb.name;<span class=\"comment\">//可以访问到</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">package</span> cn.pkgB</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</div><div class=\"line\">\tB b = <span class=\"keyword\">new</span> B();</div><div class=\"line\">\tb.name;<span class=\"comment\">//访问不到</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\"><a href=\"#3-子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\" class=\"headerlink\" title=\"3.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\"></a><strong>3.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</strong></h3><p>如果子类只能有父类的属性和方法，那要子类还有什么用？？</p>\n<h3 id=\"4-子类可以用自己的方式实现父类的方法。\"><a href=\"#4-子类可以用自己的方式实现父类的方法。\" class=\"headerlink\" title=\"4.子类可以用自己的方式实现父类的方法。\"></a><strong>4.子类可以用自己的方式实现父类的方法。</strong></h3><p>这个叫做函数重写（覆盖），我们一会会重点分析。</p>\n<h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a><strong>构造器</strong></h2><p>除了被peivate修饰的方法和变量之外，父类的构造器也不能被子类继承。</p>\n<p>但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的当属列表。</p>\n<p>如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。</p>\n<p>我们给Person类添加一个构造器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">protected</span> String name;</div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"i am eating\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//带参数的构造器</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个时候，如果你不给子类添加构造器并在第一行写入super（name，age），则会报错：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161129165450586\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p>在子类添加如下方法后错误消失：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Man</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age<span class=\"comment\">/*, boolean hasBeard*/</span>)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(name, age);</div><div class=\"line\">    <span class=\"comment\">//this.hasBeard = hasBeard;</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//注释掉的地方可有可无</span></div></pre></td></tr></table></figure>\n<p>为什么会有这个要求呢？你一会就知道了，先卖个关子。</p>\n<h2 id=\"重写与重载\"><a href=\"#重写与重载\" class=\"headerlink\" title=\"重写与重载\"></a><strong>重写与重载</strong></h2><h3 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a><strong>重写</strong></h3><p>重写又叫覆盖，发生在继承关系下的子类中。我们上面说过，子类可以用自己的方式实现父类的方法，重写不能改变参数列表，也不能缩小方法的访问权限，如果父类方法抛出异常，子类抛出的异常不能比父类的异常“大”，也不能抛出新的异常。</p>\n<p>我们Person类中有一个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"i am eating\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有一个子类修道成仙了，不吃饭，于是他可以在他自己的类里这样改<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span>  <span class=\"comment\">//这个是注解，表明这个方法是重写了父类的方法，最好写上</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">       System.out.println(<span class=\"string\">\"i don't eat\"</span>);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>这里提一下，子类重写父类方法不能缩小父类方法的访问权限但扩大是可以的。比如说父类有一个protected方法，子类重写它的时候不能改为private，但是可以改成public。</p>\n<p>这里还有一个不大不小的坑。如果你的父类方法是peivate的，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"i am eating\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以在子类中这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"i don't eat\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，这不是重写！！！！因为父类方法是私有的，所以子类根本没有得到eat()这个方法，子类的eat()方法是你重新定义的一个和父类没有半毛钱的函数。</p>\n<h3 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a><strong>重载</strong></h3><p>把重载放到这里讲只是因为它和重写有的然傻傻分不清楚，重载和继承没有任何关系（当然，继承之间也存在重载，也就是说，继承可以重载，但是重载不一定继承），它发生在类本身。重载方法的特点是方法名相同而参数列表不同。</p>\n<p>比如这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> a , <span class=\"keyword\">int</span> b)</span></span>&#123;</div><div class=\"line\">\tSystem.out.println(<span class=\"string\">\"a+b=\"</span> + (a+b));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> a , <span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c)</span></span>&#123;</div><div class=\"line\">\tSystem.out.println(<span class=\"string\">\"a+b=\"</span> + (a+b+c));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> a , <span class=\"keyword\">int</span> b ,<span class=\"keyword\">double</span> c)</span></span>&#123;</div><div class=\"line\">\tSystem.out.println(<span class=\"string\">\"a+b=\"</span> + (a+b+c));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数重载的特点：</p>\n<ul>\n<li>被重载的方法<strong>必须</strong>改变参数列表(参数个数或类型或顺序不一样)；</li>\n<li>被重载的方法可以改变返回类型；</li>\n<li>被重载的方法可以改变访问修饰符；</li>\n<li>被重载的方法可以声明新的或更广的检查异常（区别于重写）；</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n</ul>\n<p>注意：参数列表必须不同！</p>\n<h2 id=\"继承的缺点\"><a href=\"#继承的缺点\" class=\"headerlink\" title=\"继承的缺点\"></a><strong>继承的缺点</strong></h2><ul>\n<li>继承是一种强耦合关系，父类变，子类就必须变。</li>\n<li>继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。</li>\n</ul>\n<p>提醒！慎用继承！</p>\n<p>如果你知道高手写代码都想着怎么解耦你就知道这个缺点室友多么讨厌了。</p>\n<p>你可能会问，我不用继承用什么？别急，接下来的几篇文章会告诉你。</p>\n<h2 id=\"昨天的遗留问题\"><a href=\"#昨天的遗留问题\" class=\"headerlink\" title=\"昨天的遗留问题\"></a><strong>昨天的遗留问题</strong></h2><p>看了上一篇文章的人可能还记得那个遗留问题。我们现在来解决一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//父类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">protected</span> String name;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Person p)</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"marry\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//man类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Woman wife;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> money;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Person p)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.wife = (Woman)p;</div><div class=\"line\">        p.marry(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//只有自己和妻子可以用钱</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMoney</span><span class=\"params\">(Person p,<span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">this</span> || p == <span class=\"keyword\">this</span>.wife)</div><div class=\"line\">            <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            System.out.println(p.getName()+<span class=\"string\">\"抢钱！\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getMoney</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> money;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//woman类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Woman</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasLongHair;</div><div class=\"line\">    <span class=\"keyword\">private</span> Man husband;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Person p)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.husband = (Man)p;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们来看一下效果：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161129215239122\" alt=\"这里写图片描述\"> </p>\n<p>看起来还不错，不是么。</p>\n</blockquote>\n<p>当然，我更喜欢这么做</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMoney</span><span class=\"params\">(Person p,<span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">\t  <span class=\"keyword\">if</span> (p == <span class=\"keyword\">this</span> || p == <span class=\"keyword\">this</span>.wife)</div><div class=\"line\">\t      <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(money &gt; <span class=\"keyword\">this</span>.money)</div><div class=\"line\">\t\t  <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t  <span class=\"keyword\">else</span>  </div><div class=\"line\">\t      System.out.println(p.getName()+<span class=\"string\">\"抢钱！\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>继承还有很多知识点，比如向上转型和向下转型（上面解决上一篇问题的代码就用到了这个知识点），在继承中，对象是怎么初始化的，静态代码块的使用，final关键字的使用等等。</p>\n<p>但是我打算先放一放再讲，等写完组合，聚合和多态再来讨论这些知识会更好一点。</p>\n<p>下一篇《重新认识java（四） —  组合、聚合与继承的爱恨情仇》敬请期待。</p>\n<hr>\n<p>有错误或者我没讲到的地方或者更好的思路请及时与我联系！</p>\n","excerpt":"","more":"<blockquote>\n<p>学习一个新知识的第一步，就是要知道它是什么，然后要知道为什么要用它，最后要知道如何使用它。这篇文章，我们重新认识一下java中的继承。</p>\n</blockquote>\n<h2 id=\"继承是个什么东西\"><a href=\"#继承是个什么东西\" class=\"headerlink\" title=\"继承是个什么东西\"></a><strong>继承是个什么东西</strong></h2><p>我们先来看一下上一篇文章中的代码：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161129160404250\" alt=\"这里写图片描述\"><img src=\"http://img.blog.csdn.net/20161129160417453\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p> 你会发现，这两个类中都有name属性，都有marry方法。一个人，不可能只有名字吧。他还有年龄，地址，手机号码，身份证号码，身高，体重巴拉巴拉的。除了男人和女人，还有小孩，老人，教师。。。</p>\n<p>如果我们每个类里都写一遍name，age。。。也许你还没写完程序，自己就先累死了。不用我说，大家也应该知道了，没错，我们需要继承的帮助。</p>\n<p>我们把相同的属性抽取出来，定义一个新的类Person，然后让男人，女人都去继承它，从而获得Person的属性，这样，就大大简化了我们的工作。</p>\n<p>我们来尝试一下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//父类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">protected</span> String name;</div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"i am eating\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Man类 继承Person</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasBeard;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showMan</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"i am a man\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHasBeard</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> hasBeard;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//woman类 继承Person</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Woman</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasLongHair;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shouWoman</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"i am a woman\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHasLongHair</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> hasLongHair;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>简单的继承我想大家都懂，我就不多说占用篇幅了。</p>\n<h2 id=\"继承的特点\"><a href=\"#继承的特点\" class=\"headerlink\" title=\"继承的特点\"></a><strong>继承的特点</strong></h2><p>我们已经知道了什么是继承，那么继承有没有什么限制呢？</p>\n<h3 id=\"1-java中只支持单继承\"><a href=\"#1-java中只支持单继承\" class=\"headerlink\" title=\"1.java中只支持单继承\"></a><strong>1.java中只支持单继承</strong></h3><p>也就是说，一个类只能够有一个父类。但是java支持“多重继承”。</p>\n<p>单继承：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>()</span>&#123;&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> ()</span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>多重继承：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;&#125; </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>为什么java不支持多继承呢？因为容易造成不必要的混乱。比如说：</p>\n<ul>\n<li><strong>结构复杂化</strong>：如果是单一继承，一个类的父类是什么，父类的父类是什么，都很明确，因为只有单一的继承关系，然而如果是多重继承的话，一个类有多个父类，这些父类又有自己的父类，那么类之间的关系就很复杂了。</li>\n<li><strong>优先顺序模糊</strong>：假如我有A，C类同时继承了基类，B类继承了A类，然后D类又同时继承了B和C类，所以D类继承父类的方法的顺序应该是D、B、A、C还是D、B、C、A，或者是其他的顺序，很不明确。</li>\n<li><strong>功能冲突</strong>：因为多重继承有多个父类，所以当不同的父类中有相同的方法是就会产生冲突。如果B类和C类同时又有相同的方法时，D继承的是哪个方法就不明确了，因为存在两种可能性。</li>\n</ul>\n<p>当然，多继承的这些问题很多语言已经解决了，比如c++，python等，但并不是所有的语言都有必要去解决这个问题。java的类虽然不能实现多继承，但是java的接口支持多实现，这个我们讲到接口的时候再说。</p>\n<p>对多继承感兴趣的可以google一下mixin（混入），还可以去看一下基于java8的mixin实现（大多数都是线程不安全的，不要随便用）。  </p>\n</blockquote>\n<h3 id=\"2-子类拥有父类非private的属性，方法\"><a href=\"#2-子类拥有父类非private的属性，方法\" class=\"headerlink\" title=\"2.子类拥有父类非private的属性，方法\"></a><strong>2.子类拥有父类非private的属性，方法</strong></h3><p>也就是说，父类的属性或者方法如果是peivate的，那么子类是不能继承它的。讲到这里，就必须得提一下四个修饰符了：</p>\n<table>\n<thead>\n<tr>\n<th>—-</th>\n<th style=\"text-align:center\">本类</th>\n<th style=\"text-align:center\">同包（无关类或子类）</th>\n<th style=\"text-align:center\">不同包（子类）</th>\n<th style=\"text-align:center\">不同包（无关类）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>private</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>default</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n</tr>\n<tr>\n<td>protected</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n</tr>\n<tr>\n<td>public</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n</tr>\n</tbody>\n</table>\n<p>在java中，protected关键字大展身手的地方就是在继承中。《thinking in java》中是这样介绍protected的：</p>\n<blockquote>\n<p>在理想世界中，仅靠关键字private已经足够了。但在实际项目中，经常会想要将某些事物尽可能堆这个世界隐藏起来，但仍然允许导出的类的成员访问他们。关键字protected就是起这个作用的。它指明”就类用户而言，这是privated，但是对于任何一个继承于此类的导出类或其他任何一个位于同一个包内的类来说，他却是可以访问的”</p>\n</blockquote>\n<p>怎么理解呢？写个代码你就明白了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">package</span> cn.pkgA</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">protected</span> String name；</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span></span>&#123;&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</div><div class=\"line\">\tB b = <span class=\"keyword\">new</span> B();</div><div class=\"line\">\tb.name;<span class=\"comment\">//可以访问到</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">package</span> cn.pkgB</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</div><div class=\"line\">\tB b = <span class=\"keyword\">new</span> B();</div><div class=\"line\">\tb.name;<span class=\"comment\">//访问不到</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\"><a href=\"#3-子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\" class=\"headerlink\" title=\"3.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\"></a><strong>3.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</strong></h3><p>如果子类只能有父类的属性和方法，那要子类还有什么用？？</p>\n<h3 id=\"4-子类可以用自己的方式实现父类的方法。\"><a href=\"#4-子类可以用自己的方式实现父类的方法。\" class=\"headerlink\" title=\"4.子类可以用自己的方式实现父类的方法。\"></a><strong>4.子类可以用自己的方式实现父类的方法。</strong></h3><p>这个叫做函数重写（覆盖），我们一会会重点分析。</p>\n<h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a><strong>构造器</strong></h2><p>除了被peivate修饰的方法和变量之外，父类的构造器也不能被子类继承。</p>\n<p>但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的当属列表。</p>\n<p>如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。</p>\n<p>我们给Person类添加一个构造器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">protected</span> String name;</div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"i am eating\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//带参数的构造器</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个时候，如果你不给子类添加构造器并在第一行写入super（name，age），则会报错：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161129165450586\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p>在子类添加如下方法后错误消失：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Man</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age<span class=\"comment\">/*, boolean hasBeard*/</span>)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(name, age);</div><div class=\"line\">    <span class=\"comment\">//this.hasBeard = hasBeard;</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//注释掉的地方可有可无</span></div></pre></td></tr></table></figure>\n<p>为什么会有这个要求呢？你一会就知道了，先卖个关子。</p>\n<h2 id=\"重写与重载\"><a href=\"#重写与重载\" class=\"headerlink\" title=\"重写与重载\"></a><strong>重写与重载</strong></h2><h3 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a><strong>重写</strong></h3><p>重写又叫覆盖，发生在继承关系下的子类中。我们上面说过，子类可以用自己的方式实现父类的方法，重写不能改变参数列表，也不能缩小方法的访问权限，如果父类方法抛出异常，子类抛出的异常不能比父类的异常“大”，也不能抛出新的异常。</p>\n<p>我们Person类中有一个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"i am eating\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有一个子类修道成仙了，不吃饭，于是他可以在他自己的类里这样改<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span>  <span class=\"comment\">//这个是注解，表明这个方法是重写了父类的方法，最好写上</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">       System.out.println(<span class=\"string\">\"i don't eat\"</span>);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>这里提一下，子类重写父类方法不能缩小父类方法的访问权限但扩大是可以的。比如说父类有一个protected方法，子类重写它的时候不能改为private，但是可以改成public。</p>\n<p>这里还有一个不大不小的坑。如果你的父类方法是peivate的，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"i am eating\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以在子类中这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"i don't eat\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，这不是重写！！！！因为父类方法是私有的，所以子类根本没有得到eat()这个方法，子类的eat()方法是你重新定义的一个和父类没有半毛钱的函数。</p>\n<h3 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a><strong>重载</strong></h3><p>把重载放到这里讲只是因为它和重写有的然傻傻分不清楚，重载和继承没有任何关系（当然，继承之间也存在重载，也就是说，继承可以重载，但是重载不一定继承），它发生在类本身。重载方法的特点是方法名相同而参数列表不同。</p>\n<p>比如这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> a , <span class=\"keyword\">int</span> b)</span></span>&#123;</div><div class=\"line\">\tSystem.out.println(<span class=\"string\">\"a+b=\"</span> + (a+b));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> a , <span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c)</span></span>&#123;</div><div class=\"line\">\tSystem.out.println(<span class=\"string\">\"a+b=\"</span> + (a+b+c));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> a , <span class=\"keyword\">int</span> b ,<span class=\"keyword\">double</span> c)</span></span>&#123;</div><div class=\"line\">\tSystem.out.println(<span class=\"string\">\"a+b=\"</span> + (a+b+c));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数重载的特点：</p>\n<ul>\n<li>被重载的方法<strong>必须</strong>改变参数列表(参数个数或类型或顺序不一样)；</li>\n<li>被重载的方法可以改变返回类型；</li>\n<li>被重载的方法可以改变访问修饰符；</li>\n<li>被重载的方法可以声明新的或更广的检查异常（区别于重写）；</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n</ul>\n<p>注意：参数列表必须不同！</p>\n<h2 id=\"继承的缺点\"><a href=\"#继承的缺点\" class=\"headerlink\" title=\"继承的缺点\"></a><strong>继承的缺点</strong></h2><ul>\n<li>继承是一种强耦合关系，父类变，子类就必须变。</li>\n<li>继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。</li>\n</ul>\n<p>提醒！慎用继承！</p>\n<p>如果你知道高手写代码都想着怎么解耦你就知道这个缺点室友多么讨厌了。</p>\n<p>你可能会问，我不用继承用什么？别急，接下来的几篇文章会告诉你。</p>\n<h2 id=\"昨天的遗留问题\"><a href=\"#昨天的遗留问题\" class=\"headerlink\" title=\"昨天的遗留问题\"></a><strong>昨天的遗留问题</strong></h2><p>看了上一篇文章的人可能还记得那个遗留问题。我们现在来解决一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//父类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">protected</span> String name;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Person p)</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"marry\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//man类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Woman wife;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> money;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Person p)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.wife = (Woman)p;</div><div class=\"line\">        p.marry(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//只有自己和妻子可以用钱</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMoney</span><span class=\"params\">(Person p,<span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">this</span> || p == <span class=\"keyword\">this</span>.wife)</div><div class=\"line\">            <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            System.out.println(p.getName()+<span class=\"string\">\"抢钱！\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getMoney</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> money;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//woman类</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Woman</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasLongHair;</div><div class=\"line\">    <span class=\"keyword\">private</span> Man husband;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Person p)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.husband = (Man)p;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们来看一下效果：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161129215239122\" alt=\"这里写图片描述\"> </p>\n<p>看起来还不错，不是么。</p>\n</blockquote>\n<p>当然，我更喜欢这么做</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMoney</span><span class=\"params\">(Person p,<span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">\t  <span class=\"keyword\">if</span> (p == <span class=\"keyword\">this</span> || p == <span class=\"keyword\">this</span>.wife)</div><div class=\"line\">\t      <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(money &gt; <span class=\"keyword\">this</span>.money)</div><div class=\"line\">\t\t  <span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t  <span class=\"keyword\">else</span>  </div><div class=\"line\">\t      System.out.println(p.getName()+<span class=\"string\">\"抢钱！\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>继承还有很多知识点，比如向上转型和向下转型（上面解决上一篇问题的代码就用到了这个知识点），在继承中，对象是怎么初始化的，静态代码块的使用，final关键字的使用等等。</p>\n<p>但是我打算先放一放再讲，等写完组合，聚合和多态再来讨论这些知识会更好一点。</p>\n<p>下一篇《重新认识java（四） —  组合、聚合与继承的爱恨情仇》敬请期待。</p>\n<hr>\n<p>有错误或者我没讲到的地方或者更好的思路请及时与我联系！</p>\n"},{"title":"万物皆对象（上）","type":"javaImprove","order":1,"_content":"\n> 如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？\n\n## **对象，引用，类与现实世界**\n\n现实世界里有许许多多的生物，非生物，跑的跳的飞的，过去的现在的未来的，令人眼花缭乱。我们编程的目的，就是解决现实生活中的问题。所以不可避免的我们要和现实世界中各种奇怪的东西打交道。\n\n在现实世界里，你新认识了一个朋友，你知道他长什么样，知道了他的名字年龄，地址。知道他喜欢干什么有什么特长。你想用java语言描述一下这个人，你应该怎么做呢？\n\n这个时候，就有了类的概念。每一个类对应现实世界中的某一事物。比如现实世界中有人。那么我们就创建一个关于“人”的类。\n\n每一个人都有名字，都有地址等等个人信息。那么我们就在“人”的类里面添加这些属性。\n\n每一个人都会吃，会走路，那么我们就在“人”的类里面添加吃和走的方法。\n\n当这个世界又迎来了一个新生命，我们就可以“new”一个“人”，“new”出来的就叫”对象“。\n\n每一个人一出生，父母就会给他取个名字。在程序里，我们需要用一种方式来操作这个“对象”，于是，就出现了引用。我们通过引用来操作对象，设置对象的属性，操作对象的方法。\n\n这就是最基本的面向对象。\n\n>【 **现实世界的事物**】 ---抽象---> 【**类** 】---new--->【**对象** 】<---控制--- 【**引用**】\n\n## **从创建一个对象开始**\n\n创建对象的前提是先得有一个类。我们先自己创建一个person类。\n\n```\n//Person类\npublic class Person {\n    private String name;\n    private int age;\n\n    public void eat(){\n        System.out.println(\"i am eating\");\n    }\n}\n```\n创建一个person对象。\n```java\n\tPerson p = new Person();\n```\n\n怎么理解这句简单的代码呢？\n\n- **new Person** :一个Person类型的对象\n- **()** : 这个括号相当于调用了person的无参构造方法\n- **p** ： Person对象的引用\n\n有的人会认为p就是new出来的Person对象。这是错误的理解，p只是一个Person对象的引用而已。那么问题来了，什么是引用？什么又是对象呢？这个要从内存说起。\n\n## **创建对象的过程**\n\njava大体上会把内存分为四块区域：堆，栈，静态区，常量区。\n\n- 堆 ： 位于RAM中，用于存放所有的java对象。\n- 栈 ： 位于RAM中，引用就存在于栈中。\n- 静态区 : 位于RAM中，被static修饰符修饰的变量会被放在这里\n- 常量区 ：位于ROM中， 很明显，放常量的。\n\n> 事实上，我们不需要关心java的对象，变量到底存在了哪里，因为jvm会帮我们处理好这些。但是理解了这些，有助于提高我们的水平。\n\n当执行这句代码的时候。\n```java\nPerson p = new Person();\n```\n首先，会在堆中开辟一块空间存放这个新来的Person对象。然后，会创建一个引用p，存放在栈中，这个引用p指向Person对象（事实上是，p的值就是Person对象的内存地址）。\n\n这样，我们通过访问p，然后得到了Person的内存地址，进而找到了Person对象。\n\n然后又有了这样一句代码：\n\n```java\nPerson p2 = p;\n```\n\n这句代码的含义是：\n\t创建了一个新的引用，保存在栈中，引用的地址也指向Person的地址。这个时候，你通过p2来改变Person对象的状态，也会改变p的结果。因为它们指向同一个对象。（String除外，之后会专门讲String）\n\n此时，内存中是这样的：\n\n![这里写图片描述](http://img.blog.csdn.net/20161127181947666)\n\n\n用一种很通俗的方式来讲解一下引用和对象。\n\n大家都应该用过windows吧。win有一个神奇的东西叫做快捷方式。我们桌面的图标大部分都是快捷方式。它并不是我们安装在电脑上的应用的可执行文件（不是.exe文件)，那么为什么点击它可以打开应用程序呢？这个我不用讲了把。\n\n我们的对象和引用就和快捷方式和它连接的文件一样。\n\n我们不直接对文件进行操作，而是通过快捷方式来进行操作。快捷方式不能独立存在，同样，引用也不能独立存在（你可以只创建一个引用，但是当你要使用它的时候必须得给它赋值，否则它将毫无用处）。\n\n一个文件可以有多个快捷方式，同样一个对象也可以有多个引用。而一个引用只能同时对应一个对象。\n\n\n>在java里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。java表面上看起来没有指针，但它的引用其实质就是一个指针。在java里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个简单的赋值过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。\n\n## **特例：基本数据类型**\n\n为什么会有特例呢？因为用new操作符创建的对象会存在堆里，二在堆里开辟空间等行为效率较操作栈要低。而我们平时写代码的时候会经常创建一些“小变量”，比如int i = 1；如果每次都用Interger来new一个，效率不是很高而且浪费内存。\n\n所以针对这些情况，java提供了“基本数据类型”，基本数据类型一共有八种，每一个基本数据类型存放在栈中，而他们的值存放在常量区中。\n\n举个例子：\n\n```\nint i = 2;\nint j = 2;\n```\n我们需要知道的是，在常量区中，相同的常量只会存在一个。当执行第一句代码时。先查找常量区中有没有2，没有，则开辟一个空间存放2，然后在栈中存入一个变量i，让i指向2；\n\n执行第二句的时候，查找发现2已经存在了，所以就不开辟新空间了。直接在栈中保存一个新变量j，让j指向2；\n\n当然，java堆每一个基本数据类型都提供了对应的包装类。我们依旧可以用new操作符来创建我们想要的变量。\n\n```\nInteger i = new Integer(1);\nInteger j = new Integer(1);\n```\n\n但是，用new操作符创建的对象是不同的，也就是说，此时，i和j指向不同的内存地址。因为每次调用new操作符，都会在堆开辟新的空间。\n\n当然，说到基本数据类型，不得不提一下java的经典设计。\n\n先看一段代码：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127213126561) \n\n为什么一个是true一个是false呢？\n\n我就不讲了，应该都知道吧。我就贴一个Integer的源码（jdk1.8）吧。\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127213328205)\n\n> Integer 类的内部定义了一个内部类，缓存了从-128到127的所有数字，所以，你懂得。\n\n## **又一个特例 ：String**\n\nString是一个特殊的类，因为它被final修饰符所修饰，是一个不可改变的类。当然，看过java源码后你会发现，基本类型的各个包装类也被final所修饰。这里以String为例。\n\n我们来看这样一个例子\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127190238240)\n\n>执行第一句 ： 常量区开辟空间存放“abc”，s1存放在栈中指向“abc”\n\n>执行第二句，s2 也指向 “abc”，\n\n>执行第三句，因为“abc”已经存在，所以直接指向它。\n\n>所以三个变量指向同一块内存地址，结果都为true。\n\n>当s1内容改变的时候。这个时候，常量区开辟新的空间存放“bcd”，s1指向“bcd”，而s2和s3指向“abc”所以只有s2和s3相等。\n\n这种情况下，s1,s2,s3都是字符串常量，类似于基本数据类型。（如果执行的是s1 = \"abc\",那么结果会都是true）\n\n我们再看一个例子：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127191904759)\n\n> 执行第一行代码： 在堆里分配空间存放String对象，在常量区开辟空间存放常量“abc”，String对象指向常量，s1指向该对象。\n\n> 执行第二行代码：s2指向“abc”\n\n> 执行第三行代码： 在堆里分配新的空间存放String对象，新对象指向常量“abc”，s3指向该对象。\n\n> 到这里，很明显，s1和s2指向的是同一个对象（虽然两个String对象都指向同一个常量，但两个对象是不同的）\n\n> 接着就很诡异了，我们让s1 依旧= “abc\",但是结果s1和s2指向的地址不同了。\n\n怎么回事呢？这就是String类的特殊之处了，new出来的String不再是上面的字符串常量，而是字符串对象。\n\n由于String类是不可改变的，所以String对象也是不可改变的，我们每次给String赋值都相当于执行了一次new String()，然后让变量指向这个新对象，而不是在原来的对象上修改。\n\n当然，java还提供了StringBuffer类，这个是可以在原对象上做修改的。如果你需要修改原对象，那么请使用StringBuffer类。\n\n## **值传递和引用传递的战争**\n\njava是值传递还是引用传递的呢？毫无疑问，java是值传递的。那么什么又叫值传递和引用传递呢？\n\n我们先来看一个例子：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127194158008) \n\n这是一个很经典的例子，我们希望调用了swap函数以后，a和b的值可以互换，但是事实上并没有。为什么会这样呢？\n\n这就是因为java是值传递的。也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传进去的参数本身，而是它的副本。说起来比较拗口，但是其实原理很简单。我们可以这样理解：\n\n一个有形参的函数，当别的函数调用它的时候，必须要传递数据。\n比如swap函数，别的函数要调用swap就必须传两个整数过来。\n\n这个时候，有一个函数按耐不住寂寞，扔了两个整数过来，但是，swap函数有洁癖，它不喜欢用别人的东西，于是它把传过来的参数复制了一份，然后对复制的数据修修改改，而别人传过来的参数动根本没动。\n\n所以，当swap函数执行完毕之后，交换了的数据只是swap自己复制的那一份，而原来的数据没变。\n\n> 也可以理解为别的函数把数据传递给了swap函数的形参，最后改变的只是形参而实参没变，所以不会起到任何效果。\n\n我们再来看一个复杂一点的例子(Person类添加了get，set方法)：\n\n>![这里写图片描述](http://img.blog.csdn.net/20161127201149518)\n\n> 可以看到，我们把p1传进去，它并没有被替换成新的对象。因为change函数操作的不是p1这个引用本身，而是这个引用的一个副本。\n\n> 你依然可以理解为，主函数将p1复制了一份然后变成了chagne函数的形参，最终指向新Person对象的是那个副本引用，而实参p1并没有改变。\n\n再来看一个例子：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127201335005) \n \n> 这次为什么就改变了呢？分析一下。\n\n> 首先，new了一个Person对象，暂且叫他小明吧。然后p1指向小明。\n\n> 小明10岁了，随着时间的推移，小明的年龄要变了，调用了一下changgeAge方法，把小明的引用传了进去。\n\n> 传递的过程中，changgeAge也有洁癖，于是复制了一份小明的引用，这个副本也指向小明。\n\n> 然后changgeAge通过自己的副本引用，改变了小明的年龄。\n\n> 由于是小明这个对象被改变了，所以所有小明的引用调用方法得到的年龄都会改变\n \n > 所以就变了。\n\n最后简单的总结一下。\n\njava的传值过程，其实传的是副本，不管是变量还是引用。所以，不要期待把变量传递给一个函数来改变变量本身。\n\n\n","source":"study/java/zero.md","raw":"---\ntitle: 万物皆对象（上）\ntype: javaImprove\norder: 1\n---\n\n> 如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？\n\n## **对象，引用，类与现实世界**\n\n现实世界里有许许多多的生物，非生物，跑的跳的飞的，过去的现在的未来的，令人眼花缭乱。我们编程的目的，就是解决现实生活中的问题。所以不可避免的我们要和现实世界中各种奇怪的东西打交道。\n\n在现实世界里，你新认识了一个朋友，你知道他长什么样，知道了他的名字年龄，地址。知道他喜欢干什么有什么特长。你想用java语言描述一下这个人，你应该怎么做呢？\n\n这个时候，就有了类的概念。每一个类对应现实世界中的某一事物。比如现实世界中有人。那么我们就创建一个关于“人”的类。\n\n每一个人都有名字，都有地址等等个人信息。那么我们就在“人”的类里面添加这些属性。\n\n每一个人都会吃，会走路，那么我们就在“人”的类里面添加吃和走的方法。\n\n当这个世界又迎来了一个新生命，我们就可以“new”一个“人”，“new”出来的就叫”对象“。\n\n每一个人一出生，父母就会给他取个名字。在程序里，我们需要用一种方式来操作这个“对象”，于是，就出现了引用。我们通过引用来操作对象，设置对象的属性，操作对象的方法。\n\n这就是最基本的面向对象。\n\n>【 **现实世界的事物**】 ---抽象---> 【**类** 】---new--->【**对象** 】<---控制--- 【**引用**】\n\n## **从创建一个对象开始**\n\n创建对象的前提是先得有一个类。我们先自己创建一个person类。\n\n```\n//Person类\npublic class Person {\n    private String name;\n    private int age;\n\n    public void eat(){\n        System.out.println(\"i am eating\");\n    }\n}\n```\n创建一个person对象。\n```java\n\tPerson p = new Person();\n```\n\n怎么理解这句简单的代码呢？\n\n- **new Person** :一个Person类型的对象\n- **()** : 这个括号相当于调用了person的无参构造方法\n- **p** ： Person对象的引用\n\n有的人会认为p就是new出来的Person对象。这是错误的理解，p只是一个Person对象的引用而已。那么问题来了，什么是引用？什么又是对象呢？这个要从内存说起。\n\n## **创建对象的过程**\n\njava大体上会把内存分为四块区域：堆，栈，静态区，常量区。\n\n- 堆 ： 位于RAM中，用于存放所有的java对象。\n- 栈 ： 位于RAM中，引用就存在于栈中。\n- 静态区 : 位于RAM中，被static修饰符修饰的变量会被放在这里\n- 常量区 ：位于ROM中， 很明显，放常量的。\n\n> 事实上，我们不需要关心java的对象，变量到底存在了哪里，因为jvm会帮我们处理好这些。但是理解了这些，有助于提高我们的水平。\n\n当执行这句代码的时候。\n```java\nPerson p = new Person();\n```\n首先，会在堆中开辟一块空间存放这个新来的Person对象。然后，会创建一个引用p，存放在栈中，这个引用p指向Person对象（事实上是，p的值就是Person对象的内存地址）。\n\n这样，我们通过访问p，然后得到了Person的内存地址，进而找到了Person对象。\n\n然后又有了这样一句代码：\n\n```java\nPerson p2 = p;\n```\n\n这句代码的含义是：\n\t创建了一个新的引用，保存在栈中，引用的地址也指向Person的地址。这个时候，你通过p2来改变Person对象的状态，也会改变p的结果。因为它们指向同一个对象。（String除外，之后会专门讲String）\n\n此时，内存中是这样的：\n\n![这里写图片描述](http://img.blog.csdn.net/20161127181947666)\n\n\n用一种很通俗的方式来讲解一下引用和对象。\n\n大家都应该用过windows吧。win有一个神奇的东西叫做快捷方式。我们桌面的图标大部分都是快捷方式。它并不是我们安装在电脑上的应用的可执行文件（不是.exe文件)，那么为什么点击它可以打开应用程序呢？这个我不用讲了把。\n\n我们的对象和引用就和快捷方式和它连接的文件一样。\n\n我们不直接对文件进行操作，而是通过快捷方式来进行操作。快捷方式不能独立存在，同样，引用也不能独立存在（你可以只创建一个引用，但是当你要使用它的时候必须得给它赋值，否则它将毫无用处）。\n\n一个文件可以有多个快捷方式，同样一个对象也可以有多个引用。而一个引用只能同时对应一个对象。\n\n\n>在java里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。java表面上看起来没有指针，但它的引用其实质就是一个指针。在java里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个简单的赋值过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。\n\n## **特例：基本数据类型**\n\n为什么会有特例呢？因为用new操作符创建的对象会存在堆里，二在堆里开辟空间等行为效率较操作栈要低。而我们平时写代码的时候会经常创建一些“小变量”，比如int i = 1；如果每次都用Interger来new一个，效率不是很高而且浪费内存。\n\n所以针对这些情况，java提供了“基本数据类型”，基本数据类型一共有八种，每一个基本数据类型存放在栈中，而他们的值存放在常量区中。\n\n举个例子：\n\n```\nint i = 2;\nint j = 2;\n```\n我们需要知道的是，在常量区中，相同的常量只会存在一个。当执行第一句代码时。先查找常量区中有没有2，没有，则开辟一个空间存放2，然后在栈中存入一个变量i，让i指向2；\n\n执行第二句的时候，查找发现2已经存在了，所以就不开辟新空间了。直接在栈中保存一个新变量j，让j指向2；\n\n当然，java堆每一个基本数据类型都提供了对应的包装类。我们依旧可以用new操作符来创建我们想要的变量。\n\n```\nInteger i = new Integer(1);\nInteger j = new Integer(1);\n```\n\n但是，用new操作符创建的对象是不同的，也就是说，此时，i和j指向不同的内存地址。因为每次调用new操作符，都会在堆开辟新的空间。\n\n当然，说到基本数据类型，不得不提一下java的经典设计。\n\n先看一段代码：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127213126561) \n\n为什么一个是true一个是false呢？\n\n我就不讲了，应该都知道吧。我就贴一个Integer的源码（jdk1.8）吧。\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127213328205)\n\n> Integer 类的内部定义了一个内部类，缓存了从-128到127的所有数字，所以，你懂得。\n\n## **又一个特例 ：String**\n\nString是一个特殊的类，因为它被final修饰符所修饰，是一个不可改变的类。当然，看过java源码后你会发现，基本类型的各个包装类也被final所修饰。这里以String为例。\n\n我们来看这样一个例子\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127190238240)\n\n>执行第一句 ： 常量区开辟空间存放“abc”，s1存放在栈中指向“abc”\n\n>执行第二句，s2 也指向 “abc”，\n\n>执行第三句，因为“abc”已经存在，所以直接指向它。\n\n>所以三个变量指向同一块内存地址，结果都为true。\n\n>当s1内容改变的时候。这个时候，常量区开辟新的空间存放“bcd”，s1指向“bcd”，而s2和s3指向“abc”所以只有s2和s3相等。\n\n这种情况下，s1,s2,s3都是字符串常量，类似于基本数据类型。（如果执行的是s1 = \"abc\",那么结果会都是true）\n\n我们再看一个例子：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127191904759)\n\n> 执行第一行代码： 在堆里分配空间存放String对象，在常量区开辟空间存放常量“abc”，String对象指向常量，s1指向该对象。\n\n> 执行第二行代码：s2指向“abc”\n\n> 执行第三行代码： 在堆里分配新的空间存放String对象，新对象指向常量“abc”，s3指向该对象。\n\n> 到这里，很明显，s1和s2指向的是同一个对象（虽然两个String对象都指向同一个常量，但两个对象是不同的）\n\n> 接着就很诡异了，我们让s1 依旧= “abc\",但是结果s1和s2指向的地址不同了。\n\n怎么回事呢？这就是String类的特殊之处了，new出来的String不再是上面的字符串常量，而是字符串对象。\n\n由于String类是不可改变的，所以String对象也是不可改变的，我们每次给String赋值都相当于执行了一次new String()，然后让变量指向这个新对象，而不是在原来的对象上修改。\n\n当然，java还提供了StringBuffer类，这个是可以在原对象上做修改的。如果你需要修改原对象，那么请使用StringBuffer类。\n\n## **值传递和引用传递的战争**\n\njava是值传递还是引用传递的呢？毫无疑问，java是值传递的。那么什么又叫值传递和引用传递呢？\n\n我们先来看一个例子：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127194158008) \n\n这是一个很经典的例子，我们希望调用了swap函数以后，a和b的值可以互换，但是事实上并没有。为什么会这样呢？\n\n这就是因为java是值传递的。也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传进去的参数本身，而是它的副本。说起来比较拗口，但是其实原理很简单。我们可以这样理解：\n\n一个有形参的函数，当别的函数调用它的时候，必须要传递数据。\n比如swap函数，别的函数要调用swap就必须传两个整数过来。\n\n这个时候，有一个函数按耐不住寂寞，扔了两个整数过来，但是，swap函数有洁癖，它不喜欢用别人的东西，于是它把传过来的参数复制了一份，然后对复制的数据修修改改，而别人传过来的参数动根本没动。\n\n所以，当swap函数执行完毕之后，交换了的数据只是swap自己复制的那一份，而原来的数据没变。\n\n> 也可以理解为别的函数把数据传递给了swap函数的形参，最后改变的只是形参而实参没变，所以不会起到任何效果。\n\n我们再来看一个复杂一点的例子(Person类添加了get，set方法)：\n\n>![这里写图片描述](http://img.blog.csdn.net/20161127201149518)\n\n> 可以看到，我们把p1传进去，它并没有被替换成新的对象。因为change函数操作的不是p1这个引用本身，而是这个引用的一个副本。\n\n> 你依然可以理解为，主函数将p1复制了一份然后变成了chagne函数的形参，最终指向新Person对象的是那个副本引用，而实参p1并没有改变。\n\n再来看一个例子：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161127201335005) \n \n> 这次为什么就改变了呢？分析一下。\n\n> 首先，new了一个Person对象，暂且叫他小明吧。然后p1指向小明。\n\n> 小明10岁了，随着时间的推移，小明的年龄要变了，调用了一下changgeAge方法，把小明的引用传了进去。\n\n> 传递的过程中，changgeAge也有洁癖，于是复制了一份小明的引用，这个副本也指向小明。\n\n> 然后changgeAge通过自己的副本引用，改变了小明的年龄。\n\n> 由于是小明这个对象被改变了，所以所有小明的引用调用方法得到的年龄都会改变\n \n > 所以就变了。\n\n最后简单的总结一下。\n\njava的传值过程，其实传的是副本，不管是变量还是引用。所以，不要期待把变量传递给一个函数来改变变量本身。\n\n\n","date":"2016-12-13T03:51:51.000Z","updated":"2016-12-13T03:51:51.000Z","path":"study/java/zero.html","comments":1,"layout":"page","_id":"ciwnajuxr000jjl2dxlyexma6","content":"<blockquote>\n<p>如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？</p>\n</blockquote>\n<h2 id=\"对象，引用，类与现实世界\"><a href=\"#对象，引用，类与现实世界\" class=\"headerlink\" title=\"对象，引用，类与现实世界\"></a><strong>对象，引用，类与现实世界</strong></h2><p>现实世界里有许许多多的生物，非生物，跑的跳的飞的，过去的现在的未来的，令人眼花缭乱。我们编程的目的，就是解决现实生活中的问题。所以不可避免的我们要和现实世界中各种奇怪的东西打交道。</p>\n<p>在现实世界里，你新认识了一个朋友，你知道他长什么样，知道了他的名字年龄，地址。知道他喜欢干什么有什么特长。你想用java语言描述一下这个人，你应该怎么做呢？</p>\n<p>这个时候，就有了类的概念。每一个类对应现实世界中的某一事物。比如现实世界中有人。那么我们就创建一个关于“人”的类。</p>\n<p>每一个人都有名字，都有地址等等个人信息。那么我们就在“人”的类里面添加这些属性。</p>\n<p>每一个人都会吃，会走路，那么我们就在“人”的类里面添加吃和走的方法。</p>\n<p>当这个世界又迎来了一个新生命，我们就可以“new”一个“人”，“new”出来的就叫”对象“。</p>\n<p>每一个人一出生，父母就会给他取个名字。在程序里，我们需要用一种方式来操作这个“对象”，于是，就出现了引用。我们通过引用来操作对象，设置对象的属性，操作对象的方法。</p>\n<p>这就是最基本的面向对象。</p>\n<blockquote>\n<p>【 <strong>现实世界的事物</strong>】 —抽象—&gt; 【<strong>类</strong> 】—new—&gt;【<strong>对象</strong> 】&lt;—控制— 【<strong>引用</strong>】</p>\n</blockquote>\n<h2 id=\"从创建一个对象开始\"><a href=\"#从创建一个对象开始\" class=\"headerlink\" title=\"从创建一个对象开始\"></a><strong>从创建一个对象开始</strong></h2><p>创建对象的前提是先得有一个类。我们先自己创建一个person类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//Person类</div><div class=\"line\">public class Person &#123;</div><div class=\"line\">    private String name;</div><div class=\"line\">    private int age;</div><div class=\"line\"></div><div class=\"line\">    public void eat()&#123;</div><div class=\"line\">        System.out.println(&quot;i am eating&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个person对象。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure></p>\n<p>怎么理解这句简单的代码呢？</p>\n<ul>\n<li><strong>new Person</strong> :一个Person类型的对象</li>\n<li><strong>()</strong> : 这个括号相当于调用了person的无参构造方法</li>\n<li><strong>p</strong> ： Person对象的引用</li>\n</ul>\n<p>有的人会认为p就是new出来的Person对象。这是错误的理解，p只是一个Person对象的引用而已。那么问题来了，什么是引用？什么又是对象呢？这个要从内存说起。</p>\n<h2 id=\"创建对象的过程\"><a href=\"#创建对象的过程\" class=\"headerlink\" title=\"创建对象的过程\"></a><strong>创建对象的过程</strong></h2><p>java大体上会把内存分为四块区域：堆，栈，静态区，常量区。</p>\n<ul>\n<li>堆 ： 位于RAM中，用于存放所有的java对象。</li>\n<li>栈 ： 位于RAM中，引用就存在于栈中。</li>\n<li>静态区 : 位于RAM中，被static修饰符修饰的变量会被放在这里</li>\n<li>常量区 ：位于ROM中， 很明显，放常量的。</li>\n</ul>\n<blockquote>\n<p>事实上，我们不需要关心java的对象，变量到底存在了哪里，因为jvm会帮我们处理好这些。但是理解了这些，有助于提高我们的水平。</p>\n</blockquote>\n<p>当执行这句代码的时候。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure></p>\n<p>首先，会在堆中开辟一块空间存放这个新来的Person对象。然后，会创建一个引用p，存放在栈中，这个引用p指向Person对象（事实上是，p的值就是Person对象的内存地址）。</p>\n<p>这样，我们通过访问p，然后得到了Person的内存地址，进而找到了Person对象。</p>\n<p>然后又有了这样一句代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Person p2 = p;</div></pre></td></tr></table></figure>\n<p>这句代码的含义是：<br>    创建了一个新的引用，保存在栈中，引用的地址也指向Person的地址。这个时候，你通过p2来改变Person对象的状态，也会改变p的结果。因为它们指向同一个对象。（String除外，之后会专门讲String）</p>\n<p>此时，内存中是这样的：</p>\n<p><img src=\"http://img.blog.csdn.net/20161127181947666\" alt=\"这里写图片描述\"></p>\n<p>用一种很通俗的方式来讲解一下引用和对象。</p>\n<p>大家都应该用过windows吧。win有一个神奇的东西叫做快捷方式。我们桌面的图标大部分都是快捷方式。它并不是我们安装在电脑上的应用的可执行文件（不是.exe文件)，那么为什么点击它可以打开应用程序呢？这个我不用讲了把。</p>\n<p>我们的对象和引用就和快捷方式和它连接的文件一样。</p>\n<p>我们不直接对文件进行操作，而是通过快捷方式来进行操作。快捷方式不能独立存在，同样，引用也不能独立存在（你可以只创建一个引用，但是当你要使用它的时候必须得给它赋值，否则它将毫无用处）。</p>\n<p>一个文件可以有多个快捷方式，同样一个对象也可以有多个引用。而一个引用只能同时对应一个对象。</p>\n<blockquote>\n<p>在java里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。java表面上看起来没有指针，但它的引用其实质就是一个指针。在java里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个简单的赋值过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。</p>\n</blockquote>\n<h2 id=\"特例：基本数据类型\"><a href=\"#特例：基本数据类型\" class=\"headerlink\" title=\"特例：基本数据类型\"></a><strong>特例：基本数据类型</strong></h2><p>为什么会有特例呢？因为用new操作符创建的对象会存在堆里，二在堆里开辟空间等行为效率较操作栈要低。而我们平时写代码的时候会经常创建一些“小变量”，比如int i = 1；如果每次都用Interger来new一个，效率不是很高而且浪费内存。</p>\n<p>所以针对这些情况，java提供了“基本数据类型”，基本数据类型一共有八种，每一个基本数据类型存放在栈中，而他们的值存放在常量区中。</p>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">int i = 2;</div><div class=\"line\">int j = 2;</div></pre></td></tr></table></figure>\n<p>我们需要知道的是，在常量区中，相同的常量只会存在一个。当执行第一句代码时。先查找常量区中有没有2，没有，则开辟一个空间存放2，然后在栈中存入一个变量i，让i指向2；</p>\n<p>执行第二句的时候，查找发现2已经存在了，所以就不开辟新空间了。直接在栈中保存一个新变量j，让j指向2；</p>\n<p>当然，java堆每一个基本数据类型都提供了对应的包装类。我们依旧可以用new操作符来创建我们想要的变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Integer i = new Integer(1);</div><div class=\"line\">Integer j = new Integer(1);</div></pre></td></tr></table></figure>\n<p>但是，用new操作符创建的对象是不同的，也就是说，此时，i和j指向不同的内存地址。因为每次调用new操作符，都会在堆开辟新的空间。</p>\n<p>当然，说到基本数据类型，不得不提一下java的经典设计。</p>\n<p>先看一段代码：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127213126561\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p>为什么一个是true一个是false呢？</p>\n<p>我就不讲了，应该都知道吧。我就贴一个Integer的源码（jdk1.8）吧。</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127213328205\" alt=\"这里写图片描述\"></p>\n<p>Integer 类的内部定义了一个内部类，缓存了从-128到127的所有数字，所以，你懂得。</p>\n</blockquote>\n<h2 id=\"又一个特例-：String\"><a href=\"#又一个特例-：String\" class=\"headerlink\" title=\"又一个特例 ：String\"></a><strong>又一个特例 ：String</strong></h2><p>String是一个特殊的类，因为它被final修饰符所修饰，是一个不可改变的类。当然，看过java源码后你会发现，基本类型的各个包装类也被final所修饰。这里以String为例。</p>\n<p>我们来看这样一个例子</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127190238240\" alt=\"这里写图片描述\"></p>\n<p>执行第一句 ： 常量区开辟空间存放“abc”，s1存放在栈中指向“abc”</p>\n<p>执行第二句，s2 也指向 “abc”，</p>\n<p>执行第三句，因为“abc”已经存在，所以直接指向它。</p>\n<p>所以三个变量指向同一块内存地址，结果都为true。</p>\n<p>当s1内容改变的时候。这个时候，常量区开辟新的空间存放“bcd”，s1指向“bcd”，而s2和s3指向“abc”所以只有s2和s3相等。</p>\n</blockquote>\n<p>这种情况下，s1,s2,s3都是字符串常量，类似于基本数据类型。（如果执行的是s1 = “abc”,那么结果会都是true）</p>\n<p>我们再看一个例子：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127191904759\" alt=\"这里写图片描述\"></p>\n<p>执行第一行代码： 在堆里分配空间存放String对象，在常量区开辟空间存放常量“abc”，String对象指向常量，s1指向该对象。</p>\n<p>执行第二行代码：s2指向“abc”</p>\n<p>执行第三行代码： 在堆里分配新的空间存放String对象，新对象指向常量“abc”，s3指向该对象。</p>\n<p>到这里，很明显，s1和s2指向的是同一个对象（虽然两个String对象都指向同一个常量，但两个对象是不同的）</p>\n<p>接着就很诡异了，我们让s1 依旧= “abc”,但是结果s1和s2指向的地址不同了。</p>\n</blockquote>\n<p>怎么回事呢？这就是String类的特殊之处了，new出来的String不再是上面的字符串常量，而是字符串对象。</p>\n<p>由于String类是不可改变的，所以String对象也是不可改变的，我们每次给String赋值都相当于执行了一次new String()，然后让变量指向这个新对象，而不是在原来的对象上修改。</p>\n<p>当然，java还提供了StringBuffer类，这个是可以在原对象上做修改的。如果你需要修改原对象，那么请使用StringBuffer类。</p>\n<h2 id=\"值传递和引用传递的战争\"><a href=\"#值传递和引用传递的战争\" class=\"headerlink\" title=\"值传递和引用传递的战争\"></a><strong>值传递和引用传递的战争</strong></h2><p>java是值传递还是引用传递的呢？毫无疑问，java是值传递的。那么什么又叫值传递和引用传递呢？</p>\n<p>我们先来看一个例子：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127194158008\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p>这是一个很经典的例子，我们希望调用了swap函数以后，a和b的值可以互换，但是事实上并没有。为什么会这样呢？</p>\n<p>这就是因为java是值传递的。也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传进去的参数本身，而是它的副本。说起来比较拗口，但是其实原理很简单。我们可以这样理解：</p>\n<p>一个有形参的函数，当别的函数调用它的时候，必须要传递数据。<br>比如swap函数，别的函数要调用swap就必须传两个整数过来。</p>\n<p>这个时候，有一个函数按耐不住寂寞，扔了两个整数过来，但是，swap函数有洁癖，它不喜欢用别人的东西，于是它把传过来的参数复制了一份，然后对复制的数据修修改改，而别人传过来的参数动根本没动。</p>\n<p>所以，当swap函数执行完毕之后，交换了的数据只是swap自己复制的那一份，而原来的数据没变。</p>\n<blockquote>\n<p>也可以理解为别的函数把数据传递给了swap函数的形参，最后改变的只是形参而实参没变，所以不会起到任何效果。</p>\n</blockquote>\n<p>我们再来看一个复杂一点的例子(Person类添加了get，set方法)：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127201149518\" alt=\"这里写图片描述\"></p>\n<p>可以看到，我们把p1传进去，它并没有被替换成新的对象。因为change函数操作的不是p1这个引用本身，而是这个引用的一个副本。</p>\n<p>你依然可以理解为，主函数将p1复制了一份然后变成了chagne函数的形参，最终指向新Person对象的是那个副本引用，而实参p1并没有改变。</p>\n</blockquote>\n<p>再来看一个例子：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127201335005\" alt=\"这里写图片描述\"> </p>\n<p>这次为什么就改变了呢？分析一下。</p>\n<p>首先，new了一个Person对象，暂且叫他小明吧。然后p1指向小明。</p>\n<p>小明10岁了，随着时间的推移，小明的年龄要变了，调用了一下changgeAge方法，把小明的引用传了进去。</p>\n<p>传递的过程中，changgeAge也有洁癖，于是复制了一份小明的引用，这个副本也指向小明。</p>\n<p>然后changgeAge通过自己的副本引用，改变了小明的年龄。</p>\n<p>由于是小明这个对象被改变了，所以所有小明的引用调用方法得到的年龄都会改变</p>\n<p>所以就变了。</p>\n</blockquote>\n<p>最后简单的总结一下。</p>\n<p>java的传值过程，其实传的是副本，不管是变量还是引用。所以，不要期待把变量传递给一个函数来改变变量本身。</p>\n","excerpt":"","more":"<blockquote>\n<p>如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？</p>\n</blockquote>\n<h2 id=\"对象，引用，类与现实世界\"><a href=\"#对象，引用，类与现实世界\" class=\"headerlink\" title=\"对象，引用，类与现实世界\"></a><strong>对象，引用，类与现实世界</strong></h2><p>现实世界里有许许多多的生物，非生物，跑的跳的飞的，过去的现在的未来的，令人眼花缭乱。我们编程的目的，就是解决现实生活中的问题。所以不可避免的我们要和现实世界中各种奇怪的东西打交道。</p>\n<p>在现实世界里，你新认识了一个朋友，你知道他长什么样，知道了他的名字年龄，地址。知道他喜欢干什么有什么特长。你想用java语言描述一下这个人，你应该怎么做呢？</p>\n<p>这个时候，就有了类的概念。每一个类对应现实世界中的某一事物。比如现实世界中有人。那么我们就创建一个关于“人”的类。</p>\n<p>每一个人都有名字，都有地址等等个人信息。那么我们就在“人”的类里面添加这些属性。</p>\n<p>每一个人都会吃，会走路，那么我们就在“人”的类里面添加吃和走的方法。</p>\n<p>当这个世界又迎来了一个新生命，我们就可以“new”一个“人”，“new”出来的就叫”对象“。</p>\n<p>每一个人一出生，父母就会给他取个名字。在程序里，我们需要用一种方式来操作这个“对象”，于是，就出现了引用。我们通过引用来操作对象，设置对象的属性，操作对象的方法。</p>\n<p>这就是最基本的面向对象。</p>\n<blockquote>\n<p>【 <strong>现实世界的事物</strong>】 —抽象—&gt; 【<strong>类</strong> 】—new—&gt;【<strong>对象</strong> 】&lt;—控制— 【<strong>引用</strong>】</p>\n</blockquote>\n<h2 id=\"从创建一个对象开始\"><a href=\"#从创建一个对象开始\" class=\"headerlink\" title=\"从创建一个对象开始\"></a><strong>从创建一个对象开始</strong></h2><p>创建对象的前提是先得有一个类。我们先自己创建一个person类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//Person类</div><div class=\"line\">public class Person &#123;</div><div class=\"line\">    private String name;</div><div class=\"line\">    private int age;</div><div class=\"line\"></div><div class=\"line\">    public void eat()&#123;</div><div class=\"line\">        System.out.println(&quot;i am eating&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个person对象。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure></p>\n<p>怎么理解这句简单的代码呢？</p>\n<ul>\n<li><strong>new Person</strong> :一个Person类型的对象</li>\n<li><strong>()</strong> : 这个括号相当于调用了person的无参构造方法</li>\n<li><strong>p</strong> ： Person对象的引用</li>\n</ul>\n<p>有的人会认为p就是new出来的Person对象。这是错误的理解，p只是一个Person对象的引用而已。那么问题来了，什么是引用？什么又是对象呢？这个要从内存说起。</p>\n<h2 id=\"创建对象的过程\"><a href=\"#创建对象的过程\" class=\"headerlink\" title=\"创建对象的过程\"></a><strong>创建对象的过程</strong></h2><p>java大体上会把内存分为四块区域：堆，栈，静态区，常量区。</p>\n<ul>\n<li>堆 ： 位于RAM中，用于存放所有的java对象。</li>\n<li>栈 ： 位于RAM中，引用就存在于栈中。</li>\n<li>静态区 : 位于RAM中，被static修饰符修饰的变量会被放在这里</li>\n<li>常量区 ：位于ROM中， 很明显，放常量的。</li>\n</ul>\n<blockquote>\n<p>事实上，我们不需要关心java的对象，变量到底存在了哪里，因为jvm会帮我们处理好这些。但是理解了这些，有助于提高我们的水平。</p>\n</blockquote>\n<p>当执行这句代码的时候。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure></p>\n<p>首先，会在堆中开辟一块空间存放这个新来的Person对象。然后，会创建一个引用p，存放在栈中，这个引用p指向Person对象（事实上是，p的值就是Person对象的内存地址）。</p>\n<p>这样，我们通过访问p，然后得到了Person的内存地址，进而找到了Person对象。</p>\n<p>然后又有了这样一句代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Person p2 = p;</div></pre></td></tr></table></figure>\n<p>这句代码的含义是：<br>    创建了一个新的引用，保存在栈中，引用的地址也指向Person的地址。这个时候，你通过p2来改变Person对象的状态，也会改变p的结果。因为它们指向同一个对象。（String除外，之后会专门讲String）</p>\n<p>此时，内存中是这样的：</p>\n<p><img src=\"http://img.blog.csdn.net/20161127181947666\" alt=\"这里写图片描述\"></p>\n<p>用一种很通俗的方式来讲解一下引用和对象。</p>\n<p>大家都应该用过windows吧。win有一个神奇的东西叫做快捷方式。我们桌面的图标大部分都是快捷方式。它并不是我们安装在电脑上的应用的可执行文件（不是.exe文件)，那么为什么点击它可以打开应用程序呢？这个我不用讲了把。</p>\n<p>我们的对象和引用就和快捷方式和它连接的文件一样。</p>\n<p>我们不直接对文件进行操作，而是通过快捷方式来进行操作。快捷方式不能独立存在，同样，引用也不能独立存在（你可以只创建一个引用，但是当你要使用它的时候必须得给它赋值，否则它将毫无用处）。</p>\n<p>一个文件可以有多个快捷方式，同样一个对象也可以有多个引用。而一个引用只能同时对应一个对象。</p>\n<blockquote>\n<p>在java里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。java表面上看起来没有指针，但它的引用其实质就是一个指针。在java里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个简单的赋值过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。</p>\n</blockquote>\n<h2 id=\"特例：基本数据类型\"><a href=\"#特例：基本数据类型\" class=\"headerlink\" title=\"特例：基本数据类型\"></a><strong>特例：基本数据类型</strong></h2><p>为什么会有特例呢？因为用new操作符创建的对象会存在堆里，二在堆里开辟空间等行为效率较操作栈要低。而我们平时写代码的时候会经常创建一些“小变量”，比如int i = 1；如果每次都用Interger来new一个，效率不是很高而且浪费内存。</p>\n<p>所以针对这些情况，java提供了“基本数据类型”，基本数据类型一共有八种，每一个基本数据类型存放在栈中，而他们的值存放在常量区中。</p>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">int i = 2;</div><div class=\"line\">int j = 2;</div></pre></td></tr></table></figure>\n<p>我们需要知道的是，在常量区中，相同的常量只会存在一个。当执行第一句代码时。先查找常量区中有没有2，没有，则开辟一个空间存放2，然后在栈中存入一个变量i，让i指向2；</p>\n<p>执行第二句的时候，查找发现2已经存在了，所以就不开辟新空间了。直接在栈中保存一个新变量j，让j指向2；</p>\n<p>当然，java堆每一个基本数据类型都提供了对应的包装类。我们依旧可以用new操作符来创建我们想要的变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Integer i = new Integer(1);</div><div class=\"line\">Integer j = new Integer(1);</div></pre></td></tr></table></figure>\n<p>但是，用new操作符创建的对象是不同的，也就是说，此时，i和j指向不同的内存地址。因为每次调用new操作符，都会在堆开辟新的空间。</p>\n<p>当然，说到基本数据类型，不得不提一下java的经典设计。</p>\n<p>先看一段代码：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127213126561\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p>为什么一个是true一个是false呢？</p>\n<p>我就不讲了，应该都知道吧。我就贴一个Integer的源码（jdk1.8）吧。</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127213328205\" alt=\"这里写图片描述\"></p>\n<p>Integer 类的内部定义了一个内部类，缓存了从-128到127的所有数字，所以，你懂得。</p>\n</blockquote>\n<h2 id=\"又一个特例-：String\"><a href=\"#又一个特例-：String\" class=\"headerlink\" title=\"又一个特例 ：String\"></a><strong>又一个特例 ：String</strong></h2><p>String是一个特殊的类，因为它被final修饰符所修饰，是一个不可改变的类。当然，看过java源码后你会发现，基本类型的各个包装类也被final所修饰。这里以String为例。</p>\n<p>我们来看这样一个例子</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127190238240\" alt=\"这里写图片描述\"></p>\n<p>执行第一句 ： 常量区开辟空间存放“abc”，s1存放在栈中指向“abc”</p>\n<p>执行第二句，s2 也指向 “abc”，</p>\n<p>执行第三句，因为“abc”已经存在，所以直接指向它。</p>\n<p>所以三个变量指向同一块内存地址，结果都为true。</p>\n<p>当s1内容改变的时候。这个时候，常量区开辟新的空间存放“bcd”，s1指向“bcd”，而s2和s3指向“abc”所以只有s2和s3相等。</p>\n</blockquote>\n<p>这种情况下，s1,s2,s3都是字符串常量，类似于基本数据类型。（如果执行的是s1 = “abc”,那么结果会都是true）</p>\n<p>我们再看一个例子：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127191904759\" alt=\"这里写图片描述\"></p>\n<p>执行第一行代码： 在堆里分配空间存放String对象，在常量区开辟空间存放常量“abc”，String对象指向常量，s1指向该对象。</p>\n<p>执行第二行代码：s2指向“abc”</p>\n<p>执行第三行代码： 在堆里分配新的空间存放String对象，新对象指向常量“abc”，s3指向该对象。</p>\n<p>到这里，很明显，s1和s2指向的是同一个对象（虽然两个String对象都指向同一个常量，但两个对象是不同的）</p>\n<p>接着就很诡异了，我们让s1 依旧= “abc”,但是结果s1和s2指向的地址不同了。</p>\n</blockquote>\n<p>怎么回事呢？这就是String类的特殊之处了，new出来的String不再是上面的字符串常量，而是字符串对象。</p>\n<p>由于String类是不可改变的，所以String对象也是不可改变的，我们每次给String赋值都相当于执行了一次new String()，然后让变量指向这个新对象，而不是在原来的对象上修改。</p>\n<p>当然，java还提供了StringBuffer类，这个是可以在原对象上做修改的。如果你需要修改原对象，那么请使用StringBuffer类。</p>\n<h2 id=\"值传递和引用传递的战争\"><a href=\"#值传递和引用传递的战争\" class=\"headerlink\" title=\"值传递和引用传递的战争\"></a><strong>值传递和引用传递的战争</strong></h2><p>java是值传递还是引用传递的呢？毫无疑问，java是值传递的。那么什么又叫值传递和引用传递呢？</p>\n<p>我们先来看一个例子：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127194158008\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p>这是一个很经典的例子，我们希望调用了swap函数以后，a和b的值可以互换，但是事实上并没有。为什么会这样呢？</p>\n<p>这就是因为java是值传递的。也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传进去的参数本身，而是它的副本。说起来比较拗口，但是其实原理很简单。我们可以这样理解：</p>\n<p>一个有形参的函数，当别的函数调用它的时候，必须要传递数据。<br>比如swap函数，别的函数要调用swap就必须传两个整数过来。</p>\n<p>这个时候，有一个函数按耐不住寂寞，扔了两个整数过来，但是，swap函数有洁癖，它不喜欢用别人的东西，于是它把传过来的参数复制了一份，然后对复制的数据修修改改，而别人传过来的参数动根本没动。</p>\n<p>所以，当swap函数执行完毕之后，交换了的数据只是swap自己复制的那一份，而原来的数据没变。</p>\n<blockquote>\n<p>也可以理解为别的函数把数据传递给了swap函数的形参，最后改变的只是形参而实参没变，所以不会起到任何效果。</p>\n</blockquote>\n<p>我们再来看一个复杂一点的例子(Person类添加了get，set方法)：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127201149518\" alt=\"这里写图片描述\"></p>\n<p>可以看到，我们把p1传进去，它并没有被替换成新的对象。因为change函数操作的不是p1这个引用本身，而是这个引用的一个副本。</p>\n<p>你依然可以理解为，主函数将p1复制了一份然后变成了chagne函数的形参，最终指向新Person对象的是那个副本引用，而实参p1并没有改变。</p>\n</blockquote>\n<p>再来看一个例子：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161127201335005\" alt=\"这里写图片描述\"> </p>\n<p>这次为什么就改变了呢？分析一下。</p>\n<p>首先，new了一个Person对象，暂且叫他小明吧。然后p1指向小明。</p>\n<p>小明10岁了，随着时间的推移，小明的年龄要变了，调用了一下changgeAge方法，把小明的引用传了进去。</p>\n<p>传递的过程中，changgeAge也有洁癖，于是复制了一份小明的引用，这个副本也指向小明。</p>\n<p>然后changgeAge通过自己的副本引用，改变了小明的年龄。</p>\n<p>由于是小明这个对象被改变了，所以所有小明的引用调用方法得到的年龄都会改变</p>\n<p>所以就变了。</p>\n</blockquote>\n<p>最后简单的总结一下。</p>\n<p>java的传值过程，其实传的是副本，不管是变量还是引用。所以，不要期待把变量传递给一个函数来改变变量本身。</p>\n"},{"title":"开始","type":"linux","order":1,"_content":"\n在这里，我将会分享一些和linux有关的知识。包括各种环境的搭建以及一些小技巧。\n\n所有操作在腾讯云vps主机上操作\n\n系统为centOS 7 64位。","source":"study/linux/index.md","raw":"---\ntitle: 开始\ntype: linux\norder: 1\n---\n\n在这里，我将会分享一些和linux有关的知识。包括各种环境的搭建以及一些小技巧。\n\n所有操作在腾讯云vps主机上操作\n\n系统为centOS 7 64位。","date":"2016-12-13T09:04:22.000Z","updated":"2016-12-13T09:04:22.000Z","path":"study/linux/index.html","comments":1,"layout":"page","_id":"ciwnajuxs000kjl2d54gtukp3","content":"<p>在这里，我将会分享一些和linux有关的知识。包括各种环境的搭建以及一些小技巧。</p>\n<p>所有操作在腾讯云vps主机上操作</p>\n<p>系统为centOS 7 64位。</p>\n","excerpt":"","more":"<p>在这里，我将会分享一些和linux有关的知识。包括各种环境的搭建以及一些小技巧。</p>\n<p>所有操作在腾讯云vps主机上操作</p>\n<p>系统为centOS 7 64位。</p>\n"},{"title":"nodejs环境的搭建","type":"linux","order":2,"_content":"\n## **nodejs环境的搭建**\n\n> nodejs的安装方法有很多种，可以通过编译源码或者类似于apt-get等方式。但是由于我们日后可能需要在nodejs的不同版本之间切换，所以这里给大家提供的是用nvm来安装。\n\n### **nvm是什么**\n\nnvm (Node Version Manager) 是 Nodejs 版本管理器，它让我们能方便的对 Nodejs 的版本进行切换。\n\n> 举个例子，假设，我们已经安装 nvm 了。如果，我们此时需要用 5.0 版本的 Nodejs ，但是我们本机没有装该版本，那么，我们先执行\n> nvm install 5.0 来安装该版本，然后执行 nvm use 5.0， 此时用的 Nodejs 的版本即为 5.0的。以后我们切换到 5.0 版本只需执行 nvm use 5.0 即可。当然，我们可以用 nvm install 来装更多的版本。\n\n\n### **安装nvm**\n\n> nvm github地址：https://github.com/creationix/nvm\n\n```js\n$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.6/install.sh | bash\n\n\n$ source ~/.bashrc\n\n\n$ command -v nvm\n\n//如果终端打印出“mvm”，证明安装成功\n```\n\n### **通过nvm安装nodejs**\n\n在终端输入\n\n```js\n$ nvm ls-remote\n```\n\n> 这个命令可以查看当前发布的所有nodejs的版本，从0.1.14到6.4.0\n\n我们选择安装当前使用人数最多的4.5.0版本（见官网）\n\n```js\n$ nvm install 4.5.0\n```\n\n指定 nvm 使用的 Node.js 版本\n\n``` js\n$ nvm use 4.5.0\n```\n\n预设使用 4.5.0 版本，否則每次重新連線登入，還需要重新 nvm use 一次\n\n```js\n$ nvm alias default 4.5.0\n```\n\n这样，nodejs就安装好了，可以通过node -v查看当前使用的版本。同时，npm也安装好了，版本为2.15.9","source":"study/linux/one.md","raw":"---\ntitle: nodejs环境的搭建\ntype: linux\norder: 2\n---\n\n## **nodejs环境的搭建**\n\n> nodejs的安装方法有很多种，可以通过编译源码或者类似于apt-get等方式。但是由于我们日后可能需要在nodejs的不同版本之间切换，所以这里给大家提供的是用nvm来安装。\n\n### **nvm是什么**\n\nnvm (Node Version Manager) 是 Nodejs 版本管理器，它让我们能方便的对 Nodejs 的版本进行切换。\n\n> 举个例子，假设，我们已经安装 nvm 了。如果，我们此时需要用 5.0 版本的 Nodejs ，但是我们本机没有装该版本，那么，我们先执行\n> nvm install 5.0 来安装该版本，然后执行 nvm use 5.0， 此时用的 Nodejs 的版本即为 5.0的。以后我们切换到 5.0 版本只需执行 nvm use 5.0 即可。当然，我们可以用 nvm install 来装更多的版本。\n\n\n### **安装nvm**\n\n> nvm github地址：https://github.com/creationix/nvm\n\n```js\n$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.6/install.sh | bash\n\n\n$ source ~/.bashrc\n\n\n$ command -v nvm\n\n//如果终端打印出“mvm”，证明安装成功\n```\n\n### **通过nvm安装nodejs**\n\n在终端输入\n\n```js\n$ nvm ls-remote\n```\n\n> 这个命令可以查看当前发布的所有nodejs的版本，从0.1.14到6.4.0\n\n我们选择安装当前使用人数最多的4.5.0版本（见官网）\n\n```js\n$ nvm install 4.5.0\n```\n\n指定 nvm 使用的 Node.js 版本\n\n``` js\n$ nvm use 4.5.0\n```\n\n预设使用 4.5.0 版本，否則每次重新連線登入，還需要重新 nvm use 一次\n\n```js\n$ nvm alias default 4.5.0\n```\n\n这样，nodejs就安装好了，可以通过node -v查看当前使用的版本。同时，npm也安装好了，版本为2.15.9","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-12T12:38:42.000Z","path":"study/linux/one.html","comments":1,"layout":"page","_id":"ciwnajuxs000ljl2d823j5lfg","content":"<h2 id=\"nodejs环境的搭建\"><a href=\"#nodejs环境的搭建\" class=\"headerlink\" title=\"nodejs环境的搭建\"></a><strong>nodejs环境的搭建</strong></h2><blockquote>\n<p>nodejs的安装方法有很多种，可以通过编译源码或者类似于apt-get等方式。但是由于我们日后可能需要在nodejs的不同版本之间切换，所以这里给大家提供的是用nvm来安装。</p>\n</blockquote>\n<h3 id=\"nvm是什么\"><a href=\"#nvm是什么\" class=\"headerlink\" title=\"nvm是什么\"></a><strong>nvm是什么</strong></h3><p>nvm (Node Version Manager) 是 Nodejs 版本管理器，它让我们能方便的对 Nodejs 的版本进行切换。</p>\n<blockquote>\n<p>举个例子，假设，我们已经安装 nvm 了。如果，我们此时需要用 5.0 版本的 Nodejs ，但是我们本机没有装该版本，那么，我们先执行<br>nvm install 5.0 来安装该版本，然后执行 nvm use 5.0， 此时用的 Nodejs 的版本即为 5.0的。以后我们切换到 5.0 版本只需执行 nvm use 5.0 即可。当然，我们可以用 nvm install 来装更多的版本。</p>\n</blockquote>\n<h3 id=\"安装nvm\"><a href=\"#安装nvm\" class=\"headerlink\" title=\"安装nvm\"></a><strong>安装nvm</strong></h3><blockquote>\n<p>nvm github地址：<a href=\"https://github.com/creationix/nvm\" target=\"_blank\" rel=\"external\">https://github.com/creationix/nvm</a></p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.6/install.sh | bash</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ source ~/.bashrc</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ command -v nvm</div><div class=\"line\"></div><div class=\"line\">//如果终端打印出“mvm”，证明安装成功</div></pre></td></tr></table></figure>\n<h3 id=\"通过nvm安装nodejs\"><a href=\"#通过nvm安装nodejs\" class=\"headerlink\" title=\"通过nvm安装nodejs\"></a><strong>通过nvm安装nodejs</strong></h3><p>在终端输入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ nvm ls-remote</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这个命令可以查看当前发布的所有nodejs的版本，从0.1.14到6.4.0</p>\n</blockquote>\n<p>我们选择安装当前使用人数最多的4.5.0版本（见官网）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ nvm install <span class=\"number\">4.5</span><span class=\"number\">.0</span></div></pre></td></tr></table></figure>\n<p>指定 nvm 使用的 Node.js 版本</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ nvm use <span class=\"number\">4.5</span><span class=\"number\">.0</span></div></pre></td></tr></table></figure>\n<p>预设使用 4.5.0 版本，否則每次重新連線登入，還需要重新 nvm use 一次</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ nvm alias <span class=\"keyword\">default</span> <span class=\"number\">4.5</span><span class=\"number\">.0</span></div></pre></td></tr></table></figure>\n<p>这样，nodejs就安装好了，可以通过node -v查看当前使用的版本。同时，npm也安装好了，版本为2.15.9</p>\n","excerpt":"","more":"<h2 id=\"nodejs环境的搭建\"><a href=\"#nodejs环境的搭建\" class=\"headerlink\" title=\"nodejs环境的搭建\"></a><strong>nodejs环境的搭建</strong></h2><blockquote>\n<p>nodejs的安装方法有很多种，可以通过编译源码或者类似于apt-get等方式。但是由于我们日后可能需要在nodejs的不同版本之间切换，所以这里给大家提供的是用nvm来安装。</p>\n</blockquote>\n<h3 id=\"nvm是什么\"><a href=\"#nvm是什么\" class=\"headerlink\" title=\"nvm是什么\"></a><strong>nvm是什么</strong></h3><p>nvm (Node Version Manager) 是 Nodejs 版本管理器，它让我们能方便的对 Nodejs 的版本进行切换。</p>\n<blockquote>\n<p>举个例子，假设，我们已经安装 nvm 了。如果，我们此时需要用 5.0 版本的 Nodejs ，但是我们本机没有装该版本，那么，我们先执行<br>nvm install 5.0 来安装该版本，然后执行 nvm use 5.0， 此时用的 Nodejs 的版本即为 5.0的。以后我们切换到 5.0 版本只需执行 nvm use 5.0 即可。当然，我们可以用 nvm install 来装更多的版本。</p>\n</blockquote>\n<h3 id=\"安装nvm\"><a href=\"#安装nvm\" class=\"headerlink\" title=\"安装nvm\"></a><strong>安装nvm</strong></h3><blockquote>\n<p>nvm github地址：<a href=\"https://github.com/creationix/nvm\">https://github.com/creationix/nvm</a></p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.6/install.sh | bash</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ source ~/.bashrc</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ command -v nvm</div><div class=\"line\"></div><div class=\"line\">//如果终端打印出“mvm”，证明安装成功</div></pre></td></tr></table></figure>\n<h3 id=\"通过nvm安装nodejs\"><a href=\"#通过nvm安装nodejs\" class=\"headerlink\" title=\"通过nvm安装nodejs\"></a><strong>通过nvm安装nodejs</strong></h3><p>在终端输入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ nvm ls-remote</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这个命令可以查看当前发布的所有nodejs的版本，从0.1.14到6.4.0</p>\n</blockquote>\n<p>我们选择安装当前使用人数最多的4.5.0版本（见官网）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ nvm install <span class=\"number\">4.5</span><span class=\"number\">.0</span></div></pre></td></tr></table></figure>\n<p>指定 nvm 使用的 Node.js 版本</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ nvm use <span class=\"number\">4.5</span><span class=\"number\">.0</span></div></pre></td></tr></table></figure>\n<p>预设使用 4.5.0 版本，否則每次重新連線登入，還需要重新 nvm use 一次</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ nvm alias <span class=\"keyword\">default</span> <span class=\"number\">4.5</span><span class=\"number\">.0</span></div></pre></td></tr></table></figure>\n<p>这样，nodejs就安装好了，可以通过node -v查看当前使用的版本。同时，npm也安装好了，版本为2.15.9</p>\n"},{"title":"linux安装tomcat","type":"linux","order":4,"_content":"\n## linux安装tomcat\n\n> 请先看上一篇，linux安装jdk。因为tomcat需要jdk的支持。\n\n\n### 如何安装\n\n新建一个文件夹用来存放tomcat\n```js\n//新建文件夹\nmkdir /usr/tomcat\n//切换到该文件夹下\ncd /usr/tomcat\n```\n\n//使用wget，下载tomcat包\n```\nwget -c http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.9/bin/apache-tomcat-8.5.9.tar.gz\n```\n\n下载文笔后，可以使用`ls` 命令查看：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213164808670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n解压下载的文件\n```js\ntar -zxvf apache-tomcat-8.5.9.tar.gz  \n```\n> ![这里写图片描述](http://img.blog.csdn.net/20161213164853342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \n\n解压成功后，你的tomcat就安装好了。\n\n启动tomcat\n```js\n//切换到bin目录下\ncd apache-tomcat-8.5.9/bin \n//运行启动脚本\n./startup.sh \n```\n> ![这里写图片描述](http://img.blog.csdn.net/20161213165038793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n启动成功。\n\n### 如果你有防火墙\n\n那么请这样做：\n\n编辑防火墙配置文件\n\n```js\nvi /etc/sysconfig/iptables\n```\n按“i”进入输入模式，添加以下内容\n\n```js\n-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT\n\n```\n\n按esc,输入“:wq”保存并退出。\n\n重新启动防火墙\n\n```js\nservice iptables restart\n```\n\n\n### 测试\n\n在浏览器里输入 ip:8080\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213165339891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n关闭服务器\n```js\n./shutdown.sh\n```\n\ntomcat大概就是这样了，其他的操作你用过tomcat自然就懂了。\n\n### 其他\n\n默认下载的包是tomcat8的，如果你需要下载其他版本，请将wget命令后的地址换成你需要的版本的下载地址。下载地址的获取方式：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213165522876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)","source":"study/linux/three.md","raw":"---\ntitle: linux安装tomcat\ntype: linux\norder: 4\n---\n\n## linux安装tomcat\n\n> 请先看上一篇，linux安装jdk。因为tomcat需要jdk的支持。\n\n\n### 如何安装\n\n新建一个文件夹用来存放tomcat\n```js\n//新建文件夹\nmkdir /usr/tomcat\n//切换到该文件夹下\ncd /usr/tomcat\n```\n\n//使用wget，下载tomcat包\n```\nwget -c http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.9/bin/apache-tomcat-8.5.9.tar.gz\n```\n\n下载文笔后，可以使用`ls` 命令查看：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213164808670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n解压下载的文件\n```js\ntar -zxvf apache-tomcat-8.5.9.tar.gz  \n```\n> ![这里写图片描述](http://img.blog.csdn.net/20161213164853342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \n\n解压成功后，你的tomcat就安装好了。\n\n启动tomcat\n```js\n//切换到bin目录下\ncd apache-tomcat-8.5.9/bin \n//运行启动脚本\n./startup.sh \n```\n> ![这里写图片描述](http://img.blog.csdn.net/20161213165038793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n启动成功。\n\n### 如果你有防火墙\n\n那么请这样做：\n\n编辑防火墙配置文件\n\n```js\nvi /etc/sysconfig/iptables\n```\n按“i”进入输入模式，添加以下内容\n\n```js\n-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT\n\n```\n\n按esc,输入“:wq”保存并退出。\n\n重新启动防火墙\n\n```js\nservice iptables restart\n```\n\n\n### 测试\n\n在浏览器里输入 ip:8080\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213165339891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n关闭服务器\n```js\n./shutdown.sh\n```\n\ntomcat大概就是这样了，其他的操作你用过tomcat自然就懂了。\n\n### 其他\n\n默认下载的包是tomcat8的，如果你需要下载其他版本，请将wget命令后的地址换成你需要的版本的下载地址。下载地址的获取方式：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213165522876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)","date":"2016-12-13T08:58:24.000Z","updated":"2016-12-13T08:58:24.000Z","path":"study/linux/three.html","comments":1,"layout":"page","_id":"ciwnajuxu000mjl2d5q2prqe6","content":"<h2 id=\"linux安装tomcat\"><a href=\"#linux安装tomcat\" class=\"headerlink\" title=\"linux安装tomcat\"></a>linux安装tomcat</h2><blockquote>\n<p>请先看上一篇，linux安装jdk。因为tomcat需要jdk的支持。</p>\n</blockquote>\n<h3 id=\"如何安装\"><a href=\"#如何安装\" class=\"headerlink\" title=\"如何安装\"></a>如何安装</h3><p>新建一个文件夹用来存放tomcat<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//新建文件夹</span></div><div class=\"line\">mkdir /usr/tomcat</div><div class=\"line\"><span class=\"comment\">//切换到该文件夹下</span></div><div class=\"line\">cd /usr/tomcat</div></pre></td></tr></table></figure></p>\n<p>//使用wget，下载tomcat包<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wget -c http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.9/bin/apache-tomcat-8.5.9.tar.gz</div></pre></td></tr></table></figure></p>\n<p>下载文笔后，可以使用<code>ls</code> 命令查看：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213164808670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>解压下载的文件<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">tar -zxvf apache-tomcat<span class=\"number\">-8.5</span><span class=\"number\">.9</span>.tar.gz</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213164853342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p>解压成功后，你的tomcat就安装好了。</p>\n<p>启动tomcat<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//切换到bin目录下</span></div><div class=\"line\">cd apache-tomcat<span class=\"number\">-8.5</span><span class=\"number\">.9</span>/bin </div><div class=\"line\"><span class=\"comment\">//运行启动脚本</span></div><div class=\"line\">./startup.sh</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213165038793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>启动成功。</p>\n<h3 id=\"如果你有防火墙\"><a href=\"#如果你有防火墙\" class=\"headerlink\" title=\"如果你有防火墙\"></a>如果你有防火墙</h3><p>那么请这样做：</p>\n<p>编辑防火墙配置文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vi /etc/sysconfig/iptables</div></pre></td></tr></table></figure>\n<p>按“i”进入输入模式，添加以下内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">-A RH-Firewall<span class=\"number\">-1</span>-INPUT -m state --state NEW -m tcp -p tcp --dport <span class=\"number\">8080</span> -j ACCEPT</div></pre></td></tr></table></figure>\n<p>按esc,输入“:wq”保存并退出。</p>\n<p>重新启动防火墙</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">service iptables restart</div></pre></td></tr></table></figure>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>在浏览器里输入 ip:8080</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213165339891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>关闭服务器<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">./shutdown.sh</div></pre></td></tr></table></figure></p>\n<p>tomcat大概就是这样了，其他的操作你用过tomcat自然就懂了。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>默认下载的包是tomcat8的，如果你需要下载其他版本，请将wget命令后的地址换成你需要的版本的下载地址。下载地址的获取方式：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213165522876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"linux安装tomcat\"><a href=\"#linux安装tomcat\" class=\"headerlink\" title=\"linux安装tomcat\"></a>linux安装tomcat</h2><blockquote>\n<p>请先看上一篇，linux安装jdk。因为tomcat需要jdk的支持。</p>\n</blockquote>\n<h3 id=\"如何安装\"><a href=\"#如何安装\" class=\"headerlink\" title=\"如何安装\"></a>如何安装</h3><p>新建一个文件夹用来存放tomcat<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//新建文件夹</span></div><div class=\"line\">mkdir /usr/tomcat</div><div class=\"line\"><span class=\"comment\">//切换到该文件夹下</span></div><div class=\"line\">cd /usr/tomcat</div></pre></td></tr></table></figure></p>\n<p>//使用wget，下载tomcat包<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wget -c http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.9/bin/apache-tomcat-8.5.9.tar.gz</div></pre></td></tr></table></figure></p>\n<p>下载文笔后，可以使用<code>ls</code> 命令查看：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213164808670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>解压下载的文件<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">tar -zxvf apache-tomcat<span class=\"number\">-8.5</span><span class=\"number\">.9</span>.tar.gz</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213164853342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p>解压成功后，你的tomcat就安装好了。</p>\n<p>启动tomcat<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//切换到bin目录下</span></div><div class=\"line\">cd apache-tomcat<span class=\"number\">-8.5</span><span class=\"number\">.9</span>/bin </div><div class=\"line\"><span class=\"comment\">//运行启动脚本</span></div><div class=\"line\">./startup.sh</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213165038793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>启动成功。</p>\n<h3 id=\"如果你有防火墙\"><a href=\"#如果你有防火墙\" class=\"headerlink\" title=\"如果你有防火墙\"></a>如果你有防火墙</h3><p>那么请这样做：</p>\n<p>编辑防火墙配置文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vi /etc/sysconfig/iptables</div></pre></td></tr></table></figure>\n<p>按“i”进入输入模式，添加以下内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">-A RH-Firewall<span class=\"number\">-1</span>-INPUT -m state --state NEW -m tcp -p tcp --dport <span class=\"number\">8080</span> -j ACCEPT</div></pre></td></tr></table></figure>\n<p>按esc,输入“:wq”保存并退出。</p>\n<p>重新启动防火墙</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">service iptables restart</div></pre></td></tr></table></figure>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>在浏览器里输入 ip:8080</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213165339891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>关闭服务器<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">./shutdown.sh</div></pre></td></tr></table></figure></p>\n<p>tomcat大概就是这样了，其他的操作你用过tomcat自然就懂了。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>默认下载的包是tomcat8的，如果你需要下载其他版本，请将wget命令后的地址换成你需要的版本的下载地址。下载地址的获取方式：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213165522876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n"},{"title":"开始","type":"nodejs","order":1,"_content":"\n我写不知道写点什么好，暂时就这样吧。。。","source":"study/nodejs/index.md","raw":"---\ntitle: 开始\ntype: nodejs\norder: 1\n---\n\n我写不知道写点什么好，暂时就这样吧。。。","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-12T12:46:08.000Z","path":"study/nodejs/index.html","comments":1,"layout":"page","_id":"ciwnajuxv000njl2dbdxm032w","content":"<p>我写不知道写点什么好，暂时就这样吧。。。</p>\n","excerpt":"","more":"<p>我写不知道写点什么好，暂时就这样吧。。。</p>\n"},{"title":"linux下安装jdk","type":"linux","order":3,"_content":"\n## linux下安装jdk\n\n### 先看一下你的系统有没有自带的jdk\n`java -version` \n如果有，会输出相应的版本信息。那么把自带的删了。用下面的方式：\n\n```js\nrpm -qa | grep jdk \nrpm -e --nodeps xxxx //卸载对应jdk，其中xxxx为所要卸载的jdk名称\n```\n\n如果没有，那么我们直接安装\n\n### 安装jdk\n先找一个放置jdk的目录。假如为/usr/java/：\n\n```js\n//新建文件夹\nmkdir /usr/java\n//切换到这个文件夹\ncd /usr/java\n\n//下载rpm文件\nwget --no-check-certificate --no-cookies --header \"Cookie: oraclelicense=accept-securebackup-cookie\" http://download.oracle.com/otn-pub/java/jdk/8u112-b15/jdk-8u112-linux-x64.rpm\n\n```\n这个时候就是在下载jdk文件了。大概160M，网速快的话很快就好了。\n> ![这里写图片描述](http://img.blog.csdn.net/20161213162514447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以使用`ls`命令，查看下载的文件。\n\n然后\n\n```js\n//给文件添加执行权限\nchmod +x jdk-8u112-linux-x64.rpm \n//使用rpm安装\nrpm -ivh jdk-8u112-linux-x64.rpm\n```\n> ![这里写图片描述](http://img.blog.csdn.net/20161213162753022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这样jdk就安装好了，测试一下\n\n```js\n//查看java版本\njava -version\n```\n> ![这里写图片描述](http://img.blog.csdn.net/20161213162633401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n接下来配置环境变量：\n\n```js\n//编辑配置文件\nvi /etc/profile \n```\n打开配置文件，按“i”进入输入模式\n\n> 更多vi的用法，请查看我的vi使用讲解\n\n把配置文件里export PATH 中的PATH删掉。\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213162655199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n在配置文件的最末尾输入以下内容\n\n```\nexport JAVA_HOME=/usr/java/jdk1.8.0_112\nexport PATH=$JAVA_HOME/bin:$PATH \nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar \n```\n然后按esc，输入“:wq”  按回车键，保存并退出\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213162724975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n重启配置文件：\n```js\nsource /etc/profile\n```\n\n这个时候，你就可以在任何位置使用jdk了，测试一下。\n\n```js\n//切换到根目录\ncd /  \n//运行这两个java命令，看到结果证明成功\njava\njavac\n```\n\n### 使用yum命令安装openjdk。\n\nopenjdk与oracle的jdk有什么区别请自行研究。大部分人都是用Oracle的。但是如果你想使用openjdk，那么你可以用下面的方法安装。\n\n```js\n//列出所有的可安装包\n yum list java*\n```\n\n \n>![这里写图片描述](http://img.blog.csdn.net/20161213150432654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  \n\n```\n//选择你需要的版本安装，比如：\nyum install java-1.7.0-openjdk \n```\n\n恩，安装好了\n\n### 其他 \n\n本文默认安装jdk1.8，如果你需要安装其他版本的jdk，请把wget命令后的下载地址换成你需要的版本地址。下载地址获取方法：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213170150629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \n\n官网 ： http://www.oracle.com/technetwork/cn/java/javase/overview/index.html","source":"study/linux/two.md","raw":"---\ntitle: linux下安装jdk\ntype: linux\norder: 3\n---\n\n## linux下安装jdk\n\n### 先看一下你的系统有没有自带的jdk\n`java -version` \n如果有，会输出相应的版本信息。那么把自带的删了。用下面的方式：\n\n```js\nrpm -qa | grep jdk \nrpm -e --nodeps xxxx //卸载对应jdk，其中xxxx为所要卸载的jdk名称\n```\n\n如果没有，那么我们直接安装\n\n### 安装jdk\n先找一个放置jdk的目录。假如为/usr/java/：\n\n```js\n//新建文件夹\nmkdir /usr/java\n//切换到这个文件夹\ncd /usr/java\n\n//下载rpm文件\nwget --no-check-certificate --no-cookies --header \"Cookie: oraclelicense=accept-securebackup-cookie\" http://download.oracle.com/otn-pub/java/jdk/8u112-b15/jdk-8u112-linux-x64.rpm\n\n```\n这个时候就是在下载jdk文件了。大概160M，网速快的话很快就好了。\n> ![这里写图片描述](http://img.blog.csdn.net/20161213162514447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以使用`ls`命令，查看下载的文件。\n\n然后\n\n```js\n//给文件添加执行权限\nchmod +x jdk-8u112-linux-x64.rpm \n//使用rpm安装\nrpm -ivh jdk-8u112-linux-x64.rpm\n```\n> ![这里写图片描述](http://img.blog.csdn.net/20161213162753022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这样jdk就安装好了，测试一下\n\n```js\n//查看java版本\njava -version\n```\n> ![这里写图片描述](http://img.blog.csdn.net/20161213162633401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n接下来配置环境变量：\n\n```js\n//编辑配置文件\nvi /etc/profile \n```\n打开配置文件，按“i”进入输入模式\n\n> 更多vi的用法，请查看我的vi使用讲解\n\n把配置文件里export PATH 中的PATH删掉。\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213162655199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n在配置文件的最末尾输入以下内容\n\n```\nexport JAVA_HOME=/usr/java/jdk1.8.0_112\nexport PATH=$JAVA_HOME/bin:$PATH \nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar \n```\n然后按esc，输入“:wq”  按回车键，保存并退出\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213162724975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n重启配置文件：\n```js\nsource /etc/profile\n```\n\n这个时候，你就可以在任何位置使用jdk了，测试一下。\n\n```js\n//切换到根目录\ncd /  \n//运行这两个java命令，看到结果证明成功\njava\njavac\n```\n\n### 使用yum命令安装openjdk。\n\nopenjdk与oracle的jdk有什么区别请自行研究。大部分人都是用Oracle的。但是如果你想使用openjdk，那么你可以用下面的方法安装。\n\n```js\n//列出所有的可安装包\n yum list java*\n```\n\n \n>![这里写图片描述](http://img.blog.csdn.net/20161213150432654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  \n\n```\n//选择你需要的版本安装，比如：\nyum install java-1.7.0-openjdk \n```\n\n恩，安装好了\n\n### 其他 \n\n本文默认安装jdk1.8，如果你需要安装其他版本的jdk，请把wget命令后的下载地址换成你需要的版本地址。下载地址获取方法：\n\n> ![这里写图片描述](http://img.blog.csdn.net/20161213170150629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \n\n官网 ： http://www.oracle.com/technetwork/cn/java/javase/overview/index.html","date":"2016-12-13T09:04:22.000Z","updated":"2016-12-13T09:04:22.000Z","path":"study/linux/two.html","comments":1,"layout":"page","_id":"ciwnajuxw000ojl2den8iokdp","content":"<h2 id=\"linux下安装jdk\"><a href=\"#linux下安装jdk\" class=\"headerlink\" title=\"linux下安装jdk\"></a>linux下安装jdk</h2><h3 id=\"先看一下你的系统有没有自带的jdk\"><a href=\"#先看一下你的系统有没有自带的jdk\" class=\"headerlink\" title=\"先看一下你的系统有没有自带的jdk\"></a>先看一下你的系统有没有自带的jdk</h3><p><code>java -version</code><br>如果有，会输出相应的版本信息。那么把自带的删了。用下面的方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">rpm -qa | grep jdk </div><div class=\"line\">rpm -e --nodeps xxxx <span class=\"comment\">//卸载对应jdk，其中xxxx为所要卸载的jdk名称</span></div></pre></td></tr></table></figure>\n<p>如果没有，那么我们直接安装</p>\n<h3 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h3><p>先找一个放置jdk的目录。假如为/usr/java/：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//新建文件夹</span></div><div class=\"line\">mkdir /usr/java</div><div class=\"line\"><span class=\"comment\">//切换到这个文件夹</span></div><div class=\"line\">cd /usr/java</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//下载rpm文件</span></div><div class=\"line\">wget --no-check-certificate --no-cookies --header <span class=\"string\">\"Cookie: oraclelicense=accept-securebackup-cookie\"</span> http:<span class=\"comment\">//download.oracle.com/otn-pub/java/jdk/8u112-b15/jdk-8u112-linux-x64.rpm</span></div></pre></td></tr></table></figure>\n<p>这个时候就是在下载jdk文件了。大概160M，网速快的话很快就好了。</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213162514447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>可以使用<code>ls</code>命令，查看下载的文件。</p>\n<p>然后</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//给文件添加执行权限</span></div><div class=\"line\">chmod +x jdk<span class=\"number\">-8</span>u112-linux-x64.rpm </div><div class=\"line\"><span class=\"comment\">//使用rpm安装</span></div><div class=\"line\">rpm -ivh jdk<span class=\"number\">-8</span>u112-linux-x64.rpm</div></pre></td></tr></table></figure>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213162753022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>这样jdk就安装好了，测试一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//查看java版本</span></div><div class=\"line\">java -version</div></pre></td></tr></table></figure>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213162633401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>接下来配置环境变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//编辑配置文件</span></div><div class=\"line\">vi /etc/profile</div></pre></td></tr></table></figure>\n<p>打开配置文件，按“i”进入输入模式</p>\n<blockquote>\n<p>更多vi的用法，请查看我的vi使用讲解</p>\n</blockquote>\n<p>把配置文件里export PATH 中的PATH删掉。</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213162655199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>在配置文件的最末尾输入以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">export JAVA_HOME=/usr/java/jdk1.8.0_112</div><div class=\"line\">export PATH=$JAVA_HOME/bin:$PATH </div><div class=\"line\">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div></pre></td></tr></table></figure>\n<p>然后按esc，输入“:wq”  按回车键，保存并退出</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213162724975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>重启配置文件：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">source /etc/profile</div></pre></td></tr></table></figure></p>\n<p>这个时候，你就可以在任何位置使用jdk了，测试一下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//切换到根目录</span></div><div class=\"line\">cd /  </div><div class=\"line\"><span class=\"comment\">//运行这两个java命令，看到结果证明成功</span></div><div class=\"line\">java</div><div class=\"line\">javac</div></pre></td></tr></table></figure>\n<h3 id=\"使用yum命令安装openjdk。\"><a href=\"#使用yum命令安装openjdk。\" class=\"headerlink\" title=\"使用yum命令安装openjdk。\"></a>使用yum命令安装openjdk。</h3><p>openjdk与oracle的jdk有什么区别请自行研究。大部分人都是用Oracle的。但是如果你想使用openjdk，那么你可以用下面的方法安装。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//列出所有的可安装包</span></div><div class=\"line\"> yum list java*</div></pre></td></tr></table></figure>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213150432654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\">  </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//选择你需要的版本安装，比如：</div><div class=\"line\">yum install java-1.7.0-openjdk</div></pre></td></tr></table></figure>\n<p>恩，安装好了</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>本文默认安装jdk1.8，如果你需要安装其他版本的jdk，请把wget命令后的下载地址换成你需要的版本地址。下载地址获取方法：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213170150629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p>官网 ： <a href=\"http://www.oracle.com/technetwork/cn/java/javase/overview/index.html\" target=\"_blank\" rel=\"external\">http://www.oracle.com/technetwork/cn/java/javase/overview/index.html</a></p>\n","excerpt":"","more":"<h2 id=\"linux下安装jdk\"><a href=\"#linux下安装jdk\" class=\"headerlink\" title=\"linux下安装jdk\"></a>linux下安装jdk</h2><h3 id=\"先看一下你的系统有没有自带的jdk\"><a href=\"#先看一下你的系统有没有自带的jdk\" class=\"headerlink\" title=\"先看一下你的系统有没有自带的jdk\"></a>先看一下你的系统有没有自带的jdk</h3><p><code>java -version</code><br>如果有，会输出相应的版本信息。那么把自带的删了。用下面的方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">rpm -qa | grep jdk </div><div class=\"line\">rpm -e --nodeps xxxx <span class=\"comment\">//卸载对应jdk，其中xxxx为所要卸载的jdk名称</span></div></pre></td></tr></table></figure>\n<p>如果没有，那么我们直接安装</p>\n<h3 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h3><p>先找一个放置jdk的目录。假如为/usr/java/：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//新建文件夹</span></div><div class=\"line\">mkdir /usr/java</div><div class=\"line\"><span class=\"comment\">//切换到这个文件夹</span></div><div class=\"line\">cd /usr/java</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//下载rpm文件</span></div><div class=\"line\">wget --no-check-certificate --no-cookies --header <span class=\"string\">\"Cookie: oraclelicense=accept-securebackup-cookie\"</span> http:<span class=\"comment\">//download.oracle.com/otn-pub/java/jdk/8u112-b15/jdk-8u112-linux-x64.rpm</span></div></pre></td></tr></table></figure>\n<p>这个时候就是在下载jdk文件了。大概160M，网速快的话很快就好了。</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213162514447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>可以使用<code>ls</code>命令，查看下载的文件。</p>\n<p>然后</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//给文件添加执行权限</span></div><div class=\"line\">chmod +x jdk<span class=\"number\">-8</span>u112-linux-x64.rpm </div><div class=\"line\"><span class=\"comment\">//使用rpm安装</span></div><div class=\"line\">rpm -ivh jdk<span class=\"number\">-8</span>u112-linux-x64.rpm</div></pre></td></tr></table></figure>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213162753022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>这样jdk就安装好了，测试一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//查看java版本</span></div><div class=\"line\">java -version</div></pre></td></tr></table></figure>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213162633401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>接下来配置环境变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//编辑配置文件</span></div><div class=\"line\">vi /etc/profile</div></pre></td></tr></table></figure>\n<p>打开配置文件，按“i”进入输入模式</p>\n<blockquote>\n<p>更多vi的用法，请查看我的vi使用讲解</p>\n</blockquote>\n<p>把配置文件里export PATH 中的PATH删掉。</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213162655199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>在配置文件的最末尾输入以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">export JAVA_HOME=/usr/java/jdk1.8.0_112</div><div class=\"line\">export PATH=$JAVA_HOME/bin:$PATH </div><div class=\"line\">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div></pre></td></tr></table></figure>\n<p>然后按esc，输入“:wq”  按回车键，保存并退出</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213162724975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<p>重启配置文件：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">source /etc/profile</div></pre></td></tr></table></figure></p>\n<p>这个时候，你就可以在任何位置使用jdk了，测试一下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//切换到根目录</span></div><div class=\"line\">cd /  </div><div class=\"line\"><span class=\"comment\">//运行这两个java命令，看到结果证明成功</span></div><div class=\"line\">java</div><div class=\"line\">javac</div></pre></td></tr></table></figure>\n<h3 id=\"使用yum命令安装openjdk。\"><a href=\"#使用yum命令安装openjdk。\" class=\"headerlink\" title=\"使用yum命令安装openjdk。\"></a>使用yum命令安装openjdk。</h3><p>openjdk与oracle的jdk有什么区别请自行研究。大部分人都是用Oracle的。但是如果你想使用openjdk，那么你可以用下面的方法安装。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//列出所有的可安装包</span></div><div class=\"line\"> yum list java*</div></pre></td></tr></table></figure>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213150432654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\">  </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//选择你需要的版本安装，比如：</div><div class=\"line\">yum install java-1.7.0-openjdk</div></pre></td></tr></table></figure>\n<p>恩，安装好了</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>本文默认安装jdk1.8，如果你需要安装其他版本的jdk，请把wget命令后的下载地址换成你需要的版本地址。下载地址获取方法：</p>\n<blockquote>\n<p><img src=\"http://img.blog.csdn.net/20161213170150629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE2NTU5NjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"> </p>\n</blockquote>\n<p>官网 ： <a href=\"http://www.oracle.com/technetwork/cn/java/javase/overview/index.html\">http://www.oracle.com/technetwork/cn/java/javase/overview/index.html</a></p>\n"},{"title":"使用express搭建nodejs项目","type":"nodejs","order":2,"_content":"\n最近对nodejs比较感兴趣，所以打算学习一下。但是在学习过程中遇到了一些麻烦，现在将这个过程与大家分享一下。\n\n## 环境\n\n - 系统 ubutu16.04 （win10下的虚拟机）\n - nodejs版本 4.4.7\n - npm版本 2.15.8\n\n> nodejs  github主页：https://github.com/nodejs/node\n> nodejs  官网：https://nodejs.org\n> nodejs 中文社区：https://cnodejs.org\n> express github主页：https://github.com/expressjs/express\n\n## 第一步，安装nodejs\n\n**windows**请直接到上诉官网中下载安装即可，现在安装nodejs会自动将npm也安装好。\n\n**Ubuntu系统**：\n首先确保系统安装来python,gcc,g++,如果没有则安装： \n（一般Ubuntu都已默认安装）\n\n```js\n$ sudo apt-get install python \n\n$ sudo apt-get install build-essential \n\n$ sudo apt-get install gcc \n\n$ sudo apt-get install g++ \n```\n\n确保都安装了之后，从nodeJS官网下载最新源代码包：node-v4.4.7.tar.gz\n\n解压：\n\n```js\n$ tar -zxf node-v4.4.7.tar.gz \n\n$ cd node-v4.4.7\n```\n\n默认安装： \n\n```js\n$ ./configure \n\n$ make \n\n$ sudo make install \n```\n\n选择目录方式安装： \n\n```js\n$ ./configure –prefix=/usr/node \n\n$ make -j 5 #5=CPU核数+1 \n\n$ sudo make install\n```\n\n> 当然，你也可以通过linux包管理器安装：\n> `apt get install nodejs -g`\n> `apt get install npm -g`\n> 但是个人不建议这么做，因为有时候会莫名其妙的出问题，还是直接编译源码比较实在（编译过程需要一些时间）。\n\n接下来通过查看版本确认已经安装成功：\n\n```js\n$ node -v\n```\n\n```js\n$ npm -v\n```\n\n## 第二步，安装express\n\n**Windows**：打开Node.js command prompt，输入：\n\t\n\n```js\nnpm install express -g\n```\n\n> -g是全局安装，在任何地方打开命令行都可以使用相应命令\n\n**Ubuntu** 打开终端，输入：\n\t\n\n```js\n$ sudo npm install express -g\n```\n\n> 请务必使用管理员权限安装，否则会安装失败\n\n```js\n$ sudo npm install -g express-generator@4  \n```\n\n \n\n>express4.0之后把创建一个APP的功能分离出来为express-generator，所以必须得安装它，否则没法正常使用express\n\n通过输入‘express -v’确认安装成功。（有些情况无法查看版本，但是可以正常使用）\n\n## 使用express建一个demo\n\n  \n 1. 打开一个用来放源码的目录，输入`$ express nodetest -e`  \n\n> 新建一个名为nodetest的项目，使用ejs作为模板。 ejs （Embedded JavaScript） 是一个标签替换引擎，其语法与 ASP、PHP 相似，易于学习，目前被广泛应用。Express 默认提供的引擎是 jade，它颠覆了传统的模板引擎，制定了一套完整的语法用来生成 HTML 的每个标签结构，功能强大但不易学习。Express 在初始化一个项目的时候需要指定模板引擎，默认支持Jade和ejs。\n\n 2. `$ cd nodetest && npm install`\n \n\n> 进去项目文件夹，并安装所需要的依赖。无参数的 npm install 的功能就是 检查当前目录下的 package.json，并自动安装所有指定的依赖。 \n\n 3. `$ npm start`\n \n\n> 启动项目。接下来，打开浏览器，输入地址 http://localhost:3000，你就可以看到一个简单的 Welcome to Express 页面了。\n\n\n> express以前的版本，启动项目的命令是\n> `\\$ node app.js`\n> 但是，使用最新版的这样是无法启动的，正确的启动命令是\n> `$ npm start`\n\n市面上讲nodejs的书籍并不多，而且node的版本更新太快，好多书上的例子用最新版的node已经无法运行了，所以，不要觉得书上的都是正确的，遇到问题多google。\n\n\n\n> 附nodejs教程，中文文档等\n> http://download.csdn.net/detail/qq_31655965/9603069\n> http://download.csdn.net/detail/qq_31655965/9603064\n\n     ","source":"study/nodejs/one.md","raw":"---\ntitle: 使用express搭建nodejs项目\ntype: nodejs\norder: 2\n---\n\n最近对nodejs比较感兴趣，所以打算学习一下。但是在学习过程中遇到了一些麻烦，现在将这个过程与大家分享一下。\n\n## 环境\n\n - 系统 ubutu16.04 （win10下的虚拟机）\n - nodejs版本 4.4.7\n - npm版本 2.15.8\n\n> nodejs  github主页：https://github.com/nodejs/node\n> nodejs  官网：https://nodejs.org\n> nodejs 中文社区：https://cnodejs.org\n> express github主页：https://github.com/expressjs/express\n\n## 第一步，安装nodejs\n\n**windows**请直接到上诉官网中下载安装即可，现在安装nodejs会自动将npm也安装好。\n\n**Ubuntu系统**：\n首先确保系统安装来python,gcc,g++,如果没有则安装： \n（一般Ubuntu都已默认安装）\n\n```js\n$ sudo apt-get install python \n\n$ sudo apt-get install build-essential \n\n$ sudo apt-get install gcc \n\n$ sudo apt-get install g++ \n```\n\n确保都安装了之后，从nodeJS官网下载最新源代码包：node-v4.4.7.tar.gz\n\n解压：\n\n```js\n$ tar -zxf node-v4.4.7.tar.gz \n\n$ cd node-v4.4.7\n```\n\n默认安装： \n\n```js\n$ ./configure \n\n$ make \n\n$ sudo make install \n```\n\n选择目录方式安装： \n\n```js\n$ ./configure –prefix=/usr/node \n\n$ make -j 5 #5=CPU核数+1 \n\n$ sudo make install\n```\n\n> 当然，你也可以通过linux包管理器安装：\n> `apt get install nodejs -g`\n> `apt get install npm -g`\n> 但是个人不建议这么做，因为有时候会莫名其妙的出问题，还是直接编译源码比较实在（编译过程需要一些时间）。\n\n接下来通过查看版本确认已经安装成功：\n\n```js\n$ node -v\n```\n\n```js\n$ npm -v\n```\n\n## 第二步，安装express\n\n**Windows**：打开Node.js command prompt，输入：\n\t\n\n```js\nnpm install express -g\n```\n\n> -g是全局安装，在任何地方打开命令行都可以使用相应命令\n\n**Ubuntu** 打开终端，输入：\n\t\n\n```js\n$ sudo npm install express -g\n```\n\n> 请务必使用管理员权限安装，否则会安装失败\n\n```js\n$ sudo npm install -g express-generator@4  \n```\n\n \n\n>express4.0之后把创建一个APP的功能分离出来为express-generator，所以必须得安装它，否则没法正常使用express\n\n通过输入‘express -v’确认安装成功。（有些情况无法查看版本，但是可以正常使用）\n\n## 使用express建一个demo\n\n  \n 1. 打开一个用来放源码的目录，输入`$ express nodetest -e`  \n\n> 新建一个名为nodetest的项目，使用ejs作为模板。 ejs （Embedded JavaScript） 是一个标签替换引擎，其语法与 ASP、PHP 相似，易于学习，目前被广泛应用。Express 默认提供的引擎是 jade，它颠覆了传统的模板引擎，制定了一套完整的语法用来生成 HTML 的每个标签结构，功能强大但不易学习。Express 在初始化一个项目的时候需要指定模板引擎，默认支持Jade和ejs。\n\n 2. `$ cd nodetest && npm install`\n \n\n> 进去项目文件夹，并安装所需要的依赖。无参数的 npm install 的功能就是 检查当前目录下的 package.json，并自动安装所有指定的依赖。 \n\n 3. `$ npm start`\n \n\n> 启动项目。接下来，打开浏览器，输入地址 http://localhost:3000，你就可以看到一个简单的 Welcome to Express 页面了。\n\n\n> express以前的版本，启动项目的命令是\n> `\\$ node app.js`\n> 但是，使用最新版的这样是无法启动的，正确的启动命令是\n> `$ npm start`\n\n市面上讲nodejs的书籍并不多，而且node的版本更新太快，好多书上的例子用最新版的node已经无法运行了，所以，不要觉得书上的都是正确的，遇到问题多google。\n\n\n\n> 附nodejs教程，中文文档等\n> http://download.csdn.net/detail/qq_31655965/9603069\n> http://download.csdn.net/detail/qq_31655965/9603064\n\n     ","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-12T12:48:11.000Z","path":"study/nodejs/one.html","comments":1,"layout":"page","_id":"ciwnajuxx000pjl2dtxukg33i","content":"<p>最近对nodejs比较感兴趣，所以打算学习一下。但是在学习过程中遇到了一些麻烦，现在将这个过程与大家分享一下。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>系统 ubutu16.04 （win10下的虚拟机）</li>\n<li>nodejs版本 4.4.7</li>\n<li>npm版本 2.15.8</li>\n</ul>\n<blockquote>\n<p>nodejs  github主页：<a href=\"https://github.com/nodejs/node\" target=\"_blank\" rel=\"external\">https://github.com/nodejs/node</a><br>nodejs  官网：<a href=\"https://nodejs.org\" target=\"_blank\" rel=\"external\">https://nodejs.org</a><br>nodejs 中文社区：<a href=\"https://cnodejs.org\" target=\"_blank\" rel=\"external\">https://cnodejs.org</a><br>express github主页：<a href=\"https://github.com/expressjs/express\" target=\"_blank\" rel=\"external\">https://github.com/expressjs/express</a></p>\n</blockquote>\n<h2 id=\"第一步，安装nodejs\"><a href=\"#第一步，安装nodejs\" class=\"headerlink\" title=\"第一步，安装nodejs\"></a>第一步，安装nodejs</h2><p><strong>windows</strong>请直接到上诉官网中下载安装即可，现在安装nodejs会自动将npm也安装好。</p>\n<p><strong>Ubuntu系统</strong>：<br>首先确保系统安装来python,gcc,g++,如果没有则安装：<br>（一般Ubuntu都已默认安装）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ sudo apt-get install python </div><div class=\"line\"></div><div class=\"line\">$ sudo apt-get install build-essential </div><div class=\"line\"></div><div class=\"line\">$ sudo apt-get install gcc </div><div class=\"line\"></div><div class=\"line\">$ sudo apt-get install g++</div></pre></td></tr></table></figure>\n<p>确保都安装了之后，从nodeJS官网下载最新源代码包：node-v4.4.7.tar.gz</p>\n<p>解压：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ tar -zxf node-v4<span class=\"number\">.4</span><span class=\"number\">.7</span>.tar.gz </div><div class=\"line\"></div><div class=\"line\">$ cd node-v4<span class=\"number\">.4</span><span class=\"number\">.7</span></div></pre></td></tr></table></figure>\n<p>默认安装： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ ./configure </div><div class=\"line\"></div><div class=\"line\">$ make </div><div class=\"line\"></div><div class=\"line\">$ sudo make install</div></pre></td></tr></table></figure>\n<p>选择目录方式安装： </p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ ./configure –prefix=/usr/node </div><div class=\"line\"></div><div class=\"line\">$ make -j 5 #5=CPU核数+1 </div><div class=\"line\"></div><div class=\"line\">$ sudo make install</div></pre></td></tr></table></figure>\n<blockquote>\n<p>当然，你也可以通过linux包管理器安装：<br><code>apt get install nodejs -g</code><br><code>apt get install npm -g</code><br>但是个人不建议这么做，因为有时候会莫名其妙的出问题，还是直接编译源码比较实在（编译过程需要一些时间）。</p>\n</blockquote>\n<p>接下来通过查看版本确认已经安装成功：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ node -v</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ npm -v</div></pre></td></tr></table></figure>\n<h2 id=\"第二步，安装express\"><a href=\"#第二步，安装express\" class=\"headerlink\" title=\"第二步，安装express\"></a>第二步，安装express</h2><p><strong>Windows</strong>：打开Node.js command prompt，输入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">npm install express -g</div></pre></td></tr></table></figure>\n<blockquote>\n<p>-g是全局安装，在任何地方打开命令行都可以使用相应命令</p>\n</blockquote>\n<p><strong>Ubuntu</strong> 打开终端，输入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ sudo npm install express -g</div></pre></td></tr></table></figure>\n<blockquote>\n<p>请务必使用管理员权限安装，否则会安装失败</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ sudo npm install -g express-generator@<span class=\"number\">4</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>express4.0之后把创建一个APP的功能分离出来为express-generator，所以必须得安装它，否则没法正常使用express</p>\n</blockquote>\n<p>通过输入‘express -v’确认安装成功。（有些情况无法查看版本，但是可以正常使用）</p>\n<h2 id=\"使用express建一个demo\"><a href=\"#使用express建一个demo\" class=\"headerlink\" title=\"使用express建一个demo\"></a>使用express建一个demo</h2><ol>\n<li>打开一个用来放源码的目录，输入<code>$ express nodetest -e</code>  </li>\n</ol>\n<blockquote>\n<p>新建一个名为nodetest的项目，使用ejs作为模板。 ejs （Embedded JavaScript） 是一个标签替换引擎，其语法与 ASP、PHP 相似，易于学习，目前被广泛应用。Express 默认提供的引擎是 jade，它颠覆了传统的模板引擎，制定了一套完整的语法用来生成 HTML 的每个标签结构，功能强大但不易学习。Express 在初始化一个项目的时候需要指定模板引擎，默认支持Jade和ejs。</p>\n</blockquote>\n<ol>\n<li><code>$ cd nodetest &amp;&amp; npm install</code></li>\n</ol>\n<blockquote>\n<p>进去项目文件夹，并安装所需要的依赖。无参数的 npm install 的功能就是 检查当前目录下的 package.json，并自动安装所有指定的依赖。 </p>\n</blockquote>\n<ol>\n<li><code>$ npm start</code></li>\n</ol>\n<blockquote>\n<p>启动项目。接下来，打开浏览器，输入地址 <a href=\"http://localhost:3000，你就可以看到一个简单的\" target=\"_blank\" rel=\"external\">http://localhost:3000，你就可以看到一个简单的</a> Welcome to Express 页面了。</p>\n<p>express以前的版本，启动项目的命令是<br><code>\\$ node app.js</code><br>但是，使用最新版的这样是无法启动的，正确的启动命令是<br><code>$ npm start</code></p>\n</blockquote>\n<p>市面上讲nodejs的书籍并不多，而且node的版本更新太快，好多书上的例子用最新版的node已经无法运行了，所以，不要觉得书上的都是正确的，遇到问题多google。</p>\n<blockquote>\n<p>附nodejs教程，中文文档等<br><a href=\"http://download.csdn.net/detail/qq_31655965/9603069\" target=\"_blank\" rel=\"external\">http://download.csdn.net/detail/qq_31655965/9603069</a><br><a href=\"http://download.csdn.net/detail/qq_31655965/9603064\" target=\"_blank\" rel=\"external\">http://download.csdn.net/detail/qq_31655965/9603064</a></p>\n</blockquote>\n","excerpt":"","more":"<p>最近对nodejs比较感兴趣，所以打算学习一下。但是在学习过程中遇到了一些麻烦，现在将这个过程与大家分享一下。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>系统 ubutu16.04 （win10下的虚拟机）</li>\n<li>nodejs版本 4.4.7</li>\n<li>npm版本 2.15.8</li>\n</ul>\n<blockquote>\n<p>nodejs  github主页：<a href=\"https://github.com/nodejs/node\">https://github.com/nodejs/node</a><br>nodejs  官网：<a href=\"https://nodejs.org\">https://nodejs.org</a><br>nodejs 中文社区：<a href=\"https://cnodejs.org\">https://cnodejs.org</a><br>express github主页：<a href=\"https://github.com/expressjs/express\">https://github.com/expressjs/express</a></p>\n</blockquote>\n<h2 id=\"第一步，安装nodejs\"><a href=\"#第一步，安装nodejs\" class=\"headerlink\" title=\"第一步，安装nodejs\"></a>第一步，安装nodejs</h2><p><strong>windows</strong>请直接到上诉官网中下载安装即可，现在安装nodejs会自动将npm也安装好。</p>\n<p><strong>Ubuntu系统</strong>：<br>首先确保系统安装来python,gcc,g++,如果没有则安装：<br>（一般Ubuntu都已默认安装）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ sudo apt-get install python </div><div class=\"line\"></div><div class=\"line\">$ sudo apt-get install build-essential </div><div class=\"line\"></div><div class=\"line\">$ sudo apt-get install gcc </div><div class=\"line\"></div><div class=\"line\">$ sudo apt-get install g++</div></pre></td></tr></table></figure>\n<p>确保都安装了之后，从nodeJS官网下载最新源代码包：node-v4.4.7.tar.gz</p>\n<p>解压：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ tar -zxf node-v4<span class=\"number\">.4</span><span class=\"number\">.7</span>.tar.gz </div><div class=\"line\"></div><div class=\"line\">$ cd node-v4<span class=\"number\">.4</span><span class=\"number\">.7</span></div></pre></td></tr></table></figure>\n<p>默认安装： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ ./configure </div><div class=\"line\"></div><div class=\"line\">$ make </div><div class=\"line\"></div><div class=\"line\">$ sudo make install</div></pre></td></tr></table></figure>\n<p>选择目录方式安装： </p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ ./configure –prefix=/usr/node </div><div class=\"line\"></div><div class=\"line\">$ make -j 5 #5=CPU核数+1 </div><div class=\"line\"></div><div class=\"line\">$ sudo make install</div></pre></td></tr></table></figure>\n<blockquote>\n<p>当然，你也可以通过linux包管理器安装：<br><code>apt get install nodejs -g</code><br><code>apt get install npm -g</code><br>但是个人不建议这么做，因为有时候会莫名其妙的出问题，还是直接编译源码比较实在（编译过程需要一些时间）。</p>\n</blockquote>\n<p>接下来通过查看版本确认已经安装成功：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ node -v</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ npm -v</div></pre></td></tr></table></figure>\n<h2 id=\"第二步，安装express\"><a href=\"#第二步，安装express\" class=\"headerlink\" title=\"第二步，安装express\"></a>第二步，安装express</h2><p><strong>Windows</strong>：打开Node.js command prompt，输入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">npm install express -g</div></pre></td></tr></table></figure>\n<blockquote>\n<p>-g是全局安装，在任何地方打开命令行都可以使用相应命令</p>\n</blockquote>\n<p><strong>Ubuntu</strong> 打开终端，输入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ sudo npm install express -g</div></pre></td></tr></table></figure>\n<blockquote>\n<p>请务必使用管理员权限安装，否则会安装失败</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ sudo npm install -g express-generator@<span class=\"number\">4</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>express4.0之后把创建一个APP的功能分离出来为express-generator，所以必须得安装它，否则没法正常使用express</p>\n</blockquote>\n<p>通过输入‘express -v’确认安装成功。（有些情况无法查看版本，但是可以正常使用）</p>\n<h2 id=\"使用express建一个demo\"><a href=\"#使用express建一个demo\" class=\"headerlink\" title=\"使用express建一个demo\"></a>使用express建一个demo</h2><ol>\n<li>打开一个用来放源码的目录，输入<code>$ express nodetest -e</code>  </li>\n</ol>\n<blockquote>\n<p>新建一个名为nodetest的项目，使用ejs作为模板。 ejs （Embedded JavaScript） 是一个标签替换引擎，其语法与 ASP、PHP 相似，易于学习，目前被广泛应用。Express 默认提供的引擎是 jade，它颠覆了传统的模板引擎，制定了一套完整的语法用来生成 HTML 的每个标签结构，功能强大但不易学习。Express 在初始化一个项目的时候需要指定模板引擎，默认支持Jade和ejs。</p>\n</blockquote>\n<ol>\n<li><code>$ cd nodetest &amp;&amp; npm install</code></li>\n</ol>\n<blockquote>\n<p>进去项目文件夹，并安装所需要的依赖。无参数的 npm install 的功能就是 检查当前目录下的 package.json，并自动安装所有指定的依赖。 </p>\n</blockquote>\n<ol>\n<li><code>$ npm start</code></li>\n</ol>\n<blockquote>\n<p>启动项目。接下来，打开浏览器，输入地址 <a href=\"http://localhost:3000，你就可以看到一个简单的\">http://localhost:3000，你就可以看到一个简单的</a> Welcome to Express 页面了。</p>\n<p>express以前的版本，启动项目的命令是<br><code>\\$ node app.js</code><br>但是，使用最新版的这样是无法启动的，正确的启动命令是<br><code>$ npm start</code></p>\n</blockquote>\n<p>市面上讲nodejs的书籍并不多，而且node的版本更新太快，好多书上的例子用最新版的node已经无法运行了，所以，不要觉得书上的都是正确的，遇到问题多google。</p>\n<blockquote>\n<p>附nodejs教程，中文文档等<br><a href=\"http://download.csdn.net/detail/qq_31655965/9603069\">http://download.csdn.net/detail/qq_31655965/9603069</a><br><a href=\"http://download.csdn.net/detail/qq_31655965/9603064\">http://download.csdn.net/detail/qq_31655965/9603064</a></p>\n</blockquote>\n"},{"title":"Adding Instance Properties","type":"cookbook","order":1.1,"_content":"\n## Simple Example\n\nThere may be data/utilities you'd like to use in many components, but you don't want to [pollute the global scope](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md). In these cases, you can make them available to each Vue instance by defining them on the prototype:\n\n``` js\nVue.prototype.$appName = 'My App'\n```\n\nNow `$appName` is available on all Vue instances, even before creation. If we run:\n\n``` js\nnew Vue({\n  beforeCreate: function () {\n    console.log(this.$appName)\n  }\n})\n```\n\nThen `\"My App\"` will be logged to the console. It's that simple!\n\n## The Importance of Scoping Instance Properties\n\nYou may be wondering:\n\n> \"Why does `appName` start with `$`? Is that important? What does it do?\n\nNo magic is happening here. `$` is simply a convention Vue uses for properties that are available to all instances. This avoids conflicts with any defined data, computed properties, or methods.\n\n> \"Conflicts? What do you mean?\"\n\nAnother great question! If you just set:\n\n``` js\nVue.prototype.appName = 'My App'\n```\n\nThen what would you expect to be logged below?\n\n``` js\nnew Vue({\n  data: {\n    // Uh oh - appName is *also* the name of the\n    // instance property we just defined!\n    appName: 'The name of some other app'\n  },\n  beforeCreate: function () {\n    console.log(this.appName)\n  },\n  created: function () {\n    console.log(this.appName)\n  }\n})\n```\n\nIt would be `\"The name of some other app\"`, then `\"My App\"`, because `this.appName` is overwritten ([sort of](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md)) by `data` when the instance is created. We scope instance properties with `$` to avoid this. You can even use your own convention if you'd like, such as `$_appName` or `ΩappName`, to prevent even conflicts with plugins or future features.\n\n## Real-World Example: Replacing Vue Resource with Axios\n\nLet's say you're replacing the [now-retired Vue Resource](https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4). You really enjoyed accessing request methods through `this.$http` and you want to do the same thing with Axios instead.\n\nAll you have to do is include axios in your project:\n\n``` html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js\"></script>\n\n<div id=\"app\">\n  <ul>\n    <li v-for=\"user in users\">{{ user.name }}</li>\n  </ul>\n</div>\n```\n\nAlias `axios` to `Vue.prototype.$http`:\n\n``` js\nVue.prototype.$http = axios\n```\n\nThen you'll be able to use methods like `this.$http.get` in any Vue instance:\n\n``` js\nnew Vue({\n  el: '#app',\n  data: {\n    users: []\n  },\n  created () {\n    var vm = this\n    this.$http.get('https://jsonplaceholder.typicode.com/users')\n      .then(function (response) {\n        vm.users = response.data\n      })\n  }\n})\n```\n\n## The Context of Prototype Methods\n\nIn case you're not aware, methods added to a prototype in JavaScript gain the context of the instance. That means they can use `this` to access data, computed properties, methods, or anything else defined on the instance.\n\nLet's take advantage of this in a `$reverseText` method:\n\n``` js\nVue.prototype.$reverseText = function (propertyName) {\n  this[propertyName] = this[propertyName].split('').reverse().join('')\n}\n\nnew Vue({\n  data: {\n    message: 'Hello '\n  },\n  created: function () {\n    console.log(this.message)    // => \"Hello\"\n    this.$reverseText('message')\n    console.log(this.message)    // => \"olleH\"\n  }\n})\n```\n\nNote that the context binding will __not__ work if you use an ES6/2015 arrow function, as they implicitly bind to their parent scope. That means the arrow function version:\n\n``` js\nVue.prototype.$reverseText = propertyName => {\n  this[propertyName] = this[propertyName].split('').reverse().join('')\n}\n```\n\nWould throw an error:\n\n``` log\nUncaught TypeError: Cannot read property 'split' of undefined\n```\n\n## When To Avoid This Pattern\n\nAs long as you're vigilant in scoping prototype properties, using this pattern is quite safe - as in, unlikely to produce bugs.\n\nHowever, it can sometimes cause confusion with other developers. They might see `this.$http`, for example, and think, \"Oh, I didn't know about this Vue feature!\" Then they move to a different project and are confused when `this.$http` is undefined. Or, maybe they want to Google how to do something, but can't find results because they don't realize they're actually using Axios under an alias.\n\n__The convenience comes at the cost of explicitness.__ When just looking at a component, it's impossible to tell where `$http` came from. Vue itself? A plugin? A coworker?\n\nSo what are the alternatives?\n\n## Alternative Patterns\n\n### When Not Using a Module System\n\nIn applications with __no__ module system (e.g. via Webpack or Browserify), there's a pattern that's often used with _any_ JavaScript-enhanced frontend: a global `App` object.\n\nIf what you want to add has nothing to do with Vue specifically, this may be a good alternative to reach for. Here's an example:\n\n``` js\nvar App = Object.freeze({\n  name: 'My App',\n  description: '2.1.4',\n  helpers: {\n    // This is a purely functional version of\n    // the $reverseText method we saw earlier\n    reverseText: function (text) {\n      return text.split('').reverse().join('')\n    }\n  }\n})\n```\n\n<p class=\"tip\">If you raised an eyebrow at `Object.freeze`, what it does is prevent the object from being changed in the future. This essentially makes all its properties constants, protecting you from future state bugs.</p>\n\nNow the source of these shared properties is much more obvious: there's an `App` object defined somewhere in the app. To find it, developers need only run a project-wide search.\n\nAnother advantage is that `App` can now be used _anywhere_ in your code, whether it's Vue-related or not. That includes attaching values directly to instance options, rather than having to enter a function to access properties on `this`:\n\n``` js\nnew Vue({\n  data: {\n    appVersion: App.version\n  },\n  methods: {\n    reverseText: App.helpers.reverseText\n  }\n})\n```\n\n### When Using a Module System\n\nWhen you have access to a module system, you can easily organize shared code into modules, then `require`/`import` those modules wherever they're needed. This is the epitome of explicitness, because in each file you gain a list of dependencies. You know _exactly_ each one came from.\n\nWhile certainly more verbose, this approach is definitely the most maintainable, especially when working with other developers and/or building a large app.\n","source":"v2/cookbook/adding-instance-properties.md","raw":"---\ntitle: Adding Instance Properties\ntype: cookbook\norder: 1.1\n---\n\n## Simple Example\n\nThere may be data/utilities you'd like to use in many components, but you don't want to [pollute the global scope](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md). In these cases, you can make them available to each Vue instance by defining them on the prototype:\n\n``` js\nVue.prototype.$appName = 'My App'\n```\n\nNow `$appName` is available on all Vue instances, even before creation. If we run:\n\n``` js\nnew Vue({\n  beforeCreate: function () {\n    console.log(this.$appName)\n  }\n})\n```\n\nThen `\"My App\"` will be logged to the console. It's that simple!\n\n## The Importance of Scoping Instance Properties\n\nYou may be wondering:\n\n> \"Why does `appName` start with `$`? Is that important? What does it do?\n\nNo magic is happening here. `$` is simply a convention Vue uses for properties that are available to all instances. This avoids conflicts with any defined data, computed properties, or methods.\n\n> \"Conflicts? What do you mean?\"\n\nAnother great question! If you just set:\n\n``` js\nVue.prototype.appName = 'My App'\n```\n\nThen what would you expect to be logged below?\n\n``` js\nnew Vue({\n  data: {\n    // Uh oh - appName is *also* the name of the\n    // instance property we just defined!\n    appName: 'The name of some other app'\n  },\n  beforeCreate: function () {\n    console.log(this.appName)\n  },\n  created: function () {\n    console.log(this.appName)\n  }\n})\n```\n\nIt would be `\"The name of some other app\"`, then `\"My App\"`, because `this.appName` is overwritten ([sort of](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md)) by `data` when the instance is created. We scope instance properties with `$` to avoid this. You can even use your own convention if you'd like, such as `$_appName` or `ΩappName`, to prevent even conflicts with plugins or future features.\n\n## Real-World Example: Replacing Vue Resource with Axios\n\nLet's say you're replacing the [now-retired Vue Resource](https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4). You really enjoyed accessing request methods through `this.$http` and you want to do the same thing with Axios instead.\n\nAll you have to do is include axios in your project:\n\n``` html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js\"></script>\n\n<div id=\"app\">\n  <ul>\n    <li v-for=\"user in users\">{{ user.name }}</li>\n  </ul>\n</div>\n```\n\nAlias `axios` to `Vue.prototype.$http`:\n\n``` js\nVue.prototype.$http = axios\n```\n\nThen you'll be able to use methods like `this.$http.get` in any Vue instance:\n\n``` js\nnew Vue({\n  el: '#app',\n  data: {\n    users: []\n  },\n  created () {\n    var vm = this\n    this.$http.get('https://jsonplaceholder.typicode.com/users')\n      .then(function (response) {\n        vm.users = response.data\n      })\n  }\n})\n```\n\n## The Context of Prototype Methods\n\nIn case you're not aware, methods added to a prototype in JavaScript gain the context of the instance. That means they can use `this` to access data, computed properties, methods, or anything else defined on the instance.\n\nLet's take advantage of this in a `$reverseText` method:\n\n``` js\nVue.prototype.$reverseText = function (propertyName) {\n  this[propertyName] = this[propertyName].split('').reverse().join('')\n}\n\nnew Vue({\n  data: {\n    message: 'Hello '\n  },\n  created: function () {\n    console.log(this.message)    // => \"Hello\"\n    this.$reverseText('message')\n    console.log(this.message)    // => \"olleH\"\n  }\n})\n```\n\nNote that the context binding will __not__ work if you use an ES6/2015 arrow function, as they implicitly bind to their parent scope. That means the arrow function version:\n\n``` js\nVue.prototype.$reverseText = propertyName => {\n  this[propertyName] = this[propertyName].split('').reverse().join('')\n}\n```\n\nWould throw an error:\n\n``` log\nUncaught TypeError: Cannot read property 'split' of undefined\n```\n\n## When To Avoid This Pattern\n\nAs long as you're vigilant in scoping prototype properties, using this pattern is quite safe - as in, unlikely to produce bugs.\n\nHowever, it can sometimes cause confusion with other developers. They might see `this.$http`, for example, and think, \"Oh, I didn't know about this Vue feature!\" Then they move to a different project and are confused when `this.$http` is undefined. Or, maybe they want to Google how to do something, but can't find results because they don't realize they're actually using Axios under an alias.\n\n__The convenience comes at the cost of explicitness.__ When just looking at a component, it's impossible to tell where `$http` came from. Vue itself? A plugin? A coworker?\n\nSo what are the alternatives?\n\n## Alternative Patterns\n\n### When Not Using a Module System\n\nIn applications with __no__ module system (e.g. via Webpack or Browserify), there's a pattern that's often used with _any_ JavaScript-enhanced frontend: a global `App` object.\n\nIf what you want to add has nothing to do with Vue specifically, this may be a good alternative to reach for. Here's an example:\n\n``` js\nvar App = Object.freeze({\n  name: 'My App',\n  description: '2.1.4',\n  helpers: {\n    // This is a purely functional version of\n    // the $reverseText method we saw earlier\n    reverseText: function (text) {\n      return text.split('').reverse().join('')\n    }\n  }\n})\n```\n\n<p class=\"tip\">If you raised an eyebrow at `Object.freeze`, what it does is prevent the object from being changed in the future. This essentially makes all its properties constants, protecting you from future state bugs.</p>\n\nNow the source of these shared properties is much more obvious: there's an `App` object defined somewhere in the app. To find it, developers need only run a project-wide search.\n\nAnother advantage is that `App` can now be used _anywhere_ in your code, whether it's Vue-related or not. That includes attaching values directly to instance options, rather than having to enter a function to access properties on `this`:\n\n``` js\nnew Vue({\n  data: {\n    appVersion: App.version\n  },\n  methods: {\n    reverseText: App.helpers.reverseText\n  }\n})\n```\n\n### When Using a Module System\n\nWhen you have access to a module system, you can easily organize shared code into modules, then `require`/`import` those modules wherever they're needed. This is the epitome of explicitness, because in each file you gain a list of dependencies. You know _exactly_ each one came from.\n\nWhile certainly more verbose, this approach is definitely the most maintainable, especially when working with other developers and/or building a large app.\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/cookbook/adding-instance-properties.html","comments":1,"layout":"page","_id":"ciwnajuxy000qjl2dsmvzsnht","content":"<h2 id=\"Simple-Example\"><a href=\"#Simple-Example\" class=\"headerlink\" title=\"Simple Example\"></a>Simple Example</h2><p>There may be data/utilities you’d like to use in many components, but you don’t want to <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md\" target=\"_blank\" rel=\"external\">pollute the global scope</a>. In these cases, you can make them available to each Vue instance by defining them on the prototype:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$appName = <span class=\"string\">'My App'</span></div></pre></td></tr></table></figure>\n<p>Now <code>$appName</code> is available on all Vue instances, even before creation. If we run:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">beforeCreate</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$appName)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>Then <code>&quot;My App&quot;</code> will be logged to the console. It’s that simple!</p>\n<h2 id=\"The-Importance-of-Scoping-Instance-Properties\"><a href=\"#The-Importance-of-Scoping-Instance-Properties\" class=\"headerlink\" title=\"The Importance of Scoping Instance Properties\"></a>The Importance of Scoping Instance Properties</h2><p>You may be wondering:</p>\n<blockquote>\n<p>“Why does <code>appName</code> start with <code>$</code>? Is that important? What does it do?</p>\n</blockquote>\n<p>No magic is happening here. <code>$</code> is simply a convention Vue uses for properties that are available to all instances. This avoids conflicts with any defined data, computed properties, or methods.</p>\n<blockquote>\n<p>“Conflicts? What do you mean?”</p>\n</blockquote>\n<p>Another great question! If you just set:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.appName = <span class=\"string\">'My App'</span></div></pre></td></tr></table></figure>\n<p>Then what would you expect to be logged below?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// Uh oh - appName is *also* the name of the</span></div><div class=\"line\">    <span class=\"comment\">// instance property we just defined!</span></div><div class=\"line\">    appName: <span class=\"string\">'The name of some other app'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">beforeCreate</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.appName)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.appName)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>It would be <code>&quot;The name of some other app&quot;</code>, then <code>&quot;My App&quot;</code>, because <code>this.appName</code> is overwritten (<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md\" target=\"_blank\" rel=\"external\">sort of</a>) by <code>data</code> when the instance is created. We scope instance properties with <code>$</code> to avoid this. You can even use your own convention if you’d like, such as <code>$_appName</code> or <code>ΩappName</code>, to prevent even conflicts with plugins or future features.</p>\n<h2 id=\"Real-World-Example-Replacing-Vue-Resource-with-Axios\"><a href=\"#Real-World-Example-Replacing-Vue-Resource-with-Axios\" class=\"headerlink\" title=\"Real-World Example: Replacing Vue Resource with Axios\"></a>Real-World Example: Replacing Vue Resource with Axios</h2><p>Let’s say you’re replacing the <a href=\"https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4\" target=\"_blank\" rel=\"external\">now-retired Vue Resource</a>. You really enjoyed accessing request methods through <code>this.$http</code> and you want to do the same thing with Axios instead.</p>\n<p>All you have to do is include axios in your project:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"user in users\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Alias <code>axios</code> to <code>Vue.prototype.$http</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$http = axios</div></pre></td></tr></table></figure>\n<p>Then you’ll be able to use methods like <code>this.$http.get</code> in any Vue instance:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">users</span>: []</div><div class=\"line\">  &#125;,</div><div class=\"line\">  created () &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.$http.get(<span class=\"string\">'https://jsonplaceholder.typicode.com/users'</span>)</div><div class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">        vm.users = response.data</div><div class=\"line\">      &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"The-Context-of-Prototype-Methods\"><a href=\"#The-Context-of-Prototype-Methods\" class=\"headerlink\" title=\"The Context of Prototype Methods\"></a>The Context of Prototype Methods</h2><p>In case you’re not aware, methods added to a prototype in JavaScript gain the context of the instance. That means they can use <code>this</code> to access data, computed properties, methods, or anything else defined on the instance.</p>\n<p>Let’s take advantage of this in a <code>$reverseText</code> method:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$reverseText = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">propertyName</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>[propertyName] = <span class=\"keyword\">this</span>[propertyName].split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello '</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.message)    <span class=\"comment\">// =&gt; \"Hello\"</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.$reverseText(<span class=\"string\">'message'</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.message)    <span class=\"comment\">// =&gt; \"olleH\"</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>Note that the context binding will <strong>not</strong> work if you use an ES6/2015 arrow function, as they implicitly bind to their parent scope. That means the arrow function version:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$reverseText = <span class=\"function\"><span class=\"params\">propertyName</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>[propertyName] = <span class=\"keyword\">this</span>[propertyName].split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Would throw an error:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Uncaught TypeError: Cannot read property &apos;split&apos; of undefined</div></pre></td></tr></table></figure>\n<h2 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h2><p>As long as you’re vigilant in scoping prototype properties, using this pattern is quite safe - as in, unlikely to produce bugs.</p>\n<p>However, it can sometimes cause confusion with other developers. They might see <code>this.$http</code>, for example, and think, “Oh, I didn’t know about this Vue feature!” Then they move to a different project and are confused when <code>this.$http</code> is undefined. Or, maybe they want to Google how to do something, but can’t find results because they don’t realize they’re actually using Axios under an alias.</p>\n<p><strong>The convenience comes at the cost of explicitness.</strong> When just looking at a component, it’s impossible to tell where <code>$http</code> came from. Vue itself? A plugin? A coworker?</p>\n<p>So what are the alternatives?</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><h3 id=\"When-Not-Using-a-Module-System\"><a href=\"#When-Not-Using-a-Module-System\" class=\"headerlink\" title=\"When Not Using a Module System\"></a>When Not Using a Module System</h3><p>In applications with <strong>no</strong> module system (e.g. via Webpack or Browserify), there’s a pattern that’s often used with <em>any</em> JavaScript-enhanced frontend: a global <code>App</code> object.</p>\n<p>If what you want to add has nothing to do with Vue specifically, this may be a good alternative to reach for. Here’s an example:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> App = <span class=\"built_in\">Object</span>.freeze(&#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'My App'</span>,</div><div class=\"line\">  <span class=\"attr\">description</span>: <span class=\"string\">'2.1.4'</span>,</div><div class=\"line\">  <span class=\"attr\">helpers</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// This is a purely functional version of</span></div><div class=\"line\">    <span class=\"comment\">// the $reverseText method we saw earlier</span></div><div class=\"line\">    reverseText: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">text</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> text.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">If you raised an eyebrow at <code>Object.freeze</code>, what it does is prevent the object from being changed in the future. This essentially makes all its properties constants, protecting you from future state bugs.</p>\n\n<p>Now the source of these shared properties is much more obvious: there’s an <code>App</code> object defined somewhere in the app. To find it, developers need only run a project-wide search.</p>\n<p>Another advantage is that <code>App</code> can now be used <em>anywhere</em> in your code, whether it’s Vue-related or not. That includes attaching values directly to instance options, rather than having to enter a function to access properties on <code>this</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">appVersion</span>: App.version</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">reverseText</span>: App.helpers.reverseText</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"When-Using-a-Module-System\"><a href=\"#When-Using-a-Module-System\" class=\"headerlink\" title=\"When Using a Module System\"></a>When Using a Module System</h3><p>When you have access to a module system, you can easily organize shared code into modules, then <code>require</code>/<code>import</code> those modules wherever they’re needed. This is the epitome of explicitness, because in each file you gain a list of dependencies. You know <em>exactly</em> each one came from.</p>\n<p>While certainly more verbose, this approach is definitely the most maintainable, especially when working with other developers and/or building a large app.</p>\n","excerpt":"","more":"<h2 id=\"Simple-Example\"><a href=\"#Simple-Example\" class=\"headerlink\" title=\"Simple Example\"></a>Simple Example</h2><p>There may be data/utilities you’d like to use in many components, but you don’t want to <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md\">pollute the global scope</a>. In these cases, you can make them available to each Vue instance by defining them on the prototype:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$appName = <span class=\"string\">'My App'</span></div></pre></td></tr></table></figure>\n<p>Now <code>$appName</code> is available on all Vue instances, even before creation. If we run:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">beforeCreate</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$appName)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>Then <code>&quot;My App&quot;</code> will be logged to the console. It’s that simple!</p>\n<h2 id=\"The-Importance-of-Scoping-Instance-Properties\"><a href=\"#The-Importance-of-Scoping-Instance-Properties\" class=\"headerlink\" title=\"The Importance of Scoping Instance Properties\"></a>The Importance of Scoping Instance Properties</h2><p>You may be wondering:</p>\n<blockquote>\n<p>“Why does <code>appName</code> start with <code>$</code>? Is that important? What does it do?</p>\n</blockquote>\n<p>No magic is happening here. <code>$</code> is simply a convention Vue uses for properties that are available to all instances. This avoids conflicts with any defined data, computed properties, or methods.</p>\n<blockquote>\n<p>“Conflicts? What do you mean?”</p>\n</blockquote>\n<p>Another great question! If you just set:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.appName = <span class=\"string\">'My App'</span></div></pre></td></tr></table></figure>\n<p>Then what would you expect to be logged below?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// Uh oh - appName is *also* the name of the</span></div><div class=\"line\">    <span class=\"comment\">// instance property we just defined!</span></div><div class=\"line\">    appName: <span class=\"string\">'The name of some other app'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">beforeCreate</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.appName)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.appName)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>It would be <code>&quot;The name of some other app&quot;</code>, then <code>&quot;My App&quot;</code>, because <code>this.appName</code> is overwritten (<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md\">sort of</a>) by <code>data</code> when the instance is created. We scope instance properties with <code>$</code> to avoid this. You can even use your own convention if you’d like, such as <code>$_appName</code> or <code>ΩappName</code>, to prevent even conflicts with plugins or future features.</p>\n<h2 id=\"Real-World-Example-Replacing-Vue-Resource-with-Axios\"><a href=\"#Real-World-Example-Replacing-Vue-Resource-with-Axios\" class=\"headerlink\" title=\"Real-World Example: Replacing Vue Resource with Axios\"></a>Real-World Example: Replacing Vue Resource with Axios</h2><p>Let’s say you’re replacing the <a href=\"https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4\">now-retired Vue Resource</a>. You really enjoyed accessing request methods through <code>this.$http</code> and you want to do the same thing with Axios instead.</p>\n<p>All you have to do is include axios in your project:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"user in users\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Alias <code>axios</code> to <code>Vue.prototype.$http</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$http = axios</div></pre></td></tr></table></figure>\n<p>Then you’ll be able to use methods like <code>this.$http.get</code> in any Vue instance:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">users</span>: []</div><div class=\"line\">  &#125;,</div><div class=\"line\">  created () &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.$http.get(<span class=\"string\">'https://jsonplaceholder.typicode.com/users'</span>)</div><div class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">        vm.users = response.data</div><div class=\"line\">      &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"The-Context-of-Prototype-Methods\"><a href=\"#The-Context-of-Prototype-Methods\" class=\"headerlink\" title=\"The Context of Prototype Methods\"></a>The Context of Prototype Methods</h2><p>In case you’re not aware, methods added to a prototype in JavaScript gain the context of the instance. That means they can use <code>this</code> to access data, computed properties, methods, or anything else defined on the instance.</p>\n<p>Let’s take advantage of this in a <code>$reverseText</code> method:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$reverseText = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">propertyName</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>[propertyName] = <span class=\"keyword\">this</span>[propertyName].split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello '</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.message)    <span class=\"comment\">// =&gt; \"Hello\"</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.$reverseText(<span class=\"string\">'message'</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.message)    <span class=\"comment\">// =&gt; \"olleH\"</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>Note that the context binding will <strong>not</strong> work if you use an ES6/2015 arrow function, as they implicitly bind to their parent scope. That means the arrow function version:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$reverseText = <span class=\"function\"><span class=\"params\">propertyName</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>[propertyName] = <span class=\"keyword\">this</span>[propertyName].split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Would throw an error:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Uncaught TypeError: Cannot read property &apos;split&apos; of undefined</div></pre></td></tr></table></figure>\n<h2 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h2><p>As long as you’re vigilant in scoping prototype properties, using this pattern is quite safe - as in, unlikely to produce bugs.</p>\n<p>However, it can sometimes cause confusion with other developers. They might see <code>this.$http</code>, for example, and think, “Oh, I didn’t know about this Vue feature!” Then they move to a different project and are confused when <code>this.$http</code> is undefined. Or, maybe they want to Google how to do something, but can’t find results because they don’t realize they’re actually using Axios under an alias.</p>\n<p><strong>The convenience comes at the cost of explicitness.</strong> When just looking at a component, it’s impossible to tell where <code>$http</code> came from. Vue itself? A plugin? A coworker?</p>\n<p>So what are the alternatives?</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><h3 id=\"When-Not-Using-a-Module-System\"><a href=\"#When-Not-Using-a-Module-System\" class=\"headerlink\" title=\"When Not Using a Module System\"></a>When Not Using a Module System</h3><p>In applications with <strong>no</strong> module system (e.g. via Webpack or Browserify), there’s a pattern that’s often used with <em>any</em> JavaScript-enhanced frontend: a global <code>App</code> object.</p>\n<p>If what you want to add has nothing to do with Vue specifically, this may be a good alternative to reach for. Here’s an example:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> App = <span class=\"built_in\">Object</span>.freeze(&#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'My App'</span>,</div><div class=\"line\">  <span class=\"attr\">description</span>: <span class=\"string\">'2.1.4'</span>,</div><div class=\"line\">  <span class=\"attr\">helpers</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// This is a purely functional version of</span></div><div class=\"line\">    <span class=\"comment\">// the $reverseText method we saw earlier</span></div><div class=\"line\">    reverseText: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">text</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> text.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">If you raised an eyebrow at <code>Object.freeze</code>, what it does is prevent the object from being changed in the future. This essentially makes all its properties constants, protecting you from future state bugs.</p>\n\n<p>Now the source of these shared properties is much more obvious: there’s an <code>App</code> object defined somewhere in the app. To find it, developers need only run a project-wide search.</p>\n<p>Another advantage is that <code>App</code> can now be used <em>anywhere</em> in your code, whether it’s Vue-related or not. That includes attaching values directly to instance options, rather than having to enter a function to access properties on <code>this</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">appVersion</span>: App.version</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">reverseText</span>: App.helpers.reverseText</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"When-Using-a-Module-System\"><a href=\"#When-Using-a-Module-System\" class=\"headerlink\" title=\"When Using a Module System\"></a>When Using a Module System</h3><p>When you have access to a module system, you can easily organize shared code into modules, then <code>require</code>/<code>import</code> those modules wherever they’re needed. This is the epitome of explicitness, because in each file you gain a list of dependencies. You know <em>exactly</em> each one came from.</p>\n<p>While certainly more verbose, this approach is definitely the most maintainable, especially when working with other developers and/or building a large app.</p>\n"},{"title":"Introduction","type":"cookbook","order":0,"_content":"\n## WORK IN PROGRESS\n\n<p class=\"tip\">This cookbook is still in its very early stages. At this point, we will not be linking to it from anywhere else. Pages may be removed or reorganized at any time. Even the goals and overall format are still in flux.</p>\n\n## The Cookbook vs the Guide\n\nHow is the cookbook different from the guide? Why is this necessary?\n\n- __Greater Focus__: In the guide, we're essentially telling a story. Each section builds on and assumes knowledge from each previous section. In the cookbook, each recipe can and should stand on its own. This means recipes can focus on one specific aspect of Vue, rather than having to give a general overview.\n\n- __Greater Depth__: To avoid making the guide too long, we try to include only the simplest possible examples to help you understand each feature. Then we move on. In the cookbook, we can include more complex examples, combining features in interesting ways. Each recipe can also be as long and detailed as it needs to be, in order to fully explore its niche.\n\n- __Teaching JavaScript__: In the guide, we assume at least intermediate familiarity with ES5 JavaScript. For example, we won't explain how `Array.prototype.filter` works in a computed property that filters a list. In the cookbook however, essential JavaScript features (including ES6/2015+) can be explored and explained in the context of how they help us build better Vue applications.\n\n- __Exploring the Ecosystem__: For advanced features, we assume some ecosystem knowledge. For example, if you want to use single-file components in Webpack, we don't explain how to configure the non-Vue parts of the Webpack config. In the cookbook, we have the space to explore these ecosystem libraries in more depth - at least to the extent that is universally useful for Vue developers.\n\n## Guidelines for Recipes\n\nRecipes should generally:\n\n> 1. Solve a specific, common problem\n\n> 2. Start with the simplest possible example\n\n> 3. Introduce complexities one at a time\n\n> 4. Link to other docs, rather than re-explaining concepts\n\n> 5. Describe the problem, rather than assuming familiarity\n\n> 6. Explain the process, rather than just the end result\n\n> 7. Explain the pros and cons of your strategy, including when it is and isn't appropriate\n\n> 8. Mention alternative solutions, if relevant, but leave in-depth explorations to a separate recipe\n\n","source":"v2/cookbook/index.md","raw":"---\ntitle: Introduction\ntype: cookbook\norder: 0\n---\n\n## WORK IN PROGRESS\n\n<p class=\"tip\">This cookbook is still in its very early stages. At this point, we will not be linking to it from anywhere else. Pages may be removed or reorganized at any time. Even the goals and overall format are still in flux.</p>\n\n## The Cookbook vs the Guide\n\nHow is the cookbook different from the guide? Why is this necessary?\n\n- __Greater Focus__: In the guide, we're essentially telling a story. Each section builds on and assumes knowledge from each previous section. In the cookbook, each recipe can and should stand on its own. This means recipes can focus on one specific aspect of Vue, rather than having to give a general overview.\n\n- __Greater Depth__: To avoid making the guide too long, we try to include only the simplest possible examples to help you understand each feature. Then we move on. In the cookbook, we can include more complex examples, combining features in interesting ways. Each recipe can also be as long and detailed as it needs to be, in order to fully explore its niche.\n\n- __Teaching JavaScript__: In the guide, we assume at least intermediate familiarity with ES5 JavaScript. For example, we won't explain how `Array.prototype.filter` works in a computed property that filters a list. In the cookbook however, essential JavaScript features (including ES6/2015+) can be explored and explained in the context of how they help us build better Vue applications.\n\n- __Exploring the Ecosystem__: For advanced features, we assume some ecosystem knowledge. For example, if you want to use single-file components in Webpack, we don't explain how to configure the non-Vue parts of the Webpack config. In the cookbook, we have the space to explore these ecosystem libraries in more depth - at least to the extent that is universally useful for Vue developers.\n\n## Guidelines for Recipes\n\nRecipes should generally:\n\n> 1. Solve a specific, common problem\n\n> 2. Start with the simplest possible example\n\n> 3. Introduce complexities one at a time\n\n> 4. Link to other docs, rather than re-explaining concepts\n\n> 5. Describe the problem, rather than assuming familiarity\n\n> 6. Explain the process, rather than just the end result\n\n> 7. Explain the pros and cons of your strategy, including when it is and isn't appropriate\n\n> 8. Mention alternative solutions, if relevant, but leave in-depth explorations to a separate recipe\n\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/cookbook/index.html","comments":1,"layout":"page","_id":"ciwnajuxz000rjl2dbwwjxklz","content":"<h2 id=\"WORK-IN-PROGRESS\"><a href=\"#WORK-IN-PROGRESS\" class=\"headerlink\" title=\"WORK IN PROGRESS\"></a>WORK IN PROGRESS</h2><p class=\"tip\">This cookbook is still in its very early stages. At this point, we will not be linking to it from anywhere else. Pages may be removed or reorganized at any time. Even the goals and overall format are still in flux.</p>\n\n<h2 id=\"The-Cookbook-vs-the-Guide\"><a href=\"#The-Cookbook-vs-the-Guide\" class=\"headerlink\" title=\"The Cookbook vs the Guide\"></a>The Cookbook vs the Guide</h2><p>How is the cookbook different from the guide? Why is this necessary?</p>\n<ul>\n<li><p><strong>Greater Focus</strong>: In the guide, we’re essentially telling a story. Each section builds on and assumes knowledge from each previous section. In the cookbook, each recipe can and should stand on its own. This means recipes can focus on one specific aspect of Vue, rather than having to give a general overview.</p>\n</li>\n<li><p><strong>Greater Depth</strong>: To avoid making the guide too long, we try to include only the simplest possible examples to help you understand each feature. Then we move on. In the cookbook, we can include more complex examples, combining features in interesting ways. Each recipe can also be as long and detailed as it needs to be, in order to fully explore its niche.</p>\n</li>\n<li><p><strong>Teaching JavaScript</strong>: In the guide, we assume at least intermediate familiarity with ES5 JavaScript. For example, we won’t explain how <code>Array.prototype.filter</code> works in a computed property that filters a list. In the cookbook however, essential JavaScript features (including ES6/2015+) can be explored and explained in the context of how they help us build better Vue applications.</p>\n</li>\n<li><p><strong>Exploring the Ecosystem</strong>: For advanced features, we assume some ecosystem knowledge. For example, if you want to use single-file components in Webpack, we don’t explain how to configure the non-Vue parts of the Webpack config. In the cookbook, we have the space to explore these ecosystem libraries in more depth - at least to the extent that is universally useful for Vue developers.</p>\n</li>\n</ul>\n<h2 id=\"Guidelines-for-Recipes\"><a href=\"#Guidelines-for-Recipes\" class=\"headerlink\" title=\"Guidelines for Recipes\"></a>Guidelines for Recipes</h2><p>Recipes should generally:</p>\n<blockquote>\n<ol>\n<li><p>Solve a specific, common problem</p>\n</li>\n<li><p>Start with the simplest possible example</p>\n</li>\n<li><p>Introduce complexities one at a time</p>\n</li>\n<li><p>Link to other docs, rather than re-explaining concepts</p>\n</li>\n<li><p>Describe the problem, rather than assuming familiarity</p>\n</li>\n<li><p>Explain the process, rather than just the end result</p>\n</li>\n<li><p>Explain the pros and cons of your strategy, including when it is and isn’t appropriate</p>\n</li>\n<li><p>Mention alternative solutions, if relevant, but leave in-depth explorations to a separate recipe</p>\n</li>\n</ol>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"WORK-IN-PROGRESS\"><a href=\"#WORK-IN-PROGRESS\" class=\"headerlink\" title=\"WORK IN PROGRESS\"></a>WORK IN PROGRESS</h2><p class=\"tip\">This cookbook is still in its very early stages. At this point, we will not be linking to it from anywhere else. Pages may be removed or reorganized at any time. Even the goals and overall format are still in flux.</p>\n\n<h2 id=\"The-Cookbook-vs-the-Guide\"><a href=\"#The-Cookbook-vs-the-Guide\" class=\"headerlink\" title=\"The Cookbook vs the Guide\"></a>The Cookbook vs the Guide</h2><p>How is the cookbook different from the guide? Why is this necessary?</p>\n<ul>\n<li><p><strong>Greater Focus</strong>: In the guide, we’re essentially telling a story. Each section builds on and assumes knowledge from each previous section. In the cookbook, each recipe can and should stand on its own. This means recipes can focus on one specific aspect of Vue, rather than having to give a general overview.</p>\n</li>\n<li><p><strong>Greater Depth</strong>: To avoid making the guide too long, we try to include only the simplest possible examples to help you understand each feature. Then we move on. In the cookbook, we can include more complex examples, combining features in interesting ways. Each recipe can also be as long and detailed as it needs to be, in order to fully explore its niche.</p>\n</li>\n<li><p><strong>Teaching JavaScript</strong>: In the guide, we assume at least intermediate familiarity with ES5 JavaScript. For example, we won’t explain how <code>Array.prototype.filter</code> works in a computed property that filters a list. In the cookbook however, essential JavaScript features (including ES6/2015+) can be explored and explained in the context of how they help us build better Vue applications.</p>\n</li>\n<li><p><strong>Exploring the Ecosystem</strong>: For advanced features, we assume some ecosystem knowledge. For example, if you want to use single-file components in Webpack, we don’t explain how to configure the non-Vue parts of the Webpack config. In the cookbook, we have the space to explore these ecosystem libraries in more depth - at least to the extent that is universally useful for Vue developers.</p>\n</li>\n</ul>\n<h2 id=\"Guidelines-for-Recipes\"><a href=\"#Guidelines-for-Recipes\" class=\"headerlink\" title=\"Guidelines for Recipes\"></a>Guidelines for Recipes</h2><p>Recipes should generally:</p>\n<blockquote>\n<ol>\n<li><p>Solve a specific, common problem</p>\n</li>\n<li><p>Start with the simplest possible example</p>\n</li>\n<li><p>Introduce complexities one at a time</p>\n</li>\n<li><p>Link to other docs, rather than re-explaining concepts</p>\n</li>\n<li><p>Describe the problem, rather than assuming familiarity</p>\n</li>\n<li><p>Explain the process, rather than just the end result</p>\n</li>\n<li><p>Explain the pros and cons of your strategy, including when it is and isn’t appropriate</p>\n</li>\n<li><p>Mention alternative solutions, if relevant, but leave in-depth explorations to a separate recipe</p>\n</li>\n</ol>\n</blockquote>\n"},{"title":"GitHub 提交","type":"examples","order":1,"_content":"\n> 这个例子从 Github 的 API 中获取了最新的 Vue.js 提交数据，并且以列表形式将它们展示了出来。你可以轻松地切换 master 和 dev 分支。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/c5g8xnar/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","source":"v2/examples/commits.md","raw":"---\ntitle: GitHub 提交\ntype: examples\norder: 1\n---\n\n> 这个例子从 Github 的 API 中获取了最新的 Vue.js 提交数据，并且以列表形式将它们展示了出来。你可以轻松地切换 master 和 dev 分支。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/c5g8xnar/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/commits.html","comments":1,"layout":"page","_id":"ciwnajuxz000sjl2doawt3rmb","content":"<blockquote>\n<p>这个例子从 Github 的 API 中获取了最新的 Vue.js 提交数据，并且以列表形式将它们展示了出来。你可以轻松地切换 master 和 dev 分支。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/c5g8xnar/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","excerpt":"","more":"<blockquote>\n<p>这个例子从 Github 的 API 中获取了最新的 Vue.js 提交数据，并且以列表形式将它们展示了出来。你可以轻松地切换 master 和 dev 分支。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/c5g8xnar/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n"},{"type":"api","_content":"\n## 全局配置\n\n`Vue.config`  是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：\n\n### silent\n\n- **类型：** `boolean`\n\n- **默认值：** `false`\n\n- **用法：**\n\n  ``` js\n  Vue.config.silent = true\n  ```\n\n  取消 Vue 所有的日志与警告。\n\n### optionMergeStrategies\n\n- **类型：** `{ [key: string]: Function }`\n\n- **默认值：** `{}`\n\n- **用法：**\n\n  ``` js\n  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {\n    return child + 1\n  }\n\n  const Profile = Vue.extend({\n    _my_option: 1\n  })\n\n  // Profile.options._my_option = 2\n  ```\n\n  自定义合并策略的选项。\n\n  合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入。\n\n- **参考** [自定义选项的混合策略](../guide/mixins.html#Custom-Option-Merge-Strategies)\n\n### devtools\n\n- **类型：** `boolean`\n\n- **默认值：** `true` (生产版为 `false`)\n\n- **用法：**\n\n  ``` js\n  // 务必在加载 Vue 之后，立即同步设置以下内容\n  Vue.config.devtools = true\n  ```\n\n  配置是否允许 [vue-devtools](https://github.com/vuejs/vue-devtools) 检查代码。开发版本默认为 `true`，生产版本默认为 `false`。生产版本设为 `true` 可以启用检查。\n\n### errorHandler\n\n- **类型：** `Function`\n\n- **默认值：** 默认抛出错误\n\n- **用法：**\n\n  ``` js\n  Vue.config.errorHandler = function (err, vm) {\n    // handle error\n  }\n  ```\n\n  指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。\n\n  > [Sentry](https://sentry.io), an error tracking service, provides [official integration](https://sentry.io/for/vue/) using this option.\n\n### ignoredElements\n\n- **类型:** `Array<string>`\n\n- **默认值:** `[]`\n\n- **用法:**\n\n  ``` js\n  Vue.config.ignoredElements = [\n    'my-custom-web-component', 'another-web-component'\n  ]\n  ```\n\n  须使 Vue 忽略在 Vue 之外的自定义元素 (e.g., 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 `Unknown custom element` 的警告。\n\n### keyCodes\n\n- **类型：** `{ [key: string]: number | Array<number> }`\n\n- **默认值：** `{}`\n\n- **用法：**\n\n  ``` js\n  Vue.config.keyCodes = {\n    v: 86,\n    f1: 112,\n    mediaPlayPause: 179,\n    up: [38, 87]\n  }\n  ```\n\n  给 v-on 自定义键位别名。\n\n## 全局 API\n\n<h3 id=\"Vue-extend\">Vue.extend( options )</h3>\n\n- **参数：**\n  - `{Object} options`\n\n- **用法：**\n\n  使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。\n\n  `data` 选项是特例，需要注意 - 在 `Vue.extend()` 中它必须是函数\n\n  ``` html\n  <div id=\"mount-point\"></div>\n  ```\n\n  ``` js\n  // 创建构造器\n  var Profile = Vue.extend({\n    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',\n    data: function () {\n      return {\n        firstName: 'Walter',\n        lastName: 'White',\n        alias: 'Heisenberg'\n      }\n    }\n  })\n  // 创建 Profile 实例，并挂载到一个元素上。\n  new Profile().$mount('#mount-point')\n  ```\n\n  结果如下：\n\n  ``` html\n  <p>Walter White aka Heisenberg</p>\n  ```\n\n- **参考：** [组件](../guide/components.html)\n\n<h3 id=\"Vue-nextTick\">Vue.nextTick( [callback, context] )</h3>\n\n- **参数：**\n  - `{Function} [callback]`\n  - `{Object} [context]`\n\n- **用法：**\n\n  在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n\n  ``` js\n  // 修改数据\n  vm.msg = 'Hello'\n  // DOM 还没有更新\n  Vue.nextTick(function () {\n    // DOM 更新了\n  })\n  ```\n\n  > 2.1.0新增：如果没有提供回调且支持 promise 的环境中返回 promise。\n\n- **参考：** [异步更新队列](../guide/reactivity.html#Async-Update-Queue)\n\n<h3 id=\"Vue-set\">Vue.set( object, key, value )</h3>\n\n- **参数：**\n  - `{Object} object`\n  - `{string} key`\n  - `{any} value`\n\n- **返回值：** 设置的值.\n\n- **用法：**\n\n  设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。\n\n  **注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象**\n\n- **参考：** [深入响应式原理](../guide/reactivity.html)\n\n<h3 id=\"Vue-delete\">Vue.delete( object, key )</h3>\n\n- **参数：**\n  - `{Object} object`\n  - `{string} key`\n\n- **用法：**\n\n  删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。\n\n  **注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象**\n\n- **参考：** [深入响应式原理](../guide/reactivity.html)\n\n<h3 id=\"Vue-directive\">Vue.directive( id, [definition] )</h3>\n\n- **参数：**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **用法：**\n\n  注册或获取全局指令。\n\n  ``` js\n  // 注册\n  Vue.directive('my-directive', {\n    bind: function () {},\n    inserted: function () {},\n    update: function () {},\n    componentUpdated: function () {},\n    unbind: function () {}\n  })\n\n  // 注册（传入一个简单的指令函数）\n  Vue.directive('my-directive', function () {\n    // 这里将会被 `bind` 和 `update` 调用\n  })\n\n  // getter，返回已注册的指令\n  var myDirective = Vue.directive('my-directive')\n  ```\n\n- **参考：** [自定义指令](../guide/custom-directive.html)\n\n<h3 id=\"Vue-filter\">Vue.filter( id, [definition] )</h3>\n\n- **参数：**\n  - `{string} id`\n  - `{Function} [definition]`\n\n- **用法：**\n\n  注册或获取全局过滤器。\n\n  ``` js\n  // 注册\n  Vue.filter('my-filter', function (value) {\n    // 返回处理后的值\n  })\n\n  // getter，返回已注册的过滤器\n  var myFilter = Vue.filter('my-filter')\n  ```\n\n<h3 id=\"Vue-component\">Vue.component( id, [definition] )</h3>\n\n- **参数：**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **用法：**\n\n  注册或获取全局组件。注册还会自动使用给定的`id`设置组件的名称\n\n  ``` js\n  // 注册组件，传入一个扩展过的构造器\n  Vue.component('my-component', Vue.extend({ /* ... */ }))\n\n  // 注册组件，传入一个选项对象（自动调用 Vue.extend）\n  Vue.component('my-component', { /* ... */ })\n\n  // 获取注册的组件（始终返回构造器）\n  var MyComponent = Vue.component('my-component')\n  ```\n\n- **参考：** [组件](../guide/components.html)\n\n<h3 id=\"Vue-use\">Vue.use( plugin )</h3>\n\n- **参数：**\n  - `{Object | Function} plugin`\n\n- **用法：**\n\n  安装 Vue.js 插件。如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为 install 方法。install 方法将被作为 Vue 的参数调用。\n\n  当 install 方法被同一个插件多次调用，插件将只会被安装一次。\n\n- **参考：** [插件](../guide/plugins.html)\n\n<h3 id=\"Vue-mixin\">Vue.mixin( mixin )</h3>\n\n- **参数：**\n  - `{Object} mixin`\n\n- **用法：**\n\n  全局注册一个混合，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混合，向组件注入自定义的行为。**不推荐在应用代码中使用**。\n\n- **参考：** [全局混合](../guide/mixins.html#Global-Mixin)\n\n<h3 id=\"Vue-compile\">Vue.compile( template )</h3>\n\n- **参数：**\n  - `{string} template`\n\n- **用法：**\n\n  在render函数中编译模板字符串。**只在独立构建时有效**\n\n  ``` js\n  var res = Vue.compile('<div><span>{{ msg }}</span></div>')\n\n  new Vue({\n    data: {\n      msg: 'hello'\n    },\n    render: res.render,\n    staticRenderFns: res.staticRenderFns\n  })\n  ```\n\n- **参考：** [Render 函数](../guide/render-function.html)\n\n## 选项 / 数据\n\n### data\n\n\n- **类型：** `Object | Function`\n\n- **限制:** 组件的定义只接受 `function`。\n\n- **详细:**\n\n  Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。**对象必须是纯粹的对象(含有零个或多个的key/value对)**：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。\n\n  一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。\n\n  实例创建之后，可以通过 `vm.$data` 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 `vm.a` 等价于访问 `vm.$data.a`。\n\n  以 `_` 或 `$` 开头的属性 **不会** 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、 API 方法冲突。你可以使用例如 `vm.$data._property` 的方式访问这些属性。\n\n  当一个**组件**被定义， `data` 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 `data` 仍然是一个纯粹的对象，则所有的实例将**共享引用**同一个数据对象！通过提供 `data` 函数，每次创建一个新实例后，我们能够调用 `data` 函数，从而返回初始数据的一个全新副本数据对象。\n\n 如果需要，可以通过将 `vm.$data` 传入 `JSON.parse(JSON.stringify(...))` 得到深拷贝的原始数据对象。\n\n- **示例:**\n\n  ``` js\n  var data = { a: 1 }\n\n  // 直接创建一个实例\n  var vm = new Vue({\n    data: data\n  })\n  vm.a // -> 1\n  vm.$data === data // -> true\n\n  // Vue.extend() 中 data 必须是函数\n  var Component = Vue.extend({\n    data: function () {\n      return { a: 1 }\n    }\n  })\n  ```\n\n  <p class=\"tip\">注意，__不应该对 `data` 属性使用箭头函数__ (例如`data: () => { return { a: this.myProp }}`)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，`this.myProp` 将是 undefined。</p>\n\n- **参考:** [深入响应式原理](../guide/reactivity.html)\n\n### props\n\n- **类型:** `Array<string> | Object`\n\n- **详细:**\n\n  props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。\n\n- **示例:**\n\n  ``` js\n  // 简单语法\n  Vue.component('props-demo-simple', {\n    props: ['size', 'myMessage']\n  })\n\n  // 对象语法，提供校验\n  Vue.component('props-demo-advanced', {\n    props: {\n      // 只检测类型\n      height: Number,\n      // 检测类型 + 其他验证\n      age: {\n        type: Number,\n        default: 0,\n        required: true,\n        validator: function (value) {\n          return value >= 0\n        }\n      }\n    }\n  })\n  ```\n\n- **参考:** [Props](../guide/components.html#Props)\n\n### propsData\n\n- **类型:** `{ [key: string]: any }`\n\n- **限制:** 只用于 `new` 创建的实例中。\n\n- **详细:**\n\n  创建实例时传递 props。主要作用是方便测试。\n\n- **示例:**\n\n  ``` js\n  var Comp = Vue.extend({\n    props: ['msg'],\n    template: '<div>{{ msg }}</div>'\n  })\n\n  var vm = new Comp({\n    propsData: {\n      msg: 'hello'\n    }\n  })\n  ```\n- **参考:** [Props](../guide/components.html#Props)\n\n### computed\n\n- **类型:** `{ [key: string]: Function | { get: Function, set: Function } }`\n\n- **详细:**\n\n  计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。\n\n  <p class=\"tip\">注意，__不应该使用箭头函数来定义计算属性函数__ (例如 `aDouble: () => this.a * 2`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.a` 将是 undefined。</p>\n\n  计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。\n\n- **示例:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    computed: {\n      // 仅读取，值只须为函数\n      aDouble: function () {\n        return this.a * 2\n      },\n      // 读取和设置\n      aPlus: {\n        get: function () {\n          return this.a + 1\n        },\n        set: function (v) {\n          this.a = v - 1\n        }\n      }\n    }\n  })\n  vm.aPlus   // -> 2\n  vm.aPlus = 3\n  vm.a       // -> 2\n  vm.aDouble // -> 4\n  ```\n\n- **另见:**\n  - [计算属性](../guide/computed.html)\n\n### methods\n\n- **类型:** `{ [key: string]: Function }`\n\n- **详细:**\n\n  methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 `this` 自动绑定为 Vue 实例。\n\n  <p class=\"tip\">注意，__不应该使用箭头函数来定义 method 函数__ (例如 `plus: () => this.a++`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.a` 将是 undefined。</p>\n\n- **示例:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    methods: {\n      plus: function () {\n        this.a++\n      }\n    }\n  })\n  vm.plus()\n  vm.a // 2\n  ```\n\n- **参考:** [方法与事件处理器](../guide/events.html)\n\n### watch\n\n- **类型:** `{ [key: string]: string | Function | Object }`\n\n- **详细:**\n\n  一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 `$watch()`，遍历 watch 对象的每一个属性。\n\n- **示例:**\n\n  ``` js\n  var vm = new Vue({\n    data: {\n      a: 1,\n      b: 2,\n      c: 3\n    },\n    watch: {\n      a: function (val, oldVal) {\n        console.log('new: %s, old: %s', val, oldVal)\n      },\n      // 方法名\n      b: 'someMethod',\n      // 深度 watcher\n      c: {\n        handler: function (val, oldVal) { /* ... */ },\n        deep: true\n      }\n    }\n  })\n  vm.a = 2 // -> new: 2, old: 1\n  ```\n\n  <p class=\"tip\">注意，__不应该使用箭头函数来定义 watcher 函数__ (例如 `searchQuery: newValue => this.updateAutocomplete(newValue)`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.updateAutocomplete` 将是 undefined。</p>\n\n- **参考：** [实例方法 - vm.$watch](#vm-watch)\n\n## 选项 / DOM\n\n### el\n\n- **类型：** `string | HTMLElement`\n\n- **限制：** 只在由 `new` 创建的实例中遵守。\n\n- **详细：**\n\n  提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。\n\n  在实例挂载之后， 元素可以用 `vm.$el` 访问。\n\n  如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 `vm.$mount()` 手动开启编译。\n\n  <p class=\"tip\"> 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载root实例到 `<html>` 或者 `<body>` 上。</p>\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### template\n\n- **类型：** `string`\n\n- **详细：**\n\n  一个字符串模板作为 Vue 实例的标识使用。模板将会 **替换** 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发 slot。\n\n  如果值以 `#` 开始，则它用作选项符，将使用匹配元素的 innerHTML 作为模板。常用的技巧是用 `<script type=\"x-template\">` 包含模板。\n\n  <p class=\"tip\">出于安全考虑，您应该只使用您信任的 Vue 模板。避免使用其他人生成的内容作为您的模板。</p>\n\n- **参考：**\n  - [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n  - [内容分发](../guide/components.html#Content-Distribution-with-Slots)\n\n### render\n\n  - **类型：** `Function`\n\n  - **详细：**\n\n    字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。render 函数接收一个 `createElement` 方法作为第一个参数用来创建 `VNode`。\n\n    如果组件是一个函数组件，Render 函数还会接收一个额外的 `context` 参数，为没有实例的函数组件提供上下文信息。\n\n  - **参考：**\n    - [Render 函数](../guide/render-function.html)\n\n## 选项 / 生命周期钩子\n\n所有的生命周期钩子自动绑定 `this` 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 __你不能使用箭头函数来定义一个生命周期方法__ (例如 `created: () => this.fetchTodos()`)。这是因为箭头函数绑定了父上下文，因此 `this` 与你期待的 Vue 实例不同， `this.fetchTodos` 的行为未定义。\n\n### beforeCreate\n\n- **类型：** `Function`\n\n- **详细：**\n\n  在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### created\n\n- **类型：** `Function`\n\n- **详细：**\n\n  实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，`$el` 属性目前不可见。\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeMount\n\n- **类型：** `Function`\n\n- **详细：**\n\n  在挂载开始之前被调用：相关的 `render` 函数首次被调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### mounted\n\n- **类型：** `Function`\n\n- **详细：**\n\n  `el` 被新创建的 `vm.$el` 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 `mounted` 被调用时 `vm.$el` 也在文档内。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeUpdate\n\n- **类型：** `Function`\n\n- **详细：**\n\n  数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。\n\n  你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### updated\n\n- **类型：** `Function`\n\n- **详细：**\n\n  由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。\n\n  当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n\n### activated\n\n- **类型：** `Function`\n\n- **详细：**\n\n  keep-alive 组件激活时调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：**\n  - [构建组件 - keep-alive](#keep-alive)\n  - [动态组件 - keep-alive](../guide/components.html#keep-alive)\n\n### deactivated\n\n- **类型：** `Function`\n\n- **详细：**\n\n  keep-alive 组件停用时调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：**\n  - [构建组件 - keep-alive](#keep-alive)\n  - [动态组件 - keep-alive](../guide/components.html#keep-alive)\n\n### beforeDestroy\n\n- **类型：** `Function`\n\n- **详细：**\n\n  实例销毁之前调用。在这一步，实例仍然完全可用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n\n### destroyed\n\n- **类型：** `Function`\n\n- **详细：**\n\n  Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n## 选项 / 资源\n\n### directives\n\n- **类型:** `Object`\n\n- **详细:**\n\n包含 Vue 实例可用指令的哈希表。\n\n- **参考：**\n  - [自定义指令](../guide/custom-directive.html)\n  - [资源命名约定](../guide/components.html#Assets-Naming-Convention)\n\n### filters\n\n- **类型:** `Object`\n\n- **详细:**\n\n包含 Vue 实例可用过滤器的哈希表。\n\n- **另见:**\n  - [`Vue.filter`](#Vue-filter)\n\n### components\n\n- **类型:** `Object`\n\n- **详细:**\n\n包含 Vue 实例可用组件的哈希表。\n\n- **参考：**\n  - [组件](../guide/components.html)\n\n## 选项 / 杂项\n\n### parent\n\n- **类型:** `Vue instance`\n\n- **详细:**\n\n  指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 `this.$parent` 访问父实例，子实例被推入父实例的 `$children` 数组中。\n\n  <p class=\"tip\">同时使用 `$parent` 和 `$children` 有冲突 - 他们作为同一个入口 。更推荐用 props 和 events 实现父子组件通信</p>\n\n### mixins\n\n- **类型:** `Array<Object>`\n\n- **详细:**\n\n  `mixins` 选项接受一个混合对象的数组。这些混合实例对象可以像正常的实例对象一样包含选项,他们将在 `Vue.extend()` 里最终选择使用相同的选项合并逻辑合并。举例：如果你混合包含一个钩子而创建组件本身也有一个,两个函数将被调用。\n  Mixin钩子按照传入顺序依次调用,并在调用组件自身的钩子之前被调用。\n\n- **示例:**\n\n  ``` js\n  var mixin = {\n    created: function () { console.log(1) }\n  }\n  var vm = new Vue({\n    created: function () { console.log(2) },\n    mixins: [mixin]\n  })\n  // -> 1\n  // -> 2\n  ```\n\n- **参考：** [混合](../guide/mixins.html)\n\n### name\n\n- **类型:** `string`\n\n- **限制:** 只有作为组件选项时起作用。\n\n- **详细:**\n\n  允许组件模板递归地调用自身。注意，组件在全局用 `Vue.component()` 注册时，全局 ID 自动作为组件的 name。\n\n  指定 `name` 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 [vue-devtools](https://github.com/vuejs/vue-devtools), 未命名组件将显示成 `<AnonymousComponent>`, 这很没有语义。通过提供 `name` 选项，可以获得更有语义信息的组件树。\n\n### extends\n\n- **类型:** `Object | Function`\n\n- **详细:**\n\n  允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数),而无需使用 `Vue.extend`。这主要是为了便于扩展单文件组件。\n\n  这和 `mixins` 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。\n\n- **示例:**\n\n  ``` js\n  var CompA = { ... }\n\n  // 在没有调用 Vue.extend 时候继承 CompA\n  var CompB = {\n    extends: CompA,\n    ...\n  }\n  ```\n\n### delimiters\n\n- **类型:** `Array<string>`\n\n- **默认值:** `{% raw %}[\"{{\", \"}}\"]{% endraw %}`\n\n- **详细:**\n\n 改变纯文本插入分隔符。 **这个选择只有在独立构建时才有用。**\n\n\n- **示例:**\n\n  ``` js\n  new Vue({\n    delimiters: ['${', '}']\n  })\n\n  // 分隔符变成了 ES6 模板字符串的风格\n  ```\n\n### functional\n\n- **类型:** `boolean`\n\n- **详细:**\n\n  使组件无状态（没有 `data` ）和无实例（没有 `this` 上下文）。他们用一个简单的 `render` 函数返回虚拟节点使他们更容易渲染。\n\n- **参考：\n** [函数式组件](../guide/render-function.html#Functional-Components)\n\n## 实例属性\n\n### vm.$data\n\n- **类型:** `Object`\n\n- **详细:**\n\n  Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。\n\n- **另见:** [选项 - data](#data)\n\n### vm.$el\n\n- **类型:** `HTMLElement`\n\n- **只读**\n\n- **详细:**\n\n  Vue 实例使用的根 DOM 元素。\n\n### vm.$options\n\n- **类型:** `Object`\n\n- **只读**\n\n- **详细:**\n\n  用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处：\n\n  ``` js\n  new Vue({\n    customOption: 'foo',\n    created: function () {\n      console.log(this.$options.customOption) // -> 'foo'\n    }\n  })\n  ```\n\n### vm.$parent\n\n- **类型:** `Vue instance`\n\n- **只读**\n\n- **详细:**\n\n  父实例，如果当前实例有的话。\n\n### vm.$root\n\n- **类型:** `Vue instance`\n\n- **只读**\n\n- **详细:**\n\n  当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自已。\n\n### vm.$children\n\n- **类型:** `Array<Vue instance>`\n\n- **只读**\n\n- **详细:**\n\n  当前实例的直接子组件。**需要注意 `$children` 并不保证顺序，也不是响应式的。**如果你发现自己正在尝试使用 `$children` 来进行数据绑定，考虑使用一个数组配合 `v-for` 来生成子组件，并且使用 Array 作为真正的来源。\n\n### vm.$slots\n\n- **类型：** `{ [name: string]: ?Array<VNode> }`\n\n- **只读**\n\n- **详细:**\n\n  用来访问被 [slot 分发](../guide/components.html#Content-Distribution-with-Slots)的内容。每个[具名 slot](../guide/components.html#Named-Slots) 有其相应的属性（例如：`slot=\"foo\"` 中的内容将会在 `vm.$slots.foo` 中被找到）。`default` 属性包括了所有没有被包含在具名 slot 中的节点。\n\n  在使用 [render 函数](../guide/render-function.html)书写一个组件时，访问 `vm.$slots` 最有帮助。\n\n- **示例:**\n\n  ```html\n  <blog-post>\n    <h1 slot=\"header\">\n      About Me\n    </h1>\n\n    <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>\n\n    <p slot=\"footer\">\n      Copyright 2016 Evan You\n    </p>\n\n    <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.\n  </blog-post>\n  ```\n\n  ```js\n  Vue.component('blog-post', {\n    render: function (createElement) {\n      var header = this.$slots.header\n      var body   = this.$slots.default\n      var footer = this.$slots.footer\n      return createElement('div', [\n        createElement('header', header),\n        createElement('main', body),\n        createElement('footer', footer)\n      ])\n    }\n  })\n  ```\n\n- **参考：**\n  - [`<slot>` 组件](#slot-1)\n  - [使用 Slots 进行内容分发](../guide/components.html#Content-Distribution-with-Slots)\n  - [Render 函数](../guide/render-function.html#Slots)\n\n### vm.$scopedSlots\n\n> 2.1.0新增\n\n- **类型：** `{ [name: string]: props => VNode | Array<VNode> }`\n\n- **只读**\n\n- **详细：**\n\n  Used to programmatically access [scoped slots](../guide/components.html#Scoped-Slots). For each slot, including the `default` one, the object contains a corresponding function that returns VNodes.\n\n  Accessing `vm.$scopedSlots` is most useful when writing a component with a [render function](../guide/render-function.html).\n\n- **参考：**\n  - [`<slot>` 组件](#slot-1)\n  - [Scoped Slots](../guide/components.html#Scoped-Slots)\n  - [Render 函数](../guide/render-function.html#Slots)\n\n\n### vm.$refs\n\n- **类型：** `Object`\n\n- **只读**\n\n- **详细：**\n\n  一个对象，其中包含了所有拥有 `ref` 注册的子组件。\n\n- **另见：**\n  - [子组件引用](../guide/components.html#Child-Component-Refs)\n  - [ref](#ref)\n\n### vm.$isServer\n\n- **类型：** `boolean`\n\n- **只读**\n\n- **详细：**\n\n  当前 Vue 实例是否运行于服务器。\n\n- **参考：** [服务端渲染](../guide/ssr.html)\n\n## 实例方法 / 数据\n\n<h3 id=\"vm-watch\">vm.$watch( expOrFn, callback, [options] )</h3>\n\n- **参数：**\n  - `{string | Function} expOrFn`\n  - `{Function} callback`\n  - `{Object} [options]`\n    - `{boolean} deep`\n    - `{boolean} immediate`\n\n- **返回值：** `{Function} unwatch`\n\n- **用法：**\n\n  观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。\n\n  <p class=\"tip\">注意：在变异（不是替换）对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。</p>\n\n- **示例：**\n\n  ``` js\n  // 键路径\n  vm.$watch('a.b.c', function (newVal, oldVal) {\n    // 做点什么\n  })\n\n  // 函数\n  vm.$watch(\n    function () {\n      return this.a + this.b\n    },\n    function (newVal, oldVal) {\n      // 做点什么\n    }\n  )\n  ```\n\n  `vm.$watch` 返回一个取消观察函数，用来停止触发回调：\n\n  ``` js\n  var unwatch = vm.$watch('a', cb)\n  // 之后取消观察\n  unwatch()\n  ```\n\n- **选项：deep**\n\n  为了发现对象内部值的变化，可以在选项参数中指定 `deep: true` 。注意监听数组的变动不需要这么做。\n\n  ``` js\n  vm.$watch('someObject', callback, {\n    deep: true\n  })\n  vm.someObject.nestedValue = 123\n  // callback is fired\n  ```\n\n- **选项：immediate**\n\n  在选项参数中指定 `immediate: true` 将立即以表达式的当前值触发回调：\n\n  ``` js\n  vm.$watch('a', callback, {\n    immediate: true\n  })\n  // 立即以 `a` 的当前值触发回调\n  ```\n\n<h3 id=\"vm-set\">vm.$set( object, key, value )</h3>\n\n- **参数：**\n  - `{Object} object`\n  - `{string} key`\n  - `{any} value`\n\n- **返回值：** 设置的值.\n\n- **用法：**\n\n  这是全局 `Vue.set` 的**别名**。\n\n- **另见：** [Vue.set](#Vue-set)\n\n<h3 id=\"vm-delete\">vm.$delete( object, key )</h3>\n\n- **参数：**\n  - `{Object} object`\n  - `{string} key`\n\n- **用法：**\n\n  这是全局 `Vue.delete` 的**别名**。\n\n- **另见：** [Vue.delete](#Vue-delete)\n\n## 实例方法/事件\n\n<h3 id=\"vm-on\">vm.$on( event, callback )</h3>\n\n- **参数：**\n  - `{string} event`\n  - `{Function} callback`\n\n- **用法：**\n\n  监听当前实例上的自定义事件。事件可以由`vm.$emit`触发。回调函数会接收所有传入事件触发函数的额外参数。\n\n- **示例：**\n\n  ``` js\n  vm.$on('test', function (msg) {\n    console.log(msg)\n  })\n  vm.$emit('test', 'hi')\n  // -> \"hi\"\n  ```\n\n<h3 id=\"vm-once\">vm.$once( event, callback )</h3>\n\n- **参数：**\n  - `{string} event`\n  - `{Function} callback`\n\n- **用法：**\n\n  监听一个自定义事件，但是只触发一次，在第一次触发之移除除监听器。\n\n<h3 id=\"vm-off\">vm.$off( [event, callback] )</h3>\n\n- **参数：**\n  - `{string} [event]`\n  - `{Function} [callback]`\n\n- **用法：**\n\n  移除事件监听器。\n\n  - 如果没有提供参数，则移除所有的事件监听器；\n\n  - 如果只提供了事件，则移除该事件所有的监听器；\n\n  - 如果同时提供了事件与回调，则只移除这个回调的监听器。\n\n<h3 id=\"vm-emit\">vm.$emit( event, [...args] )</h3>\n\n- **参数：**\n  - `{string} event`\n  - `[...args]`\n\n  触发当前实例上的事件。附加参数都会传给监听器回调。\n\n## 实例方法 / 生命周期\n\n<h3 id=\"vm-mount\">vm.$mount( [elementOrSelector] )</h3>\n\n- **参数：**\n  - `{Element | string} [elementOrSelector]`\n  - `{boolean} [hydrating]`\n\n- **返回值：** `vm` - 实例自身\n\n- **用法：**\n\n  如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 `vm.$mount()` 手动地挂载一个未挂载的实例。\n\n  如果没有提供 `elementOrSelector` 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生DOM API把它插入文档中。\n\n  这个方法返回实例自身，因而可以链式调用其它实例方法。\n\n- **示例：**\n\n  ``` js\n  var MyComponent = Vue.extend({\n    template: '<div>Hello!</div>'\n  })\n\n  // 创建并挂载到 #app (会替换 #app)\n  new MyComponent().$mount('#app')\n\n  // 同上\n  new MyComponent({ el: '#app' })\n\n  // 或者，在文档之外渲染并且随后挂载\n  var component = new MyComponent().$mount()\n  document.getElementById('app').appendChild(component.$el)\n  ```\n\n- **参考：**\n  - [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n  - [服务端渲染](../guide/ssr.html)\n\n<h3 id=\"vm-forceUpdate\">vm.$forceUpdate()</h3>\n\n- **示例：**\n\n  迫使Vue实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。\n\n<h3 id=\"vm-nextTick\">vm.$nextTick( [callback] )</h3>\n\n- **参数：**\n  - `{Function} [callback]`\n\n- **用法：**\n\n  将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 `this` 自动绑定到调用它的实例上。\n\n\n > 2.1.0新增：如果没有提供回调且支持 promise 的环境中返回 promise。\n\n- **示例：**\n\n  ``` js\n  new Vue({\n    // ...\n    methods: {\n      // ...\n      example: function () {\n        // 修改数据\n        this.message = 'changed'\n        // DOM 还没有更新\n        this.$nextTick(function () {\n          // DOM 现在更新了\n          // `this` 绑定到当前实例\n          this.doSomethingElse()\n        })\n      }\n    }\n  })\n  ```\n\n- **参考：**\n  - [Vue.nextTick](#Vue-nextTick)\n  - [异步更新队列](../guide/reactivity.html#Async-Update-Queue)\n\n<h3 id=\"vm-destroy\">vm.$destroy()</h3>\n\n- **用法：**\n\n  完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。\n\n  触发 `beforeDestroy` 和 `destroyed` 的钩子。\n\n  <p class=\"tip\">在大多数场景中你不应该调用这个方法。最好使用 `v-if` 和 `v-for` 指令以数据驱动的方式控制子组件的生命周期。</p>\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n## 指令\n\n### v-text\n\n- **类型：** `string`\n\n- **详细：**\n\n  更新元素的 `textContent`。如果要更新部分的 `textContent` ，需要使用 `{% raw %}{{ Mustache }}{% endraw %}` 插值。\n\n- **示例：**\n\n  ```html\n  <span v-text=\"msg\"></span>\n  <!-- 和下面的一样 -->\n  <span>{{msg}}</span>\n  ```\n\n- **参考：** [数据绑定语法 - 插值](../guide/syntax.html#Text)\n\n### v-html\n\n- **类型：** `string`\n\n- **详细：**\n\n\n  更新元素的 `innerHTML` 。**注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译** 。如果试图使用 `v-html` 组合模板,可以重新考虑通过是否通过使用组件来替代。\n\n  <p class=\"tip\">在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。只在可信内容上使用 `v-html`，**永不**用在用户提交的内容上。</p>\n\n- **示例：**\n\n  ```html\n  <div v-html=\"html\"></div>\n  ```\n- **参考：** [数据绑定语法 - 插值](../guide/syntax.html#Raw-HTML)\n\n### v-show\n\n- **类型：** `any`\n\n- **用法：**\n\n  根据表达式之真假值，切换元素的 `display` CSS 属性。\n\n  当条件变化时该指令触发过渡效果。\n\n- **参考：** [条件渲染 - v-show](../guide/conditional.html#v-show)\n\n### v-if\n\n- **类型：** `any`\n\n- **用法：**\n\n  根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 `<template>` ，将提出它的内容作为条件块。\n\n  当条件变化时该指令触发过渡效果。\n\n- **参考：** [条件渲染 - v-if](../guide/conditional.html)\n\n### v-else\n\n- **不需要表达式**\n\n- **限制：** 前一兄弟元素必须有 `v-if` 或 `v-else-if`。\n\n- **用法：**\n\n  为 `v-if` 或者 `v-else-if` 添加 “else 块”。\n\n  ```html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **参考：**\n  - [条件渲染 - v-else](../guide/conditional.html#v-else)\n\n### v-else-if\n\n> 2.1.0新增\n\n- **Expects:** `any`\n\n- **Restriction:** previous sibling element must have `v-if` or `v-else-if`.\n\n- **Usage:**\n\n  Denote the \"else if block\" for `v-if`. Can be chained.\n\n  ```html\n  <div v-if=\"type === 'A'\">\n    A\n  </div>\n  <div v-else-if=\"type === 'B'\">\n    B\n  </div>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n  <div v-else>\n    Not A/B/C\n  </div>\n  ```\n\n- **See also:** [Conditional Rendering - v-else-if](../guide/conditional.html#v-else-if)\n\n### v-for\n\n- **类型：** `Array | Object | number | string`\n\n- **用法：**\n\n  基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 `alias in expression` ，为当前遍历的元素提供别名：\n\n  ``` html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  另外也可以为数组索引指定别名（或者用于对象的键）：\n\n  ``` html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(val, key) in object\"></div>\n  <div v-for=\"(val, key, index) in object\"></div>\n  ```\n\n  `v-for` 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素,您需要提供一个 `key` 的特殊属性:\n\n  ``` html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  `v-for` 的详细用法可以通过以下链接查看教程详细说明。\n\n- **参考：**\n  - [列表渲染](../guide/list.html)\n  - [key](../guide/list.html#key)\n\n### v-on\n\n- **缩写：** `@`\n\n- **类型：** `Function | Inline Statement`\n\n- **参数：** `event (required)`\n\n- **修饰符：**\n  - `.stop` - 调用 `event.stopPropagation()`。\n  - `.prevent` - 调用 `event.preventDefault()`。\n  - `.capture` - 添加事件侦听器时使用 capture 模式。\n  - `.self` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\n  - `.{keyCode | keyAlias}` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\n  - `.native` - 监听组件根元素的原生事件。\n\n- **用法：**\n\n  绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。\n\n  用在普通元素上时，只能监听 **原生 DOM 事件**。用在自定义元素组件上时，也可以监听子组件触发的**自定义事件**。\n\n  在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 `$event` 属性： `v-on:click=\"handle('ok', $event)\"`。\n\n- **示例：**\n\n  ```html\n  <!-- 方法处理器 -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- 内联语句 -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- 缩写 -->\n  <button @click=\"doThis\"></button>\n\n  <!-- 停止冒泡 -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- 阻止默认行为 -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- 阻止默认行为，没有表达式 -->\n  <form @submit.prevent></form>\n\n  <!--  串联修饰符 -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- 键修饰符，键别名 -->\n  <input @keyup.enter=\"onEnter\">\n\n  <!-- 键修饰符，键代码 -->\n  <input @keyup.13=\"onEnter\">\n  ```\n\n  在子组件上监听自定义事件（当子组件触发 “my-event” 时将调用事件处理器）：\n\n  ```html\n  <my-component @my-event=\"handleThis\"></my-component>\n\n  <!-- 内联语句 -->\n  <my-component @my-event=\"handleThis(123, $event)\"></my-component>\n\n  <!-- 组件中的原生事件 -->\n  <my-component @click.native=\"onClick\"></my-component>\n  ```\n\n- **参考：**\n  - [方法与事件处理器](../guide/events.html)\n  - [组件 - 自定义事件](../guide/components.html#Custom-Events)\n\n### v-bind\n\n- **缩写：** `:`\n\n- **类型：** `any (with argument) | Object (without argument)`\n\n- **参数：** `attrOrProp (optional)`\n\n- **修饰符：**\n  - `.prop` - 被用于绑定 DOM 属性。([what's the difference?](http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028))\n  - `.camel` - transform the kebab-case attribute name into camelCase. (supported since 2.1.0)\n\n- **用法：**\n\n  动态地绑定一个或多个特性，或一个组件 prop 到表达式。\n\n  在绑定 `class` 或 `style` 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。\n\n  在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。\n\n  没有参数时，可以绑定到一个包含键值对的对象。注意此时 `class` 和 `style` 绑定不支持数组和对象。\n\n- **示例：**\n\n  ```html\n  <!-- 绑定一个属性 -->\n  <img v-bind:src=\"imageSrc\">\n\n  <!-- 缩写 -->\n  <img :src=\"imageSrc\">\n  \n  <!-- with inline string concatenation -->\n  <img :src=\"'/path/to/images/' + fileName\">\n\n  <!-- class 绑定 -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\">\n\n  <!-- style 绑定 -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- 绑定一个有属性的对象 -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- 通过 prop 修饰符绑定 DOM 属性 -->\n  <div v-bind:text-content.prop=\"text\"></div>\n\n  <!-- prop 绑定. “prop” 必须在 my-component 中声明。 -->\n  <my-component :prop=\"someThing\"></my-component>\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n  The `.camel` modifier allows camelizing a `v-bind` attribute name when using in-DOM templates, e.g. the SVG `viewBox` attribute:\n\n  ``` html\n  <svg :view-box.camel=\"viewBox\"></svg>\n  ```\n\n  `.camel` is not needed if you are using string templates, or compiling with `vue-loader`/`vueify`.\n\n- **参考：**\n  - [Class 与 Style 绑定](../guide/class-and-style.html)\n  - [组件 - 组件 Props](../guide/components.html#Props)\n\n### v-model\n\n- **类型：** 随表单控件类型不同而不同。\n\n- **限制：**\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **修饰符：**\n  - [`.lazy`](../guide/forms.html#lazy) - 取代 `input` 监听 `change` 事件\n  - [`.number`](../guide/forms.html#number) - 输入字符串转为数字\n  - [`.trim`](../guide/forms.html#trim) - 输入首尾空格过滤\n\n- **用法：**\n\n  在表单控件或者组件上创建双向绑定。细节请看下面链接的教程。\n\n- **参考：**\n  - [表单控件绑定](../guide/forms.html)\n  - [组件 - 在输入组件上使用自定义事件](../guide/components.html#Form-Input-Components-using-Custom-Events)\n\n### v-pre\n\n- **不需要表达式**\n\n- **用法：**\n\n  跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。\n\n- **示例：**\n\n  ```html\n  <span v-pre>{{ this will not be compiled }}</span>\n   ```\n\n### v-cloak\n\n- **不需要表达式**\n\n- **用法：**\n\n  这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 `[v-cloak] { display: none }` 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。\n\n- **示例：**\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  <div> 不会显示，直到编译结束。\n\n### v-once\n\n- **不需要表达式**\n\n- **详细：**\n\n  只渲染元素和组件**一次**。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。\n\n  ```html\n  <!-- 单个元素 -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- 有子元素 -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- 组件 -->\n  <my-component v-once :comment=\"msg\"></my-component>\n  <!-- v-for 指令-->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n- **参考：**\n  - [数据绑定语法- 插值](../guide/syntax.html#Text)\n  - [组件 - 使用 v-once 实现轻量的静态组件](../guide/components.html#Cheap-Static-Components-with-v-once)\n\n## 特殊元素\n\n### key\n\n- **示例：** `string`\n\n  `key` 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。\n\n  有相同父元素的子元素必须有**独特的key**。重复的key会造成渲染错误。\n\n  最常见的用例是结合 `v-for`:\n\n  ``` html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用:\n\n  - 完整地触发组件的生命周期钩子\n  - 触发过渡\n\n  例如:\n\n  ``` html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  当 `text` 发生改变时，`<span>` 会随时被更新，因此会触发过渡。\n\n### ref\n\n- **类型：** `string`\n\n  `ref` 被用来给元素或子组件注册引用信息。引用信息会根据父组件的 `$refs` 对象进行注册。如果在普通的DOM元素上使用，引用信息就是元素; 如果用在子组件上，引用信息就是组件实例:\n\n  ``` html\n  <!-- vm.$refs.p will be the DOM node -->\n  <p ref=\"p\">hello</p>\n\n  <!-- vm.$refs.child will be the child comp instance -->\n  <child-comp ref=\"child\"></child-comp>\n  ```\n\n  当 `v-for` 用于元素或组件的时候，引用信息将是包含DOM节点或组件实例数组。\n\n  关于ref注册时间的重要说明: 因为ref本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！`$refs` 也不是响应式的，因此你不应该试图用它在模版中做数据绑定。\n\n- **参考：** [子组件 Refs](../guide/components.html#Child-Component-Refs)\n\n### slot\n\n- **类型：** `string`\n\n  用于标记往哪个slot中插入子组件内容。\n\n  详细用法，请参考下面指南部分的链接。\n\n- **参考：** [命名 Slots](../guide/components.html#Named-Slots)\n\n## 内置的组件\n\n### component\n\n- **Props：**\n  - `is` - string | ComponentDefinition | ComponentConstructor\n  - `inline-template` - boolean\n\n- **用法：**\n\n  渲染一个“元组件”为动态组件。依 `is` 的值，来决定哪个组件被渲染。\n\n  ```html\n  <!-- 动态组件由 vm 实例的属性值 `componentId` 控制 -->\n  <component :is=\"componentId\"></component>\n\n  <!-- 也能够渲染注册过的组件或 prop 传入的组件 -->\n  <component :is=\"$options.components.child\"></component>\n  ```\n\n- **参考：** [动态组件](../guide/components.html#动态组件)\n\n### transition\n\n- **Props：**\n  - `name` - string, 用于自动生成 CSS 过渡类名。例如：`name: 'fade'` 将自动拓展为`.fade-enter`，`.fade-enter-active`等。默认类名为 `\"v\"`\n  - `appear` - boolean, 是否在初始渲染时使用过渡。默认为 `false`。\n  - `css` - boolean, 是否使用 CSS 过渡类。默认为 `true`。如果设置为 `false`，将只通过组件事件触发注册的 JavaScript 钩子。\n  - `type` - string, 指定过渡事件类型，侦听过渡何时结束。有效值为 `\"transition\"` 和 `\"animation\"`。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。\n  - `mode` - string, 控制离开/进入的过渡时间序列。有效的模式有 `\"out-in\"` 和 `\"in-out\"`；默认同时生效。\n  - `enter-class` - string\n  - `leave-class` - string\n  - `enter-active-class` - string\n  - `leave-active-class` - string\n  - `appear-class` - string\n  - `appear-active-class` - string\n\n- **事件：**\n  - `before-enter`\n  - `enter`\n  - `after-enter`\n  - `before-leave`\n  - `leave`\n  - `after-leave`\n  - `before-appear`\n  - `appear`\n  - `after-appear`\n\n- **用法：**\n\n  `<transition>` 元素作为单个元素/组件的过渡效果。`<transition>` 不会渲染额外的 DOM 元素，也不会出现在检测过的组件层级中。它只是将内容包裹在其中，简单的运用过渡行为。\n\n  ```html\n  <!-- 简单元素 -->\n  <transition>\n    <div v-if=\"ok\">toggled content</div>\n  </transition>\n\n  <!-- 动态组件 -->\n  <transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </transition>\n\n  <!-- 事件钩子 -->\n  <div id=\"transition-demo\">\n    <transition @after-enter=\"transitionComplete\">\n      <div v-show=\"ok\">toggled content</div>\n    </transition>\n  </div>\n  ```\n\n  ``` js\n  new Vue({\n    ...\n    methods: {\n      transitionComplete: function (el) {\n        // 传入 'el' 这个 DOM 元素作为参数。\n      }\n    }\n    ...\n  }).$mount('#transition-demo')\n  ```\n\n- **参考：** [过渡：进入，离开和列表](../guide/transitions.html)\n\n### transition-group\n\n- **Props：**\n  - `tag` - string, 默认为 `span`\n  - `move-class` - 覆盖移动过渡期间应用的 CSS 类。\n  - 除了 `mode`，其他特性和 `<transition>` 相同。\n\n- **事件：**\n  - 事件和 `<transition>` 相同.\n\n- **用法：**\n\n  `<transition-group>` 元素作为多个元素/组件的过渡效果。`<transition-group>` 渲染一个真实的 DOM 元素。默认渲染 `<span>`，可以通过 `tag` 属性配置哪个元素应该被渲染。\n\n  注意，每个 `<transition-group>` 的子节点必须有 **独立的key** ，动画才能正常工作\n\n  `<transition-group>` 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类（通过 `name` 属性或配置 `move-class` 属性自动生成）。如果 CSS `transform` 属性是“可过渡”属性，当应用移动类时，将会使用 [FLIP 技术](https://aerotwist.com/blog/flip-your-animations/) 使元素流畅地到达动画终点。\n\n  ```html\n  <transition-group tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </transition-group>\n  ```\n\n- **参考：** [过渡：进入，离开和列表](../guide/transitions.html)\n\n### keep-alive\n\n- **Props:**\n  - `include` - string or RegExp. Only components matched by this will be cached.\n  - `exclude` - string or RegExp. Any component matched by this will not be cached.\n\n- **用法：**\n\n  `<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n\n  当组件在 `<keep-alive>` 内被切换，它的 `activated` 和 `deactivated` 这两个生命周期钩子函数将会被对应执行。\n\n  主要用于保留组件状态或避免重新渲染。\n\n  ```html\n  <!-- 基本 -->\n  <keep-alive>\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- 多个条件判断的子组件 -->\n  <keep-alive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </keep-alive>\n\n  <!-- 和 <transition> 一起使用 -->\n  <transition>\n    <keep-alive>\n      <component :is=\"view\"></component>\n    </keep-alive>\n  </transition>\n  ```\n\n- **`include` and `exclude`**\n\n  > New in 2.1.0\n\n  The `include` and `exclude` props allow components to be conditionally cached. Both props can either be a comma-delimited string or a RegExp:\n\n  ``` html\n  <!-- comma-delimited string -->\n  <keep-alive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- regex (use v-bind) -->\n  <keep-alive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n  ```\n\n  The match is first checked on the component's own `name` option, then its local registration name (the key in the parent's `components` option) if the `name` option is not available. Anonymous components cannot be matched against.\n\n  <p class=\"tip\">`<keep-alive>` 不会在函数式组件中正常工作，因为它们没有缓存实例。</p>\n\n- **参考：** [动态组件 - keep-alive](../guide/components.html#keep-alive)\n\n### slot\n\n- **Props：**\n  - `name` - string, 用于命名插槽。\n\n- **Usage:**\n\n  `<slot>` 元素作为组件模板之中的内容分发插槽。 `<slot>` 元素自身将被替换。\n\n  详细用法，请参考下面教程的链接。\n\n- **参考：** [使用Slots分发内容](../guide/components.html#使用Slots分发内容)\n\n## VNode接口\n\n- 请参考[VNode class declaration](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).\n\n## 服务端渲染\n\n- 请参考[vue-server-renderer package documentation](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).\n","source":"v2/api/index.md","raw":"---\ntype: api\n---\n\n## 全局配置\n\n`Vue.config`  是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：\n\n### silent\n\n- **类型：** `boolean`\n\n- **默认值：** `false`\n\n- **用法：**\n\n  ``` js\n  Vue.config.silent = true\n  ```\n\n  取消 Vue 所有的日志与警告。\n\n### optionMergeStrategies\n\n- **类型：** `{ [key: string]: Function }`\n\n- **默认值：** `{}`\n\n- **用法：**\n\n  ``` js\n  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {\n    return child + 1\n  }\n\n  const Profile = Vue.extend({\n    _my_option: 1\n  })\n\n  // Profile.options._my_option = 2\n  ```\n\n  自定义合并策略的选项。\n\n  合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入。\n\n- **参考** [自定义选项的混合策略](../guide/mixins.html#Custom-Option-Merge-Strategies)\n\n### devtools\n\n- **类型：** `boolean`\n\n- **默认值：** `true` (生产版为 `false`)\n\n- **用法：**\n\n  ``` js\n  // 务必在加载 Vue 之后，立即同步设置以下内容\n  Vue.config.devtools = true\n  ```\n\n  配置是否允许 [vue-devtools](https://github.com/vuejs/vue-devtools) 检查代码。开发版本默认为 `true`，生产版本默认为 `false`。生产版本设为 `true` 可以启用检查。\n\n### errorHandler\n\n- **类型：** `Function`\n\n- **默认值：** 默认抛出错误\n\n- **用法：**\n\n  ``` js\n  Vue.config.errorHandler = function (err, vm) {\n    // handle error\n  }\n  ```\n\n  指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。\n\n  > [Sentry](https://sentry.io), an error tracking service, provides [official integration](https://sentry.io/for/vue/) using this option.\n\n### ignoredElements\n\n- **类型:** `Array<string>`\n\n- **默认值:** `[]`\n\n- **用法:**\n\n  ``` js\n  Vue.config.ignoredElements = [\n    'my-custom-web-component', 'another-web-component'\n  ]\n  ```\n\n  须使 Vue 忽略在 Vue 之外的自定义元素 (e.g., 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 `Unknown custom element` 的警告。\n\n### keyCodes\n\n- **类型：** `{ [key: string]: number | Array<number> }`\n\n- **默认值：** `{}`\n\n- **用法：**\n\n  ``` js\n  Vue.config.keyCodes = {\n    v: 86,\n    f1: 112,\n    mediaPlayPause: 179,\n    up: [38, 87]\n  }\n  ```\n\n  给 v-on 自定义键位别名。\n\n## 全局 API\n\n<h3 id=\"Vue-extend\">Vue.extend( options )</h3>\n\n- **参数：**\n  - `{Object} options`\n\n- **用法：**\n\n  使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。\n\n  `data` 选项是特例，需要注意 - 在 `Vue.extend()` 中它必须是函数\n\n  ``` html\n  <div id=\"mount-point\"></div>\n  ```\n\n  ``` js\n  // 创建构造器\n  var Profile = Vue.extend({\n    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',\n    data: function () {\n      return {\n        firstName: 'Walter',\n        lastName: 'White',\n        alias: 'Heisenberg'\n      }\n    }\n  })\n  // 创建 Profile 实例，并挂载到一个元素上。\n  new Profile().$mount('#mount-point')\n  ```\n\n  结果如下：\n\n  ``` html\n  <p>Walter White aka Heisenberg</p>\n  ```\n\n- **参考：** [组件](../guide/components.html)\n\n<h3 id=\"Vue-nextTick\">Vue.nextTick( [callback, context] )</h3>\n\n- **参数：**\n  - `{Function} [callback]`\n  - `{Object} [context]`\n\n- **用法：**\n\n  在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n\n  ``` js\n  // 修改数据\n  vm.msg = 'Hello'\n  // DOM 还没有更新\n  Vue.nextTick(function () {\n    // DOM 更新了\n  })\n  ```\n\n  > 2.1.0新增：如果没有提供回调且支持 promise 的环境中返回 promise。\n\n- **参考：** [异步更新队列](../guide/reactivity.html#Async-Update-Queue)\n\n<h3 id=\"Vue-set\">Vue.set( object, key, value )</h3>\n\n- **参数：**\n  - `{Object} object`\n  - `{string} key`\n  - `{any} value`\n\n- **返回值：** 设置的值.\n\n- **用法：**\n\n  设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。\n\n  **注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象**\n\n- **参考：** [深入响应式原理](../guide/reactivity.html)\n\n<h3 id=\"Vue-delete\">Vue.delete( object, key )</h3>\n\n- **参数：**\n  - `{Object} object`\n  - `{string} key`\n\n- **用法：**\n\n  删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。\n\n  **注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象**\n\n- **参考：** [深入响应式原理](../guide/reactivity.html)\n\n<h3 id=\"Vue-directive\">Vue.directive( id, [definition] )</h3>\n\n- **参数：**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **用法：**\n\n  注册或获取全局指令。\n\n  ``` js\n  // 注册\n  Vue.directive('my-directive', {\n    bind: function () {},\n    inserted: function () {},\n    update: function () {},\n    componentUpdated: function () {},\n    unbind: function () {}\n  })\n\n  // 注册（传入一个简单的指令函数）\n  Vue.directive('my-directive', function () {\n    // 这里将会被 `bind` 和 `update` 调用\n  })\n\n  // getter，返回已注册的指令\n  var myDirective = Vue.directive('my-directive')\n  ```\n\n- **参考：** [自定义指令](../guide/custom-directive.html)\n\n<h3 id=\"Vue-filter\">Vue.filter( id, [definition] )</h3>\n\n- **参数：**\n  - `{string} id`\n  - `{Function} [definition]`\n\n- **用法：**\n\n  注册或获取全局过滤器。\n\n  ``` js\n  // 注册\n  Vue.filter('my-filter', function (value) {\n    // 返回处理后的值\n  })\n\n  // getter，返回已注册的过滤器\n  var myFilter = Vue.filter('my-filter')\n  ```\n\n<h3 id=\"Vue-component\">Vue.component( id, [definition] )</h3>\n\n- **参数：**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **用法：**\n\n  注册或获取全局组件。注册还会自动使用给定的`id`设置组件的名称\n\n  ``` js\n  // 注册组件，传入一个扩展过的构造器\n  Vue.component('my-component', Vue.extend({ /* ... */ }))\n\n  // 注册组件，传入一个选项对象（自动调用 Vue.extend）\n  Vue.component('my-component', { /* ... */ })\n\n  // 获取注册的组件（始终返回构造器）\n  var MyComponent = Vue.component('my-component')\n  ```\n\n- **参考：** [组件](../guide/components.html)\n\n<h3 id=\"Vue-use\">Vue.use( plugin )</h3>\n\n- **参数：**\n  - `{Object | Function} plugin`\n\n- **用法：**\n\n  安装 Vue.js 插件。如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为 install 方法。install 方法将被作为 Vue 的参数调用。\n\n  当 install 方法被同一个插件多次调用，插件将只会被安装一次。\n\n- **参考：** [插件](../guide/plugins.html)\n\n<h3 id=\"Vue-mixin\">Vue.mixin( mixin )</h3>\n\n- **参数：**\n  - `{Object} mixin`\n\n- **用法：**\n\n  全局注册一个混合，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混合，向组件注入自定义的行为。**不推荐在应用代码中使用**。\n\n- **参考：** [全局混合](../guide/mixins.html#Global-Mixin)\n\n<h3 id=\"Vue-compile\">Vue.compile( template )</h3>\n\n- **参数：**\n  - `{string} template`\n\n- **用法：**\n\n  在render函数中编译模板字符串。**只在独立构建时有效**\n\n  ``` js\n  var res = Vue.compile('<div><span>{{ msg }}</span></div>')\n\n  new Vue({\n    data: {\n      msg: 'hello'\n    },\n    render: res.render,\n    staticRenderFns: res.staticRenderFns\n  })\n  ```\n\n- **参考：** [Render 函数](../guide/render-function.html)\n\n## 选项 / 数据\n\n### data\n\n\n- **类型：** `Object | Function`\n\n- **限制:** 组件的定义只接受 `function`。\n\n- **详细:**\n\n  Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。**对象必须是纯粹的对象(含有零个或多个的key/value对)**：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。\n\n  一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。\n\n  实例创建之后，可以通过 `vm.$data` 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 `vm.a` 等价于访问 `vm.$data.a`。\n\n  以 `_` 或 `$` 开头的属性 **不会** 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、 API 方法冲突。你可以使用例如 `vm.$data._property` 的方式访问这些属性。\n\n  当一个**组件**被定义， `data` 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 `data` 仍然是一个纯粹的对象，则所有的实例将**共享引用**同一个数据对象！通过提供 `data` 函数，每次创建一个新实例后，我们能够调用 `data` 函数，从而返回初始数据的一个全新副本数据对象。\n\n 如果需要，可以通过将 `vm.$data` 传入 `JSON.parse(JSON.stringify(...))` 得到深拷贝的原始数据对象。\n\n- **示例:**\n\n  ``` js\n  var data = { a: 1 }\n\n  // 直接创建一个实例\n  var vm = new Vue({\n    data: data\n  })\n  vm.a // -> 1\n  vm.$data === data // -> true\n\n  // Vue.extend() 中 data 必须是函数\n  var Component = Vue.extend({\n    data: function () {\n      return { a: 1 }\n    }\n  })\n  ```\n\n  <p class=\"tip\">注意，__不应该对 `data` 属性使用箭头函数__ (例如`data: () => { return { a: this.myProp }}`)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，`this.myProp` 将是 undefined。</p>\n\n- **参考:** [深入响应式原理](../guide/reactivity.html)\n\n### props\n\n- **类型:** `Array<string> | Object`\n\n- **详细:**\n\n  props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。\n\n- **示例:**\n\n  ``` js\n  // 简单语法\n  Vue.component('props-demo-simple', {\n    props: ['size', 'myMessage']\n  })\n\n  // 对象语法，提供校验\n  Vue.component('props-demo-advanced', {\n    props: {\n      // 只检测类型\n      height: Number,\n      // 检测类型 + 其他验证\n      age: {\n        type: Number,\n        default: 0,\n        required: true,\n        validator: function (value) {\n          return value >= 0\n        }\n      }\n    }\n  })\n  ```\n\n- **参考:** [Props](../guide/components.html#Props)\n\n### propsData\n\n- **类型:** `{ [key: string]: any }`\n\n- **限制:** 只用于 `new` 创建的实例中。\n\n- **详细:**\n\n  创建实例时传递 props。主要作用是方便测试。\n\n- **示例:**\n\n  ``` js\n  var Comp = Vue.extend({\n    props: ['msg'],\n    template: '<div>{{ msg }}</div>'\n  })\n\n  var vm = new Comp({\n    propsData: {\n      msg: 'hello'\n    }\n  })\n  ```\n- **参考:** [Props](../guide/components.html#Props)\n\n### computed\n\n- **类型:** `{ [key: string]: Function | { get: Function, set: Function } }`\n\n- **详细:**\n\n  计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。\n\n  <p class=\"tip\">注意，__不应该使用箭头函数来定义计算属性函数__ (例如 `aDouble: () => this.a * 2`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.a` 将是 undefined。</p>\n\n  计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。\n\n- **示例:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    computed: {\n      // 仅读取，值只须为函数\n      aDouble: function () {\n        return this.a * 2\n      },\n      // 读取和设置\n      aPlus: {\n        get: function () {\n          return this.a + 1\n        },\n        set: function (v) {\n          this.a = v - 1\n        }\n      }\n    }\n  })\n  vm.aPlus   // -> 2\n  vm.aPlus = 3\n  vm.a       // -> 2\n  vm.aDouble // -> 4\n  ```\n\n- **另见:**\n  - [计算属性](../guide/computed.html)\n\n### methods\n\n- **类型:** `{ [key: string]: Function }`\n\n- **详细:**\n\n  methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 `this` 自动绑定为 Vue 实例。\n\n  <p class=\"tip\">注意，__不应该使用箭头函数来定义 method 函数__ (例如 `plus: () => this.a++`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.a` 将是 undefined。</p>\n\n- **示例:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    methods: {\n      plus: function () {\n        this.a++\n      }\n    }\n  })\n  vm.plus()\n  vm.a // 2\n  ```\n\n- **参考:** [方法与事件处理器](../guide/events.html)\n\n### watch\n\n- **类型:** `{ [key: string]: string | Function | Object }`\n\n- **详细:**\n\n  一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 `$watch()`，遍历 watch 对象的每一个属性。\n\n- **示例:**\n\n  ``` js\n  var vm = new Vue({\n    data: {\n      a: 1,\n      b: 2,\n      c: 3\n    },\n    watch: {\n      a: function (val, oldVal) {\n        console.log('new: %s, old: %s', val, oldVal)\n      },\n      // 方法名\n      b: 'someMethod',\n      // 深度 watcher\n      c: {\n        handler: function (val, oldVal) { /* ... */ },\n        deep: true\n      }\n    }\n  })\n  vm.a = 2 // -> new: 2, old: 1\n  ```\n\n  <p class=\"tip\">注意，__不应该使用箭头函数来定义 watcher 函数__ (例如 `searchQuery: newValue => this.updateAutocomplete(newValue)`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.updateAutocomplete` 将是 undefined。</p>\n\n- **参考：** [实例方法 - vm.$watch](#vm-watch)\n\n## 选项 / DOM\n\n### el\n\n- **类型：** `string | HTMLElement`\n\n- **限制：** 只在由 `new` 创建的实例中遵守。\n\n- **详细：**\n\n  提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。\n\n  在实例挂载之后， 元素可以用 `vm.$el` 访问。\n\n  如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 `vm.$mount()` 手动开启编译。\n\n  <p class=\"tip\"> 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载root实例到 `<html>` 或者 `<body>` 上。</p>\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### template\n\n- **类型：** `string`\n\n- **详细：**\n\n  一个字符串模板作为 Vue 实例的标识使用。模板将会 **替换** 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发 slot。\n\n  如果值以 `#` 开始，则它用作选项符，将使用匹配元素的 innerHTML 作为模板。常用的技巧是用 `<script type=\"x-template\">` 包含模板。\n\n  <p class=\"tip\">出于安全考虑，您应该只使用您信任的 Vue 模板。避免使用其他人生成的内容作为您的模板。</p>\n\n- **参考：**\n  - [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n  - [内容分发](../guide/components.html#Content-Distribution-with-Slots)\n\n### render\n\n  - **类型：** `Function`\n\n  - **详细：**\n\n    字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。render 函数接收一个 `createElement` 方法作为第一个参数用来创建 `VNode`。\n\n    如果组件是一个函数组件，Render 函数还会接收一个额外的 `context` 参数，为没有实例的函数组件提供上下文信息。\n\n  - **参考：**\n    - [Render 函数](../guide/render-function.html)\n\n## 选项 / 生命周期钩子\n\n所有的生命周期钩子自动绑定 `this` 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 __你不能使用箭头函数来定义一个生命周期方法__ (例如 `created: () => this.fetchTodos()`)。这是因为箭头函数绑定了父上下文，因此 `this` 与你期待的 Vue 实例不同， `this.fetchTodos` 的行为未定义。\n\n### beforeCreate\n\n- **类型：** `Function`\n\n- **详细：**\n\n  在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### created\n\n- **类型：** `Function`\n\n- **详细：**\n\n  实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，`$el` 属性目前不可见。\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeMount\n\n- **类型：** `Function`\n\n- **详细：**\n\n  在挂载开始之前被调用：相关的 `render` 函数首次被调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### mounted\n\n- **类型：** `Function`\n\n- **详细：**\n\n  `el` 被新创建的 `vm.$el` 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 `mounted` 被调用时 `vm.$el` 也在文档内。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeUpdate\n\n- **类型：** `Function`\n\n- **详细：**\n\n  数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。\n\n  你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n### updated\n\n- **类型：** `Function`\n\n- **详细：**\n\n  由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。\n\n  当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n\n### activated\n\n- **类型：** `Function`\n\n- **详细：**\n\n  keep-alive 组件激活时调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：**\n  - [构建组件 - keep-alive](#keep-alive)\n  - [动态组件 - keep-alive](../guide/components.html#keep-alive)\n\n### deactivated\n\n- **类型：** `Function`\n\n- **详细：**\n\n  keep-alive 组件停用时调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：**\n  - [构建组件 - keep-alive](#keep-alive)\n  - [动态组件 - keep-alive](../guide/components.html#keep-alive)\n\n### beforeDestroy\n\n- **类型：** `Function`\n\n- **详细：**\n\n  实例销毁之前调用。在这一步，实例仍然完全可用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n\n### destroyed\n\n- **类型：** `Function`\n\n- **详细：**\n\n  Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n## 选项 / 资源\n\n### directives\n\n- **类型:** `Object`\n\n- **详细:**\n\n包含 Vue 实例可用指令的哈希表。\n\n- **参考：**\n  - [自定义指令](../guide/custom-directive.html)\n  - [资源命名约定](../guide/components.html#Assets-Naming-Convention)\n\n### filters\n\n- **类型:** `Object`\n\n- **详细:**\n\n包含 Vue 实例可用过滤器的哈希表。\n\n- **另见:**\n  - [`Vue.filter`](#Vue-filter)\n\n### components\n\n- **类型:** `Object`\n\n- **详细:**\n\n包含 Vue 实例可用组件的哈希表。\n\n- **参考：**\n  - [组件](../guide/components.html)\n\n## 选项 / 杂项\n\n### parent\n\n- **类型:** `Vue instance`\n\n- **详细:**\n\n  指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 `this.$parent` 访问父实例，子实例被推入父实例的 `$children` 数组中。\n\n  <p class=\"tip\">同时使用 `$parent` 和 `$children` 有冲突 - 他们作为同一个入口 。更推荐用 props 和 events 实现父子组件通信</p>\n\n### mixins\n\n- **类型:** `Array<Object>`\n\n- **详细:**\n\n  `mixins` 选项接受一个混合对象的数组。这些混合实例对象可以像正常的实例对象一样包含选项,他们将在 `Vue.extend()` 里最终选择使用相同的选项合并逻辑合并。举例：如果你混合包含一个钩子而创建组件本身也有一个,两个函数将被调用。\n  Mixin钩子按照传入顺序依次调用,并在调用组件自身的钩子之前被调用。\n\n- **示例:**\n\n  ``` js\n  var mixin = {\n    created: function () { console.log(1) }\n  }\n  var vm = new Vue({\n    created: function () { console.log(2) },\n    mixins: [mixin]\n  })\n  // -> 1\n  // -> 2\n  ```\n\n- **参考：** [混合](../guide/mixins.html)\n\n### name\n\n- **类型:** `string`\n\n- **限制:** 只有作为组件选项时起作用。\n\n- **详细:**\n\n  允许组件模板递归地调用自身。注意，组件在全局用 `Vue.component()` 注册时，全局 ID 自动作为组件的 name。\n\n  指定 `name` 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 [vue-devtools](https://github.com/vuejs/vue-devtools), 未命名组件将显示成 `<AnonymousComponent>`, 这很没有语义。通过提供 `name` 选项，可以获得更有语义信息的组件树。\n\n### extends\n\n- **类型:** `Object | Function`\n\n- **详细:**\n\n  允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数),而无需使用 `Vue.extend`。这主要是为了便于扩展单文件组件。\n\n  这和 `mixins` 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。\n\n- **示例:**\n\n  ``` js\n  var CompA = { ... }\n\n  // 在没有调用 Vue.extend 时候继承 CompA\n  var CompB = {\n    extends: CompA,\n    ...\n  }\n  ```\n\n### delimiters\n\n- **类型:** `Array<string>`\n\n- **默认值:** `{% raw %}[\"{{\", \"}}\"]{% endraw %}`\n\n- **详细:**\n\n 改变纯文本插入分隔符。 **这个选择只有在独立构建时才有用。**\n\n\n- **示例:**\n\n  ``` js\n  new Vue({\n    delimiters: ['${', '}']\n  })\n\n  // 分隔符变成了 ES6 模板字符串的风格\n  ```\n\n### functional\n\n- **类型:** `boolean`\n\n- **详细:**\n\n  使组件无状态（没有 `data` ）和无实例（没有 `this` 上下文）。他们用一个简单的 `render` 函数返回虚拟节点使他们更容易渲染。\n\n- **参考：\n** [函数式组件](../guide/render-function.html#Functional-Components)\n\n## 实例属性\n\n### vm.$data\n\n- **类型:** `Object`\n\n- **详细:**\n\n  Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。\n\n- **另见:** [选项 - data](#data)\n\n### vm.$el\n\n- **类型:** `HTMLElement`\n\n- **只读**\n\n- **详细:**\n\n  Vue 实例使用的根 DOM 元素。\n\n### vm.$options\n\n- **类型:** `Object`\n\n- **只读**\n\n- **详细:**\n\n  用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处：\n\n  ``` js\n  new Vue({\n    customOption: 'foo',\n    created: function () {\n      console.log(this.$options.customOption) // -> 'foo'\n    }\n  })\n  ```\n\n### vm.$parent\n\n- **类型:** `Vue instance`\n\n- **只读**\n\n- **详细:**\n\n  父实例，如果当前实例有的话。\n\n### vm.$root\n\n- **类型:** `Vue instance`\n\n- **只读**\n\n- **详细:**\n\n  当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自已。\n\n### vm.$children\n\n- **类型:** `Array<Vue instance>`\n\n- **只读**\n\n- **详细:**\n\n  当前实例的直接子组件。**需要注意 `$children` 并不保证顺序，也不是响应式的。**如果你发现自己正在尝试使用 `$children` 来进行数据绑定，考虑使用一个数组配合 `v-for` 来生成子组件，并且使用 Array 作为真正的来源。\n\n### vm.$slots\n\n- **类型：** `{ [name: string]: ?Array<VNode> }`\n\n- **只读**\n\n- **详细:**\n\n  用来访问被 [slot 分发](../guide/components.html#Content-Distribution-with-Slots)的内容。每个[具名 slot](../guide/components.html#Named-Slots) 有其相应的属性（例如：`slot=\"foo\"` 中的内容将会在 `vm.$slots.foo` 中被找到）。`default` 属性包括了所有没有被包含在具名 slot 中的节点。\n\n  在使用 [render 函数](../guide/render-function.html)书写一个组件时，访问 `vm.$slots` 最有帮助。\n\n- **示例:**\n\n  ```html\n  <blog-post>\n    <h1 slot=\"header\">\n      About Me\n    </h1>\n\n    <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>\n\n    <p slot=\"footer\">\n      Copyright 2016 Evan You\n    </p>\n\n    <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.\n  </blog-post>\n  ```\n\n  ```js\n  Vue.component('blog-post', {\n    render: function (createElement) {\n      var header = this.$slots.header\n      var body   = this.$slots.default\n      var footer = this.$slots.footer\n      return createElement('div', [\n        createElement('header', header),\n        createElement('main', body),\n        createElement('footer', footer)\n      ])\n    }\n  })\n  ```\n\n- **参考：**\n  - [`<slot>` 组件](#slot-1)\n  - [使用 Slots 进行内容分发](../guide/components.html#Content-Distribution-with-Slots)\n  - [Render 函数](../guide/render-function.html#Slots)\n\n### vm.$scopedSlots\n\n> 2.1.0新增\n\n- **类型：** `{ [name: string]: props => VNode | Array<VNode> }`\n\n- **只读**\n\n- **详细：**\n\n  Used to programmatically access [scoped slots](../guide/components.html#Scoped-Slots). For each slot, including the `default` one, the object contains a corresponding function that returns VNodes.\n\n  Accessing `vm.$scopedSlots` is most useful when writing a component with a [render function](../guide/render-function.html).\n\n- **参考：**\n  - [`<slot>` 组件](#slot-1)\n  - [Scoped Slots](../guide/components.html#Scoped-Slots)\n  - [Render 函数](../guide/render-function.html#Slots)\n\n\n### vm.$refs\n\n- **类型：** `Object`\n\n- **只读**\n\n- **详细：**\n\n  一个对象，其中包含了所有拥有 `ref` 注册的子组件。\n\n- **另见：**\n  - [子组件引用](../guide/components.html#Child-Component-Refs)\n  - [ref](#ref)\n\n### vm.$isServer\n\n- **类型：** `boolean`\n\n- **只读**\n\n- **详细：**\n\n  当前 Vue 实例是否运行于服务器。\n\n- **参考：** [服务端渲染](../guide/ssr.html)\n\n## 实例方法 / 数据\n\n<h3 id=\"vm-watch\">vm.$watch( expOrFn, callback, [options] )</h3>\n\n- **参数：**\n  - `{string | Function} expOrFn`\n  - `{Function} callback`\n  - `{Object} [options]`\n    - `{boolean} deep`\n    - `{boolean} immediate`\n\n- **返回值：** `{Function} unwatch`\n\n- **用法：**\n\n  观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。\n\n  <p class=\"tip\">注意：在变异（不是替换）对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。</p>\n\n- **示例：**\n\n  ``` js\n  // 键路径\n  vm.$watch('a.b.c', function (newVal, oldVal) {\n    // 做点什么\n  })\n\n  // 函数\n  vm.$watch(\n    function () {\n      return this.a + this.b\n    },\n    function (newVal, oldVal) {\n      // 做点什么\n    }\n  )\n  ```\n\n  `vm.$watch` 返回一个取消观察函数，用来停止触发回调：\n\n  ``` js\n  var unwatch = vm.$watch('a', cb)\n  // 之后取消观察\n  unwatch()\n  ```\n\n- **选项：deep**\n\n  为了发现对象内部值的变化，可以在选项参数中指定 `deep: true` 。注意监听数组的变动不需要这么做。\n\n  ``` js\n  vm.$watch('someObject', callback, {\n    deep: true\n  })\n  vm.someObject.nestedValue = 123\n  // callback is fired\n  ```\n\n- **选项：immediate**\n\n  在选项参数中指定 `immediate: true` 将立即以表达式的当前值触发回调：\n\n  ``` js\n  vm.$watch('a', callback, {\n    immediate: true\n  })\n  // 立即以 `a` 的当前值触发回调\n  ```\n\n<h3 id=\"vm-set\">vm.$set( object, key, value )</h3>\n\n- **参数：**\n  - `{Object} object`\n  - `{string} key`\n  - `{any} value`\n\n- **返回值：** 设置的值.\n\n- **用法：**\n\n  这是全局 `Vue.set` 的**别名**。\n\n- **另见：** [Vue.set](#Vue-set)\n\n<h3 id=\"vm-delete\">vm.$delete( object, key )</h3>\n\n- **参数：**\n  - `{Object} object`\n  - `{string} key`\n\n- **用法：**\n\n  这是全局 `Vue.delete` 的**别名**。\n\n- **另见：** [Vue.delete](#Vue-delete)\n\n## 实例方法/事件\n\n<h3 id=\"vm-on\">vm.$on( event, callback )</h3>\n\n- **参数：**\n  - `{string} event`\n  - `{Function} callback`\n\n- **用法：**\n\n  监听当前实例上的自定义事件。事件可以由`vm.$emit`触发。回调函数会接收所有传入事件触发函数的额外参数。\n\n- **示例：**\n\n  ``` js\n  vm.$on('test', function (msg) {\n    console.log(msg)\n  })\n  vm.$emit('test', 'hi')\n  // -> \"hi\"\n  ```\n\n<h3 id=\"vm-once\">vm.$once( event, callback )</h3>\n\n- **参数：**\n  - `{string} event`\n  - `{Function} callback`\n\n- **用法：**\n\n  监听一个自定义事件，但是只触发一次，在第一次触发之移除除监听器。\n\n<h3 id=\"vm-off\">vm.$off( [event, callback] )</h3>\n\n- **参数：**\n  - `{string} [event]`\n  - `{Function} [callback]`\n\n- **用法：**\n\n  移除事件监听器。\n\n  - 如果没有提供参数，则移除所有的事件监听器；\n\n  - 如果只提供了事件，则移除该事件所有的监听器；\n\n  - 如果同时提供了事件与回调，则只移除这个回调的监听器。\n\n<h3 id=\"vm-emit\">vm.$emit( event, [...args] )</h3>\n\n- **参数：**\n  - `{string} event`\n  - `[...args]`\n\n  触发当前实例上的事件。附加参数都会传给监听器回调。\n\n## 实例方法 / 生命周期\n\n<h3 id=\"vm-mount\">vm.$mount( [elementOrSelector] )</h3>\n\n- **参数：**\n  - `{Element | string} [elementOrSelector]`\n  - `{boolean} [hydrating]`\n\n- **返回值：** `vm` - 实例自身\n\n- **用法：**\n\n  如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 `vm.$mount()` 手动地挂载一个未挂载的实例。\n\n  如果没有提供 `elementOrSelector` 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生DOM API把它插入文档中。\n\n  这个方法返回实例自身，因而可以链式调用其它实例方法。\n\n- **示例：**\n\n  ``` js\n  var MyComponent = Vue.extend({\n    template: '<div>Hello!</div>'\n  })\n\n  // 创建并挂载到 #app (会替换 #app)\n  new MyComponent().$mount('#app')\n\n  // 同上\n  new MyComponent({ el: '#app' })\n\n  // 或者，在文档之外渲染并且随后挂载\n  var component = new MyComponent().$mount()\n  document.getElementById('app').appendChild(component.$el)\n  ```\n\n- **参考：**\n  - [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n  - [服务端渲染](../guide/ssr.html)\n\n<h3 id=\"vm-forceUpdate\">vm.$forceUpdate()</h3>\n\n- **示例：**\n\n  迫使Vue实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。\n\n<h3 id=\"vm-nextTick\">vm.$nextTick( [callback] )</h3>\n\n- **参数：**\n  - `{Function} [callback]`\n\n- **用法：**\n\n  将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 `this` 自动绑定到调用它的实例上。\n\n\n > 2.1.0新增：如果没有提供回调且支持 promise 的环境中返回 promise。\n\n- **示例：**\n\n  ``` js\n  new Vue({\n    // ...\n    methods: {\n      // ...\n      example: function () {\n        // 修改数据\n        this.message = 'changed'\n        // DOM 还没有更新\n        this.$nextTick(function () {\n          // DOM 现在更新了\n          // `this` 绑定到当前实例\n          this.doSomethingElse()\n        })\n      }\n    }\n  })\n  ```\n\n- **参考：**\n  - [Vue.nextTick](#Vue-nextTick)\n  - [异步更新队列](../guide/reactivity.html#Async-Update-Queue)\n\n<h3 id=\"vm-destroy\">vm.$destroy()</h3>\n\n- **用法：**\n\n  完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。\n\n  触发 `beforeDestroy` 和 `destroyed` 的钩子。\n\n  <p class=\"tip\">在大多数场景中你不应该调用这个方法。最好使用 `v-if` 和 `v-for` 指令以数据驱动的方式控制子组件的生命周期。</p>\n\n- **参考：** [生命周期图示](../guide/instance.html#Lifecycle-Diagram)\n\n## 指令\n\n### v-text\n\n- **类型：** `string`\n\n- **详细：**\n\n  更新元素的 `textContent`。如果要更新部分的 `textContent` ，需要使用 `{% raw %}{{ Mustache }}{% endraw %}` 插值。\n\n- **示例：**\n\n  ```html\n  <span v-text=\"msg\"></span>\n  <!-- 和下面的一样 -->\n  <span>{{msg}}</span>\n  ```\n\n- **参考：** [数据绑定语法 - 插值](../guide/syntax.html#Text)\n\n### v-html\n\n- **类型：** `string`\n\n- **详细：**\n\n\n  更新元素的 `innerHTML` 。**注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译** 。如果试图使用 `v-html` 组合模板,可以重新考虑通过是否通过使用组件来替代。\n\n  <p class=\"tip\">在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。只在可信内容上使用 `v-html`，**永不**用在用户提交的内容上。</p>\n\n- **示例：**\n\n  ```html\n  <div v-html=\"html\"></div>\n  ```\n- **参考：** [数据绑定语法 - 插值](../guide/syntax.html#Raw-HTML)\n\n### v-show\n\n- **类型：** `any`\n\n- **用法：**\n\n  根据表达式之真假值，切换元素的 `display` CSS 属性。\n\n  当条件变化时该指令触发过渡效果。\n\n- **参考：** [条件渲染 - v-show](../guide/conditional.html#v-show)\n\n### v-if\n\n- **类型：** `any`\n\n- **用法：**\n\n  根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 `<template>` ，将提出它的内容作为条件块。\n\n  当条件变化时该指令触发过渡效果。\n\n- **参考：** [条件渲染 - v-if](../guide/conditional.html)\n\n### v-else\n\n- **不需要表达式**\n\n- **限制：** 前一兄弟元素必须有 `v-if` 或 `v-else-if`。\n\n- **用法：**\n\n  为 `v-if` 或者 `v-else-if` 添加 “else 块”。\n\n  ```html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **参考：**\n  - [条件渲染 - v-else](../guide/conditional.html#v-else)\n\n### v-else-if\n\n> 2.1.0新增\n\n- **Expects:** `any`\n\n- **Restriction:** previous sibling element must have `v-if` or `v-else-if`.\n\n- **Usage:**\n\n  Denote the \"else if block\" for `v-if`. Can be chained.\n\n  ```html\n  <div v-if=\"type === 'A'\">\n    A\n  </div>\n  <div v-else-if=\"type === 'B'\">\n    B\n  </div>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n  <div v-else>\n    Not A/B/C\n  </div>\n  ```\n\n- **See also:** [Conditional Rendering - v-else-if](../guide/conditional.html#v-else-if)\n\n### v-for\n\n- **类型：** `Array | Object | number | string`\n\n- **用法：**\n\n  基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 `alias in expression` ，为当前遍历的元素提供别名：\n\n  ``` html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  另外也可以为数组索引指定别名（或者用于对象的键）：\n\n  ``` html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(val, key) in object\"></div>\n  <div v-for=\"(val, key, index) in object\"></div>\n  ```\n\n  `v-for` 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素,您需要提供一个 `key` 的特殊属性:\n\n  ``` html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  `v-for` 的详细用法可以通过以下链接查看教程详细说明。\n\n- **参考：**\n  - [列表渲染](../guide/list.html)\n  - [key](../guide/list.html#key)\n\n### v-on\n\n- **缩写：** `@`\n\n- **类型：** `Function | Inline Statement`\n\n- **参数：** `event (required)`\n\n- **修饰符：**\n  - `.stop` - 调用 `event.stopPropagation()`。\n  - `.prevent` - 调用 `event.preventDefault()`。\n  - `.capture` - 添加事件侦听器时使用 capture 模式。\n  - `.self` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\n  - `.{keyCode | keyAlias}` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\n  - `.native` - 监听组件根元素的原生事件。\n\n- **用法：**\n\n  绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。\n\n  用在普通元素上时，只能监听 **原生 DOM 事件**。用在自定义元素组件上时，也可以监听子组件触发的**自定义事件**。\n\n  在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 `$event` 属性： `v-on:click=\"handle('ok', $event)\"`。\n\n- **示例：**\n\n  ```html\n  <!-- 方法处理器 -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- 内联语句 -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- 缩写 -->\n  <button @click=\"doThis\"></button>\n\n  <!-- 停止冒泡 -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- 阻止默认行为 -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- 阻止默认行为，没有表达式 -->\n  <form @submit.prevent></form>\n\n  <!--  串联修饰符 -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- 键修饰符，键别名 -->\n  <input @keyup.enter=\"onEnter\">\n\n  <!-- 键修饰符，键代码 -->\n  <input @keyup.13=\"onEnter\">\n  ```\n\n  在子组件上监听自定义事件（当子组件触发 “my-event” 时将调用事件处理器）：\n\n  ```html\n  <my-component @my-event=\"handleThis\"></my-component>\n\n  <!-- 内联语句 -->\n  <my-component @my-event=\"handleThis(123, $event)\"></my-component>\n\n  <!-- 组件中的原生事件 -->\n  <my-component @click.native=\"onClick\"></my-component>\n  ```\n\n- **参考：**\n  - [方法与事件处理器](../guide/events.html)\n  - [组件 - 自定义事件](../guide/components.html#Custom-Events)\n\n### v-bind\n\n- **缩写：** `:`\n\n- **类型：** `any (with argument) | Object (without argument)`\n\n- **参数：** `attrOrProp (optional)`\n\n- **修饰符：**\n  - `.prop` - 被用于绑定 DOM 属性。([what's the difference?](http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028))\n  - `.camel` - transform the kebab-case attribute name into camelCase. (supported since 2.1.0)\n\n- **用法：**\n\n  动态地绑定一个或多个特性，或一个组件 prop 到表达式。\n\n  在绑定 `class` 或 `style` 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。\n\n  在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。\n\n  没有参数时，可以绑定到一个包含键值对的对象。注意此时 `class` 和 `style` 绑定不支持数组和对象。\n\n- **示例：**\n\n  ```html\n  <!-- 绑定一个属性 -->\n  <img v-bind:src=\"imageSrc\">\n\n  <!-- 缩写 -->\n  <img :src=\"imageSrc\">\n  \n  <!-- with inline string concatenation -->\n  <img :src=\"'/path/to/images/' + fileName\">\n\n  <!-- class 绑定 -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\">\n\n  <!-- style 绑定 -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- 绑定一个有属性的对象 -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- 通过 prop 修饰符绑定 DOM 属性 -->\n  <div v-bind:text-content.prop=\"text\"></div>\n\n  <!-- prop 绑定. “prop” 必须在 my-component 中声明。 -->\n  <my-component :prop=\"someThing\"></my-component>\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n  The `.camel` modifier allows camelizing a `v-bind` attribute name when using in-DOM templates, e.g. the SVG `viewBox` attribute:\n\n  ``` html\n  <svg :view-box.camel=\"viewBox\"></svg>\n  ```\n\n  `.camel` is not needed if you are using string templates, or compiling with `vue-loader`/`vueify`.\n\n- **参考：**\n  - [Class 与 Style 绑定](../guide/class-and-style.html)\n  - [组件 - 组件 Props](../guide/components.html#Props)\n\n### v-model\n\n- **类型：** 随表单控件类型不同而不同。\n\n- **限制：**\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **修饰符：**\n  - [`.lazy`](../guide/forms.html#lazy) - 取代 `input` 监听 `change` 事件\n  - [`.number`](../guide/forms.html#number) - 输入字符串转为数字\n  - [`.trim`](../guide/forms.html#trim) - 输入首尾空格过滤\n\n- **用法：**\n\n  在表单控件或者组件上创建双向绑定。细节请看下面链接的教程。\n\n- **参考：**\n  - [表单控件绑定](../guide/forms.html)\n  - [组件 - 在输入组件上使用自定义事件](../guide/components.html#Form-Input-Components-using-Custom-Events)\n\n### v-pre\n\n- **不需要表达式**\n\n- **用法：**\n\n  跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。\n\n- **示例：**\n\n  ```html\n  <span v-pre>{{ this will not be compiled }}</span>\n   ```\n\n### v-cloak\n\n- **不需要表达式**\n\n- **用法：**\n\n  这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 `[v-cloak] { display: none }` 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。\n\n- **示例：**\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  <div> 不会显示，直到编译结束。\n\n### v-once\n\n- **不需要表达式**\n\n- **详细：**\n\n  只渲染元素和组件**一次**。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。\n\n  ```html\n  <!-- 单个元素 -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- 有子元素 -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- 组件 -->\n  <my-component v-once :comment=\"msg\"></my-component>\n  <!-- v-for 指令-->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n- **参考：**\n  - [数据绑定语法- 插值](../guide/syntax.html#Text)\n  - [组件 - 使用 v-once 实现轻量的静态组件](../guide/components.html#Cheap-Static-Components-with-v-once)\n\n## 特殊元素\n\n### key\n\n- **示例：** `string`\n\n  `key` 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。\n\n  有相同父元素的子元素必须有**独特的key**。重复的key会造成渲染错误。\n\n  最常见的用例是结合 `v-for`:\n\n  ``` html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用:\n\n  - 完整地触发组件的生命周期钩子\n  - 触发过渡\n\n  例如:\n\n  ``` html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  当 `text` 发生改变时，`<span>` 会随时被更新，因此会触发过渡。\n\n### ref\n\n- **类型：** `string`\n\n  `ref` 被用来给元素或子组件注册引用信息。引用信息会根据父组件的 `$refs` 对象进行注册。如果在普通的DOM元素上使用，引用信息就是元素; 如果用在子组件上，引用信息就是组件实例:\n\n  ``` html\n  <!-- vm.$refs.p will be the DOM node -->\n  <p ref=\"p\">hello</p>\n\n  <!-- vm.$refs.child will be the child comp instance -->\n  <child-comp ref=\"child\"></child-comp>\n  ```\n\n  当 `v-for` 用于元素或组件的时候，引用信息将是包含DOM节点或组件实例数组。\n\n  关于ref注册时间的重要说明: 因为ref本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！`$refs` 也不是响应式的，因此你不应该试图用它在模版中做数据绑定。\n\n- **参考：** [子组件 Refs](../guide/components.html#Child-Component-Refs)\n\n### slot\n\n- **类型：** `string`\n\n  用于标记往哪个slot中插入子组件内容。\n\n  详细用法，请参考下面指南部分的链接。\n\n- **参考：** [命名 Slots](../guide/components.html#Named-Slots)\n\n## 内置的组件\n\n### component\n\n- **Props：**\n  - `is` - string | ComponentDefinition | ComponentConstructor\n  - `inline-template` - boolean\n\n- **用法：**\n\n  渲染一个“元组件”为动态组件。依 `is` 的值，来决定哪个组件被渲染。\n\n  ```html\n  <!-- 动态组件由 vm 实例的属性值 `componentId` 控制 -->\n  <component :is=\"componentId\"></component>\n\n  <!-- 也能够渲染注册过的组件或 prop 传入的组件 -->\n  <component :is=\"$options.components.child\"></component>\n  ```\n\n- **参考：** [动态组件](../guide/components.html#动态组件)\n\n### transition\n\n- **Props：**\n  - `name` - string, 用于自动生成 CSS 过渡类名。例如：`name: 'fade'` 将自动拓展为`.fade-enter`，`.fade-enter-active`等。默认类名为 `\"v\"`\n  - `appear` - boolean, 是否在初始渲染时使用过渡。默认为 `false`。\n  - `css` - boolean, 是否使用 CSS 过渡类。默认为 `true`。如果设置为 `false`，将只通过组件事件触发注册的 JavaScript 钩子。\n  - `type` - string, 指定过渡事件类型，侦听过渡何时结束。有效值为 `\"transition\"` 和 `\"animation\"`。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。\n  - `mode` - string, 控制离开/进入的过渡时间序列。有效的模式有 `\"out-in\"` 和 `\"in-out\"`；默认同时生效。\n  - `enter-class` - string\n  - `leave-class` - string\n  - `enter-active-class` - string\n  - `leave-active-class` - string\n  - `appear-class` - string\n  - `appear-active-class` - string\n\n- **事件：**\n  - `before-enter`\n  - `enter`\n  - `after-enter`\n  - `before-leave`\n  - `leave`\n  - `after-leave`\n  - `before-appear`\n  - `appear`\n  - `after-appear`\n\n- **用法：**\n\n  `<transition>` 元素作为单个元素/组件的过渡效果。`<transition>` 不会渲染额外的 DOM 元素，也不会出现在检测过的组件层级中。它只是将内容包裹在其中，简单的运用过渡行为。\n\n  ```html\n  <!-- 简单元素 -->\n  <transition>\n    <div v-if=\"ok\">toggled content</div>\n  </transition>\n\n  <!-- 动态组件 -->\n  <transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </transition>\n\n  <!-- 事件钩子 -->\n  <div id=\"transition-demo\">\n    <transition @after-enter=\"transitionComplete\">\n      <div v-show=\"ok\">toggled content</div>\n    </transition>\n  </div>\n  ```\n\n  ``` js\n  new Vue({\n    ...\n    methods: {\n      transitionComplete: function (el) {\n        // 传入 'el' 这个 DOM 元素作为参数。\n      }\n    }\n    ...\n  }).$mount('#transition-demo')\n  ```\n\n- **参考：** [过渡：进入，离开和列表](../guide/transitions.html)\n\n### transition-group\n\n- **Props：**\n  - `tag` - string, 默认为 `span`\n  - `move-class` - 覆盖移动过渡期间应用的 CSS 类。\n  - 除了 `mode`，其他特性和 `<transition>` 相同。\n\n- **事件：**\n  - 事件和 `<transition>` 相同.\n\n- **用法：**\n\n  `<transition-group>` 元素作为多个元素/组件的过渡效果。`<transition-group>` 渲染一个真实的 DOM 元素。默认渲染 `<span>`，可以通过 `tag` 属性配置哪个元素应该被渲染。\n\n  注意，每个 `<transition-group>` 的子节点必须有 **独立的key** ，动画才能正常工作\n\n  `<transition-group>` 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类（通过 `name` 属性或配置 `move-class` 属性自动生成）。如果 CSS `transform` 属性是“可过渡”属性，当应用移动类时，将会使用 [FLIP 技术](https://aerotwist.com/blog/flip-your-animations/) 使元素流畅地到达动画终点。\n\n  ```html\n  <transition-group tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </transition-group>\n  ```\n\n- **参考：** [过渡：进入，离开和列表](../guide/transitions.html)\n\n### keep-alive\n\n- **Props:**\n  - `include` - string or RegExp. Only components matched by this will be cached.\n  - `exclude` - string or RegExp. Any component matched by this will not be cached.\n\n- **用法：**\n\n  `<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n\n  当组件在 `<keep-alive>` 内被切换，它的 `activated` 和 `deactivated` 这两个生命周期钩子函数将会被对应执行。\n\n  主要用于保留组件状态或避免重新渲染。\n\n  ```html\n  <!-- 基本 -->\n  <keep-alive>\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- 多个条件判断的子组件 -->\n  <keep-alive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </keep-alive>\n\n  <!-- 和 <transition> 一起使用 -->\n  <transition>\n    <keep-alive>\n      <component :is=\"view\"></component>\n    </keep-alive>\n  </transition>\n  ```\n\n- **`include` and `exclude`**\n\n  > New in 2.1.0\n\n  The `include` and `exclude` props allow components to be conditionally cached. Both props can either be a comma-delimited string or a RegExp:\n\n  ``` html\n  <!-- comma-delimited string -->\n  <keep-alive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- regex (use v-bind) -->\n  <keep-alive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n  ```\n\n  The match is first checked on the component's own `name` option, then its local registration name (the key in the parent's `components` option) if the `name` option is not available. Anonymous components cannot be matched against.\n\n  <p class=\"tip\">`<keep-alive>` 不会在函数式组件中正常工作，因为它们没有缓存实例。</p>\n\n- **参考：** [动态组件 - keep-alive](../guide/components.html#keep-alive)\n\n### slot\n\n- **Props：**\n  - `name` - string, 用于命名插槽。\n\n- **Usage:**\n\n  `<slot>` 元素作为组件模板之中的内容分发插槽。 `<slot>` 元素自身将被替换。\n\n  详细用法，请参考下面教程的链接。\n\n- **参考：** [使用Slots分发内容](../guide/components.html#使用Slots分发内容)\n\n## VNode接口\n\n- 请参考[VNode class declaration](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).\n\n## 服务端渲染\n\n- 请参考[vue-server-renderer package documentation](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/api/index.html","title":"","comments":1,"layout":"page","_id":"ciwnajuy0000tjl2d2gacgtfn","content":"<h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><p><code>Vue.config</code>  是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：</p>\n<h3 id=\"silent\"><a href=\"#silent\" class=\"headerlink\" title=\"silent\"></a>silent</h3><ul>\n<li><p><strong>类型：</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>默认值：</strong> <code>false</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.silent = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>取消 Vue 所有的日志与警告。</p>\n</li>\n</ul>\n<h3 id=\"optionMergeStrategies\"><a href=\"#optionMergeStrategies\" class=\"headerlink\" title=\"optionMergeStrategies\"></a>optionMergeStrategies</h3><ul>\n<li><p><strong>类型：</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>默认值：</strong> <code>{}</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.optionMergeStrategies._my_option = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">parent, child, vm</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> child + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Profile = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">_my_option</span>: <span class=\"number\">1</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Profile.options._my_option = 2</span></div></pre></td></tr></table></figure>\n<p>自定义合并策略的选项。</p>\n<p>合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入。</p>\n</li>\n<li><p><strong>参考</strong> <a href=\"../guide/mixins.html#Custom-Option-Merge-Strategies\">自定义选项的混合策略</a></p>\n</li>\n</ul>\n<h3 id=\"devtools\"><a href=\"#devtools\" class=\"headerlink\" title=\"devtools\"></a>devtools</h3><ul>\n<li><p><strong>类型：</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>默认值：</strong> <code>true</code> (生产版为 <code>false</code>)</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 务必在加载 Vue 之后，立即同步设置以下内容</span></div><div class=\"line\">Vue.config.devtools = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>配置是否允许 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"external\">vue-devtools</a> 检查代码。开发版本默认为 <code>true</code>，生产版本默认为 <code>false</code>。生产版本设为 <code>true</code> 可以启用检查。</p>\n</li>\n</ul>\n<h3 id=\"errorHandler\"><a href=\"#errorHandler\" class=\"headerlink\" title=\"errorHandler\"></a>errorHandler</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>默认值：</strong> 默认抛出错误</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.errorHandler = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, vm</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p>\n<blockquote>\n<p><a href=\"https://sentry.io\" target=\"_blank\" rel=\"external\">Sentry</a>, an error tracking service, provides <a href=\"https://sentry.io/for/vue/\" target=\"_blank\" rel=\"external\">official integration</a> using this option.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"ignoredElements\"><a href=\"#ignoredElements\" class=\"headerlink\" title=\"ignoredElements\"></a>ignoredElements</h3><ul>\n<li><p><strong>类型:</strong> <code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>默认值:</strong> <code>[]</code></p>\n</li>\n<li><p><strong>用法:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.ignoredElements = [</div><div class=\"line\">  <span class=\"string\">'my-custom-web-component'</span>, <span class=\"string\">'another-web-component'</span></div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>须使 Vue 忽略在 Vue 之外的自定义元素 (e.g., 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 <code>Unknown custom element</code> 的警告。</p>\n</li>\n</ul>\n<h3 id=\"keyCodes\"><a href=\"#keyCodes\" class=\"headerlink\" title=\"keyCodes\"></a>keyCodes</h3><ul>\n<li><p><strong>类型：</strong> <code>{ [key: string]: number | Array&lt;number&gt; }</code></p>\n</li>\n<li><p><strong>默认值：</strong> <code>{}</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.keyCodes = &#123;</div><div class=\"line\">  <span class=\"attr\">v</span>: <span class=\"number\">86</span>,</div><div class=\"line\">  <span class=\"attr\">f1</span>: <span class=\"number\">112</span>,</div><div class=\"line\">  <span class=\"attr\">mediaPlayPause</span>: <span class=\"number\">179</span>,</div><div class=\"line\">  <span class=\"attr\">up</span>: [<span class=\"number\">38</span>, <span class=\"number\">87</span>]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>给 v-on 自定义键位别名。</p>\n</li>\n</ul>\n<h2 id=\"全局-API\"><a href=\"#全局-API\" class=\"headerlink\" title=\"全局 API\"></a>全局 API</h2><h3 id=\"Vue-extend\">Vue.extend( options )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} options</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>\n<p><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code> 中它必须是函数</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mount-point\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建构造器</span></div><div class=\"line\"><span class=\"keyword\">var</span> Profile = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">firstName</span>: <span class=\"string\">'Walter'</span>,</div><div class=\"line\">      <span class=\"attr\">lastName</span>: <span class=\"string\">'White'</span>,</div><div class=\"line\">      <span class=\"attr\">alias</span>: <span class=\"string\">'Heisenberg'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// 创建 Profile 实例，并挂载到一个元素上。</span></div><div class=\"line\"><span class=\"keyword\">new</span> Profile().$mount(<span class=\"string\">'#mount-point'</span>)</div></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Walter White aka Heisenberg<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html\">组件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-nextTick\">Vue.nextTick( [callback, context] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n<li><code>{Object} [context]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 修改数据</span></div><div class=\"line\">vm.msg = <span class=\"string\">'Hello'</span></div><div class=\"line\"><span class=\"comment\">// DOM 还没有更新</span></div><div class=\"line\">Vue.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// DOM 更新了</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>2.1.0新增：如果没有提供回调且支持 promise 的环境中返回 promise。</p>\n</blockquote>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/reactivity.html#Async-Update-Queue\">异步更新队列</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-set\">Vue.set( object, key, value )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>返回值：</strong> 设置的值.</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。</p>\n<p><strong>注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-delete\">Vue.delete( object, key )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。</p>\n<p><strong>注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-directive\">Vue.directive( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>注册或获取全局指令。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册</span></div><div class=\"line\">Vue.directive(<span class=\"string\">'my-directive'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">bind</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">inserted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">update</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">componentUpdated</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">unbind</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 注册（传入一个简单的指令函数）</span></div><div class=\"line\">Vue.directive(<span class=\"string\">'my-directive'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 这里将会被 `bind` 和 `update` 调用</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getter，返回已注册的指令</span></div><div class=\"line\"><span class=\"keyword\">var</span> myDirective = Vue.directive(<span class=\"string\">'my-directive'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/custom-directive.html\">自定义指令</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-filter\">Vue.filter( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>注册或获取全局过滤器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册</span></div><div class=\"line\">Vue.filter(<span class=\"string\">'my-filter'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 返回处理后的值</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getter，返回已注册的过滤器</span></div><div class=\"line\"><span class=\"keyword\">var</span> myFilter = Vue.filter(<span class=\"string\">'my-filter'</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Vue-component\">Vue.component( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>注册或获取全局组件。注册还会自动使用给定的<code>id</code>设置组件的名称</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册组件，传入一个扩展过的构造器</span></div><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, Vue.extend(&#123; <span class=\"comment\">/* ... */</span> &#125;))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 注册组件，传入一个选项对象（自动调用 Vue.extend）</span></div><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123; <span class=\"comment\">/* ... */</span> &#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取注册的组件（始终返回构造器）</span></div><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = Vue.component(<span class=\"string\">'my-component'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html\">组件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-use\">Vue.use( plugin )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object | Function} plugin</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>安装 Vue.js 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 install 方法。install 方法将被作为 Vue 的参数调用。</p>\n<p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/plugins.html\">插件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-mixin\">Vue.mixin( mixin )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} mixin</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>全局注册一个混合，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混合，向组件注入自定义的行为。<strong>不推荐在应用代码中使用</strong>。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/mixins.html#Global-Mixin\">全局混合</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-compile\">Vue.compile( template )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} template</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>在render函数中编译模板字符串。<strong>只在独立构建时有效</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res = Vue.compile(<span class=\"string\">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">msg</span>: <span class=\"string\">'hello'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">render</span>: res.render,</div><div class=\"line\">  <span class=\"attr\">staticRenderFns</span>: res.staticRenderFns</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/render-function.html\">Render 函数</a></p>\n</li>\n</ul>\n<h2 id=\"选项-数据\"><a href=\"#选项-数据\" class=\"headerlink\" title=\"选项 / 数据\"></a>选项 / 数据</h2><h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><ul>\n<li><p><strong>类型：</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>限制:</strong> 组件的定义只接受 <code>function</code>。</p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。<strong>对象必须是纯粹的对象(含有零个或多个的key/value对)</strong>：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</p>\n<p>一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p>\n<p>实例创建之后，可以通过 <code>vm.$data</code> 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 <code>vm.a</code> 等价于访问 <code>vm.$data.a</code>。</p>\n<p>以 <code>_</code> 或 <code>$</code> 开头的属性 <strong>不会</strong> 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、 API 方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性。</p>\n<p>当一个<strong>组件</strong>被定义， <code>data</code> 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 <code>data</code> 仍然是一个纯粹的对象，则所有的实例将<strong>共享引用</strong>同一个数据对象！通过提供 <code>data</code> 函数，每次创建一个新实例后，我们能够调用 <code>data</code> 函数，从而返回初始数据的一个全新副本数据对象。</p>\n<p>如果需要，可以通过将 <code>vm.$data</code> 传入 <code>JSON.parse(JSON.stringify(...))</code> 得到深拷贝的原始数据对象。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 直接创建一个实例</span></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: data</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.a <span class=\"comment\">// -&gt; 1</span></div><div class=\"line\">vm.$data === data <span class=\"comment\">// -&gt; true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Vue.extend() 中 data 必须是函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> Component = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">注意，<strong>不应该对 <code>data</code> 属性使用箭头函数</strong> (例如<code>data: () =&gt; { return { a: this.myProp }}</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，<code>this.myProp</code> 将是 undefined。</p>\n</li>\n<li><p><strong>参考:</strong> <a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><ul>\n<li><p><strong>类型:</strong> <code>Array&lt;string&gt; | Object</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 简单语法</span></div><div class=\"line\">Vue.component(<span class=\"string\">'props-demo-simple'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'size'</span>, <span class=\"string\">'myMessage'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对象语法，提供校验</span></div><div class=\"line\">Vue.component(<span class=\"string\">'props-demo-advanced'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 只检测类型</span></div><div class=\"line\">    height: <span class=\"built_in\">Number</span>,</div><div class=\"line\">    <span class=\"comment\">// 检测类型 + 其他验证</span></div><div class=\"line\">    age: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">default</span>: <span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"attr\">validator</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value &gt;= <span class=\"number\">0</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考:</strong> <a href=\"../guide/components.html#Props\">Props</a></p>\n</li>\n</ul>\n<h3 id=\"propsData\"><a href=\"#propsData\" class=\"headerlink\" title=\"propsData\"></a>propsData</h3><ul>\n<li><p><strong>类型:</strong> <code>{ [key: string]: any }</code></p>\n</li>\n<li><p><strong>限制:</strong> 只用于 <code>new</code> 创建的实例中。</p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>创建实例时传递 props。主要作用是方便测试。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Comp = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'msg'</span>],</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Comp(&#123;</div><div class=\"line\">  <span class=\"attr\">propsData</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">msg</span>: <span class=\"string\">'hello'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考:</strong> <a href=\"../guide/components.html#Props\">Props</a></p>\n</li>\n</ul>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><ul>\n<li><p><strong>类型:</strong> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>\n<p class=\"tip\">注意，<strong>不应该使用箭头函数来定义计算属性函数</strong> (例如 <code>aDouble: () =&gt; this.a * 2</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p>\n\n<p>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 仅读取，值只须为函数</span></div><div class=\"line\">    aDouble: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a * <span class=\"number\">2</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 读取和设置</span></div><div class=\"line\">    aPlus: &#123;</div><div class=\"line\">      <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"number\">1</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"attr\">set</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.a = v - <span class=\"number\">1</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.aPlus   <span class=\"comment\">// -&gt; 2</span></div><div class=\"line\">vm.aPlus = <span class=\"number\">3</span></div><div class=\"line\">vm.a       <span class=\"comment\">// -&gt; 2</span></div><div class=\"line\">vm.aDouble <span class=\"comment\">// -&gt; 4</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>另见:</strong></p>\n<ul>\n<li><a href=\"../guide/computed.html\">计算属性</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><ul>\n<li><p><strong>类型:</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 Vue 实例。</p>\n<p class=\"tip\">注意，<strong>不应该使用箭头函数来定义 method 函数</strong> (例如 <code>plus: () =&gt; this.a++</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">plus</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.a++</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.plus()</div><div class=\"line\">vm.a <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考:</strong> <a href=\"../guide/events.html\">方法与事件处理器</a></p>\n</li>\n</ul>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><ul>\n<li><p><strong>类型:</strong> <code>{ [key: string]: string | Function | Object }</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个属性。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"attr\">c</span>: <span class=\"number\">3</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val, oldVal</span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'new: %s, old: %s'</span>, val, oldVal)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 方法名</span></div><div class=\"line\">    b: <span class=\"string\">'someMethod'</span>,</div><div class=\"line\">    <span class=\"comment\">// 深度 watcher</span></div><div class=\"line\">    c: &#123;</div><div class=\"line\">      <span class=\"attr\">handler</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val, oldVal</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">      <span class=\"attr\">deep</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.a = <span class=\"number\">2</span> <span class=\"comment\">// -&gt; new: 2, old: 1</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">注意，<strong>不应该使用箭头函数来定义 watcher 函数</strong> (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.updateAutocomplete</code> 将是 undefined。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"#vm-watch\">实例方法 - vm.$watch</a></p>\n</li>\n</ul>\n<h2 id=\"选项-DOM\"><a href=\"#选项-DOM\" class=\"headerlink\" title=\"选项 / DOM\"></a>选项 / DOM</h2><h3 id=\"el\"><a href=\"#el\" class=\"headerlink\" title=\"el\"></a>el</h3><ul>\n<li><p><strong>类型：</strong> <code>string | HTMLElement</code></p>\n</li>\n<li><p><strong>限制：</strong> 只在由 <code>new</code> 创建的实例中遵守。</p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p>\n<p>在实例挂载之后， 元素可以用 <code>vm.$el</code> 访问。</p>\n<p>如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 <code>vm.$mount()</code> 手动开启编译。</p>\n<p class=\"tip\"> 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载root实例到 <code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code> 上。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h3><ul>\n<li><p><strong>类型：</strong> <code>string</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>一个字符串模板作为 Vue 实例的标识使用。模板将会 <strong>替换</strong> 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发 slot。</p>\n<p>如果值以 <code>#</code> 开始，则它用作选项符，将使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 包含模板。</p>\n<p class=\"tip\">出于安全考虑，您应该只使用您信任的 Vue 模板。避免使用其他人生成的内容作为您的模板。</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">内容分发</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。render 函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>。</p>\n<p>如果组件是一个函数组件，Render 函数还会接收一个额外的 <code>context</code> 参数，为没有实例的函数组件提供上下文信息。</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/render-function.html\">Render 函数</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选项-生命周期钩子\"><a href=\"#选项-生命周期钩子\" class=\"headerlink\" title=\"选项 / 生命周期钩子\"></a>选项 / 生命周期钩子</h2><p>所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 <strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同， <code>this.fetchTodos</code> 的行为未定义。</p>\n<h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</p>\n<p>你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>\n<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>keep-alive 组件激活时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">构建组件 - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">动态组件 - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>keep-alive 组件停用时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">构建组件 - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">动态组件 - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h2 id=\"选项-资源\"><a href=\"#选项-资源\" class=\"headerlink\" title=\"选项 / 资源\"></a>选项 / 资源</h2><h3 id=\"directives\"><a href=\"#directives\" class=\"headerlink\" title=\"directives\"></a>directives</h3><ul>\n<li><p><strong>类型:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n</li>\n</ul>\n<p>包含 Vue 实例可用指令的哈希表。</p>\n<ul>\n<li><strong>参考：</strong><ul>\n<li><a href=\"../guide/custom-directive.html\">自定义指令</a></li>\n<li><a href=\"../guide/components.html#Assets-Naming-Convention\">资源命名约定</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"filters\"><a href=\"#filters\" class=\"headerlink\" title=\"filters\"></a>filters</h3><ul>\n<li><p><strong>类型:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n</li>\n</ul>\n<p>包含 Vue 实例可用过滤器的哈希表。</p>\n<ul>\n<li><strong>另见:</strong><ul>\n<li><a href=\"#Vue-filter\"><code>Vue.filter</code></a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"components\"><a href=\"#components\" class=\"headerlink\" title=\"components\"></a>components</h3><ul>\n<li><p><strong>类型:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n</li>\n</ul>\n<p>包含 Vue 实例可用组件的哈希表。</p>\n<ul>\n<li><strong>参考：</strong><ul>\n<li><a href=\"../guide/components.html\">组件</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选项-杂项\"><a href=\"#选项-杂项\" class=\"headerlink\" title=\"选项 / 杂项\"></a>选项 / 杂项</h2><h3 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h3><ul>\n<li><p><strong>类型:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。</p>\n<p class=\"tip\">同时使用 <code>$parent</code> 和 <code>$children</code> 有冲突 - 他们作为同一个入口 。更推荐用 props 和 events 实现父子组件通信</p>\n\n</li>\n</ul>\n<h3 id=\"mixins\"><a href=\"#mixins\" class=\"headerlink\" title=\"mixins\"></a>mixins</h3><ul>\n<li><p><strong>类型:</strong> <code>Array&lt;Object&gt;</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p><code>mixins</code> 选项接受一个混合对象的数组。这些混合实例对象可以像正常的实例对象一样包含选项,他们将在 <code>Vue.extend()</code> 里最终选择使用相同的选项合并逻辑合并。举例：如果你混合包含一个钩子而创建组件本身也有一个,两个函数将被调用。<br>Mixin钩子按照传入顺序依次调用,并在调用组件自身的钩子之前被调用。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>) &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>) &#125;,</div><div class=\"line\">  <span class=\"attr\">mixins</span>: [mixin]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// -&gt; 1</span></div><div class=\"line\"><span class=\"comment\">// -&gt; 2</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/mixins.html\">混合</a></p>\n</li>\n</ul>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><ul>\n<li><p><strong>类型:</strong> <code>string</code></p>\n</li>\n<li><p><strong>限制:</strong> 只有作为组件选项时起作用。</p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>允许组件模板递归地调用自身。注意，组件在全局用 <code>Vue.component()</code> 注册时，全局 ID 自动作为组件的 name。</p>\n<p>指定 <code>name</code> 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"external\">vue-devtools</a>, 未命名组件将显示成 <code>&lt;AnonymousComponent&gt;</code>, 这很没有语义。通过提供 <code>name</code> 选项，可以获得更有语义信息的组件树。</p>\n</li>\n</ul>\n<h3 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h3><ul>\n<li><p><strong>类型:</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数),而无需使用 <code>Vue.extend</code>。这主要是为了便于扩展单文件组件。</p>\n<p>这和 <code>mixins</code> 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CompA = &#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在没有调用 Vue.extend 时候继承 CompA</span></div><div class=\"line\"><span class=\"keyword\">var</span> CompB = &#123;</div><div class=\"line\">  <span class=\"attr\">extends</span>: CompA,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"delimiters\"><a href=\"#delimiters\" class=\"headerlink\" title=\"delimiters\"></a>delimiters</h3><ul>\n<li><p><strong>类型:</strong> <code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>默认值:</strong> <code>[\"{{\", \"}}\"]</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>改变纯文本插入分隔符。 <strong>这个选择只有在独立构建时才有用。</strong></p>\n</li>\n</ul>\n<ul>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">delimiters</span>: [<span class=\"string\">'$&#123;'</span>, <span class=\"string\">'&#125;'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 分隔符变成了 ES6 模板字符串的风格</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"functional\"><a href=\"#functional\" class=\"headerlink\" title=\"functional\"></a>functional</h3><ul>\n<li><p><strong>类型:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>使组件无状态（没有 <code>data</code> ）和无实例（没有 <code>this</code> 上下文）。他们用一个简单的 <code>render</code> 函数返回虚拟节点使他们更容易渲染。</p>\n</li>\n<li><p><strong>参考：\n</strong> <a href=\"../guide/render-function.html#Functional-Components\">函数式组件</a></p>\n</li>\n</ul>\n<h2 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h2><h3 id=\"vm-data\"><a href=\"#vm-data\" class=\"headerlink\" title=\"vm.$data\"></a>vm.$data</h3><ul>\n<li><p><strong>类型:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。</p>\n</li>\n<li><p><strong>另见:</strong> <a href=\"#data\">选项 - data</a></p>\n</li>\n</ul>\n<h3 id=\"vm-el\"><a href=\"#vm-el\" class=\"headerlink\" title=\"vm.$el\"></a>vm.$el</h3><ul>\n<li><p><strong>类型:</strong> <code>HTMLElement</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>Vue 实例使用的根 DOM 元素。</p>\n</li>\n</ul>\n<h3 id=\"vm-options\"><a href=\"#vm-options\" class=\"headerlink\" title=\"vm.$options\"></a>vm.$options</h3><ul>\n<li><p><strong>类型:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">customOption</span>: <span class=\"string\">'foo'</span>,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$options.customOption) <span class=\"comment\">// -&gt; 'foo'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-parent\"><a href=\"#vm-parent\" class=\"headerlink\" title=\"vm.$parent\"></a>vm.$parent</h3><ul>\n<li><p><strong>类型:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>父实例，如果当前实例有的话。</p>\n</li>\n</ul>\n<h3 id=\"vm-root\"><a href=\"#vm-root\" class=\"headerlink\" title=\"vm.$root\"></a>vm.$root</h3><ul>\n<li><p><strong>类型:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自已。</p>\n</li>\n</ul>\n<h3 id=\"vm-children\"><a href=\"#vm-children\" class=\"headerlink\" title=\"vm.$children\"></a>vm.$children</h3><ul>\n<li><p><strong>类型:</strong> <code>Array&lt;Vue instance&gt;</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>当前实例的直接子组件。<strong>需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。</strong>如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。</p>\n</li>\n</ul>\n<h3 id=\"vm-slots\"><a href=\"#vm-slots\" class=\"headerlink\" title=\"vm.$slots\"></a>vm.$slots</h3><ul>\n<li><p><strong>类型：</strong> <code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>用来访问被 <a href=\"../guide/components.html#Content-Distribution-with-Slots\">slot 分发</a>的内容。每个<a href=\"../guide/components.html#Named-Slots\">具名 slot</a> 有其相应的属性（例如：<code>slot=&quot;foo&quot;</code> 中的内容将会在 <code>vm.$slots.foo</code> 中被找到）。<code>default</code> 属性包括了所有没有被包含在具名 slot 中的节点。</p>\n<p>在使用 <a href=\"../guide/render-function.html\">render 函数</a>书写一个组件时，访问 <code>vm.$slots</code> 最有帮助。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">blog-post</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"header\"</span>&gt;</span></div><div class=\"line\">    About Me</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"footer\"</span>&gt;</span></div><div class=\"line\">    Copyright 2016 Evan You</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>.</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'blog-post'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> header = <span class=\"keyword\">this</span>.$slots.header</div><div class=\"line\">    <span class=\"keyword\">var</span> body   = <span class=\"keyword\">this</span>.$slots.default</div><div class=\"line\">    <span class=\"keyword\">var</span> footer = <span class=\"keyword\">this</span>.$slots.footer</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, [</div><div class=\"line\">      createElement(<span class=\"string\">'header'</span>, header),</div><div class=\"line\">      createElement(<span class=\"string\">'main'</span>, body),</div><div class=\"line\">      createElement(<span class=\"string\">'footer'</span>, footer)</div><div class=\"line\">    ])</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"#slot-1\"><code>&lt;slot&gt;</code> 组件</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">使用 Slots 进行内容分发</a></li>\n<li><a href=\"../guide/render-function.html#Slots\">Render 函数</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-scopedSlots\"><a href=\"#vm-scopedSlots\" class=\"headerlink\" title=\"vm.$scopedSlots\"></a>vm.$scopedSlots</h3><blockquote>\n<p>2.1.0新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型：</strong> <code>{ [name: string]: props =&gt; VNode | Array&lt;VNode&gt; }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>Used to programmatically access <a href=\"../guide/components.html#Scoped-Slots\">scoped slots</a>. For each slot, including the <code>default</code> one, the object contains a corresponding function that returns VNodes.</p>\n<p>Accessing <code>vm.$scopedSlots</code> is most useful when writing a component with a <a href=\"../guide/render-function.html\">render function</a>.</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"#slot-1\"><code>&lt;slot&gt;</code> 组件</a></li>\n<li><a href=\"../guide/components.html#Scoped-Slots\">Scoped Slots</a></li>\n<li><a href=\"../guide/render-function.html#Slots\">Render 函数</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-refs\"><a href=\"#vm-refs\" class=\"headerlink\" title=\"vm.$refs\"></a>vm.$refs</h3><ul>\n<li><p><strong>类型：</strong> <code>Object</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>一个对象，其中包含了所有拥有 <code>ref</code> 注册的子组件。</p>\n</li>\n<li><p><strong>另见：</strong></p>\n<ul>\n<li><a href=\"../guide/components.html#Child-Component-Refs\">子组件引用</a></li>\n<li><a href=\"#ref\">ref</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-isServer\"><a href=\"#vm-isServer\" class=\"headerlink\" title=\"vm.$isServer\"></a>vm.$isServer</h3><ul>\n<li><p><strong>类型：</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>当前 Vue 实例是否运行于服务器。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/ssr.html\">服务端渲染</a></p>\n</li>\n</ul>\n<h2 id=\"实例方法-数据\"><a href=\"#实例方法-数据\" class=\"headerlink\" title=\"实例方法 / 数据\"></a>实例方法 / 数据</h2><h3 id=\"vm-watch\">vm.$watch( expOrFn, callback, [options] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string | Function} expOrFn</code></li>\n<li><code>{Function} callback</code></li>\n<li><code>{Object} [options]</code><ul>\n<li><code>{boolean} deep</code></li>\n<li><code>{boolean} immediate</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>返回值：</strong> <code>{Function} unwatch</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p>\n<p class=\"tip\">注意：在变异（不是替换）对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 键路径</span></div><div class=\"line\">vm.$watch(<span class=\"string\">'a.b.c'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 做点什么</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 函数</span></div><div class=\"line\">vm.$watch(</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"keyword\">this</span>.b</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 做点什么</span></div><div class=\"line\">  &#125;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p><code>vm.$watch</code> 返回一个取消观察函数，用来停止触发回调：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> unwatch = vm.$watch(<span class=\"string\">'a'</span>, cb)</div><div class=\"line\"><span class=\"comment\">// 之后取消观察</span></div><div class=\"line\">unwatch()</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>选项：deep</strong></p>\n<p>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code> 。注意监听数组的变动不需要这么做。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$watch(<span class=\"string\">'someObject'</span>, callback, &#123;</div><div class=\"line\">  <span class=\"attr\">deep</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;)</div><div class=\"line\">vm.someObject.nestedValue = <span class=\"number\">123</span></div><div class=\"line\"><span class=\"comment\">// callback is fired</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>选项：immediate</strong></p>\n<p>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$watch(<span class=\"string\">'a'</span>, callback, &#123;</div><div class=\"line\">  <span class=\"attr\">immediate</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// 立即以 `a` 的当前值触发回调</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-set\">vm.$set( object, key, value )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>返回值：</strong> 设置的值.</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>这是全局 <code>Vue.set</code> 的<strong>别名</strong>。</p>\n</li>\n<li><p><strong>另见：</strong> <a href=\"#Vue-set\">Vue.set</a></p>\n</li>\n</ul>\n<h3 id=\"vm-delete\">vm.$delete( object, key )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>这是全局 <code>Vue.delete</code> 的<strong>别名</strong>。</p>\n</li>\n<li><p><strong>另见：</strong> <a href=\"#Vue-delete\">Vue.delete</a></p>\n</li>\n</ul>\n<h2 id=\"实例方法-事件\"><a href=\"#实例方法-事件\" class=\"headerlink\" title=\"实例方法/事件\"></a>实例方法/事件</h2><h3 id=\"vm-on\">vm.$on( event, callback )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>监听当前实例上的自定义事件。事件可以由<code>vm.$emit</code>触发。回调函数会接收所有传入事件触发函数的额外参数。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$on(<span class=\"string\">'test'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(msg)</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.$emit(<span class=\"string\">'test'</span>, <span class=\"string\">'hi'</span>)</div><div class=\"line\"><span class=\"comment\">// -&gt; \"hi\"</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-once\">vm.$once( event, callback )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>监听一个自定义事件，但是只触发一次，在第一次触发之移除除监听器。</p>\n</li>\n</ul>\n<h3 id=\"vm-off\">vm.$off( [event, callback] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} [event]</code></li>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>移除事件监听器。</p>\n<ul>\n<li><p>如果没有提供参数，则移除所有的事件监听器；</p>\n</li>\n<li><p>如果只提供了事件，则移除该事件所有的监听器；</p>\n</li>\n<li><p>如果同时提供了事件与回调，则只移除这个回调的监听器。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-emit\">vm.$emit( event, […args] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>[...args]</code></li>\n</ul>\n<p>触发当前实例上的事件。附加参数都会传给监听器回调。</p>\n</li>\n</ul>\n<h2 id=\"实例方法-生命周期\"><a href=\"#实例方法-生命周期\" class=\"headerlink\" title=\"实例方法 / 生命周期\"></a>实例方法 / 生命周期</h2><h3 id=\"vm-mount\">vm.$mount( [elementOrSelector] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Element | string} [elementOrSelector]</code></li>\n<li><code>{boolean} [hydrating]</code></li>\n</ul>\n</li>\n<li><p><strong>返回值：</strong> <code>vm</code> - 实例自身</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 <code>vm.$mount()</code> 手动地挂载一个未挂载的实例。</p>\n<p>如果没有提供 <code>elementOrSelector</code> 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生DOM API把它插入文档中。</p>\n<p>这个方法返回实例自身，因而可以链式调用其它实例方法。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;Hello!&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建并挂载到 #app (会替换 #app)</span></div><div class=\"line\"><span class=\"keyword\">new</span> MyComponent().$mount(<span class=\"string\">'#app'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 同上</span></div><div class=\"line\"><span class=\"keyword\">new</span> MyComponent(&#123; <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span> &#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 或者，在文档之外渲染并且随后挂载</span></div><div class=\"line\"><span class=\"keyword\">var</span> component = <span class=\"keyword\">new</span> MyComponent().$mount()</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>).appendChild(component.$el)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></li>\n<li><a href=\"../guide/ssr.html\">服务端渲染</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-forceUpdate\">vm.$forceUpdate()</h3>\n\n<ul>\n<li><p><strong>示例：</strong></p>\n<p>迫使Vue实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>\n</li>\n</ul>\n<h3 id=\"vm-nextTick\">vm.$nextTick( [callback] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 <code>this</code> 自动绑定到调用它的实例上。</p>\n</li>\n</ul>\n<blockquote>\n<p>2.1.0新增：如果没有提供回调且支持 promise 的环境中返回 promise。</p>\n</blockquote>\n<ul>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    example: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 修改数据</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.message = <span class=\"string\">'changed'</span></div><div class=\"line\">      <span class=\"comment\">// DOM 还没有更新</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// DOM 现在更新了</span></div><div class=\"line\">        <span class=\"comment\">// `this` 绑定到当前实例</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.doSomethingElse()</div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"#Vue-nextTick\">Vue.nextTick</a></li>\n<li><a href=\"../guide/reactivity.html#Async-Update-Queue\">异步更新队列</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-destroy\">vm.$destroy()</h3>\n\n<ul>\n<li><p><strong>用法：</strong></p>\n<p>完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。</p>\n<p>触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子。</p>\n<p class=\"tip\">在大多数场景中你不应该调用这个方法。最好使用 <code>v-if</code> 和 <code>v-for</code> 指令以数据驱动的方式控制子组件的生命周期。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><h3 id=\"v-text\"><a href=\"#v-text\" class=\"headerlink\" title=\"v-text\"></a>v-text</h3><ul>\n<li><p><strong>类型：</strong> <code>string</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>更新元素的 <code>textContent</code>。如果要更新部分的 <code>textContent</code> ，需要使用 <code>{{ Mustache }}</code> 插值。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-text</span>=<span class=\"string\">\"msg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 和下面的一样 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/syntax.html#Text\">数据绑定语法 - 插值</a></p>\n</li>\n</ul>\n<h3 id=\"v-html\"><a href=\"#v-html\" class=\"headerlink\" title=\"v-html\"></a>v-html</h3><ul>\n<li><p><strong>类型：</strong> <code>string</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n</li>\n</ul>\n<p>  更新元素的 <code>innerHTML</code> 。<strong>注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong> 。如果试图使用 <code>v-html</code> 组合模板,可以重新考虑通过是否通过使用组件来替代。</p>\n  <p class=\"tip\">在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"external\">XSS 攻击</a>。只在可信内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上。</p>\n\n<ul>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/syntax.html#Raw-HTML\">数据绑定语法 - 插值</a></p>\n</li>\n</ul>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><ul>\n<li><p><strong>类型：</strong> <code>any</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>根据表达式之真假值，切换元素的 <code>display</code> CSS 属性。</p>\n<p>当条件变化时该指令触发过渡效果。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/conditional.html#v-show\">条件渲染 - v-show</a></p>\n</li>\n</ul>\n<h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><ul>\n<li><p><strong>类型：</strong> <code>any</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <code>&lt;template&gt;</code> ，将提出它的内容作为条件块。</p>\n<p>当条件变化时该指令触发过渡效果。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/conditional.html\">条件渲染 - v-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a>v-else</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>限制：</strong> 前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>为 <code>v-if</code> 或者 <code>v-else-if</code> 添加 “else 块”。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"Math.random() &gt; 0.5\"</span>&gt;</span></div><div class=\"line\">  Now you see me</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  Now you don't</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/conditional.html#v-else\">条件渲染 - v-else</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-else-if\"><a href=\"#v-else-if\" class=\"headerlink\" title=\"v-else-if\"></a>v-else-if</h3><blockquote>\n<p>2.1.0新增</p>\n</blockquote>\n<ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Denote the “else if block” for <code>v-if</code>. Can be chained.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"type === 'A'\"</span>&gt;</span></div><div class=\"line\">  A</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'B'\"</span>&gt;</span></div><div class=\"line\">  B</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'C'\"</span>&gt;</span></div><div class=\"line\">  C</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  Not A/B/C</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html#v-else-if\">Conditional Rendering - v-else-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h3><ul>\n<li><p><strong>类型：</strong> <code>Array | Object | number | string</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias in expression</code> ，为当前遍历的元素提供别名：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; item.text &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>另外也可以为数组索引指定别名（或者用于对象的键）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(val, key) in object\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(val, key, index) in object\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>v-for</code> 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素,您需要提供一个 <code>key</code> 的特殊属性:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; item.text &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>v-for</code> 的详细用法可以通过以下链接查看教程详细说明。</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/list.html\">列表渲染</a></li>\n<li><a href=\"../guide/list.html#key\">key</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h3><ul>\n<li><p><strong>缩写：</strong> <code>@</code></p>\n</li>\n<li><p><strong>类型：</strong> <code>Function | Inline Statement</code></p>\n</li>\n<li><p><strong>参数：</strong> <code>event (required)</code></p>\n</li>\n<li><p><strong>修饰符：</strong></p>\n<ul>\n<li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li>\n<li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li>\n<li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li>\n<li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>\n<li><code>.{keyCode | keyAlias}</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>\n<li><code>.native</code> - 监听组件根元素的原生事件。</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p>\n<p>用在普通元素上时，只能监听 <strong>原生 DOM 事件</strong>。用在自定义元素组件上时，也可以监听子组件触发的<strong>自定义事件</strong>。</p>\n<p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 <code>$event</code> 属性： <code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 方法处理器 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 内联语句 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doThat('hello', $event)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 缩写 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 停止冒泡 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.stop</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 阻止默认行为 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.prevent</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> @<span class=\"attr\">submit.prevent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!--  串联修饰符 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.stop.prevent</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 键修饰符，键别名 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.enter</span>=<span class=\"string\">\"onEnter\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 键修饰符，键代码 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.13</span>=<span class=\"string\">\"onEnter\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在子组件上监听自定义事件（当子组件触发 “my-event” 时将调用事件处理器）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">my-event</span>=<span class=\"string\">\"handleThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 内联语句 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">my-event</span>=<span class=\"string\">\"handleThis(123, $event)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 组件中的原生事件 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">click.native</span>=<span class=\"string\">\"onClick\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/events.html\">方法与事件处理器</a></li>\n<li><a href=\"../guide/components.html#Custom-Events\">组件 - 自定义事件</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h3><ul>\n<li><p><strong>缩写：</strong> <code>:</code></p>\n</li>\n<li><p><strong>类型：</strong> <code>any (with argument) | Object (without argument)</code></p>\n</li>\n<li><p><strong>参数：</strong> <code>attrOrProp (optional)</code></p>\n</li>\n<li><p><strong>修饰符：</strong></p>\n<ul>\n<li><code>.prop</code> - 被用于绑定 DOM 属性。(<a href=\"http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028\" target=\"_blank\" rel=\"external\">what’s the difference?</a>)</li>\n<li><code>.camel</code> - transform the kebab-case attribute name into camelCase. (supported since 2.1.0)</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>动态地绑定一个或多个特性，或一个组件 prop 到表达式。</p>\n<p>在绑定 <code>class</code> 或 <code>style</code> 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</p>\n<p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p>\n<p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 <code>class</code> 和 <code>style</code> 绑定不支持数组和对象。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 绑定一个属性 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">v-bind:src</span>=<span class=\"string\">\"imageSrc\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 缩写 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:src</span>=<span class=\"string\">\"imageSrc\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- with inline string concatenation --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:src</span>=<span class=\"string\">\"'/path/to/images/' + fileName\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- class 绑定 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"&#123; red: isRed &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"[classA, classB]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"[classA, &#123; classB: isB, classC: isC &#125;]\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- style 绑定 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123; fontSize: size + 'px' &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"[styleObjectA, styleObjectB]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 绑定一个有属性的对象 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind</span>=<span class=\"string\">\"&#123; id: someProp, 'other-attr': otherProp &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:text-content.prop</span>=<span class=\"string\">\"text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- prop 绑定. “prop” 必须在 my-component 中声明。 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">:prop</span>=<span class=\"string\">\"someThing\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- XLink --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:xlink:special</span>=<span class=\"string\">\"foo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>The <code>.camel</code> modifier allows camelizing a <code>v-bind</code> attribute name when using in-DOM templates, e.g. the SVG <code>viewBox</code> attribute:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">:view-box.camel</span>=<span class=\"string\">\"viewBox\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>.camel</code> is not needed if you are using string templates, or compiling with <code>vue-loader</code>/<code>vueify</code>.</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/class-and-style.html\">Class 与 Style 绑定</a></li>\n<li><a href=\"../guide/components.html#Props\">组件 - 组件 Props</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h3><ul>\n<li><p><strong>类型：</strong> 随表单控件类型不同而不同。</p>\n</li>\n<li><p><strong>限制：</strong></p>\n<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li>components</li>\n</ul>\n</li>\n<li><p><strong>修饰符：</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html#lazy\"><code>.lazy</code></a> - 取代 <code>input</code> 监听 <code>change</code> 事件</li>\n<li><a href=\"../guide/forms.html#number\"><code>.number</code></a> - 输入字符串转为数字</li>\n<li><a href=\"../guide/forms.html#trim\"><code>.trim</code></a> - 输入首尾空格过滤</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>在表单控件或者组件上创建双向绑定。细节请看下面链接的教程。</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html\">表单控件绑定</a></li>\n<li><a href=\"../guide/components.html#Form-Input-Components-using-Custom-Events\">组件 - 在输入组件上使用自定义事件</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-pre\"><a href=\"#v-pre\" class=\"headerlink\" title=\"v-pre\"></a>v-pre</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-attr\">[v-cloak]</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: none;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-cloak</span>&gt;</span></div><div class=\"line\">  &#123;&#123; message &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><div> 不会显示，直到编译结束。</div></p>\n</li>\n</ul>\n<h3 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>只渲染元素和组件<strong>一次</strong>。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 单个元素 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 有子元素 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-once</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>comment<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 组件 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-once</span> <span class=\"attr\">:comment</span>=<span class=\"string\">\"msg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- v-for 指令--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"i in list\"</span> <span class=\"attr\">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/syntax.html#Text\">数据绑定语法- 插值</a></li>\n<li><a href=\"../guide/components.html#Cheap-Static-Components-with-v-once\">组件 - 使用 v-once 实现轻量的静态组件</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"特殊元素\"><a href=\"#特殊元素\" class=\"headerlink\" title=\"特殊元素\"></a>特殊元素</h2><h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><ul>\n<li><p><strong>示例：</strong> <code>string</code></p>\n<p><code>key</code> 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。</p>\n<p>有相同父元素的子元素必须有<strong>独特的key</strong>。重复的key会造成渲染错误。</p>\n<p>最常见的用例是结合 <code>v-for</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用:</p>\n<ul>\n<li>完整地触发组件的生命周期钩子</li>\n<li>触发过渡</li>\n</ul>\n<p>例如:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"text\"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code> 会随时被更新，因此会触发过渡。</p>\n</li>\n</ul>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><p><strong>类型：</strong> <code>string</code></p>\n<p><code>ref</code> 被用来给元素或子组件注册引用信息。引用信息会根据父组件的 <code>$refs</code> 对象进行注册。如果在普通的DOM元素上使用，引用信息就是元素; 如果用在子组件上，引用信息就是组件实例:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- vm.$refs.p will be the DOM node --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"p\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- vm.$refs.child will be the child comp instance --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child-comp</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child-comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当 <code>v-for</code> 用于元素或组件的时候，引用信息将是包含DOM节点或组件实例数组。</p>\n<p>关于ref注册时间的重要说明: 因为ref本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模版中做数据绑定。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html#Child-Component-Refs\">子组件 Refs</a></p>\n</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>类型：</strong> <code>string</code></p>\n<p>用于标记往哪个slot中插入子组件内容。</p>\n<p>详细用法，请参考下面指南部分的链接。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html#Named-Slots\">命名 Slots</a></p>\n</li>\n</ul>\n<h2 id=\"内置的组件\"><a href=\"#内置的组件\" class=\"headerlink\" title=\"内置的组件\"></a>内置的组件</h2><h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><ul>\n<li><p><strong>Props：</strong></p>\n<ul>\n<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>\n<li><code>inline-template</code> - boolean</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>渲染一个“元组件”为动态组件。依 <code>is</code> 的值，来决定哪个组件被渲染。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"componentId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"$options.components.child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html#动态组件\">动态组件</a></p>\n</li>\n</ul>\n<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><ul>\n<li><p><strong>Props：</strong></p>\n<ul>\n<li><code>name</code> - string, 用于自动生成 CSS 过渡类名。例如：<code>name: &#39;fade&#39;</code> 将自动拓展为<code>.fade-enter</code>，<code>.fade-enter-active</code>等。默认类名为 <code>&quot;v&quot;</code></li>\n<li><code>appear</code> - boolean, 是否在初始渲染时使用过渡。默认为 <code>false</code>。</li>\n<li><code>css</code> - boolean, 是否使用 CSS 过渡类。默认为 <code>true</code>。如果设置为 <code>false</code>，将只通过组件事件触发注册的 JavaScript 钩子。</li>\n<li><code>type</code> - string, 指定过渡事件类型，侦听过渡何时结束。有效值为 <code>&quot;transition&quot;</code> 和 <code>&quot;animation&quot;</code>。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li>\n<li><code>mode</code> - string, 控制离开/进入的过渡时间序列。有效的模式有 <code>&quot;out-in&quot;</code> 和 <code>&quot;in-out&quot;</code>；默认同时生效。</li>\n<li><code>enter-class</code> - string</li>\n<li><code>leave-class</code> - string</li>\n<li><code>enter-active-class</code> - string</li>\n<li><code>leave-active-class</code> - string</li>\n<li><code>appear-class</code> - string</li>\n<li><code>appear-active-class</code> - string</li>\n</ul>\n</li>\n<li><p><strong>事件：</strong></p>\n<ul>\n<li><code>before-enter</code></li>\n<li><code>enter</code></li>\n<li><code>after-enter</code></li>\n<li><code>before-leave</code></li>\n<li><code>leave</code></li>\n<li><code>after-leave</code></li>\n<li><code>before-appear</code></li>\n<li><code>appear</code></li>\n<li><code>after-appear</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p><code>&lt;transition&gt;</code> 元素作为单个元素/组件的过渡效果。<code>&lt;transition&gt;</code> 不会渲染额外的 DOM 元素，也不会出现在检测过的组件层级中。它只是将内容包裹在其中，简单的运用过渡行为。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 简单元素 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>toggled content<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 动态组件 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span> <span class=\"attr\">mode</span>=<span class=\"string\">\"out-in\"</span> <span class=\"attr\">appear</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 事件钩子 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transition-demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> @<span class=\"attr\">after-enter</span>=<span class=\"string\">\"transitionComplete\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"ok\"</span>&gt;</span>toggled content<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    <span class=\"attr\">transitionComplete</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 传入 'el' 这个 DOM 元素作为参数。</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;).$mount(<span class=\"string\">'#transition-demo'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/transitions.html\">过渡：进入，离开和列表</a></p>\n</li>\n</ul>\n<h3 id=\"transition-group\"><a href=\"#transition-group\" class=\"headerlink\" title=\"transition-group\"></a>transition-group</h3><ul>\n<li><p><strong>Props：</strong></p>\n<ul>\n<li><code>tag</code> - string, 默认为 <code>span</code></li>\n<li><code>move-class</code> - 覆盖移动过渡期间应用的 CSS 类。</li>\n<li>除了 <code>mode</code>，其他特性和 <code>&lt;transition&gt;</code> 相同。</li>\n</ul>\n</li>\n<li><p><strong>事件：</strong></p>\n<ul>\n<li>事件和 <code>&lt;transition&gt;</code> 相同.</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p><code>&lt;transition-group&gt;</code> 元素作为多个元素/组件的过渡效果。<code>&lt;transition-group&gt;</code> 渲染一个真实的 DOM 元素。默认渲染 <code>&lt;span&gt;</code>，可以通过 <code>tag</code> 属性配置哪个元素应该被渲染。</p>\n<p>注意，每个 <code>&lt;transition-group&gt;</code> 的子节点必须有 <strong>独立的key</strong> ，动画才能正常工作</p>\n<p><code>&lt;transition-group&gt;</code> 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类（通过 <code>name</code> 属性或配置 <code>move-class</code> 属性自动生成）。如果 CSS <code>transform</code> 属性是“可过渡”属性，当应用移动类时，将会使用 <a href=\"https://aerotwist.com/blog/flip-your-animations/\" target=\"_blank\" rel=\"external\">FLIP 技术</a> 使元素流畅地到达动画终点。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"ul\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"slide\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; item.text &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/transitions.html\">过渡：进入，离开和列表</a></p>\n</li>\n</ul>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>include</code> - string or RegExp. Only components matched by this will be cached.</li>\n<li><code>exclude</code> - string or RegExp. Any component matched by this will not be cached.</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</p>\n<p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>\n<p>主要用于保留组件状态或避免重新渲染。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 基本 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 多个条件判断的子组件 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">comp-a</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"a &gt; 1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp-a</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">comp-b</span> <span class=\"attr\">v-else</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp-b</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 和 &lt;transition&gt; 一起使用 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong><code>include</code> and <code>exclude</code></strong></p>\n<blockquote>\n<p>New in 2.1.0</p>\n</blockquote>\n<p>The <code>include</code> and <code>exclude</code> props allow components to be conditionally cached. Both props can either be a comma-delimited string or a RegExp:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- comma-delimited string --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span> <span class=\"attr\">include</span>=<span class=\"string\">\"a,b\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- regex (use v-bind) --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span> <span class=\"attr\">:include</span>=<span class=\"string\">\"/a|b/\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>The match is first checked on the component’s own <code>name</code> option, then its local registration name (the key in the parent’s <code>components</code> option) if the <code>name</code> option is not available. Anonymous components cannot be matched against.</p>\n<p class=\"tip\"><code>&lt;keep-alive&gt;</code> 不会在函数式组件中正常工作，因为它们没有缓存实例。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html#keep-alive\">动态组件 - keep-alive</a></p>\n</li>\n</ul>\n<h3 id=\"slot-1\"><a href=\"#slot-1\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>Props：</strong></p>\n<ul>\n<li><code>name</code> - string, 用于命名插槽。</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;slot&gt;</code> 元素作为组件模板之中的内容分发插槽。 <code>&lt;slot&gt;</code> 元素自身将被替换。</p>\n<p>详细用法，请参考下面教程的链接。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html#使用Slots分发内容\">使用Slots分发内容</a></p>\n</li>\n</ul>\n<h2 id=\"VNode接口\"><a href=\"#VNode接口\" class=\"headerlink\" title=\"VNode接口\"></a>VNode接口</h2><ul>\n<li>请参考<a href=\"https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js\" target=\"_blank\" rel=\"external\">VNode class declaration</a>.</li>\n</ul>\n<h2 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h2><ul>\n<li>请参考<a href=\"https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer\" target=\"_blank\" rel=\"external\">vue-server-renderer package documentation</a>.</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><p><code>Vue.config</code>  是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：</p>\n<h3 id=\"silent\"><a href=\"#silent\" class=\"headerlink\" title=\"silent\"></a>silent</h3><ul>\n<li><p><strong>类型：</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>默认值：</strong> <code>false</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.silent = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>取消 Vue 所有的日志与警告。</p>\n</li>\n</ul>\n<h3 id=\"optionMergeStrategies\"><a href=\"#optionMergeStrategies\" class=\"headerlink\" title=\"optionMergeStrategies\"></a>optionMergeStrategies</h3><ul>\n<li><p><strong>类型：</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>默认值：</strong> <code>{}</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.optionMergeStrategies._my_option = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">parent, child, vm</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> child + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Profile = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">_my_option</span>: <span class=\"number\">1</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Profile.options._my_option = 2</span></div></pre></td></tr></table></figure>\n<p>自定义合并策略的选项。</p>\n<p>合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入。</p>\n</li>\n<li><p><strong>参考</strong> <a href=\"../guide/mixins.html#Custom-Option-Merge-Strategies\">自定义选项的混合策略</a></p>\n</li>\n</ul>\n<h3 id=\"devtools\"><a href=\"#devtools\" class=\"headerlink\" title=\"devtools\"></a>devtools</h3><ul>\n<li><p><strong>类型：</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>默认值：</strong> <code>true</code> (生产版为 <code>false</code>)</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 务必在加载 Vue 之后，立即同步设置以下内容</span></div><div class=\"line\">Vue.config.devtools = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>配置是否允许 <a href=\"https://github.com/vuejs/vue-devtools\">vue-devtools</a> 检查代码。开发版本默认为 <code>true</code>，生产版本默认为 <code>false</code>。生产版本设为 <code>true</code> 可以启用检查。</p>\n</li>\n</ul>\n<h3 id=\"errorHandler\"><a href=\"#errorHandler\" class=\"headerlink\" title=\"errorHandler\"></a>errorHandler</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>默认值：</strong> 默认抛出错误</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.errorHandler = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, vm</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p>\n<blockquote>\n<p><a href=\"https://sentry.io\">Sentry</a>, an error tracking service, provides <a href=\"https://sentry.io/for/vue/\">official integration</a> using this option.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"ignoredElements\"><a href=\"#ignoredElements\" class=\"headerlink\" title=\"ignoredElements\"></a>ignoredElements</h3><ul>\n<li><p><strong>类型:</strong> <code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>默认值:</strong> <code>[]</code></p>\n</li>\n<li><p><strong>用法:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.ignoredElements = [</div><div class=\"line\">  <span class=\"string\">'my-custom-web-component'</span>, <span class=\"string\">'another-web-component'</span></div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>须使 Vue 忽略在 Vue 之外的自定义元素 (e.g., 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 <code>Unknown custom element</code> 的警告。</p>\n</li>\n</ul>\n<h3 id=\"keyCodes\"><a href=\"#keyCodes\" class=\"headerlink\" title=\"keyCodes\"></a>keyCodes</h3><ul>\n<li><p><strong>类型：</strong> <code>{ [key: string]: number | Array&lt;number&gt; }</code></p>\n</li>\n<li><p><strong>默认值：</strong> <code>{}</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.keyCodes = &#123;</div><div class=\"line\">  <span class=\"attr\">v</span>: <span class=\"number\">86</span>,</div><div class=\"line\">  <span class=\"attr\">f1</span>: <span class=\"number\">112</span>,</div><div class=\"line\">  <span class=\"attr\">mediaPlayPause</span>: <span class=\"number\">179</span>,</div><div class=\"line\">  <span class=\"attr\">up</span>: [<span class=\"number\">38</span>, <span class=\"number\">87</span>]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>给 v-on 自定义键位别名。</p>\n</li>\n</ul>\n<h2 id=\"全局-API\"><a href=\"#全局-API\" class=\"headerlink\" title=\"全局 API\"></a>全局 API</h2><h3 id=\"Vue-extend\">Vue.extend( options )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} options</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>\n<p><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code> 中它必须是函数</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mount-point\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建构造器</span></div><div class=\"line\"><span class=\"keyword\">var</span> Profile = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">firstName</span>: <span class=\"string\">'Walter'</span>,</div><div class=\"line\">      <span class=\"attr\">lastName</span>: <span class=\"string\">'White'</span>,</div><div class=\"line\">      <span class=\"attr\">alias</span>: <span class=\"string\">'Heisenberg'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// 创建 Profile 实例，并挂载到一个元素上。</span></div><div class=\"line\"><span class=\"keyword\">new</span> Profile().$mount(<span class=\"string\">'#mount-point'</span>)</div></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Walter White aka Heisenberg<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html\">组件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-nextTick\">Vue.nextTick( [callback, context] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n<li><code>{Object} [context]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 修改数据</span></div><div class=\"line\">vm.msg = <span class=\"string\">'Hello'</span></div><div class=\"line\"><span class=\"comment\">// DOM 还没有更新</span></div><div class=\"line\">Vue.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// DOM 更新了</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>2.1.0新增：如果没有提供回调且支持 promise 的环境中返回 promise。</p>\n</blockquote>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/reactivity.html#Async-Update-Queue\">异步更新队列</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-set\">Vue.set( object, key, value )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>返回值：</strong> 设置的值.</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。</p>\n<p><strong>注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-delete\">Vue.delete( object, key )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。</p>\n<p><strong>注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-directive\">Vue.directive( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>注册或获取全局指令。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册</span></div><div class=\"line\">Vue.directive(<span class=\"string\">'my-directive'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">bind</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">inserted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">update</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">componentUpdated</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">unbind</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 注册（传入一个简单的指令函数）</span></div><div class=\"line\">Vue.directive(<span class=\"string\">'my-directive'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 这里将会被 `bind` 和 `update` 调用</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getter，返回已注册的指令</span></div><div class=\"line\"><span class=\"keyword\">var</span> myDirective = Vue.directive(<span class=\"string\">'my-directive'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/custom-directive.html\">自定义指令</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-filter\">Vue.filter( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>注册或获取全局过滤器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册</span></div><div class=\"line\">Vue.filter(<span class=\"string\">'my-filter'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 返回处理后的值</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getter，返回已注册的过滤器</span></div><div class=\"line\"><span class=\"keyword\">var</span> myFilter = Vue.filter(<span class=\"string\">'my-filter'</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Vue-component\">Vue.component( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>注册或获取全局组件。注册还会自动使用给定的<code>id</code>设置组件的名称</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册组件，传入一个扩展过的构造器</span></div><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, Vue.extend(&#123; <span class=\"comment\">/* ... */</span> &#125;))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 注册组件，传入一个选项对象（自动调用 Vue.extend）</span></div><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123; <span class=\"comment\">/* ... */</span> &#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取注册的组件（始终返回构造器）</span></div><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = Vue.component(<span class=\"string\">'my-component'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html\">组件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-use\">Vue.use( plugin )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object | Function} plugin</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>安装 Vue.js 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 install 方法。install 方法将被作为 Vue 的参数调用。</p>\n<p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/plugins.html\">插件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-mixin\">Vue.mixin( mixin )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} mixin</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>全局注册一个混合，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混合，向组件注入自定义的行为。<strong>不推荐在应用代码中使用</strong>。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/mixins.html#Global-Mixin\">全局混合</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-compile\">Vue.compile( template )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} template</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>在render函数中编译模板字符串。<strong>只在独立构建时有效</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res = Vue.compile(<span class=\"string\">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">msg</span>: <span class=\"string\">'hello'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">render</span>: res.render,</div><div class=\"line\">  <span class=\"attr\">staticRenderFns</span>: res.staticRenderFns</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/render-function.html\">Render 函数</a></p>\n</li>\n</ul>\n<h2 id=\"选项-数据\"><a href=\"#选项-数据\" class=\"headerlink\" title=\"选项 / 数据\"></a>选项 / 数据</h2><h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><ul>\n<li><p><strong>类型：</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>限制:</strong> 组件的定义只接受 <code>function</code>。</p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。<strong>对象必须是纯粹的对象(含有零个或多个的key/value对)</strong>：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</p>\n<p>一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p>\n<p>实例创建之后，可以通过 <code>vm.$data</code> 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 <code>vm.a</code> 等价于访问 <code>vm.$data.a</code>。</p>\n<p>以 <code>_</code> 或 <code>$</code> 开头的属性 <strong>不会</strong> 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、 API 方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性。</p>\n<p>当一个<strong>组件</strong>被定义， <code>data</code> 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 <code>data</code> 仍然是一个纯粹的对象，则所有的实例将<strong>共享引用</strong>同一个数据对象！通过提供 <code>data</code> 函数，每次创建一个新实例后，我们能够调用 <code>data</code> 函数，从而返回初始数据的一个全新副本数据对象。</p>\n<p>如果需要，可以通过将 <code>vm.$data</code> 传入 <code>JSON.parse(JSON.stringify(...))</code> 得到深拷贝的原始数据对象。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 直接创建一个实例</span></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: data</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.a <span class=\"comment\">// -&gt; 1</span></div><div class=\"line\">vm.$data === data <span class=\"comment\">// -&gt; true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Vue.extend() 中 data 必须是函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> Component = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">注意，<strong>不应该对 <code>data</code> 属性使用箭头函数</strong> (例如<code>data: () =&gt; { return { a: this.myProp }}</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，<code>this.myProp</code> 将是 undefined。</p>\n</li>\n<li><p><strong>参考:</strong> <a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><ul>\n<li><p><strong>类型:</strong> <code>Array&lt;string&gt; | Object</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 简单语法</span></div><div class=\"line\">Vue.component(<span class=\"string\">'props-demo-simple'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'size'</span>, <span class=\"string\">'myMessage'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对象语法，提供校验</span></div><div class=\"line\">Vue.component(<span class=\"string\">'props-demo-advanced'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 只检测类型</span></div><div class=\"line\">    height: <span class=\"built_in\">Number</span>,</div><div class=\"line\">    <span class=\"comment\">// 检测类型 + 其他验证</span></div><div class=\"line\">    age: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">default</span>: <span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"attr\">validator</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value &gt;= <span class=\"number\">0</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考:</strong> <a href=\"../guide/components.html#Props\">Props</a></p>\n</li>\n</ul>\n<h3 id=\"propsData\"><a href=\"#propsData\" class=\"headerlink\" title=\"propsData\"></a>propsData</h3><ul>\n<li><p><strong>类型:</strong> <code>{ [key: string]: any }</code></p>\n</li>\n<li><p><strong>限制:</strong> 只用于 <code>new</code> 创建的实例中。</p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>创建实例时传递 props。主要作用是方便测试。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Comp = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'msg'</span>],</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Comp(&#123;</div><div class=\"line\">  <span class=\"attr\">propsData</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">msg</span>: <span class=\"string\">'hello'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考:</strong> <a href=\"../guide/components.html#Props\">Props</a></p>\n</li>\n</ul>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><ul>\n<li><p><strong>类型:</strong> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>\n<p class=\"tip\">注意，<strong>不应该使用箭头函数来定义计算属性函数</strong> (例如 <code>aDouble: () =&gt; this.a * 2</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p>\n\n<p>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 仅读取，值只须为函数</span></div><div class=\"line\">    aDouble: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a * <span class=\"number\">2</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 读取和设置</span></div><div class=\"line\">    aPlus: &#123;</div><div class=\"line\">      <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"number\">1</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"attr\">set</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.a = v - <span class=\"number\">1</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.aPlus   <span class=\"comment\">// -&gt; 2</span></div><div class=\"line\">vm.aPlus = <span class=\"number\">3</span></div><div class=\"line\">vm.a       <span class=\"comment\">// -&gt; 2</span></div><div class=\"line\">vm.aDouble <span class=\"comment\">// -&gt; 4</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>另见:</strong></p>\n<ul>\n<li><a href=\"../guide/computed.html\">计算属性</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><ul>\n<li><p><strong>类型:</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 Vue 实例。</p>\n<p class=\"tip\">注意，<strong>不应该使用箭头函数来定义 method 函数</strong> (例如 <code>plus: () =&gt; this.a++</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">plus</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.a++</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.plus()</div><div class=\"line\">vm.a <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考:</strong> <a href=\"../guide/events.html\">方法与事件处理器</a></p>\n</li>\n</ul>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><ul>\n<li><p><strong>类型:</strong> <code>{ [key: string]: string | Function | Object }</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个属性。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"attr\">c</span>: <span class=\"number\">3</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val, oldVal</span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'new: %s, old: %s'</span>, val, oldVal)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 方法名</span></div><div class=\"line\">    b: <span class=\"string\">'someMethod'</span>,</div><div class=\"line\">    <span class=\"comment\">// 深度 watcher</span></div><div class=\"line\">    c: &#123;</div><div class=\"line\">      <span class=\"attr\">handler</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val, oldVal</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">      <span class=\"attr\">deep</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.a = <span class=\"number\">2</span> <span class=\"comment\">// -&gt; new: 2, old: 1</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">注意，<strong>不应该使用箭头函数来定义 watcher 函数</strong> (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.updateAutocomplete</code> 将是 undefined。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"#vm-watch\">实例方法 - vm.$watch</a></p>\n</li>\n</ul>\n<h2 id=\"选项-DOM\"><a href=\"#选项-DOM\" class=\"headerlink\" title=\"选项 / DOM\"></a>选项 / DOM</h2><h3 id=\"el\"><a href=\"#el\" class=\"headerlink\" title=\"el\"></a>el</h3><ul>\n<li><p><strong>类型：</strong> <code>string | HTMLElement</code></p>\n</li>\n<li><p><strong>限制：</strong> 只在由 <code>new</code> 创建的实例中遵守。</p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p>\n<p>在实例挂载之后， 元素可以用 <code>vm.$el</code> 访问。</p>\n<p>如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 <code>vm.$mount()</code> 手动开启编译。</p>\n<p class=\"tip\"> 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载root实例到 <code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code> 上。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h3><ul>\n<li><p><strong>类型：</strong> <code>string</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>一个字符串模板作为 Vue 实例的标识使用。模板将会 <strong>替换</strong> 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发 slot。</p>\n<p>如果值以 <code>#</code> 开始，则它用作选项符，将使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 包含模板。</p>\n<p class=\"tip\">出于安全考虑，您应该只使用您信任的 Vue 模板。避免使用其他人生成的内容作为您的模板。</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">内容分发</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。render 函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>。</p>\n<p>如果组件是一个函数组件，Render 函数还会接收一个额外的 <code>context</code> 参数，为没有实例的函数组件提供上下文信息。</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/render-function.html\">Render 函数</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选项-生命周期钩子\"><a href=\"#选项-生命周期钩子\" class=\"headerlink\" title=\"选项 / 生命周期钩子\"></a>选项 / 生命周期钩子</h2><p>所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 <strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同， <code>this.fetchTodos</code> 的行为未定义。</p>\n<h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</p>\n<p>你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>\n<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>keep-alive 组件激活时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">构建组件 - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">动态组件 - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>keep-alive 组件停用时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">构建组件 - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">动态组件 - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><ul>\n<li><p><strong>类型：</strong> <code>Function</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h2 id=\"选项-资源\"><a href=\"#选项-资源\" class=\"headerlink\" title=\"选项 / 资源\"></a>选项 / 资源</h2><h3 id=\"directives\"><a href=\"#directives\" class=\"headerlink\" title=\"directives\"></a>directives</h3><ul>\n<li><p><strong>类型:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n</li>\n</ul>\n<p>包含 Vue 实例可用指令的哈希表。</p>\n<ul>\n<li><strong>参考：</strong><ul>\n<li><a href=\"../guide/custom-directive.html\">自定义指令</a></li>\n<li><a href=\"../guide/components.html#Assets-Naming-Convention\">资源命名约定</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"filters\"><a href=\"#filters\" class=\"headerlink\" title=\"filters\"></a>filters</h3><ul>\n<li><p><strong>类型:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n</li>\n</ul>\n<p>包含 Vue 实例可用过滤器的哈希表。</p>\n<ul>\n<li><strong>另见:</strong><ul>\n<li><a href=\"#Vue-filter\"><code>Vue.filter</code></a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"components\"><a href=\"#components\" class=\"headerlink\" title=\"components\"></a>components</h3><ul>\n<li><p><strong>类型:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n</li>\n</ul>\n<p>包含 Vue 实例可用组件的哈希表。</p>\n<ul>\n<li><strong>参考：</strong><ul>\n<li><a href=\"../guide/components.html\">组件</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选项-杂项\"><a href=\"#选项-杂项\" class=\"headerlink\" title=\"选项 / 杂项\"></a>选项 / 杂项</h2><h3 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h3><ul>\n<li><p><strong>类型:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。</p>\n<p class=\"tip\">同时使用 <code>$parent</code> 和 <code>$children</code> 有冲突 - 他们作为同一个入口 。更推荐用 props 和 events 实现父子组件通信</p>\n\n</li>\n</ul>\n<h3 id=\"mixins\"><a href=\"#mixins\" class=\"headerlink\" title=\"mixins\"></a>mixins</h3><ul>\n<li><p><strong>类型:</strong> <code>Array&lt;Object&gt;</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p><code>mixins</code> 选项接受一个混合对象的数组。这些混合实例对象可以像正常的实例对象一样包含选项,他们将在 <code>Vue.extend()</code> 里最终选择使用相同的选项合并逻辑合并。举例：如果你混合包含一个钩子而创建组件本身也有一个,两个函数将被调用。<br>Mixin钩子按照传入顺序依次调用,并在调用组件自身的钩子之前被调用。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>) &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>) &#125;,</div><div class=\"line\">  <span class=\"attr\">mixins</span>: [mixin]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// -&gt; 1</span></div><div class=\"line\"><span class=\"comment\">// -&gt; 2</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/mixins.html\">混合</a></p>\n</li>\n</ul>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><ul>\n<li><p><strong>类型:</strong> <code>string</code></p>\n</li>\n<li><p><strong>限制:</strong> 只有作为组件选项时起作用。</p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>允许组件模板递归地调用自身。注意，组件在全局用 <code>Vue.component()</code> 注册时，全局 ID 自动作为组件的 name。</p>\n<p>指定 <code>name</code> 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 <a href=\"https://github.com/vuejs/vue-devtools\">vue-devtools</a>, 未命名组件将显示成 <code>&lt;AnonymousComponent&gt;</code>, 这很没有语义。通过提供 <code>name</code> 选项，可以获得更有语义信息的组件树。</p>\n</li>\n</ul>\n<h3 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h3><ul>\n<li><p><strong>类型:</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数),而无需使用 <code>Vue.extend</code>。这主要是为了便于扩展单文件组件。</p>\n<p>这和 <code>mixins</code> 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CompA = &#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在没有调用 Vue.extend 时候继承 CompA</span></div><div class=\"line\"><span class=\"keyword\">var</span> CompB = &#123;</div><div class=\"line\">  <span class=\"attr\">extends</span>: CompA,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"delimiters\"><a href=\"#delimiters\" class=\"headerlink\" title=\"delimiters\"></a>delimiters</h3><ul>\n<li><p><strong>类型:</strong> <code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>默认值:</strong> <code>[\"{{\", \"}}\"]</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>改变纯文本插入分隔符。 <strong>这个选择只有在独立构建时才有用。</strong></p>\n</li>\n</ul>\n<ul>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">delimiters</span>: [<span class=\"string\">'$&#123;'</span>, <span class=\"string\">'&#125;'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 分隔符变成了 ES6 模板字符串的风格</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"functional\"><a href=\"#functional\" class=\"headerlink\" title=\"functional\"></a>functional</h3><ul>\n<li><p><strong>类型:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>使组件无状态（没有 <code>data</code> ）和无实例（没有 <code>this</code> 上下文）。他们用一个简单的 <code>render</code> 函数返回虚拟节点使他们更容易渲染。</p>\n</li>\n<li><p><strong>参考：\n</strong> <a href=\"../guide/render-function.html#Functional-Components\">函数式组件</a></p>\n</li>\n</ul>\n<h2 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h2><h3 id=\"vm-data\"><a href=\"#vm-data\" class=\"headerlink\" title=\"vm.$data\"></a>vm.$data</h3><ul>\n<li><p><strong>类型:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。</p>\n</li>\n<li><p><strong>另见:</strong> <a href=\"#data\">选项 - data</a></p>\n</li>\n</ul>\n<h3 id=\"vm-el\"><a href=\"#vm-el\" class=\"headerlink\" title=\"vm.$el\"></a>vm.$el</h3><ul>\n<li><p><strong>类型:</strong> <code>HTMLElement</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>Vue 实例使用的根 DOM 元素。</p>\n</li>\n</ul>\n<h3 id=\"vm-options\"><a href=\"#vm-options\" class=\"headerlink\" title=\"vm.$options\"></a>vm.$options</h3><ul>\n<li><p><strong>类型:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">customOption</span>: <span class=\"string\">'foo'</span>,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$options.customOption) <span class=\"comment\">// -&gt; 'foo'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-parent\"><a href=\"#vm-parent\" class=\"headerlink\" title=\"vm.$parent\"></a>vm.$parent</h3><ul>\n<li><p><strong>类型:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>父实例，如果当前实例有的话。</p>\n</li>\n</ul>\n<h3 id=\"vm-root\"><a href=\"#vm-root\" class=\"headerlink\" title=\"vm.$root\"></a>vm.$root</h3><ul>\n<li><p><strong>类型:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自已。</p>\n</li>\n</ul>\n<h3 id=\"vm-children\"><a href=\"#vm-children\" class=\"headerlink\" title=\"vm.$children\"></a>vm.$children</h3><ul>\n<li><p><strong>类型:</strong> <code>Array&lt;Vue instance&gt;</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>当前实例的直接子组件。<strong>需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。</strong>如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。</p>\n</li>\n</ul>\n<h3 id=\"vm-slots\"><a href=\"#vm-slots\" class=\"headerlink\" title=\"vm.$slots\"></a>vm.$slots</h3><ul>\n<li><p><strong>类型：</strong> <code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细:</strong></p>\n<p>用来访问被 <a href=\"../guide/components.html#Content-Distribution-with-Slots\">slot 分发</a>的内容。每个<a href=\"../guide/components.html#Named-Slots\">具名 slot</a> 有其相应的属性（例如：<code>slot=&quot;foo&quot;</code> 中的内容将会在 <code>vm.$slots.foo</code> 中被找到）。<code>default</code> 属性包括了所有没有被包含在具名 slot 中的节点。</p>\n<p>在使用 <a href=\"../guide/render-function.html\">render 函数</a>书写一个组件时，访问 <code>vm.$slots</code> 最有帮助。</p>\n</li>\n<li><p><strong>示例:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">blog-post</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"header\"</span>&gt;</span></div><div class=\"line\">    About Me</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"footer\"</span>&gt;</span></div><div class=\"line\">    Copyright 2016 Evan You</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>.</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'blog-post'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> header = <span class=\"keyword\">this</span>.$slots.header</div><div class=\"line\">    <span class=\"keyword\">var</span> body   = <span class=\"keyword\">this</span>.$slots.default</div><div class=\"line\">    <span class=\"keyword\">var</span> footer = <span class=\"keyword\">this</span>.$slots.footer</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, [</div><div class=\"line\">      createElement(<span class=\"string\">'header'</span>, header),</div><div class=\"line\">      createElement(<span class=\"string\">'main'</span>, body),</div><div class=\"line\">      createElement(<span class=\"string\">'footer'</span>, footer)</div><div class=\"line\">    ])</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"#slot-1\"><code>&lt;slot&gt;</code> 组件</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">使用 Slots 进行内容分发</a></li>\n<li><a href=\"../guide/render-function.html#Slots\">Render 函数</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-scopedSlots\"><a href=\"#vm-scopedSlots\" class=\"headerlink\" title=\"vm.$scopedSlots\"></a>vm.$scopedSlots</h3><blockquote>\n<p>2.1.0新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型：</strong> <code>{ [name: string]: props =&gt; VNode | Array&lt;VNode&gt; }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>Used to programmatically access <a href=\"../guide/components.html#Scoped-Slots\">scoped slots</a>. For each slot, including the <code>default</code> one, the object contains a corresponding function that returns VNodes.</p>\n<p>Accessing <code>vm.$scopedSlots</code> is most useful when writing a component with a <a href=\"../guide/render-function.html\">render function</a>.</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"#slot-1\"><code>&lt;slot&gt;</code> 组件</a></li>\n<li><a href=\"../guide/components.html#Scoped-Slots\">Scoped Slots</a></li>\n<li><a href=\"../guide/render-function.html#Slots\">Render 函数</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-refs\"><a href=\"#vm-refs\" class=\"headerlink\" title=\"vm.$refs\"></a>vm.$refs</h3><ul>\n<li><p><strong>类型：</strong> <code>Object</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>一个对象，其中包含了所有拥有 <code>ref</code> 注册的子组件。</p>\n</li>\n<li><p><strong>另见：</strong></p>\n<ul>\n<li><a href=\"../guide/components.html#Child-Component-Refs\">子组件引用</a></li>\n<li><a href=\"#ref\">ref</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-isServer\"><a href=\"#vm-isServer\" class=\"headerlink\" title=\"vm.$isServer\"></a>vm.$isServer</h3><ul>\n<li><p><strong>类型：</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>当前 Vue 实例是否运行于服务器。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/ssr.html\">服务端渲染</a></p>\n</li>\n</ul>\n<h2 id=\"实例方法-数据\"><a href=\"#实例方法-数据\" class=\"headerlink\" title=\"实例方法 / 数据\"></a>实例方法 / 数据</h2><h3 id=\"vm-watch\">vm.$watch( expOrFn, callback, [options] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string | Function} expOrFn</code></li>\n<li><code>{Function} callback</code></li>\n<li><code>{Object} [options]</code><ul>\n<li><code>{boolean} deep</code></li>\n<li><code>{boolean} immediate</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>返回值：</strong> <code>{Function} unwatch</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p>\n<p class=\"tip\">注意：在变异（不是替换）对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 键路径</span></div><div class=\"line\">vm.$watch(<span class=\"string\">'a.b.c'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 做点什么</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 函数</span></div><div class=\"line\">vm.$watch(</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"keyword\">this</span>.b</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 做点什么</span></div><div class=\"line\">  &#125;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p><code>vm.$watch</code> 返回一个取消观察函数，用来停止触发回调：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> unwatch = vm.$watch(<span class=\"string\">'a'</span>, cb)</div><div class=\"line\"><span class=\"comment\">// 之后取消观察</span></div><div class=\"line\">unwatch()</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>选项：deep</strong></p>\n<p>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code> 。注意监听数组的变动不需要这么做。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$watch(<span class=\"string\">'someObject'</span>, callback, &#123;</div><div class=\"line\">  <span class=\"attr\">deep</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;)</div><div class=\"line\">vm.someObject.nestedValue = <span class=\"number\">123</span></div><div class=\"line\"><span class=\"comment\">// callback is fired</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>选项：immediate</strong></p>\n<p>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$watch(<span class=\"string\">'a'</span>, callback, &#123;</div><div class=\"line\">  <span class=\"attr\">immediate</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// 立即以 `a` 的当前值触发回调</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-set\">vm.$set( object, key, value )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>返回值：</strong> 设置的值.</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>这是全局 <code>Vue.set</code> 的<strong>别名</strong>。</p>\n</li>\n<li><p><strong>另见：</strong> <a href=\"#Vue-set\">Vue.set</a></p>\n</li>\n</ul>\n<h3 id=\"vm-delete\">vm.$delete( object, key )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>这是全局 <code>Vue.delete</code> 的<strong>别名</strong>。</p>\n</li>\n<li><p><strong>另见：</strong> <a href=\"#Vue-delete\">Vue.delete</a></p>\n</li>\n</ul>\n<h2 id=\"实例方法-事件\"><a href=\"#实例方法-事件\" class=\"headerlink\" title=\"实例方法/事件\"></a>实例方法/事件</h2><h3 id=\"vm-on\">vm.$on( event, callback )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>监听当前实例上的自定义事件。事件可以由<code>vm.$emit</code>触发。回调函数会接收所有传入事件触发函数的额外参数。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$on(<span class=\"string\">'test'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(msg)</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.$emit(<span class=\"string\">'test'</span>, <span class=\"string\">'hi'</span>)</div><div class=\"line\"><span class=\"comment\">// -&gt; \"hi\"</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-once\">vm.$once( event, callback )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>监听一个自定义事件，但是只触发一次，在第一次触发之移除除监听器。</p>\n</li>\n</ul>\n<h3 id=\"vm-off\">vm.$off( [event, callback] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} [event]</code></li>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>移除事件监听器。</p>\n<ul>\n<li><p>如果没有提供参数，则移除所有的事件监听器；</p>\n</li>\n<li><p>如果只提供了事件，则移除该事件所有的监听器；</p>\n</li>\n<li><p>如果同时提供了事件与回调，则只移除这个回调的监听器。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-emit\">vm.$emit( event, […args] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>[...args]</code></li>\n</ul>\n<p>触发当前实例上的事件。附加参数都会传给监听器回调。</p>\n</li>\n</ul>\n<h2 id=\"实例方法-生命周期\"><a href=\"#实例方法-生命周期\" class=\"headerlink\" title=\"实例方法 / 生命周期\"></a>实例方法 / 生命周期</h2><h3 id=\"vm-mount\">vm.$mount( [elementOrSelector] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Element | string} [elementOrSelector]</code></li>\n<li><code>{boolean} [hydrating]</code></li>\n</ul>\n</li>\n<li><p><strong>返回值：</strong> <code>vm</code> - 实例自身</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 <code>vm.$mount()</code> 手动地挂载一个未挂载的实例。</p>\n<p>如果没有提供 <code>elementOrSelector</code> 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生DOM API把它插入文档中。</p>\n<p>这个方法返回实例自身，因而可以链式调用其它实例方法。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;Hello!&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建并挂载到 #app (会替换 #app)</span></div><div class=\"line\"><span class=\"keyword\">new</span> MyComponent().$mount(<span class=\"string\">'#app'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 同上</span></div><div class=\"line\"><span class=\"keyword\">new</span> MyComponent(&#123; <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span> &#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 或者，在文档之外渲染并且随后挂载</span></div><div class=\"line\"><span class=\"keyword\">var</span> component = <span class=\"keyword\">new</span> MyComponent().$mount()</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>).appendChild(component.$el)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></li>\n<li><a href=\"../guide/ssr.html\">服务端渲染</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-forceUpdate\">vm.$forceUpdate()</h3>\n\n<ul>\n<li><p><strong>示例：</strong></p>\n<p>迫使Vue实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>\n</li>\n</ul>\n<h3 id=\"vm-nextTick\">vm.$nextTick( [callback] )</h3>\n\n<ul>\n<li><p><strong>参数：</strong></p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 <code>this</code> 自动绑定到调用它的实例上。</p>\n</li>\n</ul>\n<blockquote>\n<p>2.1.0新增：如果没有提供回调且支持 promise 的环境中返回 promise。</p>\n</blockquote>\n<ul>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    example: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 修改数据</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.message = <span class=\"string\">'changed'</span></div><div class=\"line\">      <span class=\"comment\">// DOM 还没有更新</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// DOM 现在更新了</span></div><div class=\"line\">        <span class=\"comment\">// `this` 绑定到当前实例</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.doSomethingElse()</div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"#Vue-nextTick\">Vue.nextTick</a></li>\n<li><a href=\"../guide/reactivity.html#Async-Update-Queue\">异步更新队列</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-destroy\">vm.$destroy()</h3>\n\n<ul>\n<li><p><strong>用法：</strong></p>\n<p>完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。</p>\n<p>触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子。</p>\n<p class=\"tip\">在大多数场景中你不应该调用这个方法。最好使用 <code>v-if</code> 和 <code>v-for</code> 指令以数据驱动的方式控制子组件的生命周期。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">生命周期图示</a></p>\n</li>\n</ul>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><h3 id=\"v-text\"><a href=\"#v-text\" class=\"headerlink\" title=\"v-text\"></a>v-text</h3><ul>\n<li><p><strong>类型：</strong> <code>string</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>更新元素的 <code>textContent</code>。如果要更新部分的 <code>textContent</code> ，需要使用 <code>{{ Mustache }}</code> 插值。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-text</span>=<span class=\"string\">\"msg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 和下面的一样 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/syntax.html#Text\">数据绑定语法 - 插值</a></p>\n</li>\n</ul>\n<h3 id=\"v-html\"><a href=\"#v-html\" class=\"headerlink\" title=\"v-html\"></a>v-html</h3><ul>\n<li><p><strong>类型：</strong> <code>string</code></p>\n</li>\n<li><p><strong>详细：</strong></p>\n</li>\n</ul>\n<p>  更新元素的 <code>innerHTML</code> 。<strong>注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong> 。如果试图使用 <code>v-html</code> 组合模板,可以重新考虑通过是否通过使用组件来替代。</p>\n  <p class=\"tip\">在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">XSS 攻击</a>。只在可信内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上。</p>\n\n<ul>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/syntax.html#Raw-HTML\">数据绑定语法 - 插值</a></p>\n</li>\n</ul>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><ul>\n<li><p><strong>类型：</strong> <code>any</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>根据表达式之真假值，切换元素的 <code>display</code> CSS 属性。</p>\n<p>当条件变化时该指令触发过渡效果。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/conditional.html#v-show\">条件渲染 - v-show</a></p>\n</li>\n</ul>\n<h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><ul>\n<li><p><strong>类型：</strong> <code>any</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <code>&lt;template&gt;</code> ，将提出它的内容作为条件块。</p>\n<p>当条件变化时该指令触发过渡效果。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/conditional.html\">条件渲染 - v-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a>v-else</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>限制：</strong> 前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>为 <code>v-if</code> 或者 <code>v-else-if</code> 添加 “else 块”。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"Math.random() &gt; 0.5\"</span>&gt;</span></div><div class=\"line\">  Now you see me</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  Now you don't</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/conditional.html#v-else\">条件渲染 - v-else</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-else-if\"><a href=\"#v-else-if\" class=\"headerlink\" title=\"v-else-if\"></a>v-else-if</h3><blockquote>\n<p>2.1.0新增</p>\n</blockquote>\n<ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Denote the “else if block” for <code>v-if</code>. Can be chained.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"type === 'A'\"</span>&gt;</span></div><div class=\"line\">  A</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'B'\"</span>&gt;</span></div><div class=\"line\">  B</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'C'\"</span>&gt;</span></div><div class=\"line\">  C</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  Not A/B/C</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html#v-else-if\">Conditional Rendering - v-else-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h3><ul>\n<li><p><strong>类型：</strong> <code>Array | Object | number | string</code></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias in expression</code> ，为当前遍历的元素提供别名：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; item.text &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>另外也可以为数组索引指定别名（或者用于对象的键）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(val, key) in object\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(val, key, index) in object\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>v-for</code> 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素,您需要提供一个 <code>key</code> 的特殊属性:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; item.text &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>v-for</code> 的详细用法可以通过以下链接查看教程详细说明。</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/list.html\">列表渲染</a></li>\n<li><a href=\"../guide/list.html#key\">key</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h3><ul>\n<li><p><strong>缩写：</strong> <code>@</code></p>\n</li>\n<li><p><strong>类型：</strong> <code>Function | Inline Statement</code></p>\n</li>\n<li><p><strong>参数：</strong> <code>event (required)</code></p>\n</li>\n<li><p><strong>修饰符：</strong></p>\n<ul>\n<li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li>\n<li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li>\n<li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li>\n<li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>\n<li><code>.{keyCode | keyAlias}</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>\n<li><code>.native</code> - 监听组件根元素的原生事件。</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p>\n<p>用在普通元素上时，只能监听 <strong>原生 DOM 事件</strong>。用在自定义元素组件上时，也可以监听子组件触发的<strong>自定义事件</strong>。</p>\n<p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 <code>$event</code> 属性： <code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 方法处理器 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 内联语句 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doThat('hello', $event)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 缩写 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 停止冒泡 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.stop</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 阻止默认行为 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.prevent</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> @<span class=\"attr\">submit.prevent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!--  串联修饰符 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.stop.prevent</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 键修饰符，键别名 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.enter</span>=<span class=\"string\">\"onEnter\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 键修饰符，键代码 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.13</span>=<span class=\"string\">\"onEnter\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在子组件上监听自定义事件（当子组件触发 “my-event” 时将调用事件处理器）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">my-event</span>=<span class=\"string\">\"handleThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 内联语句 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">my-event</span>=<span class=\"string\">\"handleThis(123, $event)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 组件中的原生事件 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">click.native</span>=<span class=\"string\">\"onClick\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/events.html\">方法与事件处理器</a></li>\n<li><a href=\"../guide/components.html#Custom-Events\">组件 - 自定义事件</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h3><ul>\n<li><p><strong>缩写：</strong> <code>:</code></p>\n</li>\n<li><p><strong>类型：</strong> <code>any (with argument) | Object (without argument)</code></p>\n</li>\n<li><p><strong>参数：</strong> <code>attrOrProp (optional)</code></p>\n</li>\n<li><p><strong>修饰符：</strong></p>\n<ul>\n<li><code>.prop</code> - 被用于绑定 DOM 属性。(<a href=\"http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028\">what’s the difference?</a>)</li>\n<li><code>.camel</code> - transform the kebab-case attribute name into camelCase. (supported since 2.1.0)</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>动态地绑定一个或多个特性，或一个组件 prop 到表达式。</p>\n<p>在绑定 <code>class</code> 或 <code>style</code> 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</p>\n<p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p>\n<p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 <code>class</code> 和 <code>style</code> 绑定不支持数组和对象。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 绑定一个属性 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">v-bind:src</span>=<span class=\"string\">\"imageSrc\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 缩写 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:src</span>=<span class=\"string\">\"imageSrc\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- with inline string concatenation --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:src</span>=<span class=\"string\">\"'/path/to/images/' + fileName\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- class 绑定 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"&#123; red: isRed &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"[classA, classB]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"[classA, &#123; classB: isB, classC: isC &#125;]\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- style 绑定 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123; fontSize: size + 'px' &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"[styleObjectA, styleObjectB]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 绑定一个有属性的对象 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind</span>=<span class=\"string\">\"&#123; id: someProp, 'other-attr': otherProp &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:text-content.prop</span>=<span class=\"string\">\"text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- prop 绑定. “prop” 必须在 my-component 中声明。 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">:prop</span>=<span class=\"string\">\"someThing\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- XLink --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:xlink:special</span>=<span class=\"string\">\"foo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>The <code>.camel</code> modifier allows camelizing a <code>v-bind</code> attribute name when using in-DOM templates, e.g. the SVG <code>viewBox</code> attribute:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">:view-box.camel</span>=<span class=\"string\">\"viewBox\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>.camel</code> is not needed if you are using string templates, or compiling with <code>vue-loader</code>/<code>vueify</code>.</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/class-and-style.html\">Class 与 Style 绑定</a></li>\n<li><a href=\"../guide/components.html#Props\">组件 - 组件 Props</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h3><ul>\n<li><p><strong>类型：</strong> 随表单控件类型不同而不同。</p>\n</li>\n<li><p><strong>限制：</strong></p>\n<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li>components</li>\n</ul>\n</li>\n<li><p><strong>修饰符：</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html#lazy\"><code>.lazy</code></a> - 取代 <code>input</code> 监听 <code>change</code> 事件</li>\n<li><a href=\"../guide/forms.html#number\"><code>.number</code></a> - 输入字符串转为数字</li>\n<li><a href=\"../guide/forms.html#trim\"><code>.trim</code></a> - 输入首尾空格过滤</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>在表单控件或者组件上创建双向绑定。细节请看下面链接的教程。</p>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html\">表单控件绑定</a></li>\n<li><a href=\"../guide/components.html#Form-Input-Components-using-Custom-Events\">组件 - 在输入组件上使用自定义事件</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-pre\"><a href=\"#v-pre\" class=\"headerlink\" title=\"v-pre\"></a>v-pre</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-attr\">[v-cloak]</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: none;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-cloak</span>&gt;</span></div><div class=\"line\">  &#123;&#123; message &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><div> 不会显示，直到编译结束。</p>\n</li>\n</ul>\n<h3 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>详细：</strong></p>\n<p>只渲染元素和组件<strong>一次</strong>。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 单个元素 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 有子元素 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-once</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>comment<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 组件 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-once</span> <span class=\"attr\">:comment</span>=<span class=\"string\">\"msg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- v-for 指令--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"i in list\"</span> <span class=\"attr\">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong></p>\n<ul>\n<li><a href=\"../guide/syntax.html#Text\">数据绑定语法- 插值</a></li>\n<li><a href=\"../guide/components.html#Cheap-Static-Components-with-v-once\">组件 - 使用 v-once 实现轻量的静态组件</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"特殊元素\"><a href=\"#特殊元素\" class=\"headerlink\" title=\"特殊元素\"></a>特殊元素</h2><h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><ul>\n<li><p><strong>示例：</strong> <code>string</code></p>\n<p><code>key</code> 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。</p>\n<p>有相同父元素的子元素必须有<strong>独特的key</strong>。重复的key会造成渲染错误。</p>\n<p>最常见的用例是结合 <code>v-for</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用:</p>\n<ul>\n<li>完整地触发组件的生命周期钩子</li>\n<li>触发过渡</li>\n</ul>\n<p>例如:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"text\"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code> 会随时被更新，因此会触发过渡。</p>\n</li>\n</ul>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><p><strong>类型：</strong> <code>string</code></p>\n<p><code>ref</code> 被用来给元素或子组件注册引用信息。引用信息会根据父组件的 <code>$refs</code> 对象进行注册。如果在普通的DOM元素上使用，引用信息就是元素; 如果用在子组件上，引用信息就是组件实例:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- vm.$refs.p will be the DOM node --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"p\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- vm.$refs.child will be the child comp instance --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child-comp</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child-comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当 <code>v-for</code> 用于元素或组件的时候，引用信息将是包含DOM节点或组件实例数组。</p>\n<p>关于ref注册时间的重要说明: 因为ref本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模版中做数据绑定。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html#Child-Component-Refs\">子组件 Refs</a></p>\n</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>类型：</strong> <code>string</code></p>\n<p>用于标记往哪个slot中插入子组件内容。</p>\n<p>详细用法，请参考下面指南部分的链接。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html#Named-Slots\">命名 Slots</a></p>\n</li>\n</ul>\n<h2 id=\"内置的组件\"><a href=\"#内置的组件\" class=\"headerlink\" title=\"内置的组件\"></a>内置的组件</h2><h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><ul>\n<li><p><strong>Props：</strong></p>\n<ul>\n<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>\n<li><code>inline-template</code> - boolean</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p>渲染一个“元组件”为动态组件。依 <code>is</code> 的值，来决定哪个组件被渲染。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"componentId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"$options.components.child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html#动态组件\">动态组件</a></p>\n</li>\n</ul>\n<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><ul>\n<li><p><strong>Props：</strong></p>\n<ul>\n<li><code>name</code> - string, 用于自动生成 CSS 过渡类名。例如：<code>name: &#39;fade&#39;</code> 将自动拓展为<code>.fade-enter</code>，<code>.fade-enter-active</code>等。默认类名为 <code>&quot;v&quot;</code></li>\n<li><code>appear</code> - boolean, 是否在初始渲染时使用过渡。默认为 <code>false</code>。</li>\n<li><code>css</code> - boolean, 是否使用 CSS 过渡类。默认为 <code>true</code>。如果设置为 <code>false</code>，将只通过组件事件触发注册的 JavaScript 钩子。</li>\n<li><code>type</code> - string, 指定过渡事件类型，侦听过渡何时结束。有效值为 <code>&quot;transition&quot;</code> 和 <code>&quot;animation&quot;</code>。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li>\n<li><code>mode</code> - string, 控制离开/进入的过渡时间序列。有效的模式有 <code>&quot;out-in&quot;</code> 和 <code>&quot;in-out&quot;</code>；默认同时生效。</li>\n<li><code>enter-class</code> - string</li>\n<li><code>leave-class</code> - string</li>\n<li><code>enter-active-class</code> - string</li>\n<li><code>leave-active-class</code> - string</li>\n<li><code>appear-class</code> - string</li>\n<li><code>appear-active-class</code> - string</li>\n</ul>\n</li>\n<li><p><strong>事件：</strong></p>\n<ul>\n<li><code>before-enter</code></li>\n<li><code>enter</code></li>\n<li><code>after-enter</code></li>\n<li><code>before-leave</code></li>\n<li><code>leave</code></li>\n<li><code>after-leave</code></li>\n<li><code>before-appear</code></li>\n<li><code>appear</code></li>\n<li><code>after-appear</code></li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p><code>&lt;transition&gt;</code> 元素作为单个元素/组件的过渡效果。<code>&lt;transition&gt;</code> 不会渲染额外的 DOM 元素，也不会出现在检测过的组件层级中。它只是将内容包裹在其中，简单的运用过渡行为。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 简单元素 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>toggled content<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 动态组件 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span> <span class=\"attr\">mode</span>=<span class=\"string\">\"out-in\"</span> <span class=\"attr\">appear</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 事件钩子 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transition-demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> @<span class=\"attr\">after-enter</span>=<span class=\"string\">\"transitionComplete\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"ok\"</span>&gt;</span>toggled content<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    <span class=\"attr\">transitionComplete</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 传入 'el' 这个 DOM 元素作为参数。</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;).$mount(<span class=\"string\">'#transition-demo'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/transitions.html\">过渡：进入，离开和列表</a></p>\n</li>\n</ul>\n<h3 id=\"transition-group\"><a href=\"#transition-group\" class=\"headerlink\" title=\"transition-group\"></a>transition-group</h3><ul>\n<li><p><strong>Props：</strong></p>\n<ul>\n<li><code>tag</code> - string, 默认为 <code>span</code></li>\n<li><code>move-class</code> - 覆盖移动过渡期间应用的 CSS 类。</li>\n<li>除了 <code>mode</code>，其他特性和 <code>&lt;transition&gt;</code> 相同。</li>\n</ul>\n</li>\n<li><p><strong>事件：</strong></p>\n<ul>\n<li>事件和 <code>&lt;transition&gt;</code> 相同.</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p><code>&lt;transition-group&gt;</code> 元素作为多个元素/组件的过渡效果。<code>&lt;transition-group&gt;</code> 渲染一个真实的 DOM 元素。默认渲染 <code>&lt;span&gt;</code>，可以通过 <code>tag</code> 属性配置哪个元素应该被渲染。</p>\n<p>注意，每个 <code>&lt;transition-group&gt;</code> 的子节点必须有 <strong>独立的key</strong> ，动画才能正常工作</p>\n<p><code>&lt;transition-group&gt;</code> 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类（通过 <code>name</code> 属性或配置 <code>move-class</code> 属性自动生成）。如果 CSS <code>transform</code> 属性是“可过渡”属性，当应用移动类时，将会使用 <a href=\"https://aerotwist.com/blog/flip-your-animations/\">FLIP 技术</a> 使元素流畅地到达动画终点。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"ul\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"slide\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; item.text &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/transitions.html\">过渡：进入，离开和列表</a></p>\n</li>\n</ul>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>include</code> - string or RegExp. Only components matched by this will be cached.</li>\n<li><code>exclude</code> - string or RegExp. Any component matched by this will not be cached.</li>\n</ul>\n</li>\n<li><p><strong>用法：</strong></p>\n<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</p>\n<p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>\n<p>主要用于保留组件状态或避免重新渲染。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 基本 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 多个条件判断的子组件 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">comp-a</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"a &gt; 1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp-a</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">comp-b</span> <span class=\"attr\">v-else</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp-b</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 和 &lt;transition&gt; 一起使用 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong><code>include</code> and <code>exclude</code></strong></p>\n<blockquote>\n<p>New in 2.1.0</p>\n</blockquote>\n<p>The <code>include</code> and <code>exclude</code> props allow components to be conditionally cached. Both props can either be a comma-delimited string or a RegExp:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- comma-delimited string --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span> <span class=\"attr\">include</span>=<span class=\"string\">\"a,b\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- regex (use v-bind) --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span> <span class=\"attr\">:include</span>=<span class=\"string\">\"/a|b/\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>The match is first checked on the component’s own <code>name</code> option, then its local registration name (the key in the parent’s <code>components</code> option) if the <code>name</code> option is not available. Anonymous components cannot be matched against.</p>\n<p class=\"tip\"><code>&lt;keep-alive&gt;</code> 不会在函数式组件中正常工作，因为它们没有缓存实例。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html#keep-alive\">动态组件 - keep-alive</a></p>\n</li>\n</ul>\n<h3 id=\"slot-1\"><a href=\"#slot-1\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>Props：</strong></p>\n<ul>\n<li><code>name</code> - string, 用于命名插槽。</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;slot&gt;</code> 元素作为组件模板之中的内容分发插槽。 <code>&lt;slot&gt;</code> 元素自身将被替换。</p>\n<p>详细用法，请参考下面教程的链接。</p>\n</li>\n<li><p><strong>参考：</strong> <a href=\"../guide/components.html#使用Slots分发内容\">使用Slots分发内容</a></p>\n</li>\n</ul>\n<h2 id=\"VNode接口\"><a href=\"#VNode接口\" class=\"headerlink\" title=\"VNode接口\"></a>VNode接口</h2><ul>\n<li>请参考<a href=\"https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js\">VNode class declaration</a>.</li>\n</ul>\n<h2 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h2><ul>\n<li>请参考<a href=\"https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer\">vue-server-renderer package documentation</a>.</li>\n</ul>\n"},{"title":"具有伸缩性的 Header","type":"examples","order":7,"_content":"\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/y91wy85p/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","source":"v2/examples/elastic-header.md","raw":"---\ntitle: 具有伸缩性的 Header\ntype: examples\norder: 7\n---\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/y91wy85p/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/elastic-header.html","comments":1,"layout":"page","_id":"ciwnajuy1000ujl2dfcq6k512","content":"<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/y91wy85p/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","excerpt":"","more":"<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/y91wy85p/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n"},{"title":"HackerNews 克隆","type":"examples","order":10,"_content":"\n> HackerNews 克隆是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。\n\n{% raw %}\n<div style=\"max-width:600px\">\n  <a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\">\n    <img style=\"width:100%\" src=\"/images/hn.png\">\n  </a>\n</div>\n{% endraw %}\n\n> [Live Demo](https://vue-hn.now.sh/)\n> 注：如果在一段时间内没有人访问过该网站，则需要一些加载时间。\n>\n> [[Source](https://github.com/vuejs/vue-hackernews-2.0)]\n\n## 特性\n\n- 服务器端渲染\n  - Vue + vue-router + vuex\n  - 服务端数据提前获取\n  - 客户端状态 & DOM 合并\n- 单文件 Vue 组件\n  - 开发时进行热加载\n  - 生产时抽出 CSS\n- 使用 FLIP 动画进行实时列表更新\n\n## 结构概览\n\n<img width=\"973\" alt=\"Hackernew clone architecture overview\" src=\"/images/hn-architecture.png\">\n","source":"v2/examples/hackernews.md","raw":"---\ntitle: HackerNews 克隆\ntype: examples\norder: 10\n---\n\n> HackerNews 克隆是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。\n\n{% raw %}\n<div style=\"max-width:600px\">\n  <a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\">\n    <img style=\"width:100%\" src=\"/images/hn.png\">\n  </a>\n</div>\n{% endraw %}\n\n> [Live Demo](https://vue-hn.now.sh/)\n> 注：如果在一段时间内没有人访问过该网站，则需要一些加载时间。\n>\n> [[Source](https://github.com/vuejs/vue-hackernews-2.0)]\n\n## 特性\n\n- 服务器端渲染\n  - Vue + vue-router + vuex\n  - 服务端数据提前获取\n  - 客户端状态 & DOM 合并\n- 单文件 Vue 组件\n  - 开发时进行热加载\n  - 生产时抽出 CSS\n- 使用 FLIP 动画进行实时列表更新\n\n## 结构概览\n\n<img width=\"973\" alt=\"Hackernew clone architecture overview\" src=\"/images/hn-architecture.png\">\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/hackernews.html","comments":1,"layout":"page","_id":"ciwnajuy2000vjl2dbend6tl5","content":"<blockquote>\n<p>HackerNews 克隆是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。</p>\n</blockquote>\n\n<div style=\"max-width:600px\">\n  <a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\">\n    <img style=\"width:100%\" src=\"/images/hn.png\">\n  </a>\n</div>\n\n<blockquote>\n<p><a href=\"https://vue-hn.now.sh/\" target=\"_blank\" rel=\"external\">Live Demo</a><br>注：如果在一段时间内没有人访问过该网站，则需要一些加载时间。</p>\n<p>[<a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\" rel=\"external\">Source</a>]</p>\n</blockquote>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><ul>\n<li>服务器端渲染<ul>\n<li>Vue + vue-router + vuex</li>\n<li>服务端数据提前获取</li>\n<li>客户端状态 &amp; DOM 合并</li>\n</ul>\n</li>\n<li>单文件 Vue 组件<ul>\n<li>开发时进行热加载</li>\n<li>生产时抽出 CSS</li>\n</ul>\n</li>\n<li>使用 FLIP 动画进行实时列表更新</li>\n</ul>\n<h2 id=\"结构概览\"><a href=\"#结构概览\" class=\"headerlink\" title=\"结构概览\"></a>结构概览</h2><p><img width=\"973\" alt=\"Hackernew clone architecture overview\" src=\"/images/hn-architecture.png\"></p>\n","excerpt":"","more":"<blockquote>\n<p>HackerNews 克隆是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。</p>\n</blockquote>\n\n<div style=\"max-width:600px\">\n  <a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\">\n    <img style=\"width:100%\" src=\"/images/hn.png\">\n  </a>\n</div>\n\n<blockquote>\n<p><a href=\"https://vue-hn.now.sh/\">Live Demo</a><br>注：如果在一段时间内没有人访问过该网站，则需要一些加载时间。</p>\n<p>[<a href=\"https://github.com/vuejs/vue-hackernews-2.0\">Source</a>]</p>\n</blockquote>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><ul>\n<li>服务器端渲染<ul>\n<li>Vue + vue-router + vuex</li>\n<li>服务端数据提前获取</li>\n<li>客户端状态 &amp; DOM 合并</li>\n</ul>\n</li>\n<li>单文件 Vue 组件<ul>\n<li>开发时进行热加载</li>\n<li>生产时抽出 CSS</li>\n</ul>\n</li>\n<li>使用 FLIP 动画进行实时列表更新</li>\n</ul>\n<h2 id=\"结构概览\"><a href=\"#结构概览\" class=\"headerlink\" title=\"结构概览\"></a>结构概览</h2><p><img width=\"973\" alt=\"Hackernew clone architecture overview\" src=\"/images/hn-architecture.png\"></p>\n"},{"title":"Firebase + 验证","type":"examples","order":2,"_content":"\n> 本示例使用 [Firebase](https://firebase.google.com/) 作为数据存储后端，同时在客户端进行数据实时同步（你可以在多个浏览器窗口去打开它来验证）。另外，它通过计算属性实时验证，并且添加／移除选项时触发 CSS 过渡。\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/chrisvfritz/pyLbpzzx/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","source":"v2/examples/firebase.md","raw":"---\ntitle: Firebase + 验证\ntype: examples\norder: 2\n---\n\n> 本示例使用 [Firebase](https://firebase.google.com/) 作为数据存储后端，同时在客户端进行数据实时同步（你可以在多个浏览器窗口去打开它来验证）。另外，它通过计算属性实时验证，并且添加／移除选项时触发 CSS 过渡。\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/chrisvfritz/pyLbpzzx/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/firebase.html","comments":1,"layout":"page","_id":"ciwnajuy2000wjl2dsorjalaf","content":"<blockquote>\n<p>本示例使用 <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"external\">Firebase</a> 作为数据存储后端，同时在客户端进行数据实时同步（你可以在多个浏览器窗口去打开它来验证）。另外，它通过计算属性实时验证，并且添加／移除选项时触发 CSS 过渡。</p>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/chrisvfritz/pyLbpzzx/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>本示例使用 <a href=\"https://firebase.google.com/\">Firebase</a> 作为数据存储后端，同时在客户端进行数据实时同步（你可以在多个浏览器窗口去打开它来验证）。另外，它通过计算属性实时验证，并且添加／移除选项时触发 CSS 过渡。</p>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/chrisvfritz/pyLbpzzx/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n</blockquote>\n"},{"title":"网格组件","type":"examples","order":3,"_content":"\n> 本示例创建了一个可复用组件，可结合外部数据来使用它。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/xkkbfL3L/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","source":"v2/examples/grid-component.md","raw":"---\ntitle: 网格组件\ntype: examples\norder: 3\n---\n\n> 本示例创建了一个可复用组件，可结合外部数据来使用它。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/xkkbfL3L/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/grid-component.html","comments":1,"layout":"page","_id":"ciwnajuy9000xjl2dj7p3zn2j","content":"<blockquote>\n<p>本示例创建了一个可复用组件，可结合外部数据来使用它。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/xkkbfL3L/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","excerpt":"","more":"<blockquote>\n<p>本示例创建了一个可复用组件，可结合外部数据来使用它。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/xkkbfL3L/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n"},{"title":"Markdown 编辑器","type":"examples","order":0,"_content":"\n> 蠢萌的 Markdown 编辑器。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/chrisvfritz/rdjjpc7a/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","source":"v2/examples/index.md","raw":"---\ntitle: Markdown 编辑器\ntype: examples\norder: 0\n---\n\n> 蠢萌的 Markdown 编辑器。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/chrisvfritz/rdjjpc7a/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/index.html","comments":1,"layout":"page","_id":"ciwnajuya000yjl2dd12qe6q3","content":"<blockquote>\n<p>蠢萌的 Markdown 编辑器。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/chrisvfritz/rdjjpc7a/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","excerpt":"","more":"<blockquote>\n<p>蠢萌的 Markdown 编辑器。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/chrisvfritz/rdjjpc7a/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n"},{"title":"内嵌组件","type":"examples","order":8,"_content":"\n> 在本例中，我们整合了第三方 jQuery 插件（select2）,怎么做到的呢？就是把它内嵌在一个常用组件中==\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/fruqrvdL/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","source":"v2/examples/select2.md","raw":"---\ntitle: 内嵌组件\ntype: examples\norder: 8\n---\n\n> 在本例中，我们整合了第三方 jQuery 插件（select2）,怎么做到的呢？就是把它内嵌在一个常用组件中==\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/fruqrvdL/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/select2.html","comments":1,"layout":"page","_id":"ciwnajuya000zjl2dylk1g4bu","content":"<blockquote>\n<p>在本例中，我们整合了第三方 jQuery 插件（select2）,怎么做到的呢？就是把它内嵌在一个常用组件中==</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/fruqrvdL/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","excerpt":"","more":"<blockquote>\n<p>在本例中，我们整合了第三方 jQuery 插件（select2）,怎么做到的呢？就是把它内嵌在一个常用组件中==</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/fruqrvdL/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n"},{"title":"模式组件","type":"examples","order":6,"_content":"\n> 使用到的特性：组件，prop 传递，内容插入(content insertion)，过渡（transitions）。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/mwLbw11k/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","source":"v2/examples/modal.md","raw":"---\ntitle: 模式组件\ntype: examples\norder: 6\n---\n\n> 使用到的特性：组件，prop 传递，内容插入(content insertion)，过渡（transitions）。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/mwLbw11k/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/modal.html","comments":1,"layout":"page","_id":"ciwnajuyb0010jl2dplocsr8z","content":"<blockquote>\n<p>使用到的特性：组件，prop 传递，内容插入(content insertion)，过渡（transitions）。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/mwLbw11k/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","excerpt":"","more":"<blockquote>\n<p>使用到的特性：组件，prop 传递，内容插入(content insertion)，过渡（transitions）。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/mwLbw11k/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n"},{"title":"SVG 图表","type":"examples","order":5,"_content":"\n> 本示例展示了一个结合体，它由常用组件、计算属性、2 种绑定方式和 SVG 的支持组成。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/mhrckqgq/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","source":"v2/examples/svg.md","raw":"---\ntitle: SVG 图表\ntype: examples\norder: 5\n---\n\n> 本示例展示了一个结合体，它由常用组件、计算属性、2 种绑定方式和 SVG 的支持组成。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/mhrckqgq/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/svg.html","comments":1,"layout":"page","_id":"ciwnajuyb0011jl2dm289eo8n","content":"<blockquote>\n<p>本示例展示了一个结合体，它由常用组件、计算属性、2 种绑定方式和 SVG 的支持组成。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/mhrckqgq/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","excerpt":"","more":"<blockquote>\n<p>本示例展示了一个结合体，它由常用组件、计算属性、2 种绑定方式和 SVG 的支持组成。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/mhrckqgq/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n"},{"title":"TodoMVC","type":"examples","order":9,"_content":"\n> 本例是一个完全和规范一致的 TodoMVC 实现，只用了 120 行有效的 JavaScript（不包含注释和空行）。\n\n<p class=\"tip\">Note that if your web browser is configured to block 3rd-party data/cookies, the example below will not work, as the `localStorage` data will fail to be saved from JSFiddle. You'll have to click on `Edit in JSFiddle` to see the live result.</p>\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/4dr2fLb7/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","source":"v2/examples/todomvc.md","raw":"---\ntitle: TodoMVC\ntype: examples\norder: 9\n---\n\n> 本例是一个完全和规范一致的 TodoMVC 实现，只用了 120 行有效的 JavaScript（不包含注释和空行）。\n\n<p class=\"tip\">Note that if your web browser is configured to block 3rd-party data/cookies, the example below will not work, as the `localStorage` data will fail to be saved from JSFiddle. You'll have to click on `Edit in JSFiddle` to see the live result.</p>\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/4dr2fLb7/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/todomvc.html","comments":1,"layout":"page","_id":"ciwnajuyb0012jl2dy0eolugi","content":"<blockquote>\n<p>本例是一个完全和规范一致的 TodoMVC 实现，只用了 120 行有效的 JavaScript（不包含注释和空行）。</p>\n</blockquote>\n<p class=\"tip\">Note that if your web browser is configured to block 3rd-party data/cookies, the example below will not work, as the <code>localStorage</code> data will fail to be saved from JSFiddle. You’ll have to click on <code>Edit in JSFiddle</code> to see the live result.</p>\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/4dr2fLb7/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","excerpt":"","more":"<blockquote>\n<p>本例是一个完全和规范一致的 TodoMVC 实现，只用了 120 行有效的 JavaScript（不包含注释和空行）。</p>\n</blockquote>\n<p class=\"tip\">Note that if your web browser is configured to block 3rd-party data/cookies, the example below will not work, as the <code>localStorage</code> data will fail to be saved from JSFiddle. You’ll have to click on <code>Edit in JSFiddle</code> to see the live result.</p>\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/4dr2fLb7/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n"},{"title":"树形视图","type":"examples","order":4,"_content":"\n> 本示例是一个简单的树形视图实现，它展现了组件的递归使用。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/3p0j5sgy/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","source":"v2/examples/tree-view.md","raw":"---\ntitle: 树形视图\ntype: examples\norder: 4\n---\n\n> 本示例是一个简单的树形视图实现，它展现了组件的递归使用。\n\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/3p0j5sgy/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/examples/tree-view.html","comments":1,"layout":"page","_id":"ciwnajuyb0013jl2d99s69dl8","content":"<blockquote>\n<p>本示例是一个简单的树形视图实现，它展现了组件的递归使用。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/3p0j5sgy/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n","excerpt":"","more":"<blockquote>\n<p>本示例是一个简单的树形视图实现，它展现了组件的递归使用。</p>\n</blockquote>\n<iframe width=\"100%\" height=\"500\" src=\"https://jsfiddle.net/yyx990803/3p0j5sgy/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n"},{"title":"Class 与 Style 绑定","type":"guide","order":6,"_content":"\n数据绑定一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用` v-bind` 处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 `v-bind ` 用于 ` class ` 和 `style ` 时， Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。\n\n## 绑定 HTML Class\n\n### 对象语法\n\n我们可以传给 `v-bind:class` 一个对象，以动态地切换 class 。\n\n``` html\n<div v-bind:class=\"{ active: isActive }\"></div>\n```\n上面的语法表示 class`active` 的更新将取决于数据属性 `isActive` 是否为[真值](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) 。\n\n我们也可以在对象中传入更多属性用来动态切换多个 class 。此外， `v-bind:class` 指令可以与普通的 class 属性共存。如下模板:\n\n``` html\n<div class=\"static\"\n     v-bind:class=\"{ active: isActive, 'text-danger': hasError }\">\n</div>\n```\n\n如下 data:\n\n``` js\ndata: {\n  isActive: true,\n  hasError: false\n}\n```\n\n渲染为:\n\n``` html\n<div class=\"static active\"></div>\n```\n\n当 `isActive` 或者 `hasError` 变化时，class 列表将相应地更新。例如，如果 `hasError` 的值为 `true` ， class列表将变为 `\"static active text-danger\"`。\n\n你也可以直接绑定数据里的一个对象：\n\n``` html\n<div v-bind:class=\"classObject\"></div>\n```\n``` js\ndata: {\n  classObject: {\n    active: true,\n    'text-danger': false\n  }\n}\n```\n渲染的结果和上面一样。我们也可以在这里绑定返回对象的[计算属性](computed.html)。这是一个常用且强大的模式：\n\n\n``` html\n<div v-bind:class=\"classObject\"></div>\n```\n``` js\ndata: {\n  isActive: true,\n  error: null\n},\ncomputed: {\n  classObject: function () {\n    return {\n      active: this.isActive && !this.error,\n      'text-danger': this.error && this.error.type === 'fatal',\n    }\n  }\n}\n```\n\n### 数组语法\n\n我们可以把一个数组传给  `v-bind:class` ，以应用一个 class 列表：\n\n``` html\n<div v-bind:class=\"[activeClass, errorClass]\">\n```\n``` js\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n```\n\n渲染为:\n\n``` html\n<div class=\"active text-danger\"></div>\n```\n\n如果你也想根据条件切换列表中的 class ，可以用三元表达式：\n\n``` html\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\">\n```\n此例始终添加 `errorClass` ，但是只有在 `isActive` 是 true 时添加 `activeClass` 。\n\n不过，当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法：\n\n``` html\n<div v-bind:class=\"[{ active: isActive }, errorClass]\">\n```\n\n### 用在组件上\n\n> 这个章节假设你已经对 [Vue 组件](components.html) 有一定的了解。当然你也可以跳过这里，稍后再回过头来看。\n\n当你在一个定制的组件上用到 `class` 属性的时候，这些类将被添加到根元素上面，这个元素上已经存在的类不会被覆盖。\n\n例如，如果你声明了这个组件:\n\n``` js\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n```\n\n然后在使用它的时候添加一些 class：\n\n``` html\n<my-component class=\"baz boo\"></my-component>\n```\n\nHTML 最终将被渲染成为:\n\n``` html\n<p class=\"foo bar baz boo\">Hi</p>\n```\n\n同样的适用于绑定 HTML class :\n\n``` html\n<my-component v-bind:class=\"{ active: isActive }\"></my-component>\n```\n\n当 `isActive` 为 true 的时候，HTML 将被渲染成为:\n\n``` html\n<p class=\"foo bar active\"></p>\n```\n\n## 绑定内联样式\n\n### 对象语法\n\n`v-bind:style` 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）：\n\n\n``` html\n<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n```\n``` js\ndata: {\n  activeColor: 'red',\n  fontSize: 30\n}\n```\n\n直接绑定到一个样式对象通常更好，让模板更清晰：\n\n``` html\n<div v-bind:style=\"styleObject\"></div>\n```\n``` js\ndata: {\n  styleObject: {\n    color: 'red',\n    fontSize: '13px'\n  }\n}\n\n```\n同样的，对象语法常常结合返回对象的计算属性使用。\n\n### 数组语法\n\n`v-bind:style` 的数组语法可以将多个样式对象应用到一个元素上：\n\n``` html\n<div v-bind:style=\"[baseStyles, overridingStyles]\">\n```\n\n### 自动添加前缀\n\n当 `v-bind:style` 使用需要特定前缀的 CSS 属性时，如 `transform` ，Vue.js 会自动侦测并添加相应的前缀。\n\n***\n\n> 原文：http://vuejs.org/guide/class-and-style.html\n\n***\n","source":"v2/guide/class-and-style.md","raw":"---\ntitle: Class 与 Style 绑定\ntype: guide\norder: 6\n---\n\n数据绑定一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用` v-bind` 处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 `v-bind ` 用于 ` class ` 和 `style ` 时， Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。\n\n## 绑定 HTML Class\n\n### 对象语法\n\n我们可以传给 `v-bind:class` 一个对象，以动态地切换 class 。\n\n``` html\n<div v-bind:class=\"{ active: isActive }\"></div>\n```\n上面的语法表示 class`active` 的更新将取决于数据属性 `isActive` 是否为[真值](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) 。\n\n我们也可以在对象中传入更多属性用来动态切换多个 class 。此外， `v-bind:class` 指令可以与普通的 class 属性共存。如下模板:\n\n``` html\n<div class=\"static\"\n     v-bind:class=\"{ active: isActive, 'text-danger': hasError }\">\n</div>\n```\n\n如下 data:\n\n``` js\ndata: {\n  isActive: true,\n  hasError: false\n}\n```\n\n渲染为:\n\n``` html\n<div class=\"static active\"></div>\n```\n\n当 `isActive` 或者 `hasError` 变化时，class 列表将相应地更新。例如，如果 `hasError` 的值为 `true` ， class列表将变为 `\"static active text-danger\"`。\n\n你也可以直接绑定数据里的一个对象：\n\n``` html\n<div v-bind:class=\"classObject\"></div>\n```\n``` js\ndata: {\n  classObject: {\n    active: true,\n    'text-danger': false\n  }\n}\n```\n渲染的结果和上面一样。我们也可以在这里绑定返回对象的[计算属性](computed.html)。这是一个常用且强大的模式：\n\n\n``` html\n<div v-bind:class=\"classObject\"></div>\n```\n``` js\ndata: {\n  isActive: true,\n  error: null\n},\ncomputed: {\n  classObject: function () {\n    return {\n      active: this.isActive && !this.error,\n      'text-danger': this.error && this.error.type === 'fatal',\n    }\n  }\n}\n```\n\n### 数组语法\n\n我们可以把一个数组传给  `v-bind:class` ，以应用一个 class 列表：\n\n``` html\n<div v-bind:class=\"[activeClass, errorClass]\">\n```\n``` js\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n```\n\n渲染为:\n\n``` html\n<div class=\"active text-danger\"></div>\n```\n\n如果你也想根据条件切换列表中的 class ，可以用三元表达式：\n\n``` html\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\">\n```\n此例始终添加 `errorClass` ，但是只有在 `isActive` 是 true 时添加 `activeClass` 。\n\n不过，当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法：\n\n``` html\n<div v-bind:class=\"[{ active: isActive }, errorClass]\">\n```\n\n### 用在组件上\n\n> 这个章节假设你已经对 [Vue 组件](components.html) 有一定的了解。当然你也可以跳过这里，稍后再回过头来看。\n\n当你在一个定制的组件上用到 `class` 属性的时候，这些类将被添加到根元素上面，这个元素上已经存在的类不会被覆盖。\n\n例如，如果你声明了这个组件:\n\n``` js\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n```\n\n然后在使用它的时候添加一些 class：\n\n``` html\n<my-component class=\"baz boo\"></my-component>\n```\n\nHTML 最终将被渲染成为:\n\n``` html\n<p class=\"foo bar baz boo\">Hi</p>\n```\n\n同样的适用于绑定 HTML class :\n\n``` html\n<my-component v-bind:class=\"{ active: isActive }\"></my-component>\n```\n\n当 `isActive` 为 true 的时候，HTML 将被渲染成为:\n\n``` html\n<p class=\"foo bar active\"></p>\n```\n\n## 绑定内联样式\n\n### 对象语法\n\n`v-bind:style` 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）：\n\n\n``` html\n<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n```\n``` js\ndata: {\n  activeColor: 'red',\n  fontSize: 30\n}\n```\n\n直接绑定到一个样式对象通常更好，让模板更清晰：\n\n``` html\n<div v-bind:style=\"styleObject\"></div>\n```\n``` js\ndata: {\n  styleObject: {\n    color: 'red',\n    fontSize: '13px'\n  }\n}\n\n```\n同样的，对象语法常常结合返回对象的计算属性使用。\n\n### 数组语法\n\n`v-bind:style` 的数组语法可以将多个样式对象应用到一个元素上：\n\n``` html\n<div v-bind:style=\"[baseStyles, overridingStyles]\">\n```\n\n### 自动添加前缀\n\n当 `v-bind:style` 使用需要特定前缀的 CSS 属性时，如 `transform` ，Vue.js 会自动侦测并添加相应的前缀。\n\n***\n\n> 原文：http://vuejs.org/guide/class-and-style.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/class-and-style.html","comments":1,"layout":"page","_id":"ciwnajuyc0014jl2d7mtzouzn","content":"<p>数据绑定一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用<code>v-bind</code> 处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时， Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。</p>\n<h2 id=\"绑定-HTML-Class\"><a href=\"#绑定-HTML-Class\" class=\"headerlink\" title=\"绑定 HTML Class\"></a>绑定 HTML Class</h2><h3 id=\"对象语法\"><a href=\"#对象语法\" class=\"headerlink\" title=\"对象语法\"></a>对象语法</h3><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class 。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"&#123; active: isActive &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上面的语法表示 class<code>active</code> 的更新将取决于数据属性 <code>isActive</code> 是否为<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\" target=\"_blank\" rel=\"external\">真值</a> 。</p>\n<p>我们也可以在对象中传入更多属性用来动态切换多个 class 。此外， <code>v-bind:class</code> 指令可以与普通的 class 属性共存。如下模板:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"static\"</span></span></div><div class=\"line\">     <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"&#123; active: isActive, 'text-danger': hasError &#125;\"</span>&gt;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如下 data:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">isActive</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"attr\">hasError</span>: <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>渲染为:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"static active\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code> 的值为 <code>true</code> ， class列表将变为 <code>&quot;static active text-danger&quot;</code>。</p>\n<p>你也可以直接绑定数据里的一个对象：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"classObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">classObject</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">active</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"string\">'text-danger'</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>渲染的结果和上面一样。我们也可以在这里绑定返回对象的<a href=\"computed.html\">计算属性</a>。这是一个常用且强大的模式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"classObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">isActive</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"attr\">error</span>: <span class=\"literal\">null</span></div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">classObject</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">active</span>: <span class=\"keyword\">this</span>.isActive &amp;&amp; !<span class=\"keyword\">this</span>.error,</div><div class=\"line\">      <span class=\"string\">'text-danger'</span>: <span class=\"keyword\">this</span>.error &amp;&amp; <span class=\"keyword\">this</span>.error.type === <span class=\"string\">'fatal'</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"数组语法\"><a href=\"#数组语法\" class=\"headerlink\" title=\"数组语法\"></a>数组语法</h3><p>我们可以把一个数组传给  <code>v-bind:class</code> ，以应用一个 class 列表：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[activeClass, errorClass]\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">activeClass</span>: <span class=\"string\">'active'</span>,</div><div class=\"line\">  <span class=\"attr\">errorClass</span>: <span class=\"string\">'text-danger'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>渲染为:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"active text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果你也想根据条件切换列表中的 class ，可以用三元表达式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[isActive ? activeClass : '', errorClass]\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>此例始终添加 <code>errorClass</code> ，但是只有在 <code>isActive</code> 是 true 时添加 <code>activeClass</code> 。</p>\n<p>不过，当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[&#123; active: isActive &#125;, errorClass]\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"用在组件上\"><a href=\"#用在组件上\" class=\"headerlink\" title=\"用在组件上\"></a>用在组件上</h3><blockquote>\n<p>这个章节假设你已经对 <a href=\"components.html\">Vue 组件</a> 有一定的了解。当然你也可以跳过这里，稍后再回过头来看。</p>\n</blockquote>\n<p>当你在一个定制的组件上用到 <code>class</code> 属性的时候，这些类将被添加到根元素上面，这个元素上已经存在的类不会被覆盖。</p>\n<p>例如，如果你声明了这个组件:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>然后在使用它的时候添加一些 class：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">class</span>=<span class=\"string\">\"baz boo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>HTML 最终将被渲染成为:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"foo bar baz boo\"</span>&gt;</span>Hi<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>同样的适用于绑定 HTML class :</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"&#123; active: isActive &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当 <code>isActive</code> 为 true 的时候，HTML 将被渲染成为:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"foo bar active\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"绑定内联样式\"><a href=\"#绑定内联样式\" class=\"headerlink\" title=\"绑定内联样式\"></a>绑定内联样式</h2><h3 id=\"对象语法-1\"><a href=\"#对象语法-1\" class=\"headerlink\" title=\"对象语法\"></a>对象语法</h3><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">activeColor</span>: <span class=\"string\">'red'</span>,</div><div class=\"line\">  <span class=\"attr\">fontSize</span>: <span class=\"number\">30</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>直接绑定到一个样式对象通常更好，让模板更清晰：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"styleObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">styleObject</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>: <span class=\"string\">'red'</span>,</div><div class=\"line\">    <span class=\"attr\">fontSize</span>: <span class=\"string\">'13px'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，对象语法常常结合返回对象的计算属性使用。</p>\n<h3 id=\"数组语法-1\"><a href=\"#数组语法-1\" class=\"headerlink\" title=\"数组语法\"></a>数组语法</h3><p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到一个元素上：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"[baseStyles, overridingStyles]\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"自动添加前缀\"><a href=\"#自动添加前缀\" class=\"headerlink\" title=\"自动添加前缀\"></a>自动添加前缀</h3><p>当 <code>v-bind:style</code> 使用需要特定前缀的 CSS 属性时，如 <code>transform</code> ，Vue.js 会自动侦测并添加相应的前缀。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/class-and-style.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/class-and-style.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<p>数据绑定一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用<code>v-bind</code> 处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时， Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。</p>\n<h2 id=\"绑定-HTML-Class\"><a href=\"#绑定-HTML-Class\" class=\"headerlink\" title=\"绑定 HTML Class\"></a>绑定 HTML Class</h2><h3 id=\"对象语法\"><a href=\"#对象语法\" class=\"headerlink\" title=\"对象语法\"></a>对象语法</h3><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class 。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"&#123; active: isActive &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上面的语法表示 class<code>active</code> 的更新将取决于数据属性 <code>isActive</code> 是否为<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\">真值</a> 。</p>\n<p>我们也可以在对象中传入更多属性用来动态切换多个 class 。此外， <code>v-bind:class</code> 指令可以与普通的 class 属性共存。如下模板:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"static\"</span></div><div class=\"line\">     <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"&#123; active: isActive, 'text-danger': hasError &#125;\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如下 data:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">isActive</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"attr\">hasError</span>: <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>渲染为:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"static active\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code> 的值为 <code>true</code> ， class列表将变为 <code>&quot;static active text-danger&quot;</code>。</p>\n<p>你也可以直接绑定数据里的一个对象：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"classObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">classObject</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">active</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"string\">'text-danger'</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>渲染的结果和上面一样。我们也可以在这里绑定返回对象的<a href=\"computed.html\">计算属性</a>。这是一个常用且强大的模式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"classObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">isActive</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"attr\">error</span>: <span class=\"literal\">null</span></div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">classObject</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">active</span>: <span class=\"keyword\">this</span>.isActive &amp;&amp; !<span class=\"keyword\">this</span>.error,</div><div class=\"line\">      <span class=\"string\">'text-danger'</span>: <span class=\"keyword\">this</span>.error &amp;&amp; <span class=\"keyword\">this</span>.error.type === <span class=\"string\">'fatal'</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"数组语法\"><a href=\"#数组语法\" class=\"headerlink\" title=\"数组语法\"></a>数组语法</h3><p>我们可以把一个数组传给  <code>v-bind:class</code> ，以应用一个 class 列表：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[activeClass, errorClass]\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">activeClass</span>: <span class=\"string\">'active'</span>,</div><div class=\"line\">  <span class=\"attr\">errorClass</span>: <span class=\"string\">'text-danger'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>渲染为:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"active text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果你也想根据条件切换列表中的 class ，可以用三元表达式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[isActive ? activeClass : '', errorClass]\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>此例始终添加 <code>errorClass</code> ，但是只有在 <code>isActive</code> 是 true 时添加 <code>activeClass</code> 。</p>\n<p>不过，当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[&#123; active: isActive &#125;, errorClass]\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"用在组件上\"><a href=\"#用在组件上\" class=\"headerlink\" title=\"用在组件上\"></a>用在组件上</h3><blockquote>\n<p>这个章节假设你已经对 <a href=\"components.html\">Vue 组件</a> 有一定的了解。当然你也可以跳过这里，稍后再回过头来看。</p>\n</blockquote>\n<p>当你在一个定制的组件上用到 <code>class</code> 属性的时候，这些类将被添加到根元素上面，这个元素上已经存在的类不会被覆盖。</p>\n<p>例如，如果你声明了这个组件:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>然后在使用它的时候添加一些 class：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">class</span>=<span class=\"string\">\"baz boo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>HTML 最终将被渲染成为:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"foo bar baz boo\"</span>&gt;</span>Hi<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>同样的适用于绑定 HTML class :</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"&#123; active: isActive &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当 <code>isActive</code> 为 true 的时候，HTML 将被渲染成为:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"foo bar active\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"绑定内联样式\"><a href=\"#绑定内联样式\" class=\"headerlink\" title=\"绑定内联样式\"></a>绑定内联样式</h2><h3 id=\"对象语法-1\"><a href=\"#对象语法-1\" class=\"headerlink\" title=\"对象语法\"></a>对象语法</h3><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">activeColor</span>: <span class=\"string\">'red'</span>,</div><div class=\"line\">  <span class=\"attr\">fontSize</span>: <span class=\"number\">30</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>直接绑定到一个样式对象通常更好，让模板更清晰：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"styleObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">styleObject</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>: <span class=\"string\">'red'</span>,</div><div class=\"line\">    <span class=\"attr\">fontSize</span>: <span class=\"string\">'13px'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，对象语法常常结合返回对象的计算属性使用。</p>\n<h3 id=\"数组语法-1\"><a href=\"#数组语法-1\" class=\"headerlink\" title=\"数组语法\"></a>数组语法</h3><p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到一个元素上：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"[baseStyles, overridingStyles]\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"自动添加前缀\"><a href=\"#自动添加前缀\" class=\"headerlink\" title=\"自动添加前缀\"></a>自动添加前缀</h3><p>当 <code>v-bind:style</code> 使用需要特定前缀的 CSS 属性时，如 <code>transform</code> ，Vue.js 会自动侦测并添加相应的前缀。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/class-and-style.html\">http://vuejs.org/guide/class-and-style.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"对比其他框架","type":"guide","order":28,"_content":"这个页面无疑是最难编写的，但我们认为它也是非常重要的。或许你曾遇到了一些问题并且已经用其他的框架解决了。你来这里的目的是看看 Vue 是否有更好的解决方案。这也是我们在此想要回答的。\n\n客观来说，作为核心团队成员，显然我们会更偏爱 Vue，认为对于某些问题来讲用 Vue 解决会更好。如果没有这点信念，我们也就不会整天为此忙活了。但是在此，我们想尽可能地公平和准确地来描述一切。其他的框架也有显著的优点，例如 React 庞大的生态系统，或者像是 Knockout 对浏览器的支持覆盖到了 IE6。我们会尝试着把这些内容全部列出来。\n\n我们也希望得到**你**的帮助，来使文档保持最新状态，因为 JavaScript 的世界进步的太快。如果你注意到一个不准确或似乎不太正确的地方，请[提交问题](https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide)让我们知道。\n\n## React\n\nReact 和 Vue 有许多相似之处，它们都有：\n\n- 使用 Virtual DOM\n- 提供了响应式（Reactive）和组件化（Composable）的视图组件。\n- 将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。\n\n由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要指出 React 比 Vue 更好的地方，像是他们的生态系统和丰富的自定义渲染器。\n\nReact社区为我们准确进行平衡的考量提供了[非常积极地帮助](https://github.com/vuejs/vuejs.org/issues/364)，特别感谢来自 React 团队的 Dan Abramov 。他非常慷慨的花费时间来贡献专业知识，帮助我们完善这篇文档，最后我们对最终结果[都十分满意](https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244575740)。\n\n### 性能简介\n\n到目前为止，针对现实情况的测试中，Vue 的性能是优于 React 的。如果你对此表示怀疑，请继续阅读。我们会解释为什么会这样（并且会提供一个与 React 团队共同约定的比较基准）。\n\n#### 渲染性能\n\n在渲染用户界面的时候，DOM 的操作成本是最高的，不幸的是没有库可以让这些原始操作变得更快。\n我们能做到的最好效果就是：\n\n1. Minimize the number of necessary DOM mutations. Both React and Vue use virtual DOM abstractions to accomplish this and both implementations work about equally well.\n\n2. Add as little overhead (pure JavaScript computations) as possible on top of those DOM manipulations. This is an area where Vue and React differ.\n\nThe JavaScript overhead is directly related to the mechanisms of computing the necessary DOM operations. Both Vue and React utilizes Virtual DOM to achieve that, but Vue's Virtual DOM implementation (a fork of [snabbdom](https://github.com/snabbdom/snabbdom)) is much lighter-weight and thus introduces less overhead than React's.\n\nVue 和 React 也提供功能性组件，这些组件因为都是没有声明，没有实例化的，因此会花费更少的开销。当这些都用于关键性能的场景时，Vue 将会更快。为了证明这点，我们建立了一个简单的[参照项目](https://github.com/chrisvfritz/vue-render-performance-comparisons)，它负责渲染 10,000 个列表项 100 次。我们鼓励你基于此去尝试运行一下。然而在实际上，由于浏览器和硬件的差异甚至 JavaScript 引擎的不同，结果都会相应有所不同。\n\n如果你懒得去做，下面的数值是来自于一个 2014 年产的 MacBook Air 并在 Chrome 52 版本下运行所产生的。为了避免偶然性，每个参照项目都分别运行 20 次并取自最好的结果：\n\n{% raw %}\n<table class=\"benchmark-table\">\n  <thead>\n    <tr>\n      <th></th>\n      <th>Vue</th>\n      <th>React</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Fastest</th>\n      <td>23ms</td>\n      <td>63ms</td>\n    </tr>\n    <tr>\n      <th>Median</th>\n      <td>42ms</td>\n      <td>81ms</td>\n    </tr>\n    <tr>\n      <th>Average</th>\n      <td>51ms</td>\n      <td>94ms</td>\n    </tr>\n    <tr>\n      <th>95th Perc.</th>\n      <td>73ms</td>\n      <td>164ms</td>\n    </tr>\n    <tr>\n      <th>Slowest</th>\n      <td>343ms</td>\n      <td>453ms</td>\n    </tr>\n  </tbody>\n</table>\n{% endraw %}\n\n#### 更新性能\n\nIn React, when a component's state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. \n\nTo avoid unnecessary re-renders of child components, you need to implement `shouldComponentUpdate` everywhere and use immutable data structures. In Vue, a component's dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render.\n\n这意味着，未经优化的 Vue 相比未经优化的 React 要快的多。由于 Vue 改进过渲染性能，甚至全面优化过的 React 通常也会慢于开箱即用的 Vue。\n\n#### 开发中\n\n显然，在生产环境中的性能是至关重要的，目前为止我们所具体讨论的便是针对此环境。但开发过程中的表现也不容小视。不错的是用 Vue 和 React 开发大多数应用的速度都是足够快的。\n\n当性能在生产中性能是直接与终端用户体验相关的更重要的指标时，表现在开发中仍然很重要,因为它是与开发相关经验\n\n然而，假如你要开发一个对性能要求比较高的数据可视化或者动画的应用时，你需要了解到下面这点：在开发中，Vue 每秒最高处理 10 帧，而 React 每秒最高处理不到 1 帧。\n\n这是由于 React 有大量的检查机制，这会让它提供许多有用的警告和错误提示信息。我们同样认为这些是很重要的，但是我们在实现这些检查时，也更加密切地关注了性能方面。\n\n### HTML & CSS\n\n在 React 中，它们都是 JavaScript 编写的，听起来这十分简单和优雅。然而不幸的事实是，JavaScript 内的 HTML 和 CSS 会产生很多痛点。在 Vue 中我们采用 Web 技术并在其上进行扩展。接下来将通过一些实例向你展示这意味的是什么。\n\n\n#### JSX vs Templates\n\n在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 Javascript 的一种语法糖。这有一个[通过React社区审核过的例子](https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244582684)：\n\n``` jsx\n  render () {\n\t    let { items } = this.props\n\n\t    let children\n\t    if ( items.length > 0 ) {\n\t        children = (\n\t            <ul>\n\t                {items.map( item =>\n\t                    <li key={item.id}>{item.name}</li>\n\t                )}\n\t            </ul>\n\t        )\n\t    } else {\n\t        children = <p>No items found.</p>\n\t    }\n\n\t    return (\n\t        <div className = 'list-container'>\n\t            {children}\n\t        </div>\n\t    )\n\t}\n```\n\nJSX 的渲染功能有下面这些优势：\n\n- 你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。\n- 工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的（比如，linting、类型检查、编辑器的自动完成）。\n\n在 Vue 中，由于有时需要用这些功能，我们也提供了[渲染功能](render-function.html) 并且[支持了 JSX](render-function.html#JSX)。然而，对于大多数组件来说，渲染功能是不推荐使用了。\n\n在这方面，我们提供的是更简单的模板：\n\n``` html\n\t<template>\n\t    <div class=\"list-container\">\n\t        <ul v-if=\"items.length\">\n\t            <li v-for=\"item in items\">\n\t                {{ item.name }}\n\t            </li>\n\t        </ul>\n\t        <p v-else>No items found.</p>\n\t    </div>\n\t</template>\n```\n\n优点如下：\n\n- 在写模板的过程中，样式风格已定并涉及更少的功能实现。\n- 模板总是会被声明的。\n- 模板中任何 HTML 语法都是有效的。\n- 阅读起来更贴合英语（比如，for each item in items）。\n- 不需要高级版本的 JavaScript 语法，来增加可读性。\n\n这样，不仅开发人员更容易编写代码，设计人员和开发人员也可以更容易的分析代码和贡献代码。\n\n这还没有结束。Vue 拥抱 HTML，而不是用 JavaScript 去重塑它。在模板内，Vue 也允许你用预处理器比如 Pug（原名 Jade）。\n\n``` pug\ndiv.list-container\n  ul(v-if=\"items.length\")\n    li(v-for=\"item in items\") {{ item.name }}\n  p(v-else) No items found.\n```\n\n#### CSS 的组件作用域\n\n除非你把组件分布在多个文件上(例如 [CSS Modules](https://github.com/gajus/react-css-modules))，要不在 React 中作用域内的 CSS 就会产生警告。非常简单的 CSS 还可以工作，但是稍微复杂点的，比如悬停状态、媒体查询、伪类选择符等要么通过沉重的依赖来重做要么就直接不能用。\n\n而 Vue 可以让你在每个[单文件组件](single-file-components.html)中完全访问 CSS。\n\n``` html\n\t<style scoped>\n\t    @media (min-width: 250px) {\n\t        .list-container:hover {\n\t            background: orange;\n\t        }\n\t    }\n\t</style>\n```\n\n这个可选 `scoped` 属性会自动添加一个唯一的属性（比如 `data-v-21e5b78`）为组件内 CSS 指定作用域，编译的时候 `.list-container:hover` 会被编译成类似 `.list-container[data-v-21e5b78]:hover`。\n\n如果你已经熟悉 CSS Modules，Vue 单文件组件也有 [first-class 支持它](http://vue-loader.vuejs.org/en/features/css-modules.html)。\n\n最后，就像 HTML 一样，你可以选择自己偏爱的 CSS 预处理器（或后处理器）编写 CSS，这些生态系统允许您利用现有的库。这可以让你围绕设计为中心展开工作，,比如您的构建过程中颜色操作，而不是引入专门的库来增加你应用的体积和复杂度。\n\n### 规模\n\n#### 向上扩展\n\nVue 和 React 都提供了强大的路由来应对大型应用。React 社区在状态管理方面非常有创新精神（比如Flux、Redux），而这些状态管理模式甚至[ Redux 本身](https://github.com/egoist/revue)也可以非常容易的集成在 Vue 应用中。实际上，Vue 更进一步地采用了这种模式（[Vuex](https://github.com/vuejs/vuex)），更加深入集成 Vue 的状态管理解决方案 Vuex 相信能为你带来更好的开发体验。\n\n两者另一个重要差异是，Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。\n\n最后，Vue 提供了[Vue-cli 脚手架](https://github.com/vuejs/vue-cli)，能让你非常容易地构建项目，包含了 [Webpack](https://github.com/vuejs-templates/webpack), [Browserify](https://github.com/vuejs-templates/browserify), 甚至 [no build system](https://github.com/vuejs-templates/simple)。React 在这方面也提供了[create-react-app](https://github.com/facebookincubator/create-react-app)，但是现在还存在一些局限性：\n\n- 它不允许在项目生成时进行任何配置，而 Vue 支持 Yeoman-like 定制。\n- 它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。\n- 它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。\n\n而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。如果阅读更多关于[不同的设计理念](https://github.com/facebookincubator/create-react-app#philosophy)。\n\n#### 向下扩展\n\nReact 学习曲线陡峭，在你开始学 React 前，你需要知道 JSX 和 ES2015，因为许多示例用的是这些语法。你需要学习构建系统，虽然你在技术上可以用 Babel 来实时编译代码，但是这并不推荐用于生产环境。\n\n就像 Vue 向上扩展好比 React 一样，Vue 向下扩展后就类似于 jQuery。你只要把如下标签放到页面就可以运行：\n\n`<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>`\n\n\n然后你就可以编写 Vue 代码并应用到生产中，你只要用 min 版 Vue 文件替换掉就不用担心其他的性能问题。\n\n由于起步阶段不需学 JSX，ES2015 以及构建系统，所以开发者只需不到一天的时间阅读[指南](./)就可以建立简单的应用程序。\n\n### 本地渲染\n\nReactNative 能使你用相同的组件模型编写有本地渲染能力的 APP（IOS 和 Android）。能同时跨多平台开发，对开发者是非常棒的。相应地，Vue 和 [Weex](https://alibaba.github.io/weex/) 会进行官方合作，Weex 是阿里的跨平台用户界面开发框架，Weex 的 JavaScript 框架运行时用的就是 Vue。这意味着在 Weex 的帮助下，你使用 Vue 语法开发的组件不仅仅可以运行在浏览器端，还能被用于开发 IOS 和 Android 上的原生应用。\n\n在现在，Weex 还在积极发展，成熟度也不能和 ReactNative 相抗衡。但是，Weex 的发展是由世界上最大的电子商务企业的需求在驱动，Vue 团队也会和 Weex 团队积极合作确保为开发者带来良好的开发体验。\n\n### MobX\n\nMobx 在 React 社区很流行，实际上在 Vue 也采用了几乎相同的反应系统。在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue，所以如果你习惯组合使用它们，那么选择 Vue 会更合理。\n\n## Angular 1\n\nVue 的一些语法和 Angular 的很相似（例如 `v-if` vs `ng-if`）。因为 Angular 是 Vue 早期开发的灵感来源。然而，Augular 中存在的许多问题，在 Vue 中已经得到解决。\n\n### 复杂性\n\n在 API 与设计两方面上 Vue.js 都比 Angular 1 简单得多，因此你可以快速地掌握它的全部特性并投入开发。\n\n### 灵活性和模块化\n\nVue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 Angular 1 制定的规则，这让 Vue 能适用于各种项目。我们知道把决定权交给你是非常必要的。\n这也就是为什么我们提供 [Webpack template](https://github.com/vuejs-templates/webpack)，让你可以用几分钟，去选择是否启用高级特性，比如热模块加载、linting、CSS 提取等等。\n\n### 数据绑定\n\nAngular 1 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。\n\n### 指令与组件\n\n在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。在 Angular 中两者有不少相混的地方。\n\n### 性能\n\nVue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。\n\n在 Angular 1 中，当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。\n\nVue 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系。\n\n有意思的是，Angular 2 和 Vue 用相似的设计解决了一些 Angular 1 中存在的问题。\n\n## Angular 2\n\n我们单独将 Augluar 2 作分类，因为它完全是一个全新的框架。例如：它具有优秀的组件系统，并且许多实现已经完全重写，API 也完全改变了。\n\n### TypeScript\n\nAngular 1 面向的是较小的应用程序，Angular 2 已转移焦点，面向的是大型企业应用。在这一点上 TypeScript 经常会被引用，它对那些喜欢用 Java 或者 C# 等类型安全的语言的人是非常有用的。\n\nVue 也十分适合制作[企业应用](https://github.com/vuejs/awesome-vue#enterprise-usage)，你也可以通过使用[官方类型](https://github.com/vuejs/vue/tree/dev/types)或[官方装饰器](https://github.com/itsFrank/vue-typescript)来支持 TypeScript，这完全可由你的方案来定。\n\n### 大小和性能\n\n在性能方面，这两个框架都非常的快。但目前尚没有足够的数据用例来具体展示。如果你一定要量化这些数据，你可以查看[第三方参照](http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html)，它表明 Vue 2 相比 Angular2 是更快的。\n\n在大小方面，虽然 Angular 2 使用 tree-shaking 和离线编译技术使代码体积减小了许多。但包含编译器和全部功能的 Vue2(23kb) 相比 Angular 2(50kb) 还是要小的多。但是要注意，用 Angular 2 的 App 的体积缩减是使用了 tree-shaking 移除了那些框架中没有用到的功能，但随着功能引入的不断增多，尺寸会变得越来越大。\n\n### 灵活性\n\nVue 相比于 Angular 2 则更加灵活，Vue 官方提供了构建工具来协助你构建项目，但它并不限制你去如何构建。有人可能喜欢用统一的方式来构建，也有很多开发者喜欢这种灵活自由的方式。\n\n### 学习曲线\n\n开始使用 Vue，你使用的是熟悉的 HTML、符合 ES5 规则的 JavaScript（也就是纯 JavaScript）。有了这些基本的技能，你可以快速地掌握它([指南](./))并投入开发 。\n\nAngular 2 的学习曲线是非常陡峭的。即使不包括 TypeScript，它的[开始指南](https://angular.io/docs/js/latest/quickstart.html)中所用的就有 ES2015 标准的 JavaScript，18个 NPM 依赖包，4 个文件和超过 3 千多字的介绍，这一切都是为了完成个 Hello World。而[Vue's Hello World](https://jsfiddle.net/chrisvfritz/50wL7mdz/)就非常简单。甚至我们并不用花费一整个页面去介绍它。\n\n## Ember\n\nEmber 是一个全能框架。它提供了大量的约定，一旦你熟悉了它们，开发会变得很高效。不过，这也意味着学习曲线较高，而且并不灵活。这意味着在框架和库（加上一系列松散耦合的工具）之间做权衡选择。后者会更自由，但是也要求你做更多架构上的决定。\n\n也就是说，我们最好比较的是 Vue 内核和 Ember 的[模板](https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/)与[数据模型](https://guides.emberjs.com/v2.10.0/object-model/)层：\n\n* Vue 在普通 JavaScript 对象上建立响应，提供自动化的计算属性。在 Ember 中需要将所有东西放在 Ember 对象内，并且手工为计算属性声明依赖。\n\n* Vue 的模板语法可以用全功能的 JavaScript 表达式，而 Handlebars 的语法和帮助函数相比来说非常受限。\n\n* 在性能上，Vue 甩开 Ember 几条街，即使是 Ember 2.0 的最新 Glimmer 引擎。Vue 能够自动批量更新，而 Ember 在关键性能场景时需要手动管理。\n\n## Knockout\n\nKnockout 是 MVVM 领域内的先驱，并且追踪依赖。它的响应系统和 Vue 也很相似。它在[浏览器支持](http://knockoutjs.com/documentation/browser-support.html)以及其他方面的表现也是让人印象深刻的。它最低能支持到 IE6，而 Vue 最低只能支持到 IE9。\n\n随着时间的推移，Knockout 的发展已有所放缓，并且略显有点老旧了。比如，它的组件系统缺少完备的生命周期事件方法，尽管这些在现在是非常常见的。以及相比于 [Vue](components.html#Content-Distribution-with-Slots) 调用子组件的接口它的方法显得有点笨重。\n\n如果你有兴趣研究，你还会发现二者在接口设计的理念上是不同的。这可以通过各自创建的 [simple Todo List](https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89) 体现出来。或许有点主观，但是很多人认为 Vue 的 API 接口更简单结构更优雅。\n\n## Polymer\n\nPolymer 是另一个由谷歌赞助的项目，事实上也是 Vue 的一个灵感来源。Vue 的组件可以粗略的类比于 Polymer 的自定义元素，并且两者具有相似的开发风格。最大的不同之处在于，Polymer 是基于最新版的 Web Components 标准之上，并且需要重量级的 polyfills 来帮助工作（性能下降），浏览器本身并不支持这些功能。相比而言，Vue 在支持到 IE9 的情况下并不需要依赖 polyfills 来工作。\n\n在 Polymer 1.0 版本中，为了弥补性能，团队非常有限的使用数据绑定系统。例如，在 Polymer 中唯一支持的表达式只有布尔值否定和单一的方法调用，它的 computed 方法的实现也并不是很灵活。\n\nPolymer 自定义的元素是用 HTML 文件来创建的，这会限制使用 JavaScript/CSS（和被现代浏览器普遍支持的语言特性）。相比之下，Vue 的单文件组件允许你非常容易的使用 ES2015 和你想用的 CSS 预编译处理器。\n\n在部署生产环境时，Polymer 建议使用 HTML Imports 加载所有资源。而这要求服务器和客户端都支持 Http 2.0 协议，并且浏览器实现了此标准。这是否可行就取决于你的目标用户和部署环境了。如果状况不佳，你必须用 Vulcanizer 工具来打包 Polymer 元素。而在这方面，Vue 可以结合异步组件的特性和 Webpack 的代码分割特性来实现懒加载（lazy-loaded）。这同时确保了对旧浏览器的兼容且又能更快加载。\n\n而 Vue 和 Web Component 标准进行深层次的整合也是完全可行的，比如使用 Custom Elements、Shadow DOM 的样式封装。然而在我们做出严肃的实现承诺之前，我们目前仍在等待相关标准成熟，进而再广泛应用于主流的浏览器中。\n\n## Riot\n\nRiot 2.0 提供了一个类似于基于组件的开发模型（在 Riot 中称之为 Tag），它提供了小巧精美的 API。Riot 和 Vue 在设计理念上可能有许多相似处。尽管相比 Riot ，Vue 要显得重一点，Vue 还是有很多显著优势的：\n\n- [过渡效果系统](transitions.html)。Riot 现在还没有提供。\n-功能更加强大的路由机制，Riot 的路由功能的 API 是极少的。\n- 更好的性能。Riot 使用了 [遍历 DOM 树](http://riotjs.com/compare/#virtual-dom-vs-expressions-binding) 而不是虚拟 DOM，但实际上用的还是脏检查机制，因此和 Angular 1 患有相同的性能问题。\n- 更多成熟工具的支持。Vue 提供官方支持[Webpack](https://github.com/vuejs/vue-loader) 和 [Browserify](https://github.com/vuejs/vueify)，而 Riot 是依靠社区来建立集成系统。\n\n***\n\n> 原文：http://vuejs.org/guide/comparison.html\n\n***\n","source":"v2/guide/comparison.md","raw":"---\ntitle: 对比其他框架\ntype: guide\norder: 28\n---\n这个页面无疑是最难编写的，但我们认为它也是非常重要的。或许你曾遇到了一些问题并且已经用其他的框架解决了。你来这里的目的是看看 Vue 是否有更好的解决方案。这也是我们在此想要回答的。\n\n客观来说，作为核心团队成员，显然我们会更偏爱 Vue，认为对于某些问题来讲用 Vue 解决会更好。如果没有这点信念，我们也就不会整天为此忙活了。但是在此，我们想尽可能地公平和准确地来描述一切。其他的框架也有显著的优点，例如 React 庞大的生态系统，或者像是 Knockout 对浏览器的支持覆盖到了 IE6。我们会尝试着把这些内容全部列出来。\n\n我们也希望得到**你**的帮助，来使文档保持最新状态，因为 JavaScript 的世界进步的太快。如果你注意到一个不准确或似乎不太正确的地方，请[提交问题](https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide)让我们知道。\n\n## React\n\nReact 和 Vue 有许多相似之处，它们都有：\n\n- 使用 Virtual DOM\n- 提供了响应式（Reactive）和组件化（Composable）的视图组件。\n- 将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。\n\n由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要指出 React 比 Vue 更好的地方，像是他们的生态系统和丰富的自定义渲染器。\n\nReact社区为我们准确进行平衡的考量提供了[非常积极地帮助](https://github.com/vuejs/vuejs.org/issues/364)，特别感谢来自 React 团队的 Dan Abramov 。他非常慷慨的花费时间来贡献专业知识，帮助我们完善这篇文档，最后我们对最终结果[都十分满意](https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244575740)。\n\n### 性能简介\n\n到目前为止，针对现实情况的测试中，Vue 的性能是优于 React 的。如果你对此表示怀疑，请继续阅读。我们会解释为什么会这样（并且会提供一个与 React 团队共同约定的比较基准）。\n\n#### 渲染性能\n\n在渲染用户界面的时候，DOM 的操作成本是最高的，不幸的是没有库可以让这些原始操作变得更快。\n我们能做到的最好效果就是：\n\n1. Minimize the number of necessary DOM mutations. Both React and Vue use virtual DOM abstractions to accomplish this and both implementations work about equally well.\n\n2. Add as little overhead (pure JavaScript computations) as possible on top of those DOM manipulations. This is an area where Vue and React differ.\n\nThe JavaScript overhead is directly related to the mechanisms of computing the necessary DOM operations. Both Vue and React utilizes Virtual DOM to achieve that, but Vue's Virtual DOM implementation (a fork of [snabbdom](https://github.com/snabbdom/snabbdom)) is much lighter-weight and thus introduces less overhead than React's.\n\nVue 和 React 也提供功能性组件，这些组件因为都是没有声明，没有实例化的，因此会花费更少的开销。当这些都用于关键性能的场景时，Vue 将会更快。为了证明这点，我们建立了一个简单的[参照项目](https://github.com/chrisvfritz/vue-render-performance-comparisons)，它负责渲染 10,000 个列表项 100 次。我们鼓励你基于此去尝试运行一下。然而在实际上，由于浏览器和硬件的差异甚至 JavaScript 引擎的不同，结果都会相应有所不同。\n\n如果你懒得去做，下面的数值是来自于一个 2014 年产的 MacBook Air 并在 Chrome 52 版本下运行所产生的。为了避免偶然性，每个参照项目都分别运行 20 次并取自最好的结果：\n\n{% raw %}\n<table class=\"benchmark-table\">\n  <thead>\n    <tr>\n      <th></th>\n      <th>Vue</th>\n      <th>React</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Fastest</th>\n      <td>23ms</td>\n      <td>63ms</td>\n    </tr>\n    <tr>\n      <th>Median</th>\n      <td>42ms</td>\n      <td>81ms</td>\n    </tr>\n    <tr>\n      <th>Average</th>\n      <td>51ms</td>\n      <td>94ms</td>\n    </tr>\n    <tr>\n      <th>95th Perc.</th>\n      <td>73ms</td>\n      <td>164ms</td>\n    </tr>\n    <tr>\n      <th>Slowest</th>\n      <td>343ms</td>\n      <td>453ms</td>\n    </tr>\n  </tbody>\n</table>\n{% endraw %}\n\n#### 更新性能\n\nIn React, when a component's state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. \n\nTo avoid unnecessary re-renders of child components, you need to implement `shouldComponentUpdate` everywhere and use immutable data structures. In Vue, a component's dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render.\n\n这意味着，未经优化的 Vue 相比未经优化的 React 要快的多。由于 Vue 改进过渲染性能，甚至全面优化过的 React 通常也会慢于开箱即用的 Vue。\n\n#### 开发中\n\n显然，在生产环境中的性能是至关重要的，目前为止我们所具体讨论的便是针对此环境。但开发过程中的表现也不容小视。不错的是用 Vue 和 React 开发大多数应用的速度都是足够快的。\n\n当性能在生产中性能是直接与终端用户体验相关的更重要的指标时，表现在开发中仍然很重要,因为它是与开发相关经验\n\n然而，假如你要开发一个对性能要求比较高的数据可视化或者动画的应用时，你需要了解到下面这点：在开发中，Vue 每秒最高处理 10 帧，而 React 每秒最高处理不到 1 帧。\n\n这是由于 React 有大量的检查机制，这会让它提供许多有用的警告和错误提示信息。我们同样认为这些是很重要的，但是我们在实现这些检查时，也更加密切地关注了性能方面。\n\n### HTML & CSS\n\n在 React 中，它们都是 JavaScript 编写的，听起来这十分简单和优雅。然而不幸的事实是，JavaScript 内的 HTML 和 CSS 会产生很多痛点。在 Vue 中我们采用 Web 技术并在其上进行扩展。接下来将通过一些实例向你展示这意味的是什么。\n\n\n#### JSX vs Templates\n\n在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 Javascript 的一种语法糖。这有一个[通过React社区审核过的例子](https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244582684)：\n\n``` jsx\n  render () {\n\t    let { items } = this.props\n\n\t    let children\n\t    if ( items.length > 0 ) {\n\t        children = (\n\t            <ul>\n\t                {items.map( item =>\n\t                    <li key={item.id}>{item.name}</li>\n\t                )}\n\t            </ul>\n\t        )\n\t    } else {\n\t        children = <p>No items found.</p>\n\t    }\n\n\t    return (\n\t        <div className = 'list-container'>\n\t            {children}\n\t        </div>\n\t    )\n\t}\n```\n\nJSX 的渲染功能有下面这些优势：\n\n- 你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。\n- 工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的（比如，linting、类型检查、编辑器的自动完成）。\n\n在 Vue 中，由于有时需要用这些功能，我们也提供了[渲染功能](render-function.html) 并且[支持了 JSX](render-function.html#JSX)。然而，对于大多数组件来说，渲染功能是不推荐使用了。\n\n在这方面，我们提供的是更简单的模板：\n\n``` html\n\t<template>\n\t    <div class=\"list-container\">\n\t        <ul v-if=\"items.length\">\n\t            <li v-for=\"item in items\">\n\t                {{ item.name }}\n\t            </li>\n\t        </ul>\n\t        <p v-else>No items found.</p>\n\t    </div>\n\t</template>\n```\n\n优点如下：\n\n- 在写模板的过程中，样式风格已定并涉及更少的功能实现。\n- 模板总是会被声明的。\n- 模板中任何 HTML 语法都是有效的。\n- 阅读起来更贴合英语（比如，for each item in items）。\n- 不需要高级版本的 JavaScript 语法，来增加可读性。\n\n这样，不仅开发人员更容易编写代码，设计人员和开发人员也可以更容易的分析代码和贡献代码。\n\n这还没有结束。Vue 拥抱 HTML，而不是用 JavaScript 去重塑它。在模板内，Vue 也允许你用预处理器比如 Pug（原名 Jade）。\n\n``` pug\ndiv.list-container\n  ul(v-if=\"items.length\")\n    li(v-for=\"item in items\") {{ item.name }}\n  p(v-else) No items found.\n```\n\n#### CSS 的组件作用域\n\n除非你把组件分布在多个文件上(例如 [CSS Modules](https://github.com/gajus/react-css-modules))，要不在 React 中作用域内的 CSS 就会产生警告。非常简单的 CSS 还可以工作，但是稍微复杂点的，比如悬停状态、媒体查询、伪类选择符等要么通过沉重的依赖来重做要么就直接不能用。\n\n而 Vue 可以让你在每个[单文件组件](single-file-components.html)中完全访问 CSS。\n\n``` html\n\t<style scoped>\n\t    @media (min-width: 250px) {\n\t        .list-container:hover {\n\t            background: orange;\n\t        }\n\t    }\n\t</style>\n```\n\n这个可选 `scoped` 属性会自动添加一个唯一的属性（比如 `data-v-21e5b78`）为组件内 CSS 指定作用域，编译的时候 `.list-container:hover` 会被编译成类似 `.list-container[data-v-21e5b78]:hover`。\n\n如果你已经熟悉 CSS Modules，Vue 单文件组件也有 [first-class 支持它](http://vue-loader.vuejs.org/en/features/css-modules.html)。\n\n最后，就像 HTML 一样，你可以选择自己偏爱的 CSS 预处理器（或后处理器）编写 CSS，这些生态系统允许您利用现有的库。这可以让你围绕设计为中心展开工作，,比如您的构建过程中颜色操作，而不是引入专门的库来增加你应用的体积和复杂度。\n\n### 规模\n\n#### 向上扩展\n\nVue 和 React 都提供了强大的路由来应对大型应用。React 社区在状态管理方面非常有创新精神（比如Flux、Redux），而这些状态管理模式甚至[ Redux 本身](https://github.com/egoist/revue)也可以非常容易的集成在 Vue 应用中。实际上，Vue 更进一步地采用了这种模式（[Vuex](https://github.com/vuejs/vuex)），更加深入集成 Vue 的状态管理解决方案 Vuex 相信能为你带来更好的开发体验。\n\n两者另一个重要差异是，Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。\n\n最后，Vue 提供了[Vue-cli 脚手架](https://github.com/vuejs/vue-cli)，能让你非常容易地构建项目，包含了 [Webpack](https://github.com/vuejs-templates/webpack), [Browserify](https://github.com/vuejs-templates/browserify), 甚至 [no build system](https://github.com/vuejs-templates/simple)。React 在这方面也提供了[create-react-app](https://github.com/facebookincubator/create-react-app)，但是现在还存在一些局限性：\n\n- 它不允许在项目生成时进行任何配置，而 Vue 支持 Yeoman-like 定制。\n- 它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。\n- 它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。\n\n而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。如果阅读更多关于[不同的设计理念](https://github.com/facebookincubator/create-react-app#philosophy)。\n\n#### 向下扩展\n\nReact 学习曲线陡峭，在你开始学 React 前，你需要知道 JSX 和 ES2015，因为许多示例用的是这些语法。你需要学习构建系统，虽然你在技术上可以用 Babel 来实时编译代码，但是这并不推荐用于生产环境。\n\n就像 Vue 向上扩展好比 React 一样，Vue 向下扩展后就类似于 jQuery。你只要把如下标签放到页面就可以运行：\n\n`<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>`\n\n\n然后你就可以编写 Vue 代码并应用到生产中，你只要用 min 版 Vue 文件替换掉就不用担心其他的性能问题。\n\n由于起步阶段不需学 JSX，ES2015 以及构建系统，所以开发者只需不到一天的时间阅读[指南](./)就可以建立简单的应用程序。\n\n### 本地渲染\n\nReactNative 能使你用相同的组件模型编写有本地渲染能力的 APP（IOS 和 Android）。能同时跨多平台开发，对开发者是非常棒的。相应地，Vue 和 [Weex](https://alibaba.github.io/weex/) 会进行官方合作，Weex 是阿里的跨平台用户界面开发框架，Weex 的 JavaScript 框架运行时用的就是 Vue。这意味着在 Weex 的帮助下，你使用 Vue 语法开发的组件不仅仅可以运行在浏览器端，还能被用于开发 IOS 和 Android 上的原生应用。\n\n在现在，Weex 还在积极发展，成熟度也不能和 ReactNative 相抗衡。但是，Weex 的发展是由世界上最大的电子商务企业的需求在驱动，Vue 团队也会和 Weex 团队积极合作确保为开发者带来良好的开发体验。\n\n### MobX\n\nMobx 在 React 社区很流行，实际上在 Vue 也采用了几乎相同的反应系统。在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue，所以如果你习惯组合使用它们，那么选择 Vue 会更合理。\n\n## Angular 1\n\nVue 的一些语法和 Angular 的很相似（例如 `v-if` vs `ng-if`）。因为 Angular 是 Vue 早期开发的灵感来源。然而，Augular 中存在的许多问题，在 Vue 中已经得到解决。\n\n### 复杂性\n\n在 API 与设计两方面上 Vue.js 都比 Angular 1 简单得多，因此你可以快速地掌握它的全部特性并投入开发。\n\n### 灵活性和模块化\n\nVue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 Angular 1 制定的规则，这让 Vue 能适用于各种项目。我们知道把决定权交给你是非常必要的。\n这也就是为什么我们提供 [Webpack template](https://github.com/vuejs-templates/webpack)，让你可以用几分钟，去选择是否启用高级特性，比如热模块加载、linting、CSS 提取等等。\n\n### 数据绑定\n\nAngular 1 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。\n\n### 指令与组件\n\n在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。在 Angular 中两者有不少相混的地方。\n\n### 性能\n\nVue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。\n\n在 Angular 1 中，当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。\n\nVue 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系。\n\n有意思的是，Angular 2 和 Vue 用相似的设计解决了一些 Angular 1 中存在的问题。\n\n## Angular 2\n\n我们单独将 Augluar 2 作分类，因为它完全是一个全新的框架。例如：它具有优秀的组件系统，并且许多实现已经完全重写，API 也完全改变了。\n\n### TypeScript\n\nAngular 1 面向的是较小的应用程序，Angular 2 已转移焦点，面向的是大型企业应用。在这一点上 TypeScript 经常会被引用，它对那些喜欢用 Java 或者 C# 等类型安全的语言的人是非常有用的。\n\nVue 也十分适合制作[企业应用](https://github.com/vuejs/awesome-vue#enterprise-usage)，你也可以通过使用[官方类型](https://github.com/vuejs/vue/tree/dev/types)或[官方装饰器](https://github.com/itsFrank/vue-typescript)来支持 TypeScript，这完全可由你的方案来定。\n\n### 大小和性能\n\n在性能方面，这两个框架都非常的快。但目前尚没有足够的数据用例来具体展示。如果你一定要量化这些数据，你可以查看[第三方参照](http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html)，它表明 Vue 2 相比 Angular2 是更快的。\n\n在大小方面，虽然 Angular 2 使用 tree-shaking 和离线编译技术使代码体积减小了许多。但包含编译器和全部功能的 Vue2(23kb) 相比 Angular 2(50kb) 还是要小的多。但是要注意，用 Angular 2 的 App 的体积缩减是使用了 tree-shaking 移除了那些框架中没有用到的功能，但随着功能引入的不断增多，尺寸会变得越来越大。\n\n### 灵活性\n\nVue 相比于 Angular 2 则更加灵活，Vue 官方提供了构建工具来协助你构建项目，但它并不限制你去如何构建。有人可能喜欢用统一的方式来构建，也有很多开发者喜欢这种灵活自由的方式。\n\n### 学习曲线\n\n开始使用 Vue，你使用的是熟悉的 HTML、符合 ES5 规则的 JavaScript（也就是纯 JavaScript）。有了这些基本的技能，你可以快速地掌握它([指南](./))并投入开发 。\n\nAngular 2 的学习曲线是非常陡峭的。即使不包括 TypeScript，它的[开始指南](https://angular.io/docs/js/latest/quickstart.html)中所用的就有 ES2015 标准的 JavaScript，18个 NPM 依赖包，4 个文件和超过 3 千多字的介绍，这一切都是为了完成个 Hello World。而[Vue's Hello World](https://jsfiddle.net/chrisvfritz/50wL7mdz/)就非常简单。甚至我们并不用花费一整个页面去介绍它。\n\n## Ember\n\nEmber 是一个全能框架。它提供了大量的约定，一旦你熟悉了它们，开发会变得很高效。不过，这也意味着学习曲线较高，而且并不灵活。这意味着在框架和库（加上一系列松散耦合的工具）之间做权衡选择。后者会更自由，但是也要求你做更多架构上的决定。\n\n也就是说，我们最好比较的是 Vue 内核和 Ember 的[模板](https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/)与[数据模型](https://guides.emberjs.com/v2.10.0/object-model/)层：\n\n* Vue 在普通 JavaScript 对象上建立响应，提供自动化的计算属性。在 Ember 中需要将所有东西放在 Ember 对象内，并且手工为计算属性声明依赖。\n\n* Vue 的模板语法可以用全功能的 JavaScript 表达式，而 Handlebars 的语法和帮助函数相比来说非常受限。\n\n* 在性能上，Vue 甩开 Ember 几条街，即使是 Ember 2.0 的最新 Glimmer 引擎。Vue 能够自动批量更新，而 Ember 在关键性能场景时需要手动管理。\n\n## Knockout\n\nKnockout 是 MVVM 领域内的先驱，并且追踪依赖。它的响应系统和 Vue 也很相似。它在[浏览器支持](http://knockoutjs.com/documentation/browser-support.html)以及其他方面的表现也是让人印象深刻的。它最低能支持到 IE6，而 Vue 最低只能支持到 IE9。\n\n随着时间的推移，Knockout 的发展已有所放缓，并且略显有点老旧了。比如，它的组件系统缺少完备的生命周期事件方法，尽管这些在现在是非常常见的。以及相比于 [Vue](components.html#Content-Distribution-with-Slots) 调用子组件的接口它的方法显得有点笨重。\n\n如果你有兴趣研究，你还会发现二者在接口设计的理念上是不同的。这可以通过各自创建的 [simple Todo List](https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89) 体现出来。或许有点主观，但是很多人认为 Vue 的 API 接口更简单结构更优雅。\n\n## Polymer\n\nPolymer 是另一个由谷歌赞助的项目，事实上也是 Vue 的一个灵感来源。Vue 的组件可以粗略的类比于 Polymer 的自定义元素，并且两者具有相似的开发风格。最大的不同之处在于，Polymer 是基于最新版的 Web Components 标准之上，并且需要重量级的 polyfills 来帮助工作（性能下降），浏览器本身并不支持这些功能。相比而言，Vue 在支持到 IE9 的情况下并不需要依赖 polyfills 来工作。\n\n在 Polymer 1.0 版本中，为了弥补性能，团队非常有限的使用数据绑定系统。例如，在 Polymer 中唯一支持的表达式只有布尔值否定和单一的方法调用，它的 computed 方法的实现也并不是很灵活。\n\nPolymer 自定义的元素是用 HTML 文件来创建的，这会限制使用 JavaScript/CSS（和被现代浏览器普遍支持的语言特性）。相比之下，Vue 的单文件组件允许你非常容易的使用 ES2015 和你想用的 CSS 预编译处理器。\n\n在部署生产环境时，Polymer 建议使用 HTML Imports 加载所有资源。而这要求服务器和客户端都支持 Http 2.0 协议，并且浏览器实现了此标准。这是否可行就取决于你的目标用户和部署环境了。如果状况不佳，你必须用 Vulcanizer 工具来打包 Polymer 元素。而在这方面，Vue 可以结合异步组件的特性和 Webpack 的代码分割特性来实现懒加载（lazy-loaded）。这同时确保了对旧浏览器的兼容且又能更快加载。\n\n而 Vue 和 Web Component 标准进行深层次的整合也是完全可行的，比如使用 Custom Elements、Shadow DOM 的样式封装。然而在我们做出严肃的实现承诺之前，我们目前仍在等待相关标准成熟，进而再广泛应用于主流的浏览器中。\n\n## Riot\n\nRiot 2.0 提供了一个类似于基于组件的开发模型（在 Riot 中称之为 Tag），它提供了小巧精美的 API。Riot 和 Vue 在设计理念上可能有许多相似处。尽管相比 Riot ，Vue 要显得重一点，Vue 还是有很多显著优势的：\n\n- [过渡效果系统](transitions.html)。Riot 现在还没有提供。\n-功能更加强大的路由机制，Riot 的路由功能的 API 是极少的。\n- 更好的性能。Riot 使用了 [遍历 DOM 树](http://riotjs.com/compare/#virtual-dom-vs-expressions-binding) 而不是虚拟 DOM，但实际上用的还是脏检查机制，因此和 Angular 1 患有相同的性能问题。\n- 更多成熟工具的支持。Vue 提供官方支持[Webpack](https://github.com/vuejs/vue-loader) 和 [Browserify](https://github.com/vuejs/vueify)，而 Riot 是依靠社区来建立集成系统。\n\n***\n\n> 原文：http://vuejs.org/guide/comparison.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/comparison.html","comments":1,"layout":"page","_id":"ciwnajuyd0015jl2dx0bswy6w","content":"<p>这个页面无疑是最难编写的，但我们认为它也是非常重要的。或许你曾遇到了一些问题并且已经用其他的框架解决了。你来这里的目的是看看 Vue 是否有更好的解决方案。这也是我们在此想要回答的。</p>\n<p>客观来说，作为核心团队成员，显然我们会更偏爱 Vue，认为对于某些问题来讲用 Vue 解决会更好。如果没有这点信念，我们也就不会整天为此忙活了。但是在此，我们想尽可能地公平和准确地来描述一切。其他的框架也有显著的优点，例如 React 庞大的生态系统，或者像是 Knockout 对浏览器的支持覆盖到了 IE6。我们会尝试着把这些内容全部列出来。</p>\n<p>我们也希望得到<strong>你</strong>的帮助，来使文档保持最新状态，因为 JavaScript 的世界进步的太快。如果你注意到一个不准确或似乎不太正确的地方，请<a href=\"https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide\" target=\"_blank\" rel=\"external\">提交问题</a>让我们知道。</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>React 和 Vue 有许多相似之处，它们都有：</p>\n<ul>\n<li>使用 Virtual DOM</li>\n<li>提供了响应式（Reactive）和组件化（Composable）的视图组件。</li>\n<li>将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。</li>\n</ul>\n<p>由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要指出 React 比 Vue 更好的地方，像是他们的生态系统和丰富的自定义渲染器。</p>\n<p>React社区为我们准确进行平衡的考量提供了<a href=\"https://github.com/vuejs/vuejs.org/issues/364\" target=\"_blank\" rel=\"external\">非常积极地帮助</a>，特别感谢来自 React 团队的 Dan Abramov 。他非常慷慨的花费时间来贡献专业知识，帮助我们完善这篇文档，最后我们对最终结果<a href=\"https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244575740\" target=\"_blank\" rel=\"external\">都十分满意</a>。</p>\n<h3 id=\"性能简介\"><a href=\"#性能简介\" class=\"headerlink\" title=\"性能简介\"></a>性能简介</h3><p>到目前为止，针对现实情况的测试中，Vue 的性能是优于 React 的。如果你对此表示怀疑，请继续阅读。我们会解释为什么会这样（并且会提供一个与 React 团队共同约定的比较基准）。</p>\n<h4 id=\"渲染性能\"><a href=\"#渲染性能\" class=\"headerlink\" title=\"渲染性能\"></a>渲染性能</h4><p>在渲染用户界面的时候，DOM 的操作成本是最高的，不幸的是没有库可以让这些原始操作变得更快。<br>我们能做到的最好效果就是：</p>\n<ol>\n<li><p>Minimize the number of necessary DOM mutations. Both React and Vue use virtual DOM abstractions to accomplish this and both implementations work about equally well.</p>\n</li>\n<li><p>Add as little overhead (pure JavaScript computations) as possible on top of those DOM manipulations. This is an area where Vue and React differ.</p>\n</li>\n</ol>\n<p>The JavaScript overhead is directly related to the mechanisms of computing the necessary DOM operations. Both Vue and React utilizes Virtual DOM to achieve that, but Vue’s Virtual DOM implementation (a fork of <a href=\"https://github.com/snabbdom/snabbdom\" target=\"_blank\" rel=\"external\">snabbdom</a>) is much lighter-weight and thus introduces less overhead than React’s.</p>\n<p>Vue 和 React 也提供功能性组件，这些组件因为都是没有声明，没有实例化的，因此会花费更少的开销。当这些都用于关键性能的场景时，Vue 将会更快。为了证明这点，我们建立了一个简单的<a href=\"https://github.com/chrisvfritz/vue-render-performance-comparisons\" target=\"_blank\" rel=\"external\">参照项目</a>，它负责渲染 10,000 个列表项 100 次。我们鼓励你基于此去尝试运行一下。然而在实际上，由于浏览器和硬件的差异甚至 JavaScript 引擎的不同，结果都会相应有所不同。</p>\n<p>如果你懒得去做，下面的数值是来自于一个 2014 年产的 MacBook Air 并在 Chrome 52 版本下运行所产生的。为了避免偶然性，每个参照项目都分别运行 20 次并取自最好的结果：</p>\n\n<table class=\"benchmark-table\">\n  <thead>\n    <tr>\n      <th></th>\n      <th>Vue</th>\n      <th>React</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Fastest</th>\n      <td>23ms</td>\n      <td>63ms</td>\n    </tr>\n    <tr>\n      <th>Median</th>\n      <td>42ms</td>\n      <td>81ms</td>\n    </tr>\n    <tr>\n      <th>Average</th>\n      <td>51ms</td>\n      <td>94ms</td>\n    </tr>\n    <tr>\n      <th>95th Perc.</th>\n      <td>73ms</td>\n      <td>164ms</td>\n    </tr>\n    <tr>\n      <th>Slowest</th>\n      <td>343ms</td>\n      <td>453ms</td>\n    </tr>\n  </tbody>\n</table>\n\n<h4 id=\"更新性能\"><a href=\"#更新性能\" class=\"headerlink\" title=\"更新性能\"></a>更新性能</h4><p>In React, when a component’s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. </p>\n<p>To avoid unnecessary re-renders of child components, you need to implement <code>shouldComponentUpdate</code> everywhere and use immutable data structures. In Vue, a component’s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render.</p>\n<p>这意味着，未经优化的 Vue 相比未经优化的 React 要快的多。由于 Vue 改进过渲染性能，甚至全面优化过的 React 通常也会慢于开箱即用的 Vue。</p>\n<h4 id=\"开发中\"><a href=\"#开发中\" class=\"headerlink\" title=\"开发中\"></a>开发中</h4><p>显然，在生产环境中的性能是至关重要的，目前为止我们所具体讨论的便是针对此环境。但开发过程中的表现也不容小视。不错的是用 Vue 和 React 开发大多数应用的速度都是足够快的。</p>\n<p>当性能在生产中性能是直接与终端用户体验相关的更重要的指标时，表现在开发中仍然很重要,因为它是与开发相关经验</p>\n<p>然而，假如你要开发一个对性能要求比较高的数据可视化或者动画的应用时，你需要了解到下面这点：在开发中，Vue 每秒最高处理 10 帧，而 React 每秒最高处理不到 1 帧。</p>\n<p>这是由于 React 有大量的检查机制，这会让它提供许多有用的警告和错误提示信息。我们同样认为这些是很重要的，但是我们在实现这些检查时，也更加密切地关注了性能方面。</p>\n<h3 id=\"HTML-amp-CSS\"><a href=\"#HTML-amp-CSS\" class=\"headerlink\" title=\"HTML &amp; CSS\"></a>HTML &amp; CSS</h3><p>在 React 中，它们都是 JavaScript 编写的，听起来这十分简单和优雅。然而不幸的事实是，JavaScript 内的 HTML 和 CSS 会产生很多痛点。在 Vue 中我们采用 Web 技术并在其上进行扩展。接下来将通过一些实例向你展示这意味的是什么。</p>\n<h4 id=\"JSX-vs-Templates\"><a href=\"#JSX-vs-Templates\" class=\"headerlink\" title=\"JSX vs Templates\"></a>JSX vs Templates</h4><p>在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 Javascript 的一种语法糖。这有一个<a href=\"https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244582684\" target=\"_blank\" rel=\"external\">通过React社区审核过的例子</a>：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><div class=\"line\"> render () &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> &#123; items &#125; = <span class=\"keyword\">this</span>.props</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> children</div><div class=\"line\">    <span class=\"keyword\">if</span> ( items.length &gt; <span class=\"number\">0</span> ) &#123;</div><div class=\"line\">        children = (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></div><div class=\"line\">                &#123;items.map( item =&gt;</div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">                )&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">        )</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        children = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>No items found.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span> = <span class=\"string\">'list-container'</span>&gt;</span></span></div><div class=\"line\">            &#123;children&#125;</div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    )</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>JSX 的渲染功能有下面这些优势：</p>\n<ul>\n<li>你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。</li>\n<li>工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的（比如，linting、类型检查、编辑器的自动完成）。</li>\n</ul>\n<p>在 Vue 中，由于有时需要用这些功能，我们也提供了<a href=\"render-function.html\">渲染功能</a> 并且<a href=\"render-function.html#JSX\">支持了 JSX</a>。然而，对于大多数组件来说，渲染功能是不推荐使用了。</p>\n<p>在这方面，我们提供的是更简单的模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"list-container\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"items.length\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span></div><div class=\"line\">                &#123;&#123; item.name &#125;&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>No items found.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>优点如下：</p>\n<ul>\n<li>在写模板的过程中，样式风格已定并涉及更少的功能实现。</li>\n<li>模板总是会被声明的。</li>\n<li>模板中任何 HTML 语法都是有效的。</li>\n<li>阅读起来更贴合英语（比如，for each item in items）。</li>\n<li>不需要高级版本的 JavaScript 语法，来增加可读性。</li>\n</ul>\n<p>这样，不仅开发人员更容易编写代码，设计人员和开发人员也可以更容易的分析代码和贡献代码。</p>\n<p>这还没有结束。Vue 拥抱 HTML，而不是用 JavaScript 去重塑它。在模板内，Vue 也允许你用预处理器比如 Pug（原名 Jade）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">div.list-container</div><div class=\"line\">  ul(v-if=&quot;items.length&quot;)</div><div class=\"line\">    li(v-for=&quot;item in items&quot;) &#123;&#123; item.name &#125;&#125;</div><div class=\"line\">  p(v-else) No items found.</div></pre></td></tr></table></figure>\n<h4 id=\"CSS-的组件作用域\"><a href=\"#CSS-的组件作用域\" class=\"headerlink\" title=\"CSS 的组件作用域\"></a>CSS 的组件作用域</h4><p>除非你把组件分布在多个文件上(例如 <a href=\"https://github.com/gajus/react-css-modules\" target=\"_blank\" rel=\"external\">CSS Modules</a>)，要不在 React 中作用域内的 CSS 就会产生警告。非常简单的 CSS 还可以工作，但是稍微复杂点的，比如悬停状态、媒体查询、伪类选择符等要么通过沉重的依赖来重做要么就直接不能用。</p>\n<p>而 Vue 可以让你在每个<a href=\"single-file-components.html\">单文件组件</a>中完全访问 CSS。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span><span class=\"css\"></span></div><div class=\"line\">    @<span class=\"keyword\">media</span> (min-width: <span class=\"number\">250px</span>) &#123;</div><div class=\"line\">        <span class=\"selector-class\">.list-container</span><span class=\"selector-pseudo\">:hover</span> &#123;</div><div class=\"line\">            <span class=\"attribute\">background</span>: orange;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个可选 <code>scoped</code> 属性会自动添加一个唯一的属性（比如 <code>data-v-21e5b78</code>）为组件内 CSS 指定作用域，编译的时候 <code>.list-container:hover</code> 会被编译成类似 <code>.list-container[data-v-21e5b78]:hover</code>。</p>\n<p>如果你已经熟悉 CSS Modules，Vue 单文件组件也有 <a href=\"http://vue-loader.vuejs.org/en/features/css-modules.html\" target=\"_blank\" rel=\"external\">first-class 支持它</a>。</p>\n<p>最后，就像 HTML 一样，你可以选择自己偏爱的 CSS 预处理器（或后处理器）编写 CSS，这些生态系统允许您利用现有的库。这可以让你围绕设计为中心展开工作，,比如您的构建过程中颜色操作，而不是引入专门的库来增加你应用的体积和复杂度。</p>\n<h3 id=\"规模\"><a href=\"#规模\" class=\"headerlink\" title=\"规模\"></a>规模</h3><h4 id=\"向上扩展\"><a href=\"#向上扩展\" class=\"headerlink\" title=\"向上扩展\"></a>向上扩展</h4><p>Vue 和 React 都提供了强大的路由来应对大型应用。React 社区在状态管理方面非常有创新精神（比如Flux、Redux），而这些状态管理模式甚至<a href=\"https://github.com/egoist/revue\" target=\"_blank\" rel=\"external\"> Redux 本身</a>也可以非常容易的集成在 Vue 应用中。实际上，Vue 更进一步地采用了这种模式（<a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">Vuex</a>），更加深入集成 Vue 的状态管理解决方案 Vuex 相信能为你带来更好的开发体验。</p>\n<p>两者另一个重要差异是，Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。</p>\n<p>最后，Vue 提供了<a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"external\">Vue-cli 脚手架</a>，能让你非常容易地构建项目，包含了 <a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"external\">Webpack</a>, <a href=\"https://github.com/vuejs-templates/browserify\" target=\"_blank\" rel=\"external\">Browserify</a>, 甚至 <a href=\"https://github.com/vuejs-templates/simple\" target=\"_blank\" rel=\"external\">no build system</a>。React 在这方面也提供了<a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"external\">create-react-app</a>，但是现在还存在一些局限性：</p>\n<ul>\n<li>它不允许在项目生成时进行任何配置，而 Vue 支持 Yeoman-like 定制。</li>\n<li>它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。</li>\n<li>它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。</li>\n</ul>\n<p>而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。如果阅读更多关于<a href=\"https://github.com/facebookincubator/create-react-app#philosophy\" target=\"_blank\" rel=\"external\">不同的设计理念</a>。</p>\n<h4 id=\"向下扩展\"><a href=\"#向下扩展\" class=\"headerlink\" title=\"向下扩展\"></a>向下扩展</h4><p>React 学习曲线陡峭，在你开始学 React 前，你需要知道 JSX 和 ES2015，因为许多示例用的是这些语法。你需要学习构建系统，虽然你在技术上可以用 Babel 来实时编译代码，但是这并不推荐用于生产环境。</p>\n<p>就像 Vue 向上扩展好比 React 一样，Vue 向下扩展后就类似于 jQuery。你只要把如下标签放到页面就可以运行：</p>\n<p><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>然后你就可以编写 Vue 代码并应用到生产中，你只要用 min 版 Vue 文件替换掉就不用担心其他的性能问题。</p>\n<p>由于起步阶段不需学 JSX，ES2015 以及构建系统，所以开发者只需不到一天的时间阅读<a href=\"./\">指南</a>就可以建立简单的应用程序。</p>\n<h3 id=\"本地渲染\"><a href=\"#本地渲染\" class=\"headerlink\" title=\"本地渲染\"></a>本地渲染</h3><p>ReactNative 能使你用相同的组件模型编写有本地渲染能力的 APP（IOS 和 Android）。能同时跨多平台开发，对开发者是非常棒的。相应地，Vue 和 <a href=\"https://alibaba.github.io/weex/\" target=\"_blank\" rel=\"external\">Weex</a> 会进行官方合作，Weex 是阿里的跨平台用户界面开发框架，Weex 的 JavaScript 框架运行时用的就是 Vue。这意味着在 Weex 的帮助下，你使用 Vue 语法开发的组件不仅仅可以运行在浏览器端，还能被用于开发 IOS 和 Android 上的原生应用。</p>\n<p>在现在，Weex 还在积极发展，成熟度也不能和 ReactNative 相抗衡。但是，Weex 的发展是由世界上最大的电子商务企业的需求在驱动，Vue 团队也会和 Weex 团队积极合作确保为开发者带来良好的开发体验。</p>\n<h3 id=\"MobX\"><a href=\"#MobX\" class=\"headerlink\" title=\"MobX\"></a>MobX</h3><p>Mobx 在 React 社区很流行，实际上在 Vue 也采用了几乎相同的反应系统。在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue，所以如果你习惯组合使用它们，那么选择 Vue 会更合理。</p>\n<h2 id=\"Angular-1\"><a href=\"#Angular-1\" class=\"headerlink\" title=\"Angular 1\"></a>Angular 1</h2><p>Vue 的一些语法和 Angular 的很相似（例如 <code>v-if</code> vs <code>ng-if</code>）。因为 Angular 是 Vue 早期开发的灵感来源。然而，Augular 中存在的许多问题，在 Vue 中已经得到解决。</p>\n<h3 id=\"复杂性\"><a href=\"#复杂性\" class=\"headerlink\" title=\"复杂性\"></a>复杂性</h3><p>在 API 与设计两方面上 Vue.js 都比 Angular 1 简单得多，因此你可以快速地掌握它的全部特性并投入开发。</p>\n<h3 id=\"灵活性和模块化\"><a href=\"#灵活性和模块化\" class=\"headerlink\" title=\"灵活性和模块化\"></a>灵活性和模块化</h3><p>Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 Angular 1 制定的规则，这让 Vue 能适用于各种项目。我们知道把决定权交给你是非常必要的。<br>这也就是为什么我们提供 <a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"external\">Webpack template</a>，让你可以用几分钟，去选择是否启用高级特性，比如热模块加载、linting、CSS 提取等等。</p>\n<h3 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h3><p>Angular 1 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。</p>\n<h3 id=\"指令与组件\"><a href=\"#指令与组件\" class=\"headerlink\" title=\"指令与组件\"></a>指令与组件</h3><p>在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。在 Angular 中两者有不少相混的地方。</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。</p>\n<p>在 Angular 1 中，当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。</p>\n<p>Vue 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系。</p>\n<p>有意思的是，Angular 2 和 Vue 用相似的设计解决了一些 Angular 1 中存在的问题。</p>\n<h2 id=\"Angular-2\"><a href=\"#Angular-2\" class=\"headerlink\" title=\"Angular 2\"></a>Angular 2</h2><p>我们单独将 Augluar 2 作分类，因为它完全是一个全新的框架。例如：它具有优秀的组件系统，并且许多实现已经完全重写，API 也完全改变了。</p>\n<h3 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h3><p>Angular 1 面向的是较小的应用程序，Angular 2 已转移焦点，面向的是大型企业应用。在这一点上 TypeScript 经常会被引用，它对那些喜欢用 Java 或者 C# 等类型安全的语言的人是非常有用的。</p>\n<p>Vue 也十分适合制作<a href=\"https://github.com/vuejs/awesome-vue#enterprise-usage\" target=\"_blank\" rel=\"external\">企业应用</a>，你也可以通过使用<a href=\"https://github.com/vuejs/vue/tree/dev/types\" target=\"_blank\" rel=\"external\">官方类型</a>或<a href=\"https://github.com/itsFrank/vue-typescript\" target=\"_blank\" rel=\"external\">官方装饰器</a>来支持 TypeScript，这完全可由你的方案来定。</p>\n<h3 id=\"大小和性能\"><a href=\"#大小和性能\" class=\"headerlink\" title=\"大小和性能\"></a>大小和性能</h3><p>在性能方面，这两个框架都非常的快。但目前尚没有足够的数据用例来具体展示。如果你一定要量化这些数据，你可以查看<a href=\"http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html\" target=\"_blank\" rel=\"external\">第三方参照</a>，它表明 Vue 2 相比 Angular2 是更快的。</p>\n<p>在大小方面，虽然 Angular 2 使用 tree-shaking 和离线编译技术使代码体积减小了许多。但包含编译器和全部功能的 Vue2(23kb) 相比 Angular 2(50kb) 还是要小的多。但是要注意，用 Angular 2 的 App 的体积缩减是使用了 tree-shaking 移除了那些框架中没有用到的功能，但随着功能引入的不断增多，尺寸会变得越来越大。</p>\n<h3 id=\"灵活性\"><a href=\"#灵活性\" class=\"headerlink\" title=\"灵活性\"></a>灵活性</h3><p>Vue 相比于 Angular 2 则更加灵活，Vue 官方提供了构建工具来协助你构建项目，但它并不限制你去如何构建。有人可能喜欢用统一的方式来构建，也有很多开发者喜欢这种灵活自由的方式。</p>\n<h3 id=\"学习曲线\"><a href=\"#学习曲线\" class=\"headerlink\" title=\"学习曲线\"></a>学习曲线</h3><p>开始使用 Vue，你使用的是熟悉的 HTML、符合 ES5 规则的 JavaScript（也就是纯 JavaScript）。有了这些基本的技能，你可以快速地掌握它(<a href=\"./\">指南</a>)并投入开发 。</p>\n<p>Angular 2 的学习曲线是非常陡峭的。即使不包括 TypeScript，它的<a href=\"https://angular.io/docs/js/latest/quickstart.html\" target=\"_blank\" rel=\"external\">开始指南</a>中所用的就有 ES2015 标准的 JavaScript，18个 NPM 依赖包，4 个文件和超过 3 千多字的介绍，这一切都是为了完成个 Hello World。而<a href=\"https://jsfiddle.net/chrisvfritz/50wL7mdz/\" target=\"_blank\" rel=\"external\">Vue’s Hello World</a>就非常简单。甚至我们并不用花费一整个页面去介绍它。</p>\n<h2 id=\"Ember\"><a href=\"#Ember\" class=\"headerlink\" title=\"Ember\"></a>Ember</h2><p>Ember 是一个全能框架。它提供了大量的约定，一旦你熟悉了它们，开发会变得很高效。不过，这也意味着学习曲线较高，而且并不灵活。这意味着在框架和库（加上一系列松散耦合的工具）之间做权衡选择。后者会更自由，但是也要求你做更多架构上的决定。</p>\n<p>也就是说，我们最好比较的是 Vue 内核和 Ember 的<a href=\"https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/\" target=\"_blank\" rel=\"external\">模板</a>与<a href=\"https://guides.emberjs.com/v2.10.0/object-model/\" target=\"_blank\" rel=\"external\">数据模型</a>层：</p>\n<ul>\n<li><p>Vue 在普通 JavaScript 对象上建立响应，提供自动化的计算属性。在 Ember 中需要将所有东西放在 Ember 对象内，并且手工为计算属性声明依赖。</p>\n</li>\n<li><p>Vue 的模板语法可以用全功能的 JavaScript 表达式，而 Handlebars 的语法和帮助函数相比来说非常受限。</p>\n</li>\n<li><p>在性能上，Vue 甩开 Ember 几条街，即使是 Ember 2.0 的最新 Glimmer 引擎。Vue 能够自动批量更新，而 Ember 在关键性能场景时需要手动管理。</p>\n</li>\n</ul>\n<h2 id=\"Knockout\"><a href=\"#Knockout\" class=\"headerlink\" title=\"Knockout\"></a>Knockout</h2><p>Knockout 是 MVVM 领域内的先驱，并且追踪依赖。它的响应系统和 Vue 也很相似。它在<a href=\"http://knockoutjs.com/documentation/browser-support.html\" target=\"_blank\" rel=\"external\">浏览器支持</a>以及其他方面的表现也是让人印象深刻的。它最低能支持到 IE6，而 Vue 最低只能支持到 IE9。</p>\n<p>随着时间的推移，Knockout 的发展已有所放缓，并且略显有点老旧了。比如，它的组件系统缺少完备的生命周期事件方法，尽管这些在现在是非常常见的。以及相比于 <a href=\"components.html#Content-Distribution-with-Slots\">Vue</a> 调用子组件的接口它的方法显得有点笨重。</p>\n<p>如果你有兴趣研究，你还会发现二者在接口设计的理念上是不同的。这可以通过各自创建的 <a href=\"https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89\" target=\"_blank\" rel=\"external\">simple Todo List</a> 体现出来。或许有点主观，但是很多人认为 Vue 的 API 接口更简单结构更优雅。</p>\n<h2 id=\"Polymer\"><a href=\"#Polymer\" class=\"headerlink\" title=\"Polymer\"></a>Polymer</h2><p>Polymer 是另一个由谷歌赞助的项目，事实上也是 Vue 的一个灵感来源。Vue 的组件可以粗略的类比于 Polymer 的自定义元素，并且两者具有相似的开发风格。最大的不同之处在于，Polymer 是基于最新版的 Web Components 标准之上，并且需要重量级的 polyfills 来帮助工作（性能下降），浏览器本身并不支持这些功能。相比而言，Vue 在支持到 IE9 的情况下并不需要依赖 polyfills 来工作。</p>\n<p>在 Polymer 1.0 版本中，为了弥补性能，团队非常有限的使用数据绑定系统。例如，在 Polymer 中唯一支持的表达式只有布尔值否定和单一的方法调用，它的 computed 方法的实现也并不是很灵活。</p>\n<p>Polymer 自定义的元素是用 HTML 文件来创建的，这会限制使用 JavaScript/CSS（和被现代浏览器普遍支持的语言特性）。相比之下，Vue 的单文件组件允许你非常容易的使用 ES2015 和你想用的 CSS 预编译处理器。</p>\n<p>在部署生产环境时，Polymer 建议使用 HTML Imports 加载所有资源。而这要求服务器和客户端都支持 Http 2.0 协议，并且浏览器实现了此标准。这是否可行就取决于你的目标用户和部署环境了。如果状况不佳，你必须用 Vulcanizer 工具来打包 Polymer 元素。而在这方面，Vue 可以结合异步组件的特性和 Webpack 的代码分割特性来实现懒加载（lazy-loaded）。这同时确保了对旧浏览器的兼容且又能更快加载。</p>\n<p>而 Vue 和 Web Component 标准进行深层次的整合也是完全可行的，比如使用 Custom Elements、Shadow DOM 的样式封装。然而在我们做出严肃的实现承诺之前，我们目前仍在等待相关标准成熟，进而再广泛应用于主流的浏览器中。</p>\n<h2 id=\"Riot\"><a href=\"#Riot\" class=\"headerlink\" title=\"Riot\"></a>Riot</h2><p>Riot 2.0 提供了一个类似于基于组件的开发模型（在 Riot 中称之为 Tag），它提供了小巧精美的 API。Riot 和 Vue 在设计理念上可能有许多相似处。尽管相比 Riot ，Vue 要显得重一点，Vue 还是有很多显著优势的：</p>\n<ul>\n<li><a href=\"transitions.html\">过渡效果系统</a>。Riot 现在还没有提供。<br>-功能更加强大的路由机制，Riot 的路由功能的 API 是极少的。</li>\n<li>更好的性能。Riot 使用了 <a href=\"http://riotjs.com/compare/#virtual-dom-vs-expressions-binding\" target=\"_blank\" rel=\"external\">遍历 DOM 树</a> 而不是虚拟 DOM，但实际上用的还是脏检查机制，因此和 Angular 1 患有相同的性能问题。</li>\n<li>更多成熟工具的支持。Vue 提供官方支持<a href=\"https://github.com/vuejs/vue-loader\" target=\"_blank\" rel=\"external\">Webpack</a> 和 <a href=\"https://github.com/vuejs/vueify\" target=\"_blank\" rel=\"external\">Browserify</a>，而 Riot 是依靠社区来建立集成系统。</li>\n</ul>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/comparison.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/comparison.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<p>这个页面无疑是最难编写的，但我们认为它也是非常重要的。或许你曾遇到了一些问题并且已经用其他的框架解决了。你来这里的目的是看看 Vue 是否有更好的解决方案。这也是我们在此想要回答的。</p>\n<p>客观来说，作为核心团队成员，显然我们会更偏爱 Vue，认为对于某些问题来讲用 Vue 解决会更好。如果没有这点信念，我们也就不会整天为此忙活了。但是在此，我们想尽可能地公平和准确地来描述一切。其他的框架也有显著的优点，例如 React 庞大的生态系统，或者像是 Knockout 对浏览器的支持覆盖到了 IE6。我们会尝试着把这些内容全部列出来。</p>\n<p>我们也希望得到<strong>你</strong>的帮助，来使文档保持最新状态，因为 JavaScript 的世界进步的太快。如果你注意到一个不准确或似乎不太正确的地方，请<a href=\"https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide\">提交问题</a>让我们知道。</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>React 和 Vue 有许多相似之处，它们都有：</p>\n<ul>\n<li>使用 Virtual DOM</li>\n<li>提供了响应式（Reactive）和组件化（Composable）的视图组件。</li>\n<li>将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。</li>\n</ul>\n<p>由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要指出 React 比 Vue 更好的地方，像是他们的生态系统和丰富的自定义渲染器。</p>\n<p>React社区为我们准确进行平衡的考量提供了<a href=\"https://github.com/vuejs/vuejs.org/issues/364\">非常积极地帮助</a>，特别感谢来自 React 团队的 Dan Abramov 。他非常慷慨的花费时间来贡献专业知识，帮助我们完善这篇文档，最后我们对最终结果<a href=\"https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244575740\">都十分满意</a>。</p>\n<h3 id=\"性能简介\"><a href=\"#性能简介\" class=\"headerlink\" title=\"性能简介\"></a>性能简介</h3><p>到目前为止，针对现实情况的测试中，Vue 的性能是优于 React 的。如果你对此表示怀疑，请继续阅读。我们会解释为什么会这样（并且会提供一个与 React 团队共同约定的比较基准）。</p>\n<h4 id=\"渲染性能\"><a href=\"#渲染性能\" class=\"headerlink\" title=\"渲染性能\"></a>渲染性能</h4><p>在渲染用户界面的时候，DOM 的操作成本是最高的，不幸的是没有库可以让这些原始操作变得更快。<br>我们能做到的最好效果就是：</p>\n<ol>\n<li><p>Minimize the number of necessary DOM mutations. Both React and Vue use virtual DOM abstractions to accomplish this and both implementations work about equally well.</p>\n</li>\n<li><p>Add as little overhead (pure JavaScript computations) as possible on top of those DOM manipulations. This is an area where Vue and React differ.</p>\n</li>\n</ol>\n<p>The JavaScript overhead is directly related to the mechanisms of computing the necessary DOM operations. Both Vue and React utilizes Virtual DOM to achieve that, but Vue’s Virtual DOM implementation (a fork of <a href=\"https://github.com/snabbdom/snabbdom\">snabbdom</a>) is much lighter-weight and thus introduces less overhead than React’s.</p>\n<p>Vue 和 React 也提供功能性组件，这些组件因为都是没有声明，没有实例化的，因此会花费更少的开销。当这些都用于关键性能的场景时，Vue 将会更快。为了证明这点，我们建立了一个简单的<a href=\"https://github.com/chrisvfritz/vue-render-performance-comparisons\">参照项目</a>，它负责渲染 10,000 个列表项 100 次。我们鼓励你基于此去尝试运行一下。然而在实际上，由于浏览器和硬件的差异甚至 JavaScript 引擎的不同，结果都会相应有所不同。</p>\n<p>如果你懒得去做，下面的数值是来自于一个 2014 年产的 MacBook Air 并在 Chrome 52 版本下运行所产生的。为了避免偶然性，每个参照项目都分别运行 20 次并取自最好的结果：</p>\n\n<table class=\"benchmark-table\">\n  <thead>\n    <tr>\n      <th></th>\n      <th>Vue</th>\n      <th>React</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Fastest</th>\n      <td>23ms</td>\n      <td>63ms</td>\n    </tr>\n    <tr>\n      <th>Median</th>\n      <td>42ms</td>\n      <td>81ms</td>\n    </tr>\n    <tr>\n      <th>Average</th>\n      <td>51ms</td>\n      <td>94ms</td>\n    </tr>\n    <tr>\n      <th>95th Perc.</th>\n      <td>73ms</td>\n      <td>164ms</td>\n    </tr>\n    <tr>\n      <th>Slowest</th>\n      <td>343ms</td>\n      <td>453ms</td>\n    </tr>\n  </tbody>\n</table>\n\n<h4 id=\"更新性能\"><a href=\"#更新性能\" class=\"headerlink\" title=\"更新性能\"></a>更新性能</h4><p>In React, when a component’s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. </p>\n<p>To avoid unnecessary re-renders of child components, you need to implement <code>shouldComponentUpdate</code> everywhere and use immutable data structures. In Vue, a component’s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render.</p>\n<p>这意味着，未经优化的 Vue 相比未经优化的 React 要快的多。由于 Vue 改进过渲染性能，甚至全面优化过的 React 通常也会慢于开箱即用的 Vue。</p>\n<h4 id=\"开发中\"><a href=\"#开发中\" class=\"headerlink\" title=\"开发中\"></a>开发中</h4><p>显然，在生产环境中的性能是至关重要的，目前为止我们所具体讨论的便是针对此环境。但开发过程中的表现也不容小视。不错的是用 Vue 和 React 开发大多数应用的速度都是足够快的。</p>\n<p>当性能在生产中性能是直接与终端用户体验相关的更重要的指标时，表现在开发中仍然很重要,因为它是与开发相关经验</p>\n<p>然而，假如你要开发一个对性能要求比较高的数据可视化或者动画的应用时，你需要了解到下面这点：在开发中，Vue 每秒最高处理 10 帧，而 React 每秒最高处理不到 1 帧。</p>\n<p>这是由于 React 有大量的检查机制，这会让它提供许多有用的警告和错误提示信息。我们同样认为这些是很重要的，但是我们在实现这些检查时，也更加密切地关注了性能方面。</p>\n<h3 id=\"HTML-amp-CSS\"><a href=\"#HTML-amp-CSS\" class=\"headerlink\" title=\"HTML &amp; CSS\"></a>HTML &amp; CSS</h3><p>在 React 中，它们都是 JavaScript 编写的，听起来这十分简单和优雅。然而不幸的事实是，JavaScript 内的 HTML 和 CSS 会产生很多痛点。在 Vue 中我们采用 Web 技术并在其上进行扩展。接下来将通过一些实例向你展示这意味的是什么。</p>\n<h4 id=\"JSX-vs-Templates\"><a href=\"#JSX-vs-Templates\" class=\"headerlink\" title=\"JSX vs Templates\"></a>JSX vs Templates</h4><p>在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 Javascript 的一种语法糖。这有一个<a href=\"https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244582684\">通过React社区审核过的例子</a>：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><div class=\"line\"> render () &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> &#123; items &#125; = <span class=\"keyword\">this</span>.props</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> children</div><div class=\"line\">    <span class=\"keyword\">if</span> ( items.length &gt; <span class=\"number\">0</span> ) &#123;</div><div class=\"line\">        children = (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">                &#123;items.map( item =&gt;</div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">                )&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></div><div class=\"line\">        )</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        children = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>No items found.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span> = <span class=\"string\">'list-container'</span>&gt;</span></div><div class=\"line\">            &#123;children&#125;</div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">    )</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>JSX 的渲染功能有下面这些优势：</p>\n<ul>\n<li>你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。</li>\n<li>工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的（比如，linting、类型检查、编辑器的自动完成）。</li>\n</ul>\n<p>在 Vue 中，由于有时需要用这些功能，我们也提供了<a href=\"render-function.html\">渲染功能</a> 并且<a href=\"render-function.html#JSX\">支持了 JSX</a>。然而，对于大多数组件来说，渲染功能是不推荐使用了。</p>\n<p>在这方面，我们提供的是更简单的模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"list-container\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"items.length\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span></div><div class=\"line\">                &#123;&#123; item.name &#125;&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>No items found.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>优点如下：</p>\n<ul>\n<li>在写模板的过程中，样式风格已定并涉及更少的功能实现。</li>\n<li>模板总是会被声明的。</li>\n<li>模板中任何 HTML 语法都是有效的。</li>\n<li>阅读起来更贴合英语（比如，for each item in items）。</li>\n<li>不需要高级版本的 JavaScript 语法，来增加可读性。</li>\n</ul>\n<p>这样，不仅开发人员更容易编写代码，设计人员和开发人员也可以更容易的分析代码和贡献代码。</p>\n<p>这还没有结束。Vue 拥抱 HTML，而不是用 JavaScript 去重塑它。在模板内，Vue 也允许你用预处理器比如 Pug（原名 Jade）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">div.list-container</div><div class=\"line\">  ul(v-if=&quot;items.length&quot;)</div><div class=\"line\">    li(v-for=&quot;item in items&quot;) &#123;&#123; item.name &#125;&#125;</div><div class=\"line\">  p(v-else) No items found.</div></pre></td></tr></table></figure>\n<h4 id=\"CSS-的组件作用域\"><a href=\"#CSS-的组件作用域\" class=\"headerlink\" title=\"CSS 的组件作用域\"></a>CSS 的组件作用域</h4><p>除非你把组件分布在多个文件上(例如 <a href=\"https://github.com/gajus/react-css-modules\">CSS Modules</a>)，要不在 React 中作用域内的 CSS 就会产生警告。非常简单的 CSS 还可以工作，但是稍微复杂点的，比如悬停状态、媒体查询、伪类选择符等要么通过沉重的依赖来重做要么就直接不能用。</p>\n<p>而 Vue 可以让你在每个<a href=\"single-file-components.html\">单文件组件</a>中完全访问 CSS。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span><span class=\"css\"></div><div class=\"line\">    @<span class=\"keyword\">media</span> (min-width: <span class=\"number\">250px</span>) &#123;</div><div class=\"line\">        <span class=\"selector-class\">.list-container</span><span class=\"selector-pseudo\">:hover</span> &#123;</div><div class=\"line\">            <span class=\"attribute\">background</span>: orange;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个可选 <code>scoped</code> 属性会自动添加一个唯一的属性（比如 <code>data-v-21e5b78</code>）为组件内 CSS 指定作用域，编译的时候 <code>.list-container:hover</code> 会被编译成类似 <code>.list-container[data-v-21e5b78]:hover</code>。</p>\n<p>如果你已经熟悉 CSS Modules，Vue 单文件组件也有 <a href=\"http://vue-loader.vuejs.org/en/features/css-modules.html\">first-class 支持它</a>。</p>\n<p>最后，就像 HTML 一样，你可以选择自己偏爱的 CSS 预处理器（或后处理器）编写 CSS，这些生态系统允许您利用现有的库。这可以让你围绕设计为中心展开工作，,比如您的构建过程中颜色操作，而不是引入专门的库来增加你应用的体积和复杂度。</p>\n<h3 id=\"规模\"><a href=\"#规模\" class=\"headerlink\" title=\"规模\"></a>规模</h3><h4 id=\"向上扩展\"><a href=\"#向上扩展\" class=\"headerlink\" title=\"向上扩展\"></a>向上扩展</h4><p>Vue 和 React 都提供了强大的路由来应对大型应用。React 社区在状态管理方面非常有创新精神（比如Flux、Redux），而这些状态管理模式甚至<a href=\"https://github.com/egoist/revue\"> Redux 本身</a>也可以非常容易的集成在 Vue 应用中。实际上，Vue 更进一步地采用了这种模式（<a href=\"https://github.com/vuejs/vuex\">Vuex</a>），更加深入集成 Vue 的状态管理解决方案 Vuex 相信能为你带来更好的开发体验。</p>\n<p>两者另一个重要差异是，Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。</p>\n<p>最后，Vue 提供了<a href=\"https://github.com/vuejs/vue-cli\">Vue-cli 脚手架</a>，能让你非常容易地构建项目，包含了 <a href=\"https://github.com/vuejs-templates/webpack\">Webpack</a>, <a href=\"https://github.com/vuejs-templates/browserify\">Browserify</a>, 甚至 <a href=\"https://github.com/vuejs-templates/simple\">no build system</a>。React 在这方面也提供了<a href=\"https://github.com/facebookincubator/create-react-app\">create-react-app</a>，但是现在还存在一些局限性：</p>\n<ul>\n<li>它不允许在项目生成时进行任何配置，而 Vue 支持 Yeoman-like 定制。</li>\n<li>它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。</li>\n<li>它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。</li>\n</ul>\n<p>而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。如果阅读更多关于<a href=\"https://github.com/facebookincubator/create-react-app#philosophy\">不同的设计理念</a>。</p>\n<h4 id=\"向下扩展\"><a href=\"#向下扩展\" class=\"headerlink\" title=\"向下扩展\"></a>向下扩展</h4><p>React 学习曲线陡峭，在你开始学 React 前，你需要知道 JSX 和 ES2015，因为许多示例用的是这些语法。你需要学习构建系统，虽然你在技术上可以用 Babel 来实时编译代码，但是这并不推荐用于生产环境。</p>\n<p>就像 Vue 向上扩展好比 React 一样，Vue 向下扩展后就类似于 jQuery。你只要把如下标签放到页面就可以运行：</p>\n<p><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>然后你就可以编写 Vue 代码并应用到生产中，你只要用 min 版 Vue 文件替换掉就不用担心其他的性能问题。</p>\n<p>由于起步阶段不需学 JSX，ES2015 以及构建系统，所以开发者只需不到一天的时间阅读<a href=\"./\">指南</a>就可以建立简单的应用程序。</p>\n<h3 id=\"本地渲染\"><a href=\"#本地渲染\" class=\"headerlink\" title=\"本地渲染\"></a>本地渲染</h3><p>ReactNative 能使你用相同的组件模型编写有本地渲染能力的 APP（IOS 和 Android）。能同时跨多平台开发，对开发者是非常棒的。相应地，Vue 和 <a href=\"https://alibaba.github.io/weex/\">Weex</a> 会进行官方合作，Weex 是阿里的跨平台用户界面开发框架，Weex 的 JavaScript 框架运行时用的就是 Vue。这意味着在 Weex 的帮助下，你使用 Vue 语法开发的组件不仅仅可以运行在浏览器端，还能被用于开发 IOS 和 Android 上的原生应用。</p>\n<p>在现在，Weex 还在积极发展，成熟度也不能和 ReactNative 相抗衡。但是，Weex 的发展是由世界上最大的电子商务企业的需求在驱动，Vue 团队也会和 Weex 团队积极合作确保为开发者带来良好的开发体验。</p>\n<h3 id=\"MobX\"><a href=\"#MobX\" class=\"headerlink\" title=\"MobX\"></a>MobX</h3><p>Mobx 在 React 社区很流行，实际上在 Vue 也采用了几乎相同的反应系统。在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue，所以如果你习惯组合使用它们，那么选择 Vue 会更合理。</p>\n<h2 id=\"Angular-1\"><a href=\"#Angular-1\" class=\"headerlink\" title=\"Angular 1\"></a>Angular 1</h2><p>Vue 的一些语法和 Angular 的很相似（例如 <code>v-if</code> vs <code>ng-if</code>）。因为 Angular 是 Vue 早期开发的灵感来源。然而，Augular 中存在的许多问题，在 Vue 中已经得到解决。</p>\n<h3 id=\"复杂性\"><a href=\"#复杂性\" class=\"headerlink\" title=\"复杂性\"></a>复杂性</h3><p>在 API 与设计两方面上 Vue.js 都比 Angular 1 简单得多，因此你可以快速地掌握它的全部特性并投入开发。</p>\n<h3 id=\"灵活性和模块化\"><a href=\"#灵活性和模块化\" class=\"headerlink\" title=\"灵活性和模块化\"></a>灵活性和模块化</h3><p>Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 Angular 1 制定的规则，这让 Vue 能适用于各种项目。我们知道把决定权交给你是非常必要的。<br>这也就是为什么我们提供 <a href=\"https://github.com/vuejs-templates/webpack\">Webpack template</a>，让你可以用几分钟，去选择是否启用高级特性，比如热模块加载、linting、CSS 提取等等。</p>\n<h3 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h3><p>Angular 1 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。</p>\n<h3 id=\"指令与组件\"><a href=\"#指令与组件\" class=\"headerlink\" title=\"指令与组件\"></a>指令与组件</h3><p>在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。在 Angular 中两者有不少相混的地方。</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。</p>\n<p>在 Angular 1 中，当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。</p>\n<p>Vue 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系。</p>\n<p>有意思的是，Angular 2 和 Vue 用相似的设计解决了一些 Angular 1 中存在的问题。</p>\n<h2 id=\"Angular-2\"><a href=\"#Angular-2\" class=\"headerlink\" title=\"Angular 2\"></a>Angular 2</h2><p>我们单独将 Augluar 2 作分类，因为它完全是一个全新的框架。例如：它具有优秀的组件系统，并且许多实现已经完全重写，API 也完全改变了。</p>\n<h3 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h3><p>Angular 1 面向的是较小的应用程序，Angular 2 已转移焦点，面向的是大型企业应用。在这一点上 TypeScript 经常会被引用，它对那些喜欢用 Java 或者 C# 等类型安全的语言的人是非常有用的。</p>\n<p>Vue 也十分适合制作<a href=\"https://github.com/vuejs/awesome-vue#enterprise-usage\">企业应用</a>，你也可以通过使用<a href=\"https://github.com/vuejs/vue/tree/dev/types\">官方类型</a>或<a href=\"https://github.com/itsFrank/vue-typescript\">官方装饰器</a>来支持 TypeScript，这完全可由你的方案来定。</p>\n<h3 id=\"大小和性能\"><a href=\"#大小和性能\" class=\"headerlink\" title=\"大小和性能\"></a>大小和性能</h3><p>在性能方面，这两个框架都非常的快。但目前尚没有足够的数据用例来具体展示。如果你一定要量化这些数据，你可以查看<a href=\"http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html\">第三方参照</a>，它表明 Vue 2 相比 Angular2 是更快的。</p>\n<p>在大小方面，虽然 Angular 2 使用 tree-shaking 和离线编译技术使代码体积减小了许多。但包含编译器和全部功能的 Vue2(23kb) 相比 Angular 2(50kb) 还是要小的多。但是要注意，用 Angular 2 的 App 的体积缩减是使用了 tree-shaking 移除了那些框架中没有用到的功能，但随着功能引入的不断增多，尺寸会变得越来越大。</p>\n<h3 id=\"灵活性\"><a href=\"#灵活性\" class=\"headerlink\" title=\"灵活性\"></a>灵活性</h3><p>Vue 相比于 Angular 2 则更加灵活，Vue 官方提供了构建工具来协助你构建项目，但它并不限制你去如何构建。有人可能喜欢用统一的方式来构建，也有很多开发者喜欢这种灵活自由的方式。</p>\n<h3 id=\"学习曲线\"><a href=\"#学习曲线\" class=\"headerlink\" title=\"学习曲线\"></a>学习曲线</h3><p>开始使用 Vue，你使用的是熟悉的 HTML、符合 ES5 规则的 JavaScript（也就是纯 JavaScript）。有了这些基本的技能，你可以快速地掌握它(<a href=\"./\">指南</a>)并投入开发 。</p>\n<p>Angular 2 的学习曲线是非常陡峭的。即使不包括 TypeScript，它的<a href=\"https://angular.io/docs/js/latest/quickstart.html\">开始指南</a>中所用的就有 ES2015 标准的 JavaScript，18个 NPM 依赖包，4 个文件和超过 3 千多字的介绍，这一切都是为了完成个 Hello World。而<a href=\"https://jsfiddle.net/chrisvfritz/50wL7mdz/\">Vue’s Hello World</a>就非常简单。甚至我们并不用花费一整个页面去介绍它。</p>\n<h2 id=\"Ember\"><a href=\"#Ember\" class=\"headerlink\" title=\"Ember\"></a>Ember</h2><p>Ember 是一个全能框架。它提供了大量的约定，一旦你熟悉了它们，开发会变得很高效。不过，这也意味着学习曲线较高，而且并不灵活。这意味着在框架和库（加上一系列松散耦合的工具）之间做权衡选择。后者会更自由，但是也要求你做更多架构上的决定。</p>\n<p>也就是说，我们最好比较的是 Vue 内核和 Ember 的<a href=\"https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/\">模板</a>与<a href=\"https://guides.emberjs.com/v2.10.0/object-model/\">数据模型</a>层：</p>\n<ul>\n<li><p>Vue 在普通 JavaScript 对象上建立响应，提供自动化的计算属性。在 Ember 中需要将所有东西放在 Ember 对象内，并且手工为计算属性声明依赖。</p>\n</li>\n<li><p>Vue 的模板语法可以用全功能的 JavaScript 表达式，而 Handlebars 的语法和帮助函数相比来说非常受限。</p>\n</li>\n<li><p>在性能上，Vue 甩开 Ember 几条街，即使是 Ember 2.0 的最新 Glimmer 引擎。Vue 能够自动批量更新，而 Ember 在关键性能场景时需要手动管理。</p>\n</li>\n</ul>\n<h2 id=\"Knockout\"><a href=\"#Knockout\" class=\"headerlink\" title=\"Knockout\"></a>Knockout</h2><p>Knockout 是 MVVM 领域内的先驱，并且追踪依赖。它的响应系统和 Vue 也很相似。它在<a href=\"http://knockoutjs.com/documentation/browser-support.html\">浏览器支持</a>以及其他方面的表现也是让人印象深刻的。它最低能支持到 IE6，而 Vue 最低只能支持到 IE9。</p>\n<p>随着时间的推移，Knockout 的发展已有所放缓，并且略显有点老旧了。比如，它的组件系统缺少完备的生命周期事件方法，尽管这些在现在是非常常见的。以及相比于 <a href=\"components.html#Content-Distribution-with-Slots\">Vue</a> 调用子组件的接口它的方法显得有点笨重。</p>\n<p>如果你有兴趣研究，你还会发现二者在接口设计的理念上是不同的。这可以通过各自创建的 <a href=\"https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89\">simple Todo List</a> 体现出来。或许有点主观，但是很多人认为 Vue 的 API 接口更简单结构更优雅。</p>\n<h2 id=\"Polymer\"><a href=\"#Polymer\" class=\"headerlink\" title=\"Polymer\"></a>Polymer</h2><p>Polymer 是另一个由谷歌赞助的项目，事实上也是 Vue 的一个灵感来源。Vue 的组件可以粗略的类比于 Polymer 的自定义元素，并且两者具有相似的开发风格。最大的不同之处在于，Polymer 是基于最新版的 Web Components 标准之上，并且需要重量级的 polyfills 来帮助工作（性能下降），浏览器本身并不支持这些功能。相比而言，Vue 在支持到 IE9 的情况下并不需要依赖 polyfills 来工作。</p>\n<p>在 Polymer 1.0 版本中，为了弥补性能，团队非常有限的使用数据绑定系统。例如，在 Polymer 中唯一支持的表达式只有布尔值否定和单一的方法调用，它的 computed 方法的实现也并不是很灵活。</p>\n<p>Polymer 自定义的元素是用 HTML 文件来创建的，这会限制使用 JavaScript/CSS（和被现代浏览器普遍支持的语言特性）。相比之下，Vue 的单文件组件允许你非常容易的使用 ES2015 和你想用的 CSS 预编译处理器。</p>\n<p>在部署生产环境时，Polymer 建议使用 HTML Imports 加载所有资源。而这要求服务器和客户端都支持 Http 2.0 协议，并且浏览器实现了此标准。这是否可行就取决于你的目标用户和部署环境了。如果状况不佳，你必须用 Vulcanizer 工具来打包 Polymer 元素。而在这方面，Vue 可以结合异步组件的特性和 Webpack 的代码分割特性来实现懒加载（lazy-loaded）。这同时确保了对旧浏览器的兼容且又能更快加载。</p>\n<p>而 Vue 和 Web Component 标准进行深层次的整合也是完全可行的，比如使用 Custom Elements、Shadow DOM 的样式封装。然而在我们做出严肃的实现承诺之前，我们目前仍在等待相关标准成熟，进而再广泛应用于主流的浏览器中。</p>\n<h2 id=\"Riot\"><a href=\"#Riot\" class=\"headerlink\" title=\"Riot\"></a>Riot</h2><p>Riot 2.0 提供了一个类似于基于组件的开发模型（在 Riot 中称之为 Tag），它提供了小巧精美的 API。Riot 和 Vue 在设计理念上可能有许多相似处。尽管相比 Riot ，Vue 要显得重一点，Vue 还是有很多显著优势的：</p>\n<ul>\n<li><a href=\"transitions.html\">过渡效果系统</a>。Riot 现在还没有提供。<br>-功能更加强大的路由机制，Riot 的路由功能的 API 是极少的。</li>\n<li>更好的性能。Riot 使用了 <a href=\"http://riotjs.com/compare/#virtual-dom-vs-expressions-binding\">遍历 DOM 树</a> 而不是虚拟 DOM，但实际上用的还是脏检查机制，因此和 Angular 1 患有相同的性能问题。</li>\n<li>更多成熟工具的支持。Vue 提供官方支持<a href=\"https://github.com/vuejs/vue-loader\">Webpack</a> 和 <a href=\"https://github.com/vuejs/vueify\">Browserify</a>，而 Riot 是依靠社区来建立集成系统。</li>\n</ul>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/comparison.html\">http://vuejs.org/guide/comparison.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"组件","type":"guide","order":11,"_content":"\n## 什么是组件？\n\n组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。\n\n## 使用组件\n\n### 注册\n\n之前说过，我们可以通过以下方式创建一个 Vue 实例：\n\n``` js\nnew Vue({\n  el: '#some-element',\n  // 选项\n})\n```\n\n要注册一个全局组件，你可以使用 `Vue.component(tagName, options)`。 例如：\n\n``` js\nVue.component('my-component', {\n  // 选项\n})\n```\n\n<p class=\"tip\">对于自定义标签名，Vue.js 不强制要求遵循 [W3C规则](https://www.w3.org/TR/custom-elements/#concepts) （小写，并且包含一个短杠），尽管遵循这个规则比较好。</p>\n\n组件在注册之后，便可以在父实例的模块中以自定义元素 `<my-component></my-component>` 的形式使用。要确保在初始化根实例 **之前** 注册了组件：\n\n``` html\n<div id=\"example\">\n  <my-component></my-component>\n</div>\n```\n\n``` js\n// 注册\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\n\n// 创建根实例\nnew Vue({\n  el: '#example'\n})\n```\n\n渲染为：\n\n``` html\n<div id=\"example\">\n  <div>A custom component!</div>\n</div>\n```\n\n{% raw %}\n<div id=\"example\" class=\"demo\">\n  <my-component></my-component>\n</div>\n<script>\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\nnew Vue({ el: '#example' })\n</script>\n{% endraw %}\n\n### 局部注册\n\n不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用：\n\n``` js\nvar Child = {\n  template: '<div>A custom component!</div>'\n}\n\nnew Vue({\n  // ...\n  components: {\n    // <my-component> 将只在父模板可用\n    'my-component': Child\n  }\n})\n```\n\n这种封装也适用于其它可注册的 Vue 功能，如指令。\n\n### DOM 模版解析说明\n\n当使用 DOM 作为模版时（例如，将 `el` 选项挂载到一个已存在的元素上）, 你会受到 HTML 的一些限制，因为 Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。尤其像这些元素 `<ul>` ， `<ol>`， `<table>` ， `<select>` 限制了能被它包裹的元素， `<option>` 只能出现在其它元素内部。\n\n在自定义组件中使用这些受限制的元素时会导致一些问题，例如：\n\n``` html\n<table>\n  <my-row>...</my-row>\n</table>\n```\n\n自定义组件 `<my-row>` 被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 `is` 属性：\n\n``` html\n<table>\n  <tr is=\"my-row\"></tr>\n</table>\n```\n\n**应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：**\n\n- `<script type=\"text/x-template\">`\n- JavaScript内联模版字符串\n- `.vue` 组件\n\n因此，有必要的话请使用字符串模版。\n\n### `data` 必须是函数\n\n使用组件时，大多数选项可以被传入到 Vue 构造器中，有一个例外： `data` 必须是函数。 实际上，如果你这么做：\n\n``` js\nVue.component('my-component', {\n  template: '<span>{{ message }}</span>',\n  data: {\n    message: 'hello'\n  }\n})\n```\n\n那么 Vue 会在控制台发出警告，告诉你在组件中 `data` 必须是一个函数。最好理解这种规则的存在意义。\n\n``` html\n<div id=\"example-2\">\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n</div>\n```\n\n``` js\nvar data = { counter: 0 }\n\nVue.component('simple-counter', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  // data 是一个函数，因此 Vue 不会警告，\n  // 但是我们为每一个组件返回了同一个对象引用\n  data: function () {\n    return data\n  }\n})\n\nnew Vue({\n  el: '#example-2'\n})\n```\n\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n</div>\n<script>\nvar data = { counter: 0 }\nVue.component('simple-counter', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return data\n  }\n})\nnew Vue({\n  el: '#example-2'\n})\n</script>\n{% endraw %}\n\n由于这三个组件共享了同一个 `data` ， 因此增加一个 counter 会影响所有组件！我们可以通过为每个组件返回新的 data 对象来解决这个问题：\n\n``` js\ndata: function () {\n  return {\n    counter: 0\n  }\n}\n```\n\n现在每个 counter 都有它自己内部的状态了：\n\n{% raw %}\n<div id=\"example-2-5\" class=\"demo\">\n  <my-component></my-component>\n  <my-component></my-component>\n  <my-component></my-component>\n</div>\n<script>\nVue.component('my-component', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  }\n})\nnew Vue({\n  el: '#example-2-5'\n})\n</script>\n{% endraw %}\n\n### 构成组件\n\n组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。\n\n在 Vue.js 中，父子组件的关系可以总结为 **props down, events up** 。父组件通过 **props** 向下传递数据给子组件，子组件通过 **events** 给父组件发送消息。看看它们是怎么工作的。\n\n<p style=\"text-align: center\">\n  <img style=\"width:300px\" src=\"/images/props-events.png\" alt=\"props down, events up\">\n</p>\n\n## Prop\n\n### 使用 Prop 传递数据\n\n组件实例的作用域是**孤立的**。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。\n\nprop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 [`props` 选项](../api/#props)声明 “prop”：\n\n``` js\nVue.component('child', {\n  // 声明 props\n  props: ['message'],\n  // 就像 data 一样，prop 可以用在模板内\n  // 同样也可以在 vm 实例中像 “this.message” 这样使用\n  template: '<span>{{ message }}</span>'\n})\n```\n\n然后向它传入一个普通字符串：\n\n``` html\n<child message=\"hello!\"></child>\n```\n\n结果：\n\n{% raw %}\n<div id=\"prop-example-1\" class=\"demo\">\n  <child message=\"hello!\"></child>\n</div>\n<script>\nnew Vue({\n  el: '#prop-example-1',\n  components: {\n    child: {\n      props: ['message'],\n      template: '<span>{{ message }}</span>'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n### camelCase vs. kebab-case\n\nHTML 特性不区分大小写。当使用非字符串模版时，prop的名字形式会从 camelCase 转为 kebab-case（短横线隔开）：\n\n``` js\nVue.component('child', {\n  // camelCase in JavaScript\n  props: ['myMessage'],\n  template: '<span>{{ myMessage }}</span>'\n})\n```\n\n``` html\n<!-- kebab-case in HTML -->\n<child my-message=\"hello!\"></child>\n```\n\n再次说明，如果你使用字符串模版，不用在意这些限制。\n\n### 动态 Prop\n\n类似于用 `v-bind` 绑定 HTML 特性到一个表达式，也可以用 `v-bind` 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件：\n\n``` html\n<div>\n  <input v-model=\"parentMsg\">\n  <br>\n  <child v-bind:my-message=\"parentMsg\"></child>\n</div>\n```\n\n使用 `v-bind` 的缩写语法通常更简单：\n\n``` html\n<child :my-message=\"parentMsg\"></child>\n```\n\n结果：\n\n{% raw %}\n<div id=\"demo-2\" class=\"demo\">\n  <input v-model=\"parentMsg\">\n  <br>\n  <child v-bind:my-message=\"parentMsg\"></child>\n</div>\n<script>\nnew Vue({\n  el: '#demo-2',\n  data: {\n    parentMsg: 'Message from parent'\n  },\n  components: {\n    child: {\n      props: ['myMessage'],\n      template: '<span>{{myMessage}}</span>'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n### 字面量语法 vs 动态语法\n\n初学者常犯的一个错误是使用字面量语法传递数值：\n\n``` html\n<!-- 传递了一个字符串\"1\" -->\n<comp some-prop=\"1\"></comp>\n```\n\n因为它是一个字面 prop ，它的值以字符串 `\"1\"` 而不是以实际的数字传下去。如果想传递一个实际的 JavaScript 数字，需要使用 `v-bind` ，从而让它的值被当作 JavaScript 表达式计算：\n\n``` html\n<!-- 传递实际的数字 -->\n<comp v-bind:some-prop=\"1\"></comp>\n```\n\n### 单向数据流\n\nprop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。\n\n另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你**不应该**在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。\n\n通常有两种改变 prop 的情况：\n\n1. prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；\n\n2. prop 作为需要被转变的原始值传入。\n\n更确切的说这两种情况是：\n\n1. 定义一个局部 data 属性，并将 prop 的初始值作为局部数据的初始值。\n\n  ``` js\n  props: ['initialCounter'],\n  data: function () {\n    return { counter: this.initialCounter }\n  }\n  ```\n\n2. 定义一个 computed 属性，此属性从 prop 的值计算得出。\n\n  ``` js\n  props: ['size'],\n  computed: {\n    normalizedSize: function () {\n      return this.size.trim().toLowerCase()\n    }\n  }\n  ```\n\n<p class=\"tip\">注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它**会影响**父组件的状态。</p>\n\n### Prop 验证\n\n组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告。当组件给其他人使用时这很有用。\n\nprop 是一个对象而不是字符串数组时，它包含验证要求：\n\n``` js\nVue.component('example', {\n  props: {\n    // 基础类型检测 （`null` 意思是任何类型都可以）\n    propA: Number,\n    // 多种类型\n    propB: [String, Number],\n    // 必传且是字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 数字，有默认值\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 数组／对象的默认值应当由一个工厂函数返回\n    propE: {\n      type: Object,\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        return value > 10\n      }\n    }\n  }\n})\n```\n\n`type` 可以是下面原生构造器：\n\n- String\n- Number\n- Boolean\n- Function\n- Object\n- Array\n\n`type` 也可以是一个自定义构造器，使用 `instanceof` 检测。\n\n当 prop 验证失败了， Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告。\n\n## 自定义事件\n\n我们知道，父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！\n\n### 使用 `v-on` 绑定自定义事件\n\n每个 Vue 实例都实现了[事件接口(Events interface)](../api/#Instance-Methods-Events)，即：\n\n- 使用 `$on(eventName)` 监听事件\n- 使用 `$emit(eventName)` 触发事件\n\n<p class=\"tip\">Vue的事件系统分离自浏览器的[EventTarget API](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget)。尽管它们的运行类似，但是`$on` 和 `$emit` __不是__`addEventListener` 和 `dispatchEvent` 的别名。</p>\n\n另外，父组件可以在使用子组件的地方直接用 `v-on` 来监听子组件触发的事件。\n\n下面是一个例子：\n\n``` html\n<div id=\"counter-event-example\">\n  <p>{{ total }}</p>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n```\n\n``` js\nVue.component('button-counter', {\n  template: '<button v-on:click=\"increment\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  },\n  methods: {\n    increment: function () {\n      this.counter += 1\n      this.$emit('increment')\n    }\n  },\n})\n\nnew Vue({\n  el: '#counter-event-example',\n  data: {\n    total: 0\n  },\n  methods: {\n    incrementTotal: function () {\n      this.total += 1\n    }\n  }\n})\n```\n\n{% raw %}\n<div id=\"counter-event-example\" class=\"demo\">\n  <p>{{ total }}</p>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n<script>\nVue.component('button-counter', {\n  template: '<button v-on:click=\"increment\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  },\n  methods: {\n    increment: function () {\n      this.counter += 1\n      this.$emit('increment')\n    }\n  },\n})\nnew Vue({\n  el: '#counter-event-example',\n  data: {\n    total: 0\n  },\n  methods: {\n    incrementTotal: function () {\n      this.total += 1\n    }\n  }\n})\n</script>\n{% endraw %}\n\n在本例中，子组件已经和它外部完全解耦了。它所做的只是触发一个父组件关心的内部事件。\n\n#### 给组件绑定原生事件\n\n有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 `.native` 修饰 `v-on` 。例如：\n\n``` html\n<my-component v-on:click.native=\"doTheThing\"></my-component>\n```\n\n### 使用自定义事件的表单输入组件\n\n自定义事件也可以用来创建自定义的表单输入组件，使用 `v-model` 来进行数据双向绑定。牢记：\n\n``` html\n<input v-model=\"something\">\n```\n\n仅仅是一个语法糖：\n\n``` html\n<input v-bind:value=\"something\" v-on:input=\"something = $event.target.value\">\n```\n\n所以在组件中使用时，它相当于下面的简写：\n\n``` html\n<custom-input v-bind:value=\"something\" v-on:input=\"something = arguments[0]\"></custom-input>\n```\n\n所以要让组件的 `v-model` 生效，它必须：\n\n- 接受一个 `value` 属性\n- 在有新的 value 时触发 `input` 事件\n\n一个非常简单的货币输入：\n\n``` html\n<currency-input v-model=\"price\"></currency-input>\n```\n\n``` js\nVue.component('currency-input', {\n  template: '\\\n    <span>\\\n      $\\\n      <input\\\n        ref=\"input\"\\\n        v-bind:value=\"value\"\\\n        v-on:input=\"updateValue($event.target.value)\"\\\n      >\\\n    </span>\\\n  ',\n  props: ['value'],\n  methods: {\n    // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制\n    updateValue: function (value) {\n      var formattedValue = value\n        // 删除两侧的空格符\n        .trim()\n        // 保留 2 小数位\n        .slice(0, value.indexOf('.') + 3)\n      // 如果值不统一，手动覆盖以保持一致\n      if (formattedValue !== value) {\n        this.$refs.input.value = formattedValue\n      }\n      // 通过 input 事件发出数值\n      this.$emit('input', Number(formattedValue))\n    }\n  }\n})\n```\n\n{% raw %}\n<div id=\"currency-input-example\" class=\"demo\">\n  <currency-input v-model=\"price\"></currency-input>\n</div>\n<script>\nVue.component('currency-input', {\n  template: '\\\n    <span>\\\n      $\\\n      <input\\\n        ref=\"input\"\\\n        v-bind:value=\"value\"\\\n        v-on:input=\"updateValue($event.target.value)\"\\\n      >\\\n    </span>\\\n  ',\n  props: ['value'],\n  methods: {\n    updateValue: function (value) {\n      var formattedValue = value\n        .trim()\n        .slice(0, value.indexOf('.') + 3)\n      if (formattedValue !== value) {\n        this.$refs.input.value = formattedValue\n      }\n      this.$emit('input', Number(formattedValue))\n    }\n  }\n})\nnew Vue({ el: '#currency-input-example' })\n</script>\n{% endraw %}\n\n上面的实现方式太过理想化了。 比如，用户甚至可以输入多个小数点或句号 - 哦哦！因此我们需要一个更有意义的例子，下面是一个更加完善的货币过滤器：\n\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/result,html,js\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n这个接口不仅仅可以用来连接组件内部的表单输入，也很容易集成你自己创造的输入类型。想象一下：\n\n``` html\n<voice-recognizer v-model=\"question\"></voice-recognizer>\n<webcam-gesture-reader v-model=\"gesture\"></webcam-gesture-reader>\n<webcam-retinal-scanner v-model=\"retinalImage\"></webcam-retinal-scanner>\n```\n\n### 非父子组件通信\n\n有时候非父子关系的组件也需要通信。在简单的场景下，使用一个空的 Vue 实例作为中央事件总线：\n\n``` js\nvar bus = new Vue()\n```\n``` js\n// 触发组件 A 中的事件\nbus.$emit('id-selected', 1)\n```\n``` js\n// 在组件 B 创建的钩子中监听事件\nbus.$on('id-selected', function (id) {\n  // ...\n})\n```\n\n在更多复杂的情况下，你应该考虑使用专门的 [状态管理模式](state-management.html).\n\n## 使用 Slot 分发内容\n\n在使用组件时，常常要像这样组合它们：\n\n``` html\n<app>\n  <app-header></app-header>\n  <app-footer></app-footer>\n</app>\n```\n\n注意两点：\n\n1. `<app>` 组件不知道它的挂载点会有什么内容。挂载点的内容是由`<app>`的父组件决定的。\n\n2. `<app>` 组件很可能有它自己的模版。\n\n为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 **内容分发** (或 \"transclusion\" 如果你熟悉 Angular)。Vue.js 实现了一个内容分发 API ，参照了当前 [Web 组件规范草案](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md)，使用特殊的 `<slot>` 元素作为原始内容的插槽。\n\n### 编译作用域\n\n在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为：\n\n``` html\n<child-component>\n  {{ message }}\n</child-component>\n```\n\n`message` 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：\n\n父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。\n\n一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：\n\n``` html\n<!-- 无效 -->\n<child-component v-show=\"someChildProperty\"></child-component>\n```\n\n假定 `someChildProperty` 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。\n\n如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做：\n\n``` js\nVue.component('child-component', {\n  // 有效，因为是在正确的作用域内\n  template: '<div v-show=\"someChildProperty\">Child</div>',\n  data: function () {\n    return {\n      someChildProperty: true\n    }\n  }\n})\n```\n\n类似地，分发内容是在父组件作用域内编译。\n\n### 单个 Slot\n\n除非子组件模板包含至少一个 `<slot>` 插口，否则父组件的内容将会被**丢弃**。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。\n\n最初在 `<slot>` 标签中的任何内容都被视为**备用内容**。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。\n\n假定 `my-component` 组件有下面模板：\n\n``` html\n<div>\n  <h2>我是子组件的标题</h2>\n  <slot>\n    只有在没有要分发的内容时才会显示。\n  </slot>\n</div>\n```\n\n父组件模版：\n\n``` html\n<div>\n  <h1>我是父组件的标题</h1>\n  <my-component>\n    <p>这是一些初始内容</p>\n    <p>这是更多的初始内容</p>\n  </my-component>\n</div>\n```\n\n渲染结果：\n\n``` html\n<div>\n  <h1>我是父组件的标题</h1>\n  <div>\n    <h2>我是子组件的标题</h2>\n    <p>这是一些初始内容</p>\n    <p>这是更多的初始内容</p>\n  </div>\n</div>\n```\n\n### 具名 Slot\n\n`<slot>` 元素可以用一个特殊的属性 `name` 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 `slot` 特性的元素。\n\n仍然可以有一个匿名 slot ，它是**默认 slot** ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。\n\n例如，假定我们有一个 `app-layout` 组件，它的模板为：\n\n``` html\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\n父组件模版：\n\n``` html\n<app-layout>\n  <h1 slot=\"header\">这里可能是一个页面标题</h1>\n\n  <p>主要内容的一个段落。</p>\n  <p>另一个主要段落。</p>\n\n  <p slot=\"footer\">这里有一些联系信息</p>\n</app-layout>\n```\n\n渲染结果为：\n\n``` html\n<div class=\"container\">\n  <header>\n    <h1>这里可能是一个页面标题</h1>\n  </header>\n  <main>\n    <p>主要内容的一个段落。</p>\n    <p>另一个主要段落。</p>\n  </main>\n  <footer>\n    <p>这里有一些联系信息</p>\n  </footer>\n</div>\n```\n\n在组合组件时，内容分发 API 是非常有用的机制。\n\n\n### 作用域插槽\n\n> 2.1.0 新增\n\n作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。\n\n在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：\n\n``` html\n<div class=\"child\">\n  <slot text=\"hello from child\"></slot>\n</div>\n```\n\n在父级中，具有特殊属性 `scope` 的 `<template>` 元素，表示它是作用域插槽的模板。`scope` 的值对应一个临时变量名，此变量接收从子组件中传递的 prop 对象：\n\n``` html\n<div class=\"parent\">\n  <child>\n    <template scope=\"props\">\n      <span>hello from parent</span>\n      <span>{{ props.text }}</span>\n    </template>\n  </child>\n</div>\n```\n\n如果我们渲染以上结果，得到的输出会是：\n\n``` html\n<div class=\"parent\">\n  <div class=\"child\">\n    <span>hello from parent</span>\n    <span>hello from child</span>\n  </div>\n</div>\n```\n\n作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：\n\n``` html\n<my-awesome-list :items=\"items\">\n  <!-- 作用域插槽也可以在这里命名 -->\n  <template slot=\"item\" scope=\"props\">\n    <li class=\"my-fancy-item\">{{ props.text }}</li>\n  </template>\n</my-awesome-list>\n```\n\n列表组件的模板：\n\n``` html\n<ul>\n  <slot name=\"item\"\n    v-for=\"item in items\"\n    :text=\"item.text\">\n    <!-- fallback content here -->\n  </slot>\n</ul>\n```\n\n## 动态组件\n\n多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 `<component>` 元素，动态地绑定到它的 `is` 特性：\n\n``` js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    currentView: 'home'\n  },\n  components: {\n    home: { /* ... */ },\n    posts: { /* ... */ },\n    archive: { /* ... */ }\n  }\n})\n```\n\n``` html\n<component v-bind:is=\"currentView\">\n  <!-- 组件在 vm.currentview 变化时改变！ -->\n</component>\n```\n\n也可以直接绑定到组件对象上：\n\n``` js\nvar Home = {\n  template: '<p>Welcome home!</p>'\n}\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    currentView: Home\n  }\n})\n```\n\n### `keep-alive`\n\n如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 `keep-alive` 指令参数：\n\n``` html\n<keep-alive>\n  <component :is=\"currentView\">\n    <!-- 非活动组件将被缓存！ -->\n  </component>\n</keep-alive>\n```\n\n在[API 参考](../api/#keep-alive)查看更多 `<keep-alive>` 的细节。\n\n## 杂项\n\n### 编写可复用组件\n\n在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。\n\nVue 组件的 API 来自三部分 - props, events 和 slots ：\n\n- **Props** 允许外部环境传递数据给组件\n\n- **Events** 允许组件触发外部环境的副作用\n\n- **Slots** 允许外部环境将额外的内容组合在组件中。\n\n使用 `v-bind` 和 `v-on` 的简写语法，模板的缩进清楚且简洁：\n\n``` html\n<my-component\n  :foo=\"baz\"\n  :bar=\"qux\"\n  @event-a=\"doThis\"\n  @event-b=\"doThat\"\n>\n  <img slot=\"icon\" src=\"...\">\n  <p slot=\"main-text\">Hello!</p>\n</my-component>\n```\n\n### 子组件索引\n\n尽管有 props 和 events ，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 `ref` 为子组件指定一个索引 ID 。例如：\n\n``` html\n<div id=\"parent\">\n  <user-profile ref=\"profile\"></user-profile>\n</div>\n```\n\n``` js\nvar parent = new Vue({ el: '#parent' })\n// 访问子组件\nvar child = parent.$refs.profile\n```\n\n当 `ref` 和 `v-for` 一起使用时， ref 是一个数组或对象，包含相应的子组件。\n\n<p class=\"tip\">`$refs` 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 `$refs` 。</p>\n\n### 异步组件\n\n在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单， Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：\n\n``` js\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    // Pass the component definition to the resolve callback\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```\n\n工厂函数接收一个 `resolve` 回调，在收到从服务器下载的组件定义时调用。也可以调用 `reject(reason)` 指示加载失败。这里 `setTimeout` 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：[Webpack 的代码分割功能](http://webpack.github.io/docs/code-splitting.html)：\n\n``` js\nVue.component('async-webpack-example', function (resolve) {\n  // 这个特殊的 require 语法告诉 webpack\n  // 自动将编译后的代码分割成不同的块，\n  // 这些块将通过 Ajax 请求自动下载。\n  require(['./my-async-component'], resolve)\n})\n```\n\n你可以使用 Webpack 2 + ES2015 的语法返回一个 `Promise` resolve 函数：\n\n``` js\nVue.component(\n  'async-webpack-example',\n  () => System.import('./my-async-component')\n)\n```\n\n<p class=\"tip\">如果你是 <strong>Browserify</strong> 用户,可能就无法使用异步组件了,它的作者已经[表明](https://github.com/substack/node-browserify/issues/58#issuecomment-21978224) Browserify 是不支持异步加载的。Browserify 社区发现 [一些解决方法](https://github.com/vuejs/vuejs.org/issues/620)，可能有助于已存在的复杂应用。对于其他场景，我们推荐简单实用 Webpack 构建，一流的异步支持</p>\n\n### 组件命名约定\n\n当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 。Vue 不关心这个。\n\n``` js\n// 在组件定义中\ncomponents: {\n  // 使用 kebab-case 形式注册\n  'kebab-cased-component': { /* ... */ },\n  // register using camelCase\n  'camelCasedComponent': { /* ... */ },\n  // register using TitleCase\n  'TitleCasedComponent': { /* ... */ }\n}\n```\n\n在 HTML 模版中，请使用 kebab-case 形式：\n\n``` html\n<!-- 在HTML模版中始终使用 kebab-case -->\n<kebab-cased-component></kebab-cased-component>\n<camel-cased-component></camel-cased-component>\n<title-cased-component></title-cased-component>\n```\n\n当使用字符串模式时，可以不受 HTML 的 case-insensitive 限制。这意味实际上在模版中，你可以使用 camelCase 、 TitleCase 或者 kebab-case 来引用：\n\n``` html\n<!-- 在字符串模版中可以用任何你喜欢的方式! -->\n<my-component></my-component>\n<myComponent></myComponent>\n<MyComponent></MyComponent>\n```\n\n如果组件未经 `slot` 元素传递内容，你甚至可以在组件名后使用 `/` 使其自闭合：\n\n``` html\n<my-component/>\n```\n\n当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。\n\n### 递归组件\n\n组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以：\n\n``` js\nname: 'unique-name-of-my-component'\n```\n\n当你利用`Vue.component`全局注册了一个组件, 全局的ID作为组件的 `name` 选项，被自动设置.\n\n``` js\nVue.component('unique-name-of-my-component', {\n  // ...\n})\n```\n\n如果你不谨慎, 递归组件可能导致死循环:\n\n``` js\nname: 'stack-overflow',\ntemplate: '<div><stack-overflow></stack-overflow></div>'\n```\n\n上面组件会导致一个错误 “max stack size exceeded” ，所以要确保递归调用有终止条件 (比如递归调用时使用 `v-if` 并让他最终返回 `false` )。\n\n\n### Circular References Between Components\n\nLet's say you're building a file directory tree, like in Finder or File Explorer. You might have a `tree-folder` component with this template:\n\n``` html\n<p>\n  <span>{{ folder.name }}</span>\n  <tree-folder-contents :children=\"folder.children\"/>\n</p>\n```\n\nThen a `tree-folder-contents` component with this template:\n\n``` html\n<ul>\n  <li v-for=\"child in children\">\n    <tree-folder v-if=\"child.children\" :folder=\"child\"/>\n    <span v-else>{{ child.name }}</span>\n  </li>\n</ul>\n```\n\nWhen you look closely, you'll see that these components will actually be each other's descendent _and_ ancestor in the render tree - a paradox! When registering components globally with `Vue.component`, this paradox is resolved for you automatically. If that's you, you can stop reading here.\n\nHowever, if you're requiring/importing components using a __module system__, e.g. via Webpack or Browserify, you'll get an error:\n\n```\nFailed to mount component: template or render function not defined.\n```\n\nTo explain what's happening, I'll call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc, etc. It's stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, \"A needs B _eventually_, but there's no need to resolve B first.\"\n\nIn our case, I'll make that point the `tree-folder` component. We know the child that creates the paradox is the `tree-folder-contents` component, so we'll wait until the `beforeCreate` lifecycle hook to register it:\n\n``` js\nbeforeCreate: function () {\n  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')\n}\n```\n\nProblem solved!\n\n### 内联模版\n\n如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。\n\n``` html\n<my-component inline-template>\n  <div>\n    <p>These are compiled as the component's own template.</p>\n    <p>Not parent's transclusion content.</p>\n  </div>\n</my-component>\n```\n\n但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 `.vue` 文件中使用 `template` 元素。\n\n### X-Templates\n\n另一种定义模版的方式是在 JavaScript 标签里使用 `text/x-template` 类型，并且指定一个id。例如：\n\n``` html\n<script type=\"text/x-template\" id=\"hello-world-template\">\n  <p>Hello hello hello</p>\n</script>\n```\n\n``` js\nVue.component('hello-world', {\n  template: '#hello-world-template'\n})\n```\n\n这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。\n\n### 使用 `v-once` 的低级静态组件(Cheap Static Component)\n\n尽管在 Vue 中渲染 HTML 很快，不过当组件中包含**大量**静态内容时，可以考虑使用 `v-once` 将渲染结果缓存起来，就像这样：\n\n``` js\nVue.component('terms-of-service', {\n  template: '\\\n    <div v-once>\\\n      <h1>Terms of Service</h1>\\\n      ... a lot of static content ...\\\n    </div>\\\n  '\n})\n```\n\n***\n\n> 原文：http://vuejs.org/guide/components.html\n\n***\n","source":"v2/guide/components.md","raw":"---\ntitle: 组件\ntype: guide\norder: 11\n---\n\n## 什么是组件？\n\n组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。\n\n## 使用组件\n\n### 注册\n\n之前说过，我们可以通过以下方式创建一个 Vue 实例：\n\n``` js\nnew Vue({\n  el: '#some-element',\n  // 选项\n})\n```\n\n要注册一个全局组件，你可以使用 `Vue.component(tagName, options)`。 例如：\n\n``` js\nVue.component('my-component', {\n  // 选项\n})\n```\n\n<p class=\"tip\">对于自定义标签名，Vue.js 不强制要求遵循 [W3C规则](https://www.w3.org/TR/custom-elements/#concepts) （小写，并且包含一个短杠），尽管遵循这个规则比较好。</p>\n\n组件在注册之后，便可以在父实例的模块中以自定义元素 `<my-component></my-component>` 的形式使用。要确保在初始化根实例 **之前** 注册了组件：\n\n``` html\n<div id=\"example\">\n  <my-component></my-component>\n</div>\n```\n\n``` js\n// 注册\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\n\n// 创建根实例\nnew Vue({\n  el: '#example'\n})\n```\n\n渲染为：\n\n``` html\n<div id=\"example\">\n  <div>A custom component!</div>\n</div>\n```\n\n{% raw %}\n<div id=\"example\" class=\"demo\">\n  <my-component></my-component>\n</div>\n<script>\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\nnew Vue({ el: '#example' })\n</script>\n{% endraw %}\n\n### 局部注册\n\n不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用：\n\n``` js\nvar Child = {\n  template: '<div>A custom component!</div>'\n}\n\nnew Vue({\n  // ...\n  components: {\n    // <my-component> 将只在父模板可用\n    'my-component': Child\n  }\n})\n```\n\n这种封装也适用于其它可注册的 Vue 功能，如指令。\n\n### DOM 模版解析说明\n\n当使用 DOM 作为模版时（例如，将 `el` 选项挂载到一个已存在的元素上）, 你会受到 HTML 的一些限制，因为 Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。尤其像这些元素 `<ul>` ， `<ol>`， `<table>` ， `<select>` 限制了能被它包裹的元素， `<option>` 只能出现在其它元素内部。\n\n在自定义组件中使用这些受限制的元素时会导致一些问题，例如：\n\n``` html\n<table>\n  <my-row>...</my-row>\n</table>\n```\n\n自定义组件 `<my-row>` 被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 `is` 属性：\n\n``` html\n<table>\n  <tr is=\"my-row\"></tr>\n</table>\n```\n\n**应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：**\n\n- `<script type=\"text/x-template\">`\n- JavaScript内联模版字符串\n- `.vue` 组件\n\n因此，有必要的话请使用字符串模版。\n\n### `data` 必须是函数\n\n使用组件时，大多数选项可以被传入到 Vue 构造器中，有一个例外： `data` 必须是函数。 实际上，如果你这么做：\n\n``` js\nVue.component('my-component', {\n  template: '<span>{{ message }}</span>',\n  data: {\n    message: 'hello'\n  }\n})\n```\n\n那么 Vue 会在控制台发出警告，告诉你在组件中 `data` 必须是一个函数。最好理解这种规则的存在意义。\n\n``` html\n<div id=\"example-2\">\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n</div>\n```\n\n``` js\nvar data = { counter: 0 }\n\nVue.component('simple-counter', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  // data 是一个函数，因此 Vue 不会警告，\n  // 但是我们为每一个组件返回了同一个对象引用\n  data: function () {\n    return data\n  }\n})\n\nnew Vue({\n  el: '#example-2'\n})\n```\n\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n</div>\n<script>\nvar data = { counter: 0 }\nVue.component('simple-counter', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return data\n  }\n})\nnew Vue({\n  el: '#example-2'\n})\n</script>\n{% endraw %}\n\n由于这三个组件共享了同一个 `data` ， 因此增加一个 counter 会影响所有组件！我们可以通过为每个组件返回新的 data 对象来解决这个问题：\n\n``` js\ndata: function () {\n  return {\n    counter: 0\n  }\n}\n```\n\n现在每个 counter 都有它自己内部的状态了：\n\n{% raw %}\n<div id=\"example-2-5\" class=\"demo\">\n  <my-component></my-component>\n  <my-component></my-component>\n  <my-component></my-component>\n</div>\n<script>\nVue.component('my-component', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  }\n})\nnew Vue({\n  el: '#example-2-5'\n})\n</script>\n{% endraw %}\n\n### 构成组件\n\n组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。\n\n在 Vue.js 中，父子组件的关系可以总结为 **props down, events up** 。父组件通过 **props** 向下传递数据给子组件，子组件通过 **events** 给父组件发送消息。看看它们是怎么工作的。\n\n<p style=\"text-align: center\">\n  <img style=\"width:300px\" src=\"/images/props-events.png\" alt=\"props down, events up\">\n</p>\n\n## Prop\n\n### 使用 Prop 传递数据\n\n组件实例的作用域是**孤立的**。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。\n\nprop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 [`props` 选项](../api/#props)声明 “prop”：\n\n``` js\nVue.component('child', {\n  // 声明 props\n  props: ['message'],\n  // 就像 data 一样，prop 可以用在模板内\n  // 同样也可以在 vm 实例中像 “this.message” 这样使用\n  template: '<span>{{ message }}</span>'\n})\n```\n\n然后向它传入一个普通字符串：\n\n``` html\n<child message=\"hello!\"></child>\n```\n\n结果：\n\n{% raw %}\n<div id=\"prop-example-1\" class=\"demo\">\n  <child message=\"hello!\"></child>\n</div>\n<script>\nnew Vue({\n  el: '#prop-example-1',\n  components: {\n    child: {\n      props: ['message'],\n      template: '<span>{{ message }}</span>'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n### camelCase vs. kebab-case\n\nHTML 特性不区分大小写。当使用非字符串模版时，prop的名字形式会从 camelCase 转为 kebab-case（短横线隔开）：\n\n``` js\nVue.component('child', {\n  // camelCase in JavaScript\n  props: ['myMessage'],\n  template: '<span>{{ myMessage }}</span>'\n})\n```\n\n``` html\n<!-- kebab-case in HTML -->\n<child my-message=\"hello!\"></child>\n```\n\n再次说明，如果你使用字符串模版，不用在意这些限制。\n\n### 动态 Prop\n\n类似于用 `v-bind` 绑定 HTML 特性到一个表达式，也可以用 `v-bind` 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件：\n\n``` html\n<div>\n  <input v-model=\"parentMsg\">\n  <br>\n  <child v-bind:my-message=\"parentMsg\"></child>\n</div>\n```\n\n使用 `v-bind` 的缩写语法通常更简单：\n\n``` html\n<child :my-message=\"parentMsg\"></child>\n```\n\n结果：\n\n{% raw %}\n<div id=\"demo-2\" class=\"demo\">\n  <input v-model=\"parentMsg\">\n  <br>\n  <child v-bind:my-message=\"parentMsg\"></child>\n</div>\n<script>\nnew Vue({\n  el: '#demo-2',\n  data: {\n    parentMsg: 'Message from parent'\n  },\n  components: {\n    child: {\n      props: ['myMessage'],\n      template: '<span>{{myMessage}}</span>'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n### 字面量语法 vs 动态语法\n\n初学者常犯的一个错误是使用字面量语法传递数值：\n\n``` html\n<!-- 传递了一个字符串\"1\" -->\n<comp some-prop=\"1\"></comp>\n```\n\n因为它是一个字面 prop ，它的值以字符串 `\"1\"` 而不是以实际的数字传下去。如果想传递一个实际的 JavaScript 数字，需要使用 `v-bind` ，从而让它的值被当作 JavaScript 表达式计算：\n\n``` html\n<!-- 传递实际的数字 -->\n<comp v-bind:some-prop=\"1\"></comp>\n```\n\n### 单向数据流\n\nprop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。\n\n另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你**不应该**在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。\n\n通常有两种改变 prop 的情况：\n\n1. prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；\n\n2. prop 作为需要被转变的原始值传入。\n\n更确切的说这两种情况是：\n\n1. 定义一个局部 data 属性，并将 prop 的初始值作为局部数据的初始值。\n\n  ``` js\n  props: ['initialCounter'],\n  data: function () {\n    return { counter: this.initialCounter }\n  }\n  ```\n\n2. 定义一个 computed 属性，此属性从 prop 的值计算得出。\n\n  ``` js\n  props: ['size'],\n  computed: {\n    normalizedSize: function () {\n      return this.size.trim().toLowerCase()\n    }\n  }\n  ```\n\n<p class=\"tip\">注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它**会影响**父组件的状态。</p>\n\n### Prop 验证\n\n组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告。当组件给其他人使用时这很有用。\n\nprop 是一个对象而不是字符串数组时，它包含验证要求：\n\n``` js\nVue.component('example', {\n  props: {\n    // 基础类型检测 （`null` 意思是任何类型都可以）\n    propA: Number,\n    // 多种类型\n    propB: [String, Number],\n    // 必传且是字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 数字，有默认值\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 数组／对象的默认值应当由一个工厂函数返回\n    propE: {\n      type: Object,\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        return value > 10\n      }\n    }\n  }\n})\n```\n\n`type` 可以是下面原生构造器：\n\n- String\n- Number\n- Boolean\n- Function\n- Object\n- Array\n\n`type` 也可以是一个自定义构造器，使用 `instanceof` 检测。\n\n当 prop 验证失败了， Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告。\n\n## 自定义事件\n\n我们知道，父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！\n\n### 使用 `v-on` 绑定自定义事件\n\n每个 Vue 实例都实现了[事件接口(Events interface)](../api/#Instance-Methods-Events)，即：\n\n- 使用 `$on(eventName)` 监听事件\n- 使用 `$emit(eventName)` 触发事件\n\n<p class=\"tip\">Vue的事件系统分离自浏览器的[EventTarget API](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget)。尽管它们的运行类似，但是`$on` 和 `$emit` __不是__`addEventListener` 和 `dispatchEvent` 的别名。</p>\n\n另外，父组件可以在使用子组件的地方直接用 `v-on` 来监听子组件触发的事件。\n\n下面是一个例子：\n\n``` html\n<div id=\"counter-event-example\">\n  <p>{{ total }}</p>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n```\n\n``` js\nVue.component('button-counter', {\n  template: '<button v-on:click=\"increment\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  },\n  methods: {\n    increment: function () {\n      this.counter += 1\n      this.$emit('increment')\n    }\n  },\n})\n\nnew Vue({\n  el: '#counter-event-example',\n  data: {\n    total: 0\n  },\n  methods: {\n    incrementTotal: function () {\n      this.total += 1\n    }\n  }\n})\n```\n\n{% raw %}\n<div id=\"counter-event-example\" class=\"demo\">\n  <p>{{ total }}</p>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n<script>\nVue.component('button-counter', {\n  template: '<button v-on:click=\"increment\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  },\n  methods: {\n    increment: function () {\n      this.counter += 1\n      this.$emit('increment')\n    }\n  },\n})\nnew Vue({\n  el: '#counter-event-example',\n  data: {\n    total: 0\n  },\n  methods: {\n    incrementTotal: function () {\n      this.total += 1\n    }\n  }\n})\n</script>\n{% endraw %}\n\n在本例中，子组件已经和它外部完全解耦了。它所做的只是触发一个父组件关心的内部事件。\n\n#### 给组件绑定原生事件\n\n有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 `.native` 修饰 `v-on` 。例如：\n\n``` html\n<my-component v-on:click.native=\"doTheThing\"></my-component>\n```\n\n### 使用自定义事件的表单输入组件\n\n自定义事件也可以用来创建自定义的表单输入组件，使用 `v-model` 来进行数据双向绑定。牢记：\n\n``` html\n<input v-model=\"something\">\n```\n\n仅仅是一个语法糖：\n\n``` html\n<input v-bind:value=\"something\" v-on:input=\"something = $event.target.value\">\n```\n\n所以在组件中使用时，它相当于下面的简写：\n\n``` html\n<custom-input v-bind:value=\"something\" v-on:input=\"something = arguments[0]\"></custom-input>\n```\n\n所以要让组件的 `v-model` 生效，它必须：\n\n- 接受一个 `value` 属性\n- 在有新的 value 时触发 `input` 事件\n\n一个非常简单的货币输入：\n\n``` html\n<currency-input v-model=\"price\"></currency-input>\n```\n\n``` js\nVue.component('currency-input', {\n  template: '\\\n    <span>\\\n      $\\\n      <input\\\n        ref=\"input\"\\\n        v-bind:value=\"value\"\\\n        v-on:input=\"updateValue($event.target.value)\"\\\n      >\\\n    </span>\\\n  ',\n  props: ['value'],\n  methods: {\n    // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制\n    updateValue: function (value) {\n      var formattedValue = value\n        // 删除两侧的空格符\n        .trim()\n        // 保留 2 小数位\n        .slice(0, value.indexOf('.') + 3)\n      // 如果值不统一，手动覆盖以保持一致\n      if (formattedValue !== value) {\n        this.$refs.input.value = formattedValue\n      }\n      // 通过 input 事件发出数值\n      this.$emit('input', Number(formattedValue))\n    }\n  }\n})\n```\n\n{% raw %}\n<div id=\"currency-input-example\" class=\"demo\">\n  <currency-input v-model=\"price\"></currency-input>\n</div>\n<script>\nVue.component('currency-input', {\n  template: '\\\n    <span>\\\n      $\\\n      <input\\\n        ref=\"input\"\\\n        v-bind:value=\"value\"\\\n        v-on:input=\"updateValue($event.target.value)\"\\\n      >\\\n    </span>\\\n  ',\n  props: ['value'],\n  methods: {\n    updateValue: function (value) {\n      var formattedValue = value\n        .trim()\n        .slice(0, value.indexOf('.') + 3)\n      if (formattedValue !== value) {\n        this.$refs.input.value = formattedValue\n      }\n      this.$emit('input', Number(formattedValue))\n    }\n  }\n})\nnew Vue({ el: '#currency-input-example' })\n</script>\n{% endraw %}\n\n上面的实现方式太过理想化了。 比如，用户甚至可以输入多个小数点或句号 - 哦哦！因此我们需要一个更有意义的例子，下面是一个更加完善的货币过滤器：\n\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/result,html,js\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n这个接口不仅仅可以用来连接组件内部的表单输入，也很容易集成你自己创造的输入类型。想象一下：\n\n``` html\n<voice-recognizer v-model=\"question\"></voice-recognizer>\n<webcam-gesture-reader v-model=\"gesture\"></webcam-gesture-reader>\n<webcam-retinal-scanner v-model=\"retinalImage\"></webcam-retinal-scanner>\n```\n\n### 非父子组件通信\n\n有时候非父子关系的组件也需要通信。在简单的场景下，使用一个空的 Vue 实例作为中央事件总线：\n\n``` js\nvar bus = new Vue()\n```\n``` js\n// 触发组件 A 中的事件\nbus.$emit('id-selected', 1)\n```\n``` js\n// 在组件 B 创建的钩子中监听事件\nbus.$on('id-selected', function (id) {\n  // ...\n})\n```\n\n在更多复杂的情况下，你应该考虑使用专门的 [状态管理模式](state-management.html).\n\n## 使用 Slot 分发内容\n\n在使用组件时，常常要像这样组合它们：\n\n``` html\n<app>\n  <app-header></app-header>\n  <app-footer></app-footer>\n</app>\n```\n\n注意两点：\n\n1. `<app>` 组件不知道它的挂载点会有什么内容。挂载点的内容是由`<app>`的父组件决定的。\n\n2. `<app>` 组件很可能有它自己的模版。\n\n为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 **内容分发** (或 \"transclusion\" 如果你熟悉 Angular)。Vue.js 实现了一个内容分发 API ，参照了当前 [Web 组件规范草案](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md)，使用特殊的 `<slot>` 元素作为原始内容的插槽。\n\n### 编译作用域\n\n在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为：\n\n``` html\n<child-component>\n  {{ message }}\n</child-component>\n```\n\n`message` 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：\n\n父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。\n\n一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：\n\n``` html\n<!-- 无效 -->\n<child-component v-show=\"someChildProperty\"></child-component>\n```\n\n假定 `someChildProperty` 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。\n\n如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做：\n\n``` js\nVue.component('child-component', {\n  // 有效，因为是在正确的作用域内\n  template: '<div v-show=\"someChildProperty\">Child</div>',\n  data: function () {\n    return {\n      someChildProperty: true\n    }\n  }\n})\n```\n\n类似地，分发内容是在父组件作用域内编译。\n\n### 单个 Slot\n\n除非子组件模板包含至少一个 `<slot>` 插口，否则父组件的内容将会被**丢弃**。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。\n\n最初在 `<slot>` 标签中的任何内容都被视为**备用内容**。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。\n\n假定 `my-component` 组件有下面模板：\n\n``` html\n<div>\n  <h2>我是子组件的标题</h2>\n  <slot>\n    只有在没有要分发的内容时才会显示。\n  </slot>\n</div>\n```\n\n父组件模版：\n\n``` html\n<div>\n  <h1>我是父组件的标题</h1>\n  <my-component>\n    <p>这是一些初始内容</p>\n    <p>这是更多的初始内容</p>\n  </my-component>\n</div>\n```\n\n渲染结果：\n\n``` html\n<div>\n  <h1>我是父组件的标题</h1>\n  <div>\n    <h2>我是子组件的标题</h2>\n    <p>这是一些初始内容</p>\n    <p>这是更多的初始内容</p>\n  </div>\n</div>\n```\n\n### 具名 Slot\n\n`<slot>` 元素可以用一个特殊的属性 `name` 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 `slot` 特性的元素。\n\n仍然可以有一个匿名 slot ，它是**默认 slot** ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。\n\n例如，假定我们有一个 `app-layout` 组件，它的模板为：\n\n``` html\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\n父组件模版：\n\n``` html\n<app-layout>\n  <h1 slot=\"header\">这里可能是一个页面标题</h1>\n\n  <p>主要内容的一个段落。</p>\n  <p>另一个主要段落。</p>\n\n  <p slot=\"footer\">这里有一些联系信息</p>\n</app-layout>\n```\n\n渲染结果为：\n\n``` html\n<div class=\"container\">\n  <header>\n    <h1>这里可能是一个页面标题</h1>\n  </header>\n  <main>\n    <p>主要内容的一个段落。</p>\n    <p>另一个主要段落。</p>\n  </main>\n  <footer>\n    <p>这里有一些联系信息</p>\n  </footer>\n</div>\n```\n\n在组合组件时，内容分发 API 是非常有用的机制。\n\n\n### 作用域插槽\n\n> 2.1.0 新增\n\n作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。\n\n在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：\n\n``` html\n<div class=\"child\">\n  <slot text=\"hello from child\"></slot>\n</div>\n```\n\n在父级中，具有特殊属性 `scope` 的 `<template>` 元素，表示它是作用域插槽的模板。`scope` 的值对应一个临时变量名，此变量接收从子组件中传递的 prop 对象：\n\n``` html\n<div class=\"parent\">\n  <child>\n    <template scope=\"props\">\n      <span>hello from parent</span>\n      <span>{{ props.text }}</span>\n    </template>\n  </child>\n</div>\n```\n\n如果我们渲染以上结果，得到的输出会是：\n\n``` html\n<div class=\"parent\">\n  <div class=\"child\">\n    <span>hello from parent</span>\n    <span>hello from child</span>\n  </div>\n</div>\n```\n\n作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：\n\n``` html\n<my-awesome-list :items=\"items\">\n  <!-- 作用域插槽也可以在这里命名 -->\n  <template slot=\"item\" scope=\"props\">\n    <li class=\"my-fancy-item\">{{ props.text }}</li>\n  </template>\n</my-awesome-list>\n```\n\n列表组件的模板：\n\n``` html\n<ul>\n  <slot name=\"item\"\n    v-for=\"item in items\"\n    :text=\"item.text\">\n    <!-- fallback content here -->\n  </slot>\n</ul>\n```\n\n## 动态组件\n\n多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 `<component>` 元素，动态地绑定到它的 `is` 特性：\n\n``` js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    currentView: 'home'\n  },\n  components: {\n    home: { /* ... */ },\n    posts: { /* ... */ },\n    archive: { /* ... */ }\n  }\n})\n```\n\n``` html\n<component v-bind:is=\"currentView\">\n  <!-- 组件在 vm.currentview 变化时改变！ -->\n</component>\n```\n\n也可以直接绑定到组件对象上：\n\n``` js\nvar Home = {\n  template: '<p>Welcome home!</p>'\n}\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    currentView: Home\n  }\n})\n```\n\n### `keep-alive`\n\n如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 `keep-alive` 指令参数：\n\n``` html\n<keep-alive>\n  <component :is=\"currentView\">\n    <!-- 非活动组件将被缓存！ -->\n  </component>\n</keep-alive>\n```\n\n在[API 参考](../api/#keep-alive)查看更多 `<keep-alive>` 的细节。\n\n## 杂项\n\n### 编写可复用组件\n\n在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。\n\nVue 组件的 API 来自三部分 - props, events 和 slots ：\n\n- **Props** 允许外部环境传递数据给组件\n\n- **Events** 允许组件触发外部环境的副作用\n\n- **Slots** 允许外部环境将额外的内容组合在组件中。\n\n使用 `v-bind` 和 `v-on` 的简写语法，模板的缩进清楚且简洁：\n\n``` html\n<my-component\n  :foo=\"baz\"\n  :bar=\"qux\"\n  @event-a=\"doThis\"\n  @event-b=\"doThat\"\n>\n  <img slot=\"icon\" src=\"...\">\n  <p slot=\"main-text\">Hello!</p>\n</my-component>\n```\n\n### 子组件索引\n\n尽管有 props 和 events ，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 `ref` 为子组件指定一个索引 ID 。例如：\n\n``` html\n<div id=\"parent\">\n  <user-profile ref=\"profile\"></user-profile>\n</div>\n```\n\n``` js\nvar parent = new Vue({ el: '#parent' })\n// 访问子组件\nvar child = parent.$refs.profile\n```\n\n当 `ref` 和 `v-for` 一起使用时， ref 是一个数组或对象，包含相应的子组件。\n\n<p class=\"tip\">`$refs` 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 `$refs` 。</p>\n\n### 异步组件\n\n在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单， Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：\n\n``` js\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    // Pass the component definition to the resolve callback\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```\n\n工厂函数接收一个 `resolve` 回调，在收到从服务器下载的组件定义时调用。也可以调用 `reject(reason)` 指示加载失败。这里 `setTimeout` 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：[Webpack 的代码分割功能](http://webpack.github.io/docs/code-splitting.html)：\n\n``` js\nVue.component('async-webpack-example', function (resolve) {\n  // 这个特殊的 require 语法告诉 webpack\n  // 自动将编译后的代码分割成不同的块，\n  // 这些块将通过 Ajax 请求自动下载。\n  require(['./my-async-component'], resolve)\n})\n```\n\n你可以使用 Webpack 2 + ES2015 的语法返回一个 `Promise` resolve 函数：\n\n``` js\nVue.component(\n  'async-webpack-example',\n  () => System.import('./my-async-component')\n)\n```\n\n<p class=\"tip\">如果你是 <strong>Browserify</strong> 用户,可能就无法使用异步组件了,它的作者已经[表明](https://github.com/substack/node-browserify/issues/58#issuecomment-21978224) Browserify 是不支持异步加载的。Browserify 社区发现 [一些解决方法](https://github.com/vuejs/vuejs.org/issues/620)，可能有助于已存在的复杂应用。对于其他场景，我们推荐简单实用 Webpack 构建，一流的异步支持</p>\n\n### 组件命名约定\n\n当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 。Vue 不关心这个。\n\n``` js\n// 在组件定义中\ncomponents: {\n  // 使用 kebab-case 形式注册\n  'kebab-cased-component': { /* ... */ },\n  // register using camelCase\n  'camelCasedComponent': { /* ... */ },\n  // register using TitleCase\n  'TitleCasedComponent': { /* ... */ }\n}\n```\n\n在 HTML 模版中，请使用 kebab-case 形式：\n\n``` html\n<!-- 在HTML模版中始终使用 kebab-case -->\n<kebab-cased-component></kebab-cased-component>\n<camel-cased-component></camel-cased-component>\n<title-cased-component></title-cased-component>\n```\n\n当使用字符串模式时，可以不受 HTML 的 case-insensitive 限制。这意味实际上在模版中，你可以使用 camelCase 、 TitleCase 或者 kebab-case 来引用：\n\n``` html\n<!-- 在字符串模版中可以用任何你喜欢的方式! -->\n<my-component></my-component>\n<myComponent></myComponent>\n<MyComponent></MyComponent>\n```\n\n如果组件未经 `slot` 元素传递内容，你甚至可以在组件名后使用 `/` 使其自闭合：\n\n``` html\n<my-component/>\n```\n\n当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。\n\n### 递归组件\n\n组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以：\n\n``` js\nname: 'unique-name-of-my-component'\n```\n\n当你利用`Vue.component`全局注册了一个组件, 全局的ID作为组件的 `name` 选项，被自动设置.\n\n``` js\nVue.component('unique-name-of-my-component', {\n  // ...\n})\n```\n\n如果你不谨慎, 递归组件可能导致死循环:\n\n``` js\nname: 'stack-overflow',\ntemplate: '<div><stack-overflow></stack-overflow></div>'\n```\n\n上面组件会导致一个错误 “max stack size exceeded” ，所以要确保递归调用有终止条件 (比如递归调用时使用 `v-if` 并让他最终返回 `false` )。\n\n\n### Circular References Between Components\n\nLet's say you're building a file directory tree, like in Finder or File Explorer. You might have a `tree-folder` component with this template:\n\n``` html\n<p>\n  <span>{{ folder.name }}</span>\n  <tree-folder-contents :children=\"folder.children\"/>\n</p>\n```\n\nThen a `tree-folder-contents` component with this template:\n\n``` html\n<ul>\n  <li v-for=\"child in children\">\n    <tree-folder v-if=\"child.children\" :folder=\"child\"/>\n    <span v-else>{{ child.name }}</span>\n  </li>\n</ul>\n```\n\nWhen you look closely, you'll see that these components will actually be each other's descendent _and_ ancestor in the render tree - a paradox! When registering components globally with `Vue.component`, this paradox is resolved for you automatically. If that's you, you can stop reading here.\n\nHowever, if you're requiring/importing components using a __module system__, e.g. via Webpack or Browserify, you'll get an error:\n\n```\nFailed to mount component: template or render function not defined.\n```\n\nTo explain what's happening, I'll call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc, etc. It's stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, \"A needs B _eventually_, but there's no need to resolve B first.\"\n\nIn our case, I'll make that point the `tree-folder` component. We know the child that creates the paradox is the `tree-folder-contents` component, so we'll wait until the `beforeCreate` lifecycle hook to register it:\n\n``` js\nbeforeCreate: function () {\n  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')\n}\n```\n\nProblem solved!\n\n### 内联模版\n\n如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。\n\n``` html\n<my-component inline-template>\n  <div>\n    <p>These are compiled as the component's own template.</p>\n    <p>Not parent's transclusion content.</p>\n  </div>\n</my-component>\n```\n\n但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 `.vue` 文件中使用 `template` 元素。\n\n### X-Templates\n\n另一种定义模版的方式是在 JavaScript 标签里使用 `text/x-template` 类型，并且指定一个id。例如：\n\n``` html\n<script type=\"text/x-template\" id=\"hello-world-template\">\n  <p>Hello hello hello</p>\n</script>\n```\n\n``` js\nVue.component('hello-world', {\n  template: '#hello-world-template'\n})\n```\n\n这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。\n\n### 使用 `v-once` 的低级静态组件(Cheap Static Component)\n\n尽管在 Vue 中渲染 HTML 很快，不过当组件中包含**大量**静态内容时，可以考虑使用 `v-once` 将渲染结果缓存起来，就像这样：\n\n``` js\nVue.component('terms-of-service', {\n  template: '\\\n    <div v-once>\\\n      <h1>Terms of Service</h1>\\\n      ... a lot of static content ...\\\n    </div>\\\n  '\n})\n```\n\n***\n\n> 原文：http://vuejs.org/guide/components.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/components.html","comments":1,"layout":"page","_id":"ciwnajuye0016jl2daeal7pdy","content":"<h2 id=\"什么是组件？\"><a href=\"#什么是组件？\" class=\"headerlink\" title=\"什么是组件？\"></a>什么是组件？</h2><p>组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。</p>\n<h2 id=\"使用组件\"><a href=\"#使用组件\" class=\"headerlink\" title=\"使用组件\"></a>使用组件</h2><h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><p>之前说过，我们可以通过以下方式创建一个 Vue 实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#some-element'</span>,</div><div class=\"line\">  <span class=\"comment\">// 选项</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>要注册一个全局组件，你可以使用 <code>Vue.component(tagName, options)</code>。 例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// 选项</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">对于自定义标签名，Vue.js 不强制要求遵循 <a href=\"https://www.w3.org/TR/custom-elements/#concepts\" target=\"_blank\" rel=\"external\">W3C规则</a> （小写，并且包含一个短杠），尽管遵循这个规则比较好。</p>\n\n<p>组件在注册之后，便可以在父实例的模块中以自定义元素 <code>&lt;my-component&gt;&lt;/my-component&gt;</code> 的形式使用。要确保在初始化根实例 <strong>之前</strong> 注册了组件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册</span></div><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建根实例</span></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>渲染为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>A custom component!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example\" class=\"demo\">\n  <my-component></my-component>\n</div>\n<script>\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\nnew Vue({ el: '#example' })\n</script>\n\n<h3 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h3><p>不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Child = &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  components: &#123;</div><div class=\"line\">    <span class=\"comment\">// &lt;my-component&gt; 将只在父模板可用</span></div><div class=\"line\">    <span class=\"string\">'my-component'</span>: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这种封装也适用于其它可注册的 Vue 功能，如指令。</p>\n<h3 id=\"DOM-模版解析说明\"><a href=\"#DOM-模版解析说明\" class=\"headerlink\" title=\"DOM 模版解析说明\"></a>DOM 模版解析说明</h3><p>当使用 DOM 作为模版时（例如，将 <code>el</code> 选项挂载到一个已存在的元素上）, 你会受到 HTML 的一些限制，因为 Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。尤其像这些元素 <code>&lt;ul&gt;</code> ， <code>&lt;ol&gt;</code>， <code>&lt;table&gt;</code> ， <code>&lt;select&gt;</code> 限制了能被它包裹的元素， <code>&lt;option&gt;</code> 只能出现在其它元素内部。</p>\n<p>在自定义组件中使用这些受限制的元素时会导致一些问题，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-row</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">my-row</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>自定义组件 <code>&lt;my-row&gt;</code> 被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 <code>is</code> 属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tr</span> <span class=\"attr\">is</span>=<span class=\"string\">\"my-row\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：</strong></p>\n<ul>\n<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>\n<li>JavaScript内联模版字符串</li>\n<li><code>.vue</code> 组件</li>\n</ul>\n<p>因此，有必要的话请使用字符串模版。</p>\n<h3 id=\"data-必须是函数\"><a href=\"#data-必须是函数\" class=\"headerlink\" title=\"data 必须是函数\"></a><code>data</code> 必须是函数</h3><p>使用组件时，大多数选项可以被传入到 Vue 构造器中，有一个例外： <code>data</code> 必须是函数。 实际上，如果你这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'hello'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>那么 Vue 会在控制台发出警告，告诉你在组件中 <code>data</code> 必须是一个函数。最好理解这种规则的存在意义。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">simple-counter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">simple-counter</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">simple-counter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">simple-counter</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">simple-counter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">simple-counter</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">counter</span>: <span class=\"number\">0</span> &#125;</div><div class=\"line\"></div><div class=\"line\">Vue.component(<span class=\"string\">'simple-counter'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class=\"line\">  <span class=\"comment\">// data 是一个函数，因此 Vue 不会警告，</span></div><div class=\"line\">  <span class=\"comment\">// 但是我们为每一个组件返回了同一个对象引用</span></div><div class=\"line\">  data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> data</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-2'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"example-2\" class=\"demo\">\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n</div>\n<script>\nvar data = { counter: 0 }\nVue.component('simple-counter', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return data\n  }\n})\nnew Vue({\n  el: '#example-2'\n})\n</script>\n\n<p>由于这三个组件共享了同一个 <code>data</code> ， 因此增加一个 counter 会影响所有组件！我们可以通过为每个组件返回新的 data 对象来解决这个问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">counter</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在每个 counter 都有它自己内部的状态了：</p>\n\n<div id=\"example-2-5\" class=\"demo\">\n  <my-component></my-component>\n  <my-component></my-component>\n  <my-component></my-component>\n</div>\n<script>\nVue.component('my-component', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  }\n})\nnew Vue({\n  el: '#example-2-5'\n})\n</script>\n\n<h3 id=\"构成组件\"><a href=\"#构成组件\" class=\"headerlink\" title=\"构成组件\"></a>构成组件</h3><p>组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。</p>\n<p>在 Vue.js 中，父子组件的关系可以总结为 <strong>props down, events up</strong> 。父组件通过 <strong>props</strong> 向下传递数据给子组件，子组件通过 <strong>events</strong> 给父组件发送消息。看看它们是怎么工作的。</p>\n<p style=\"text-align: center\"><br>  <img style=\"width:300px\" src=\"/images/props-events.png\" alt=\"props down, events up\"><br></p>\n\n<h2 id=\"Prop\"><a href=\"#Prop\" class=\"headerlink\" title=\"Prop\"></a>Prop</h2><h3 id=\"使用-Prop-传递数据\"><a href=\"#使用-Prop-传递数据\" class=\"headerlink\" title=\"使用 Prop 传递数据\"></a>使用 Prop 传递数据</h3><p>组件实例的作用域是<strong>孤立的</strong>。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。</p>\n<p>prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 <a href=\"../api/#props\"><code>props</code> 选项</a>声明 “prop”：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'child'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// 声明 props</span></div><div class=\"line\">  props: [<span class=\"string\">'message'</span>],</div><div class=\"line\">  <span class=\"comment\">// 就像 data 一样，prop 可以用在模板内</span></div><div class=\"line\">  <span class=\"comment\">// 同样也可以在 vm 实例中像 “this.message” 这样使用</span></div><div class=\"line\">  template: <span class=\"string\">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>然后向它传入一个普通字符串：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">message</span>=<span class=\"string\">\"hello!\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"prop-example-1\" class=\"demo\">\n  <child message=\"hello!\"></child>\n</div>\n<script>\nnew Vue({\n  el: '#prop-example-1',\n  components: {\n    child: {\n      props: ['message'],\n      template: '<span>{{ message }}</span>'\n    }\n  }\n})\n</script>\n\n<h3 id=\"camelCase-vs-kebab-case\"><a href=\"#camelCase-vs-kebab-case\" class=\"headerlink\" title=\"camelCase vs. kebab-case\"></a>camelCase vs. kebab-case</h3><p>HTML 特性不区分大小写。当使用非字符串模版时，prop的名字形式会从 camelCase 转为 kebab-case（短横线隔开）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'child'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// camelCase in JavaScript</span></div><div class=\"line\">  props: [<span class=\"string\">'myMessage'</span>],</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- kebab-case in HTML --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">my-message</span>=<span class=\"string\">\"hello!\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>再次说明，如果你使用字符串模版，不用在意这些限制。</p>\n<h3 id=\"动态-Prop\"><a href=\"#动态-Prop\" class=\"headerlink\" title=\"动态 Prop\"></a>动态 Prop</h3><p>类似于用 <code>v-bind</code> 绑定 HTML 特性到一个表达式，也可以用 <code>v-bind</code> 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"parentMsg\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">v-bind:my-message</span>=<span class=\"string\">\"parentMsg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>使用 <code>v-bind</code> 的缩写语法通常更简单：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">:my-message</span>=<span class=\"string\">\"parentMsg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"demo-2\" class=\"demo\">\n  <input v-model=\"parentMsg\">\n  <br>\n  <child v-bind:my-message=\"parentMsg\"></child>\n</div>\n<script>\nnew Vue({\n  el: '#demo-2',\n  data: {\n    parentMsg: 'Message from parent'\n  },\n  components: {\n    child: {\n      props: ['myMessage'],\n      template: '<span>{{myMessage}}</span>'\n    }\n  }\n})\n</script>\n\n<h3 id=\"字面量语法-vs-动态语法\"><a href=\"#字面量语法-vs-动态语法\" class=\"headerlink\" title=\"字面量语法 vs 动态语法\"></a>字面量语法 vs 动态语法</h3><p>初学者常犯的一个错误是使用字面量语法传递数值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 传递了一个字符串\"1\" --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">some-prop</span>=<span class=\"string\">\"1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>因为它是一个字面 prop ，它的值以字符串 <code>&quot;1&quot;</code> 而不是以实际的数字传下去。如果想传递一个实际的 JavaScript 数字，需要使用 <code>v-bind</code> ，从而让它的值被当作 JavaScript 表达式计算：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 传递实际的数字 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">v-bind:some-prop</span>=<span class=\"string\">\"1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h3><p>prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。</p>\n<p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你<strong>不应该</strong>在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。</p>\n<p>通常有两种改变 prop 的情况：</p>\n<ol>\n<li><p>prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；</p>\n</li>\n<li><p>prop 作为需要被转变的原始值传入。</p>\n</li>\n</ol>\n<p>更确切的说这两种情况是：</p>\n<ol>\n<li><p>定义一个局部 data 属性，并将 prop 的初始值作为局部数据的初始值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">props: [<span class=\"string\">'initialCounter'</span>],</div><div class=\"line\"><span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">counter</span>: <span class=\"keyword\">this</span>.initialCounter &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>定义一个 computed 属性，此属性从 prop 的值计算得出。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">props: [<span class=\"string\">'size'</span>],</div><div class=\"line\"><span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">normalizedSize</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size.trim().toLowerCase()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p class=\"tip\">注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它<strong>会影响</strong>父组件的状态。</p>\n\n<h3 id=\"Prop-验证\"><a href=\"#Prop-验证\" class=\"headerlink\" title=\"Prop 验证\"></a>Prop 验证</h3><p>组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告。当组件给其他人使用时这很有用。</p>\n<p>prop 是一个对象而不是字符串数组时，它包含验证要求：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'example'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 基础类型检测 （`null` 意思是任何类型都可以）</span></div><div class=\"line\">    propA: <span class=\"built_in\">Number</span>,</div><div class=\"line\">    <span class=\"comment\">// 多种类型</span></div><div class=\"line\">    propB: [<span class=\"built_in\">String</span>, <span class=\"built_in\">Number</span>],</div><div class=\"line\">    <span class=\"comment\">// 必传且是字符串</span></div><div class=\"line\">    propC: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">String</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 数字，有默认值</span></div><div class=\"line\">    propD: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">default</span>: <span class=\"number\">100</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 数组／对象的默认值应当由一个工厂函数返回</span></div><div class=\"line\">    propE: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Object</span>,</div><div class=\"line\">      <span class=\"attr\">default</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"attr\">message</span>: <span class=\"string\">'hello'</span> &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 自定义验证函数</span></div><div class=\"line\">    propF: &#123;</div><div class=\"line\">      <span class=\"attr\">validator</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value &gt; <span class=\"number\">10</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><code>type</code> 可以是下面原生构造器：</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Function</li>\n<li>Object</li>\n<li>Array</li>\n</ul>\n<p><code>type</code> 也可以是一个自定义构造器，使用 <code>instanceof</code> 检测。</p>\n<p>当 prop 验证失败了， Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告。</p>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><p>我们知道，父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！</p>\n<h3 id=\"使用-v-on-绑定自定义事件\"><a href=\"#使用-v-on-绑定自定义事件\" class=\"headerlink\" title=\"使用 v-on 绑定自定义事件\"></a>使用 <code>v-on</code> 绑定自定义事件</h3><p>每个 Vue 实例都实现了<a href=\"../api/#Instance-Methods-Events\">事件接口(Events interface)</a>，即：</p>\n<ul>\n<li>使用 <code>$on(eventName)</code> 监听事件</li>\n<li>使用 <code>$emit(eventName)</code> 触发事件</li>\n</ul>\n<p class=\"tip\">Vue的事件系统分离自浏览器的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\" target=\"_blank\" rel=\"external\">EventTarget API</a>。尽管它们的运行类似，但是<code>$on</code> 和 <code>$emit</code> <strong>不是</strong><code>addEventListener</code> 和 <code>dispatchEvent</code> 的别名。</p>\n\n<p>另外，父组件可以在使用子组件的地方直接用 <code>v-on</code> 来监听子组件触发的事件。</p>\n<p>下面是一个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"counter-event-example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; total &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button-counter</span> <span class=\"attr\">v-on:increment</span>=<span class=\"string\">\"incrementTotal\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button-counter</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button-counter</span> <span class=\"attr\">v-on:increment</span>=<span class=\"string\">\"incrementTotal\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button-counter</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'button-counter'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;button v-on:click=\"increment\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">counter</span>: <span class=\"number\">0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">increment</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.counter += <span class=\"number\">1</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'increment'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#counter-event-example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">total</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">incrementTotal</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.total += <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"counter-event-example\" class=\"demo\">\n  <p>{{ total }}</p>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n<script>\nVue.component('button-counter', {\n  template: '<button v-on:click=\"increment\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  },\n  methods: {\n    increment: function () {\n      this.counter += 1\n      this.$emit('increment')\n    }\n  },\n})\nnew Vue({\n  el: '#counter-event-example',\n  data: {\n    total: 0\n  },\n  methods: {\n    incrementTotal: function () {\n      this.total += 1\n    }\n  }\n})\n</script>\n\n<p>在本例中，子组件已经和它外部完全解耦了。它所做的只是触发一个父组件关心的内部事件。</p>\n<h4 id=\"给组件绑定原生事件\"><a href=\"#给组件绑定原生事件\" class=\"headerlink\" title=\"给组件绑定原生事件\"></a>给组件绑定原生事件</h4><p>有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 <code>.native</code> 修饰 <code>v-on</code> 。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-on:click.native</span>=<span class=\"string\">\"doTheThing\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"使用自定义事件的表单输入组件\"><a href=\"#使用自定义事件的表单输入组件\" class=\"headerlink\" title=\"使用自定义事件的表单输入组件\"></a>使用自定义事件的表单输入组件</h3><p>自定义事件也可以用来创建自定义的表单输入组件，使用 <code>v-model</code> 来进行数据双向绑定。牢记：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"something\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>仅仅是一个语法糖：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"something\"</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"something = $event.target.value\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>所以在组件中使用时，它相当于下面的简写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">custom-input</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"something\"</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"something = arguments[0]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">custom-input</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>所以要让组件的 <code>v-model</code> 生效，它必须：</p>\n<ul>\n<li>接受一个 <code>value</code> 属性</li>\n<li>在有新的 value 时触发 <code>input</code> 事件</li>\n</ul>\n<p>一个非常简单的货币输入：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">currency-input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"price\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">currency-input</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'currency-input'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'\\</span></div><div class=\"line\">    &lt;span&gt;\\</div><div class=\"line\">      $\\</div><div class=\"line\">      &lt;input\\</div><div class=\"line\">        ref=\"input\"\\</div><div class=\"line\">        v-bind:value=\"value\"\\</div><div class=\"line\">        v-on:input=\"updateValue($event.target.value)\"\\</div><div class=\"line\">      &gt;\\</div><div class=\"line\">    &lt;/span&gt;\\</div><div class=\"line\">  ',</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'value'</span>],</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制</span></div><div class=\"line\">    updateValue: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> formattedValue = value</div><div class=\"line\">        <span class=\"comment\">// 删除两侧的空格符</span></div><div class=\"line\">        .trim()</div><div class=\"line\">        <span class=\"comment\">// 保留 2 小数位</span></div><div class=\"line\">        .slice(<span class=\"number\">0</span>, value.indexOf(<span class=\"string\">'.'</span>) + <span class=\"number\">3</span>)</div><div class=\"line\">      <span class=\"comment\">// 如果值不统一，手动覆盖以保持一致</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (formattedValue !== value) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.$refs.input.value = formattedValue</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 通过 input 事件发出数值</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'input'</span>, <span class=\"built_in\">Number</span>(formattedValue))</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"currency-input-example\" class=\"demo\">\n  <currency-input v-model=\"price\"></currency-input>\n</div>\n<script>\nVue.component('currency-input', {\n  template: '\\\n    <span>\\\n      $\\\n      <input\\\n        ref=\"input\"\\\n        v-bind:value=\"value\"\\\n        v-on:input=\"updateValue($event.target.value)\"\\\n      >\\\n    </span>\\\n  ',\n  props: ['value'],\n  methods: {\n    updateValue: function (value) {\n      var formattedValue = value\n        .trim()\n        .slice(0, value.indexOf('.') + 3)\n      if (formattedValue !== value) {\n        this.$refs.input.value = formattedValue\n      }\n      this.$emit('input', Number(formattedValue))\n    }\n  }\n})\nnew Vue({ el: '#currency-input-example' })\n</script>\n\n<p>上面的实现方式太过理想化了。 比如，用户甚至可以输入多个小数点或句号 - 哦哦！因此我们需要一个更有意义的例子，下面是一个更加完善的货币过滤器：</p>\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/result,html,js\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>这个接口不仅仅可以用来连接组件内部的表单输入，也很容易集成你自己创造的输入类型。想象一下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">voice-recognizer</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"question\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">voice-recognizer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">webcam-gesture-reader</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"gesture\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">webcam-gesture-reader</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">webcam-retinal-scanner</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"retinalImage\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">webcam-retinal-scanner</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"非父子组件通信\"><a href=\"#非父子组件通信\" class=\"headerlink\" title=\"非父子组件通信\"></a>非父子组件通信</h3><p>有时候非父子关系的组件也需要通信。在简单的场景下，使用一个空的 Vue 实例作为中央事件总线：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bus = <span class=\"keyword\">new</span> Vue()</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 触发组件 A 中的事件</span></div><div class=\"line\">bus.$emit(<span class=\"string\">'id-selected'</span>, <span class=\"number\">1</span>)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在组件 B 创建的钩子中监听事件</span></div><div class=\"line\">bus.$on(<span class=\"string\">'id-selected'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在更多复杂的情况下，你应该考虑使用专门的 <a href=\"state-management.html\">状态管理模式</a>.</p>\n<h2 id=\"使用-Slot-分发内容\"><a href=\"#使用-Slot-分发内容\" class=\"headerlink\" title=\"使用 Slot 分发内容\"></a>使用 Slot 分发内容</h2><p>在使用组件时，常常要像这样组合它们：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">app-header</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-header</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">app-footer</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-footer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>注意两点：</p>\n<ol>\n<li><p><code>&lt;app&gt;</code> 组件不知道它的挂载点会有什么内容。挂载点的内容是由<code>&lt;app&gt;</code>的父组件决定的。</p>\n</li>\n<li><p><code>&lt;app&gt;</code> 组件很可能有它自己的模版。</p>\n</li>\n</ol>\n<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 <strong>内容分发</strong> (或 “transclusion” 如果你熟悉 Angular)。Vue.js 实现了一个内容分发 API ，参照了当前 <a href=\"https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md\" target=\"_blank\" rel=\"external\">Web 组件规范草案</a>，使用特殊的 <code>&lt;slot&gt;</code> 元素作为原始内容的插槽。</p>\n<h3 id=\"编译作用域\"><a href=\"#编译作用域\" class=\"headerlink\" title=\"编译作用域\"></a>编译作用域</h3><p>在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child-component</span>&gt;</span></div><div class=\"line\">  &#123;&#123; message &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">child-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>message</code> 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：</p>\n<p>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。</p>\n<p>一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 无效 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child-component</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"someChildProperty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>假定 <code>someChildProperty</code> 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。</p>\n<p>如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'child-component'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// 有效，因为是在正确的作用域内</span></div><div class=\"line\">  template: <span class=\"string\">'&lt;div v-show=\"someChildProperty\"&gt;Child&lt;/div&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">someChildProperty</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>类似地，分发内容是在父组件作用域内编译。</p>\n<h3 id=\"单个-Slot\"><a href=\"#单个-Slot\" class=\"headerlink\" title=\"单个 Slot\"></a>单个 Slot</h3><p>除非子组件模板包含至少一个 <code>&lt;slot&gt;</code> 插口，否则父组件的内容将会被<strong>丢弃</strong>。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。</p>\n<p>最初在 <code>&lt;slot&gt;</code> 标签中的任何内容都被视为<strong>备用内容</strong>。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。</p>\n<p>假定 <code>my-component</code> 组件有下面模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是子组件的标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    只有在没有要分发的内容时才会显示。</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>父组件模版：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是父组件的标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是一些初始内容<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是更多的初始内容<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>渲染结果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是父组件的标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是子组件的标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是一些初始内容<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是更多的初始内容<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"具名-Slot\"><a href=\"#具名-Slot\" class=\"headerlink\" title=\"具名 Slot\"></a>具名 Slot</h3><p><code>&lt;slot&gt;</code> 元素可以用一个特殊的属性 <code>name</code> 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 <code>slot</code> 特性的元素。</p>\n<p>仍然可以有一个匿名 slot ，它是<strong>默认 slot</strong> ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。</p>\n<p>例如，假定我们有一个 <code>app-layout</code> 组件，它的模板为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"header\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"footer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>父组件模版：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-layout</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"header\"</span>&gt;</span>这里可能是一个页面标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>主要内容的一个段落。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>另一个主要段落。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"footer\"</span>&gt;</span>这里有一些联系信息<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-layout</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>渲染结果为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>这里可能是一个页面标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>主要内容的一个段落。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>另一个主要段落。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这里有一些联系信息<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在组合组件时，内容分发 API 是非常有用的机制。</p>\n<h3 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h3><blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<p>作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。</p>\n<p>在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">text</span>=<span class=\"string\">\"hello from child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在父级中，具有特殊属性 <code>scope</code> 的 <code>&lt;template&gt;</code> 元素，表示它是作用域插槽的模板。<code>scope</code> 的值对应一个临时变量名，此变量接收从子组件中传递的 prop 对象：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"props\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>hello from parent<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果我们渲染以上结果，得到的输出会是：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>hello from parent<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>hello from child<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-awesome-list</span> <span class=\"attr\">:items</span>=<span class=\"string\">\"items\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 作用域插槽也可以在这里命名 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"item\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"props\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"my-fancy-item\"</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-awesome-list</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>列表组件的模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"item\"</span></span></div><div class=\"line\">    <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span></div><div class=\"line\">    <span class=\"attr\">:text</span>=<span class=\"string\">\"item.text\"</span>&gt;</div><div class=\"line\">    <span class=\"comment\">&lt;!-- fallback content here --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"动态组件\"><a href=\"#动态组件\" class=\"headerlink\" title=\"动态组件\"></a>动态组件</h2><p>多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <code>&lt;component&gt;</code> 元素，动态地绑定到它的 <code>is</code> 特性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">currentView</span>: <span class=\"string\">'home'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">components</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">home</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">    <span class=\"attr\">posts</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">    <span class=\"attr\">archive</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"currentView\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>也可以直接绑定到组件对象上：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Home = &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;Welcome home!&lt;/p&gt;'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">currentView</span>: Home</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a><code>keep-alive</code></h3><p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 <code>keep-alive</code> 指令参数：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"currentView\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 非活动组件将被缓存！ --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在<a href=\"../api/#keep-alive\">API 参考</a>查看更多 <code>&lt;keep-alive&gt;</code> 的细节。</p>\n<h2 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h2><h3 id=\"编写可复用组件\"><a href=\"#编写可复用组件\" class=\"headerlink\" title=\"编写可复用组件\"></a>编写可复用组件</h3><p>在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。</p>\n<p>Vue 组件的 API 来自三部分 - props, events 和 slots ：</p>\n<ul>\n<li><p><strong>Props</strong> 允许外部环境传递数据给组件</p>\n</li>\n<li><p><strong>Events</strong> 允许组件触发外部环境的副作用</p>\n</li>\n<li><p><strong>Slots</strong> 允许外部环境将额外的内容组合在组件中。</p>\n</li>\n</ul>\n<p>使用 <code>v-bind</code> 和 <code>v-on</code> 的简写语法，模板的缩进清楚且简洁：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span></span></div><div class=\"line\">  <span class=\"attr\">:foo</span>=<span class=\"string\">\"baz\"</span></div><div class=\"line\">  <span class=\"attr\">:bar</span>=<span class=\"string\">\"qux\"</span></div><div class=\"line\">  @<span class=\"attr\">event-a</span>=<span class=\"string\">\"doThis\"</span></div><div class=\"line\">  @<span class=\"attr\">event-b</span>=<span class=\"string\">\"doThat\"</span></div><div class=\"line\">&gt;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"icon\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"...\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"main-text\"</span>&gt;</span>Hello!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"子组件索引\"><a href=\"#子组件索引\" class=\"headerlink\" title=\"子组件索引\"></a>子组件索引</h3><p>尽管有 props 和 events ，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 <code>ref</code> 为子组件指定一个索引 ID 。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">user-profile</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"profile\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">user-profile</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Vue(&#123; <span class=\"attr\">el</span>: <span class=\"string\">'#parent'</span> &#125;)</div><div class=\"line\"><span class=\"comment\">// 访问子组件</span></div><div class=\"line\"><span class=\"keyword\">var</span> child = parent.$refs.profile</div></pre></td></tr></table></figure>\n<p>当 <code>ref</code> 和 <code>v-for</code> 一起使用时， ref 是一个数组或对象，包含相应的子组件。</p>\n<p class=\"tip\"><code>$refs</code> 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 <code>$refs</code> 。</p>\n\n<h3 id=\"异步组件\"><a href=\"#异步组件\" class=\"headerlink\" title=\"异步组件\"></a>异步组件</h3><p>在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单， Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'async-example'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Pass the component definition to the resolve callback</span></div><div class=\"line\">    resolve(&#123;</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;I am async!&lt;/div&gt;'</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>工厂函数接收一个 <code>resolve</code> 回调，在收到从服务器下载的组件定义时调用。也可以调用 <code>reject(reason)</code> 指示加载失败。这里 <code>setTimeout</code> 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：<a href=\"http://webpack.github.io/docs/code-splitting.html\" target=\"_blank\" rel=\"external\">Webpack 的代码分割功能</a>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'async-webpack-example'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 这个特殊的 require 语法告诉 webpack</span></div><div class=\"line\">  <span class=\"comment\">// 自动将编译后的代码分割成不同的块，</span></div><div class=\"line\">  <span class=\"comment\">// 这些块将通过 Ajax 请求自动下载。</span></div><div class=\"line\">  <span class=\"built_in\">require</span>([<span class=\"string\">'./my-async-component'</span>], resolve)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>你可以使用 Webpack 2 + ES2015 的语法返回一个 <code>Promise</code> resolve 函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(</div><div class=\"line\">  <span class=\"string\">'async-webpack-example'</span>,</div><div class=\"line\">  () =&gt; System.import(<span class=\"string\">'./my-async-component'</span>)</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p class=\"tip\">如果你是 <strong>Browserify</strong> 用户,可能就无法使用异步组件了,它的作者已经<a href=\"https://github.com/substack/node-browserify/issues/58#issuecomment-21978224\" target=\"_blank\" rel=\"external\">表明</a> Browserify 是不支持异步加载的。Browserify 社区发现 <a href=\"https://github.com/vuejs/vuejs.org/issues/620\" target=\"_blank\" rel=\"external\">一些解决方法</a>，可能有助于已存在的复杂应用。对于其他场景，我们推荐简单实用 Webpack 构建，一流的异步支持</p>\n\n<h3 id=\"组件命名约定\"><a href=\"#组件命名约定\" class=\"headerlink\" title=\"组件命名约定\"></a>组件命名约定</h3><p>当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 。Vue 不关心这个。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在组件定义中</span></div><div class=\"line\">components: &#123;</div><div class=\"line\">  <span class=\"comment\">// 使用 kebab-case 形式注册</span></div><div class=\"line\">  <span class=\"string\">'kebab-cased-component'</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">  <span class=\"comment\">// register using camelCase</span></div><div class=\"line\">  <span class=\"string\">'camelCasedComponent'</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">  <span class=\"comment\">// register using TitleCase</span></div><div class=\"line\">  <span class=\"string\">'TitleCasedComponent'</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 HTML 模版中，请使用 kebab-case 形式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 在HTML模版中始终使用 kebab-case --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">kebab-cased-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">kebab-cased-component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">camel-cased-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">camel-cased-component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title-cased-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title-cased-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当使用字符串模式时，可以不受 HTML 的 case-insensitive 限制。这意味实际上在模版中，你可以使用 camelCase 、 TitleCase 或者 kebab-case 来引用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 在字符串模版中可以用任何你喜欢的方式! --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">myComponent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">myComponent</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">MyComponent</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果组件未经 <code>slot</code> 元素传递内容，你甚至可以在组件名后使用 <code>/</code> 使其自闭合：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。</p>\n<h3 id=\"递归组件\"><a href=\"#递归组件\" class=\"headerlink\" title=\"递归组件\"></a>递归组件</h3><p>组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">'unique-name-of-my-component'</span></div></pre></td></tr></table></figure>\n<p>当你利用<code>Vue.component</code>全局注册了一个组件, 全局的ID作为组件的 <code>name</code> 选项，被自动设置.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'unique-name-of-my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>如果你不谨慎, 递归组件可能导致死循环:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">'stack-overflow'</span>,</div><div class=\"line\"><span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></div></pre></td></tr></table></figure>\n<p>上面组件会导致一个错误 “max stack size exceeded” ，所以要确保递归调用有终止条件 (比如递归调用时使用 <code>v-if</code> 并让他最终返回 <code>false</code> )。</p>\n<h3 id=\"Circular-References-Between-Components\"><a href=\"#Circular-References-Between-Components\" class=\"headerlink\" title=\"Circular References Between Components\"></a>Circular References Between Components</h3><p>Let’s say you’re building a file directory tree, like in Finder or File Explorer. You might have a <code>tree-folder</code> component with this template:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tree-folder-contents</span> <span class=\"attr\">:children</span>=<span class=\"string\">\"folder.children\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Then a <code>tree-folder-contents</code> component with this template:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"child in children\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tree-folder</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"child.children\"</span> <span class=\"attr\">:folder</span>=<span class=\"string\">\"child\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>When you look closely, you’ll see that these components will actually be each other’s descendent <em>and</em> ancestor in the render tree - a paradox! When registering components globally with <code>Vue.component</code>, this paradox is resolved for you automatically. If that’s you, you can stop reading here.</p>\n<p>However, if you’re requiring/importing components using a <strong>module system</strong>, e.g. via Webpack or Browserify, you’ll get an error:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Failed to mount component: template or render function not defined.</div></pre></td></tr></table></figure>\n<p>To explain what’s happening, I’ll call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc, etc. It’s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, “A needs B <em>eventually</em>, but there’s no need to resolve B first.”</p>\n<p>In our case, I’ll make that point the <code>tree-folder</code> component. We know the child that creates the paradox is the <code>tree-folder-contents</code> component, so we’ll wait until the <code>beforeCreate</code> lifecycle hook to register it:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">beforeCreate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.$options.components.TreeFolderContents = <span class=\"built_in\">require</span>(<span class=\"string\">'./tree-folder-contents.vue'</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Problem solved!</p>\n<h3 id=\"内联模版\"><a href=\"#内联模版\" class=\"headerlink\" title=\"内联模版\"></a>内联模版</h3><p>如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">inline-template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>These are compiled as the component's own template.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Not parent's transclusion content.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 <code>.vue</code> 文件中使用 <code>template</code> 元素。</p>\n<h3 id=\"X-Templates\"><a href=\"#X-Templates\" class=\"headerlink\" title=\"X-Templates\"></a>X-Templates</h3><p>另一种定义模版的方式是在 JavaScript 标签里使用 <code>text/x-template</code> 类型，并且指定一个id。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/x-template\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"hello-world-template\"</span>&gt;</span><span class=\"xml\"></span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello hello hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'hello-world'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'#hello-world-template'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。</p>\n<h3 id=\"使用-v-once-的低级静态组件-Cheap-Static-Component\"><a href=\"#使用-v-once-的低级静态组件-Cheap-Static-Component\" class=\"headerlink\" title=\"使用 v-once 的低级静态组件(Cheap Static Component)\"></a>使用 <code>v-once</code> 的低级静态组件(Cheap Static Component)</h3><p>尽管在 Vue 中渲染 HTML 很快，不过当组件中包含<strong>大量</strong>静态内容时，可以考虑使用 <code>v-once</code> 将渲染结果缓存起来，就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'terms-of-service'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'\\</span></div><div class=\"line\">    &lt;div v-once&gt;\\</div><div class=\"line\">      &lt;h1&gt;Terms of Service&lt;/h1&gt;\\</div><div class=\"line\">      ... a lot of static content ...\\</div><div class=\"line\">    &lt;/div&gt;\\</div><div class=\"line\">  '</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/components.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/components.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"什么是组件？\"><a href=\"#什么是组件？\" class=\"headerlink\" title=\"什么是组件？\"></a>什么是组件？</h2><p>组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。</p>\n<h2 id=\"使用组件\"><a href=\"#使用组件\" class=\"headerlink\" title=\"使用组件\"></a>使用组件</h2><h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><p>之前说过，我们可以通过以下方式创建一个 Vue 实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#some-element'</span>,</div><div class=\"line\">  <span class=\"comment\">// 选项</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>要注册一个全局组件，你可以使用 <code>Vue.component(tagName, options)</code>。 例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// 选项</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">对于自定义标签名，Vue.js 不强制要求遵循 <a href=\"https://www.w3.org/TR/custom-elements/#concepts\">W3C规则</a> （小写，并且包含一个短杠），尽管遵循这个规则比较好。</p>\n\n<p>组件在注册之后，便可以在父实例的模块中以自定义元素 <code>&lt;my-component&gt;&lt;/my-component&gt;</code> 的形式使用。要确保在初始化根实例 <strong>之前</strong> 注册了组件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册</span></div><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建根实例</span></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>渲染为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>A custom component!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example\" class=\"demo\">\n  <my-component></my-component>\n</div>\n<script>\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\nnew Vue({ el: '#example' })\n</script>\n\n<h3 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h3><p>不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Child = &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  components: &#123;</div><div class=\"line\">    <span class=\"comment\">// &lt;my-component&gt; 将只在父模板可用</span></div><div class=\"line\">    <span class=\"string\">'my-component'</span>: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这种封装也适用于其它可注册的 Vue 功能，如指令。</p>\n<h3 id=\"DOM-模版解析说明\"><a href=\"#DOM-模版解析说明\" class=\"headerlink\" title=\"DOM 模版解析说明\"></a>DOM 模版解析说明</h3><p>当使用 DOM 作为模版时（例如，将 <code>el</code> 选项挂载到一个已存在的元素上）, 你会受到 HTML 的一些限制，因为 Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。尤其像这些元素 <code>&lt;ul&gt;</code> ， <code>&lt;ol&gt;</code>， <code>&lt;table&gt;</code> ， <code>&lt;select&gt;</code> 限制了能被它包裹的元素， <code>&lt;option&gt;</code> 只能出现在其它元素内部。</p>\n<p>在自定义组件中使用这些受限制的元素时会导致一些问题，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-row</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">my-row</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>自定义组件 <code>&lt;my-row&gt;</code> 被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 <code>is</code> 属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tr</span> <span class=\"attr\">is</span>=<span class=\"string\">\"my-row\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：</strong></p>\n<ul>\n<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>\n<li>JavaScript内联模版字符串</li>\n<li><code>.vue</code> 组件</li>\n</ul>\n<p>因此，有必要的话请使用字符串模版。</p>\n<h3 id=\"data-必须是函数\"><a href=\"#data-必须是函数\" class=\"headerlink\" title=\"data 必须是函数\"></a><code>data</code> 必须是函数</h3><p>使用组件时，大多数选项可以被传入到 Vue 构造器中，有一个例外： <code>data</code> 必须是函数。 实际上，如果你这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'hello'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>那么 Vue 会在控制台发出警告，告诉你在组件中 <code>data</code> 必须是一个函数。最好理解这种规则的存在意义。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">simple-counter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">simple-counter</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">simple-counter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">simple-counter</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">simple-counter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">simple-counter</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">counter</span>: <span class=\"number\">0</span> &#125;</div><div class=\"line\"></div><div class=\"line\">Vue.component(<span class=\"string\">'simple-counter'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class=\"line\">  <span class=\"comment\">// data 是一个函数，因此 Vue 不会警告，</span></div><div class=\"line\">  <span class=\"comment\">// 但是我们为每一个组件返回了同一个对象引用</span></div><div class=\"line\">  data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> data</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-2'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"example-2\" class=\"demo\">\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n</div>\n<script>\nvar data = { counter: 0 }\nVue.component('simple-counter', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return data\n  }\n})\nnew Vue({\n  el: '#example-2'\n})\n</script>\n\n<p>由于这三个组件共享了同一个 <code>data</code> ， 因此增加一个 counter 会影响所有组件！我们可以通过为每个组件返回新的 data 对象来解决这个问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">counter</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在每个 counter 都有它自己内部的状态了：</p>\n\n<div id=\"example-2-5\" class=\"demo\">\n  <my-component></my-component>\n  <my-component></my-component>\n  <my-component></my-component>\n</div>\n<script>\nVue.component('my-component', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  }\n})\nnew Vue({\n  el: '#example-2-5'\n})\n</script>\n\n<h3 id=\"构成组件\"><a href=\"#构成组件\" class=\"headerlink\" title=\"构成组件\"></a>构成组件</h3><p>组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。</p>\n<p>在 Vue.js 中，父子组件的关系可以总结为 <strong>props down, events up</strong> 。父组件通过 <strong>props</strong> 向下传递数据给子组件，子组件通过 <strong>events</strong> 给父组件发送消息。看看它们是怎么工作的。</p>\n<p style=\"text-align: center\"><br>  <img style=\"width:300px\" src=\"/images/props-events.png\" alt=\"props down, events up\"><br></p>\n\n<h2 id=\"Prop\"><a href=\"#Prop\" class=\"headerlink\" title=\"Prop\"></a>Prop</h2><h3 id=\"使用-Prop-传递数据\"><a href=\"#使用-Prop-传递数据\" class=\"headerlink\" title=\"使用 Prop 传递数据\"></a>使用 Prop 传递数据</h3><p>组件实例的作用域是<strong>孤立的</strong>。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。</p>\n<p>prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 <a href=\"../api/#props\"><code>props</code> 选项</a>声明 “prop”：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'child'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// 声明 props</span></div><div class=\"line\">  props: [<span class=\"string\">'message'</span>],</div><div class=\"line\">  <span class=\"comment\">// 就像 data 一样，prop 可以用在模板内</span></div><div class=\"line\">  <span class=\"comment\">// 同样也可以在 vm 实例中像 “this.message” 这样使用</span></div><div class=\"line\">  template: <span class=\"string\">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>然后向它传入一个普通字符串：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">message</span>=<span class=\"string\">\"hello!\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"prop-example-1\" class=\"demo\">\n  <child message=\"hello!\"></child>\n</div>\n<script>\nnew Vue({\n  el: '#prop-example-1',\n  components: {\n    child: {\n      props: ['message'],\n      template: '<span>{{ message }}</span>'\n    }\n  }\n})\n</script>\n\n<h3 id=\"camelCase-vs-kebab-case\"><a href=\"#camelCase-vs-kebab-case\" class=\"headerlink\" title=\"camelCase vs. kebab-case\"></a>camelCase vs. kebab-case</h3><p>HTML 特性不区分大小写。当使用非字符串模版时，prop的名字形式会从 camelCase 转为 kebab-case（短横线隔开）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'child'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// camelCase in JavaScript</span></div><div class=\"line\">  props: [<span class=\"string\">'myMessage'</span>],</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- kebab-case in HTML --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">my-message</span>=<span class=\"string\">\"hello!\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>再次说明，如果你使用字符串模版，不用在意这些限制。</p>\n<h3 id=\"动态-Prop\"><a href=\"#动态-Prop\" class=\"headerlink\" title=\"动态 Prop\"></a>动态 Prop</h3><p>类似于用 <code>v-bind</code> 绑定 HTML 特性到一个表达式，也可以用 <code>v-bind</code> 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"parentMsg\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">v-bind:my-message</span>=<span class=\"string\">\"parentMsg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>使用 <code>v-bind</code> 的缩写语法通常更简单：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">:my-message</span>=<span class=\"string\">\"parentMsg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"demo-2\" class=\"demo\">\n  <input v-model=\"parentMsg\">\n  <br>\n  <child v-bind:my-message=\"parentMsg\"></child>\n</div>\n<script>\nnew Vue({\n  el: '#demo-2',\n  data: {\n    parentMsg: 'Message from parent'\n  },\n  components: {\n    child: {\n      props: ['myMessage'],\n      template: '<span>{{myMessage}}</span>'\n    }\n  }\n})\n</script>\n\n<h3 id=\"字面量语法-vs-动态语法\"><a href=\"#字面量语法-vs-动态语法\" class=\"headerlink\" title=\"字面量语法 vs 动态语法\"></a>字面量语法 vs 动态语法</h3><p>初学者常犯的一个错误是使用字面量语法传递数值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 传递了一个字符串\"1\" --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">some-prop</span>=<span class=\"string\">\"1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>因为它是一个字面 prop ，它的值以字符串 <code>&quot;1&quot;</code> 而不是以实际的数字传下去。如果想传递一个实际的 JavaScript 数字，需要使用 <code>v-bind</code> ，从而让它的值被当作 JavaScript 表达式计算：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 传递实际的数字 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">v-bind:some-prop</span>=<span class=\"string\">\"1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h3><p>prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。</p>\n<p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你<strong>不应该</strong>在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。</p>\n<p>通常有两种改变 prop 的情况：</p>\n<ol>\n<li><p>prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；</p>\n</li>\n<li><p>prop 作为需要被转变的原始值传入。</p>\n</li>\n</ol>\n<p>更确切的说这两种情况是：</p>\n<ol>\n<li><p>定义一个局部 data 属性，并将 prop 的初始值作为局部数据的初始值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">props: [<span class=\"string\">'initialCounter'</span>],</div><div class=\"line\"><span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">counter</span>: <span class=\"keyword\">this</span>.initialCounter &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>定义一个 computed 属性，此属性从 prop 的值计算得出。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">props: [<span class=\"string\">'size'</span>],</div><div class=\"line\"><span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">normalizedSize</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size.trim().toLowerCase()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p class=\"tip\">注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它<strong>会影响</strong>父组件的状态。</p>\n\n<h3 id=\"Prop-验证\"><a href=\"#Prop-验证\" class=\"headerlink\" title=\"Prop 验证\"></a>Prop 验证</h3><p>组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告。当组件给其他人使用时这很有用。</p>\n<p>prop 是一个对象而不是字符串数组时，它包含验证要求：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'example'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 基础类型检测 （`null` 意思是任何类型都可以）</span></div><div class=\"line\">    propA: <span class=\"built_in\">Number</span>,</div><div class=\"line\">    <span class=\"comment\">// 多种类型</span></div><div class=\"line\">    propB: [<span class=\"built_in\">String</span>, <span class=\"built_in\">Number</span>],</div><div class=\"line\">    <span class=\"comment\">// 必传且是字符串</span></div><div class=\"line\">    propC: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">String</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 数字，有默认值</span></div><div class=\"line\">    propD: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">default</span>: <span class=\"number\">100</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 数组／对象的默认值应当由一个工厂函数返回</span></div><div class=\"line\">    propE: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Object</span>,</div><div class=\"line\">      <span class=\"attr\">default</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"attr\">message</span>: <span class=\"string\">'hello'</span> &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 自定义验证函数</span></div><div class=\"line\">    propF: &#123;</div><div class=\"line\">      <span class=\"attr\">validator</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value &gt; <span class=\"number\">10</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><code>type</code> 可以是下面原生构造器：</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Function</li>\n<li>Object</li>\n<li>Array</li>\n</ul>\n<p><code>type</code> 也可以是一个自定义构造器，使用 <code>instanceof</code> 检测。</p>\n<p>当 prop 验证失败了， Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告。</p>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><p>我们知道，父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！</p>\n<h3 id=\"使用-v-on-绑定自定义事件\"><a href=\"#使用-v-on-绑定自定义事件\" class=\"headerlink\" title=\"使用 v-on 绑定自定义事件\"></a>使用 <code>v-on</code> 绑定自定义事件</h3><p>每个 Vue 实例都实现了<a href=\"../api/#Instance-Methods-Events\">事件接口(Events interface)</a>，即：</p>\n<ul>\n<li>使用 <code>$on(eventName)</code> 监听事件</li>\n<li>使用 <code>$emit(eventName)</code> 触发事件</li>\n</ul>\n<p class=\"tip\">Vue的事件系统分离自浏览器的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\">EventTarget API</a>。尽管它们的运行类似，但是<code>$on</code> 和 <code>$emit</code> <strong>不是</strong><code>addEventListener</code> 和 <code>dispatchEvent</code> 的别名。</p>\n\n<p>另外，父组件可以在使用子组件的地方直接用 <code>v-on</code> 来监听子组件触发的事件。</p>\n<p>下面是一个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"counter-event-example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; total &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button-counter</span> <span class=\"attr\">v-on:increment</span>=<span class=\"string\">\"incrementTotal\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button-counter</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button-counter</span> <span class=\"attr\">v-on:increment</span>=<span class=\"string\">\"incrementTotal\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button-counter</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'button-counter'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;button v-on:click=\"increment\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">counter</span>: <span class=\"number\">0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">increment</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.counter += <span class=\"number\">1</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'increment'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#counter-event-example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">total</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">incrementTotal</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.total += <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"counter-event-example\" class=\"demo\">\n  <p>{{ total }}</p>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n<script>\nVue.component('button-counter', {\n  template: '<button v-on:click=\"increment\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  },\n  methods: {\n    increment: function () {\n      this.counter += 1\n      this.$emit('increment')\n    }\n  },\n})\nnew Vue({\n  el: '#counter-event-example',\n  data: {\n    total: 0\n  },\n  methods: {\n    incrementTotal: function () {\n      this.total += 1\n    }\n  }\n})\n</script>\n\n<p>在本例中，子组件已经和它外部完全解耦了。它所做的只是触发一个父组件关心的内部事件。</p>\n<h4 id=\"给组件绑定原生事件\"><a href=\"#给组件绑定原生事件\" class=\"headerlink\" title=\"给组件绑定原生事件\"></a>给组件绑定原生事件</h4><p>有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 <code>.native</code> 修饰 <code>v-on</code> 。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-on:click.native</span>=<span class=\"string\">\"doTheThing\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"使用自定义事件的表单输入组件\"><a href=\"#使用自定义事件的表单输入组件\" class=\"headerlink\" title=\"使用自定义事件的表单输入组件\"></a>使用自定义事件的表单输入组件</h3><p>自定义事件也可以用来创建自定义的表单输入组件，使用 <code>v-model</code> 来进行数据双向绑定。牢记：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"something\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>仅仅是一个语法糖：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"something\"</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"something = $event.target.value\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>所以在组件中使用时，它相当于下面的简写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">custom-input</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"something\"</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"something = arguments[0]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">custom-input</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>所以要让组件的 <code>v-model</code> 生效，它必须：</p>\n<ul>\n<li>接受一个 <code>value</code> 属性</li>\n<li>在有新的 value 时触发 <code>input</code> 事件</li>\n</ul>\n<p>一个非常简单的货币输入：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">currency-input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"price\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">currency-input</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'currency-input'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'\\</div><div class=\"line\">    &lt;span&gt;\\</div><div class=\"line\">      $\\</div><div class=\"line\">      &lt;input\\</div><div class=\"line\">        ref=\"input\"\\</div><div class=\"line\">        v-bind:value=\"value\"\\</div><div class=\"line\">        v-on:input=\"updateValue($event.target.value)\"\\</div><div class=\"line\">      &gt;\\</div><div class=\"line\">    &lt;/span&gt;\\</div><div class=\"line\">  '</span>,</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'value'</span>],</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制</span></div><div class=\"line\">    updateValue: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> formattedValue = value</div><div class=\"line\">        <span class=\"comment\">// 删除两侧的空格符</span></div><div class=\"line\">        .trim()</div><div class=\"line\">        <span class=\"comment\">// 保留 2 小数位</span></div><div class=\"line\">        .slice(<span class=\"number\">0</span>, value.indexOf(<span class=\"string\">'.'</span>) + <span class=\"number\">3</span>)</div><div class=\"line\">      <span class=\"comment\">// 如果值不统一，手动覆盖以保持一致</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (formattedValue !== value) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.$refs.input.value = formattedValue</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 通过 input 事件发出数值</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'input'</span>, <span class=\"built_in\">Number</span>(formattedValue))</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"currency-input-example\" class=\"demo\">\n  <currency-input v-model=\"price\"></currency-input>\n</div>\n<script>\nVue.component('currency-input', {\n  template: '\\\n    <span>\\\n      $\\\n      <input\\\n        ref=\"input\"\\\n        v-bind:value=\"value\"\\\n        v-on:input=\"updateValue($event.target.value)\"\\\n      >\\\n    </span>\\\n  ',\n  props: ['value'],\n  methods: {\n    updateValue: function (value) {\n      var formattedValue = value\n        .trim()\n        .slice(0, value.indexOf('.') + 3)\n      if (formattedValue !== value) {\n        this.$refs.input.value = formattedValue\n      }\n      this.$emit('input', Number(formattedValue))\n    }\n  }\n})\nnew Vue({ el: '#currency-input-example' })\n</script>\n\n<p>上面的实现方式太过理想化了。 比如，用户甚至可以输入多个小数点或句号 - 哦哦！因此我们需要一个更有意义的例子，下面是一个更加完善的货币过滤器：</p>\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/result,html,js\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>这个接口不仅仅可以用来连接组件内部的表单输入，也很容易集成你自己创造的输入类型。想象一下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">voice-recognizer</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"question\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">voice-recognizer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">webcam-gesture-reader</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"gesture\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">webcam-gesture-reader</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">webcam-retinal-scanner</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"retinalImage\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">webcam-retinal-scanner</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"非父子组件通信\"><a href=\"#非父子组件通信\" class=\"headerlink\" title=\"非父子组件通信\"></a>非父子组件通信</h3><p>有时候非父子关系的组件也需要通信。在简单的场景下，使用一个空的 Vue 实例作为中央事件总线：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bus = <span class=\"keyword\">new</span> Vue()</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 触发组件 A 中的事件</span></div><div class=\"line\">bus.$emit(<span class=\"string\">'id-selected'</span>, <span class=\"number\">1</span>)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在组件 B 创建的钩子中监听事件</span></div><div class=\"line\">bus.$on(<span class=\"string\">'id-selected'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在更多复杂的情况下，你应该考虑使用专门的 <a href=\"state-management.html\">状态管理模式</a>.</p>\n<h2 id=\"使用-Slot-分发内容\"><a href=\"#使用-Slot-分发内容\" class=\"headerlink\" title=\"使用 Slot 分发内容\"></a>使用 Slot 分发内容</h2><p>在使用组件时，常常要像这样组合它们：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">app-header</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-header</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">app-footer</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-footer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>注意两点：</p>\n<ol>\n<li><p><code>&lt;app&gt;</code> 组件不知道它的挂载点会有什么内容。挂载点的内容是由<code>&lt;app&gt;</code>的父组件决定的。</p>\n</li>\n<li><p><code>&lt;app&gt;</code> 组件很可能有它自己的模版。</p>\n</li>\n</ol>\n<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 <strong>内容分发</strong> (或 “transclusion” 如果你熟悉 Angular)。Vue.js 实现了一个内容分发 API ，参照了当前 <a href=\"https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md\">Web 组件规范草案</a>，使用特殊的 <code>&lt;slot&gt;</code> 元素作为原始内容的插槽。</p>\n<h3 id=\"编译作用域\"><a href=\"#编译作用域\" class=\"headerlink\" title=\"编译作用域\"></a>编译作用域</h3><p>在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child-component</span>&gt;</span></div><div class=\"line\">  &#123;&#123; message &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">child-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>message</code> 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：</p>\n<p>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。</p>\n<p>一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 无效 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child-component</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"someChildProperty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>假定 <code>someChildProperty</code> 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。</p>\n<p>如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'child-component'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// 有效，因为是在正确的作用域内</span></div><div class=\"line\">  template: <span class=\"string\">'&lt;div v-show=\"someChildProperty\"&gt;Child&lt;/div&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">someChildProperty</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>类似地，分发内容是在父组件作用域内编译。</p>\n<h3 id=\"单个-Slot\"><a href=\"#单个-Slot\" class=\"headerlink\" title=\"单个 Slot\"></a>单个 Slot</h3><p>除非子组件模板包含至少一个 <code>&lt;slot&gt;</code> 插口，否则父组件的内容将会被<strong>丢弃</strong>。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。</p>\n<p>最初在 <code>&lt;slot&gt;</code> 标签中的任何内容都被视为<strong>备用内容</strong>。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。</p>\n<p>假定 <code>my-component</code> 组件有下面模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是子组件的标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    只有在没有要分发的内容时才会显示。</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>父组件模版：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是父组件的标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是一些初始内容<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是更多的初始内容<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>渲染结果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是父组件的标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是子组件的标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是一些初始内容<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是更多的初始内容<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"具名-Slot\"><a href=\"#具名-Slot\" class=\"headerlink\" title=\"具名 Slot\"></a>具名 Slot</h3><p><code>&lt;slot&gt;</code> 元素可以用一个特殊的属性 <code>name</code> 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 <code>slot</code> 特性的元素。</p>\n<p>仍然可以有一个匿名 slot ，它是<strong>默认 slot</strong> ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。</p>\n<p>例如，假定我们有一个 <code>app-layout</code> 组件，它的模板为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"header\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"footer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>父组件模版：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-layout</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"header\"</span>&gt;</span>这里可能是一个页面标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>主要内容的一个段落。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>另一个主要段落。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"footer\"</span>&gt;</span>这里有一些联系信息<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-layout</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>渲染结果为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>这里可能是一个页面标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>主要内容的一个段落。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>另一个主要段落。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这里有一些联系信息<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在组合组件时，内容分发 API 是非常有用的机制。</p>\n<h3 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h3><blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<p>作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。</p>\n<p>在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">text</span>=<span class=\"string\">\"hello from child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在父级中，具有特殊属性 <code>scope</code> 的 <code>&lt;template&gt;</code> 元素，表示它是作用域插槽的模板。<code>scope</code> 的值对应一个临时变量名，此变量接收从子组件中传递的 prop 对象：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"props\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>hello from parent<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果我们渲染以上结果，得到的输出会是：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>hello from parent<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>hello from child<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-awesome-list</span> <span class=\"attr\">:items</span>=<span class=\"string\">\"items\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 作用域插槽也可以在这里命名 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"item\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"props\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"my-fancy-item\"</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-awesome-list</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>列表组件的模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"item\"</span></div><div class=\"line\">    <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span></div><div class=\"line\">    <span class=\"attr\">:text</span>=<span class=\"string\">\"item.text\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- fallback content here --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"动态组件\"><a href=\"#动态组件\" class=\"headerlink\" title=\"动态组件\"></a>动态组件</h2><p>多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <code>&lt;component&gt;</code> 元素，动态地绑定到它的 <code>is</code> 特性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">currentView</span>: <span class=\"string\">'home'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">components</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">home</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">    <span class=\"attr\">posts</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">    <span class=\"attr\">archive</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"currentView\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>也可以直接绑定到组件对象上：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Home = &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;Welcome home!&lt;/p&gt;'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">currentView</span>: Home</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a><code>keep-alive</code></h3><p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 <code>keep-alive</code> 指令参数：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"currentView\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 非活动组件将被缓存！ --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在<a href=\"../api/#keep-alive\">API 参考</a>查看更多 <code>&lt;keep-alive&gt;</code> 的细节。</p>\n<h2 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h2><h3 id=\"编写可复用组件\"><a href=\"#编写可复用组件\" class=\"headerlink\" title=\"编写可复用组件\"></a>编写可复用组件</h3><p>在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。</p>\n<p>Vue 组件的 API 来自三部分 - props, events 和 slots ：</p>\n<ul>\n<li><p><strong>Props</strong> 允许外部环境传递数据给组件</p>\n</li>\n<li><p><strong>Events</strong> 允许组件触发外部环境的副作用</p>\n</li>\n<li><p><strong>Slots</strong> 允许外部环境将额外的内容组合在组件中。</p>\n</li>\n</ul>\n<p>使用 <code>v-bind</code> 和 <code>v-on</code> 的简写语法，模板的缩进清楚且简洁：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span></div><div class=\"line\">  <span class=\"attr\">:foo</span>=<span class=\"string\">\"baz\"</span></div><div class=\"line\">  <span class=\"attr\">:bar</span>=<span class=\"string\">\"qux\"</span></div><div class=\"line\">  @<span class=\"attr\">event-a</span>=<span class=\"string\">\"doThis\"</span></div><div class=\"line\">  @<span class=\"attr\">event-b</span>=<span class=\"string\">\"doThat\"</span></div><div class=\"line\">&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"icon\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"...\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"main-text\"</span>&gt;</span>Hello!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"子组件索引\"><a href=\"#子组件索引\" class=\"headerlink\" title=\"子组件索引\"></a>子组件索引</h3><p>尽管有 props 和 events ，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 <code>ref</code> 为子组件指定一个索引 ID 。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">user-profile</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"profile\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">user-profile</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Vue(&#123; <span class=\"attr\">el</span>: <span class=\"string\">'#parent'</span> &#125;)</div><div class=\"line\"><span class=\"comment\">// 访问子组件</span></div><div class=\"line\"><span class=\"keyword\">var</span> child = parent.$refs.profile</div></pre></td></tr></table></figure>\n<p>当 <code>ref</code> 和 <code>v-for</code> 一起使用时， ref 是一个数组或对象，包含相应的子组件。</p>\n<p class=\"tip\"><code>$refs</code> 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 <code>$refs</code> 。</p>\n\n<h3 id=\"异步组件\"><a href=\"#异步组件\" class=\"headerlink\" title=\"异步组件\"></a>异步组件</h3><p>在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单， Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'async-example'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Pass the component definition to the resolve callback</span></div><div class=\"line\">    resolve(&#123;</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;I am async!&lt;/div&gt;'</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>工厂函数接收一个 <code>resolve</code> 回调，在收到从服务器下载的组件定义时调用。也可以调用 <code>reject(reason)</code> 指示加载失败。这里 <code>setTimeout</code> 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：<a href=\"http://webpack.github.io/docs/code-splitting.html\">Webpack 的代码分割功能</a>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'async-webpack-example'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 这个特殊的 require 语法告诉 webpack</span></div><div class=\"line\">  <span class=\"comment\">// 自动将编译后的代码分割成不同的块，</span></div><div class=\"line\">  <span class=\"comment\">// 这些块将通过 Ajax 请求自动下载。</span></div><div class=\"line\">  <span class=\"built_in\">require</span>([<span class=\"string\">'./my-async-component'</span>], resolve)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>你可以使用 Webpack 2 + ES2015 的语法返回一个 <code>Promise</code> resolve 函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(</div><div class=\"line\">  <span class=\"string\">'async-webpack-example'</span>,</div><div class=\"line\">  () =&gt; System.import(<span class=\"string\">'./my-async-component'</span>)</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p class=\"tip\">如果你是 <strong>Browserify</strong> 用户,可能就无法使用异步组件了,它的作者已经<a href=\"https://github.com/substack/node-browserify/issues/58#issuecomment-21978224\">表明</a> Browserify 是不支持异步加载的。Browserify 社区发现 <a href=\"https://github.com/vuejs/vuejs.org/issues/620\">一些解决方法</a>，可能有助于已存在的复杂应用。对于其他场景，我们推荐简单实用 Webpack 构建，一流的异步支持</p>\n\n<h3 id=\"组件命名约定\"><a href=\"#组件命名约定\" class=\"headerlink\" title=\"组件命名约定\"></a>组件命名约定</h3><p>当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 。Vue 不关心这个。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在组件定义中</span></div><div class=\"line\">components: &#123;</div><div class=\"line\">  <span class=\"comment\">// 使用 kebab-case 形式注册</span></div><div class=\"line\">  <span class=\"string\">'kebab-cased-component'</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">  <span class=\"comment\">// register using camelCase</span></div><div class=\"line\">  <span class=\"string\">'camelCasedComponent'</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">  <span class=\"comment\">// register using TitleCase</span></div><div class=\"line\">  <span class=\"string\">'TitleCasedComponent'</span>: &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 HTML 模版中，请使用 kebab-case 形式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 在HTML模版中始终使用 kebab-case --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">kebab-cased-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">kebab-cased-component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">camel-cased-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">camel-cased-component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title-cased-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title-cased-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当使用字符串模式时，可以不受 HTML 的 case-insensitive 限制。这意味实际上在模版中，你可以使用 camelCase 、 TitleCase 或者 kebab-case 来引用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 在字符串模版中可以用任何你喜欢的方式! --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">myComponent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">myComponent</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">MyComponent</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果组件未经 <code>slot</code> 元素传递内容，你甚至可以在组件名后使用 <code>/</code> 使其自闭合：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。</p>\n<h3 id=\"递归组件\"><a href=\"#递归组件\" class=\"headerlink\" title=\"递归组件\"></a>递归组件</h3><p>组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">'unique-name-of-my-component'</span></div></pre></td></tr></table></figure>\n<p>当你利用<code>Vue.component</code>全局注册了一个组件, 全局的ID作为组件的 <code>name</code> 选项，被自动设置.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'unique-name-of-my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>如果你不谨慎, 递归组件可能导致死循环:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">'stack-overflow'</span>,</div><div class=\"line\"><span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></div></pre></td></tr></table></figure>\n<p>上面组件会导致一个错误 “max stack size exceeded” ，所以要确保递归调用有终止条件 (比如递归调用时使用 <code>v-if</code> 并让他最终返回 <code>false</code> )。</p>\n<h3 id=\"Circular-References-Between-Components\"><a href=\"#Circular-References-Between-Components\" class=\"headerlink\" title=\"Circular References Between Components\"></a>Circular References Between Components</h3><p>Let’s say you’re building a file directory tree, like in Finder or File Explorer. You might have a <code>tree-folder</code> component with this template:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tree-folder-contents</span> <span class=\"attr\">:children</span>=<span class=\"string\">\"folder.children\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Then a <code>tree-folder-contents</code> component with this template:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"child in children\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tree-folder</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"child.children\"</span> <span class=\"attr\">:folder</span>=<span class=\"string\">\"child\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>When you look closely, you’ll see that these components will actually be each other’s descendent <em>and</em> ancestor in the render tree - a paradox! When registering components globally with <code>Vue.component</code>, this paradox is resolved for you automatically. If that’s you, you can stop reading here.</p>\n<p>However, if you’re requiring/importing components using a <strong>module system</strong>, e.g. via Webpack or Browserify, you’ll get an error:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Failed to mount component: template or render function not defined.</div></pre></td></tr></table></figure>\n<p>To explain what’s happening, I’ll call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc, etc. It’s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, “A needs B <em>eventually</em>, but there’s no need to resolve B first.”</p>\n<p>In our case, I’ll make that point the <code>tree-folder</code> component. We know the child that creates the paradox is the <code>tree-folder-contents</code> component, so we’ll wait until the <code>beforeCreate</code> lifecycle hook to register it:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">beforeCreate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.$options.components.TreeFolderContents = <span class=\"built_in\">require</span>(<span class=\"string\">'./tree-folder-contents.vue'</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Problem solved!</p>\n<h3 id=\"内联模版\"><a href=\"#内联模版\" class=\"headerlink\" title=\"内联模版\"></a>内联模版</h3><p>如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">inline-template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>These are compiled as the component's own template.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Not parent's transclusion content.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 <code>.vue</code> 文件中使用 <code>template</code> 元素。</p>\n<h3 id=\"X-Templates\"><a href=\"#X-Templates\" class=\"headerlink\" title=\"X-Templates\"></a>X-Templates</h3><p>另一种定义模版的方式是在 JavaScript 标签里使用 <code>text/x-template</code> 类型，并且指定一个id。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/x-template\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"hello-world-template\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello hello hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'hello-world'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'#hello-world-template'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。</p>\n<h3 id=\"使用-v-once-的低级静态组件-Cheap-Static-Component\"><a href=\"#使用-v-once-的低级静态组件-Cheap-Static-Component\" class=\"headerlink\" title=\"使用 v-once 的低级静态组件(Cheap Static Component)\"></a>使用 <code>v-once</code> 的低级静态组件(Cheap Static Component)</h3><p>尽管在 Vue 中渲染 HTML 很快，不过当组件中包含<strong>大量</strong>静态内容时，可以考虑使用 <code>v-once</code> 将渲染结果缓存起来，就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'terms-of-service'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'\\</div><div class=\"line\">    &lt;div v-once&gt;\\</div><div class=\"line\">      &lt;h1&gt;Terms of Service&lt;/h1&gt;\\</div><div class=\"line\">      ... a lot of static content ...\\</div><div class=\"line\">    &lt;/div&gt;\\</div><div class=\"line\">  '</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/components.html\">http://vuejs.org/guide/components.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"计算属性","type":"guide","order":5,"_content":"\n## 计算属性\n\n在模板中绑定表达式是非常便利的，但是它们实际上只用于简单的操作。在模板中放入太多的逻辑会让模板过重且难以维护。例如：\n\n```html\n<div id=\"example\">\n  {{ message.split('').reverse().join('') }}\n</div>\n```\n\n在这种情况下，模板不再简单和清晰。在实现反向显示 `message` 之前，你应该确认它。这个问题在你不止一次反向显示 message 的时候变得更加糟糕。\n\n这就是为什么任何复杂逻辑，你都应当使用**计算属性**。\n\n### 基础例子\n\n``` html\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n```\n\n``` js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n\n结果：\n\n{% raw %}\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n<script>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n{% endraw %}\n\n\n这里我们声明了一个计算属性 `reversedMessage` 。我们提供的函数将用作属性 `vm.reversedMessage` 的 getter 。\n\n``` js\nconsole.log(vm.reversedMessage) // -> 'olleH'\nvm.message = 'Goodbye'\nconsole.log(vm.reversedMessage) // -> 'eybdooG'\n```\n\n你可以打开浏览器的控制台，修改 vm 。 `vm.reversedMessage` 的值始终取决于 `vm.message` 的值。\n\n你可以像绑定普通属性一样在模板中绑定计算属性。 Vue 知道 `vm.reversedMessage` 依赖于 `vm.message` ，因此当 `vm.message` 发生改变时，依赖于 `vm.reversedMessage` 的绑定也会更新。而且最妙的是我们是声明式地创建这种依赖关系：计算属性的 getter 是干净无副作用的，因此也是易于测试和理解的。\n\n### 计算缓存 vs Methods\n\n你可能已经注意到我们可以通过调用表达式中的method来达到同样的效果：\n\n``` html\n<p>Reversed message: \"{{ reverseMessage() }}\"</p>\n```\n\n``` js\n// in component\nmethods: {\n  reverseMessage: function () {\n    return this.message.split('').reverse().join('')\n  }\n}\n```\n\n不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。对于最终的结果，两种方式确实是相同的。然而，不同的是**计算属性是基于它的依赖缓存**。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 `message` 没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。\n\n这也同样意味着如下计算属性将不会更新，因为 `Date.now()` 不是响应式依赖：\n\n``` js\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n```\n\n相比而言，每当重新渲染的时候，method 调用**总会**执行函数。\n\n我们为什么需要缓存？假设我们有一个重要的计算属性 **A** ，这个计算属性需要一个巨大的数组遍历和做大量的计算。然后我们可能有其他的计算属性依赖于 **A** 。如果没有缓存，我们将不可避免的多次执行 **A** 的 getter ！如果你不希望有缓存，请用 method 替代。\n\n### 计算属性 vs Watched Property\n\nVue.js 提供了一个方法 `$watch` ，它用于观察 Vue 实例上的数据变动。当一些数据需要根据其它数据变化时， `$watch` 很诱人 —— 特别是如果你来自 AngularJS 。不过，通常更好的办法是使用计算属性而不是一个命令式的 `$watch` 回调。思考下面例子：\n\n``` html\n<div id=\"demo\">{{ fullName }}</div>\n```\n\n``` js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n```\n\n上面代码是命令式的和重复的。跟计算属性对比：\n\n``` js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n})\n```\n\n这样更好，不是吗？\n\n### 计算 setter\n\n计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：\n\n``` js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n```\n\n现在在运行 `vm.fullName = 'John Doe'` 时， setter 会被调用， `vm.firstName` 和 `vm.lastName` 也会被对应更新。\n\n## 观察 Watchers\n\n虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher 。这是为什么 Vue 提供一个更通用的方法通过 `watch` 选项，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。\n\n例如：\n\n```html\n<div id=\"watch-example\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n```\n\n```html\n<!-- Since there is already a rich ecosystem of ajax libraries    -->\n<!-- and collections of general-purpose utility methods, Vue core -->\n<!-- is able to remain small by not reinventing them. This also   -->\n<!-- gives you the freedom to just use what you're familiar with. -->\n<script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 question 发生改变，这个函数就会运行\n    question: function (newQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.getAnswer()\n    }\n  },\n  methods: {\n    // _.debounce 是一个通过 lodash 限制操作频率的函数。\n    // 在这个例子中，我们希望限制访问yesno.wtf/api的频率\n    // ajax请求直到用户输入完毕才会发出\n    // 学习更多关于 _.debounce function (and its cousin\n    // _.throttle), 参考: https://lodash.com/docs#debounce\n    getAnswer: _.debounce(\n      function () {\n        var vm = this\n        if (this.question.indexOf('?') === -1) {\n          vm.answer = 'Questions usually contain a question mark. ;-)'\n          return\n        }\n        vm.answer = 'Thinking...'\n        axios.get('https://yesno.wtf/api')\n          .then(function (response) {\n            vm.answer = _.capitalize(response.data.answer)\n          })\n          .catch(function (error) {\n            vm.answer = 'Error! Could not reach the API. ' + error\n          })\n      },\n      // 这是我们为用户停止输入等待的毫秒数\n      500\n    )\n  }\n})\n</script>\n```\n\n\n结果：\n\n{% raw %}\n<div id=\"watch-example\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n<script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 question 发生改变，这个函数就会运行\n    question: function (newQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.getAnswer()\n    }\n  },\n  methods: {\n    getAnswer: _.debounce(\n      function () {\n        var vm = this\n        if (this.question.indexOf('?') === -1) {\n          vm.answer = 'Questions usually contain a question mark. ;-)'\n          return\n        }\n        vm.answer = 'Thinking...'\n        axios.get('https://yesno.wtf/api')\n          .then(function (response) {\n            vm.answer = _.capitalize(response.data.answer)\n          })\n          .catch(function (error) {\n            vm.answer = 'Error! Could not reach the API. ' + error\n          })\n      },\n      // 这是我们为用户停止输入等待的毫秒数\n      500\n    )\n  }\n})\n</script>\n{% endraw %}\n\n在这个示例中，使用 `watch` 选项允许我们执行异步操作（访问一个 API），限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这是计算属性无法做到的。\n\n除了 `watch` 选项之外，您还可以使用 [vm.$watch API](../api/#vm-watch) 命令。\n\n***\n\n> 原文：http://vuejs.org/guide/computed.html\n\n***\n\n","source":"v2/guide/computed.md","raw":"---\ntitle: 计算属性\ntype: guide\norder: 5\n---\n\n## 计算属性\n\n在模板中绑定表达式是非常便利的，但是它们实际上只用于简单的操作。在模板中放入太多的逻辑会让模板过重且难以维护。例如：\n\n```html\n<div id=\"example\">\n  {{ message.split('').reverse().join('') }}\n</div>\n```\n\n在这种情况下，模板不再简单和清晰。在实现反向显示 `message` 之前，你应该确认它。这个问题在你不止一次反向显示 message 的时候变得更加糟糕。\n\n这就是为什么任何复杂逻辑，你都应当使用**计算属性**。\n\n### 基础例子\n\n``` html\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n```\n\n``` js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n\n结果：\n\n{% raw %}\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n<script>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n{% endraw %}\n\n\n这里我们声明了一个计算属性 `reversedMessage` 。我们提供的函数将用作属性 `vm.reversedMessage` 的 getter 。\n\n``` js\nconsole.log(vm.reversedMessage) // -> 'olleH'\nvm.message = 'Goodbye'\nconsole.log(vm.reversedMessage) // -> 'eybdooG'\n```\n\n你可以打开浏览器的控制台，修改 vm 。 `vm.reversedMessage` 的值始终取决于 `vm.message` 的值。\n\n你可以像绑定普通属性一样在模板中绑定计算属性。 Vue 知道 `vm.reversedMessage` 依赖于 `vm.message` ，因此当 `vm.message` 发生改变时，依赖于 `vm.reversedMessage` 的绑定也会更新。而且最妙的是我们是声明式地创建这种依赖关系：计算属性的 getter 是干净无副作用的，因此也是易于测试和理解的。\n\n### 计算缓存 vs Methods\n\n你可能已经注意到我们可以通过调用表达式中的method来达到同样的效果：\n\n``` html\n<p>Reversed message: \"{{ reverseMessage() }}\"</p>\n```\n\n``` js\n// in component\nmethods: {\n  reverseMessage: function () {\n    return this.message.split('').reverse().join('')\n  }\n}\n```\n\n不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。对于最终的结果，两种方式确实是相同的。然而，不同的是**计算属性是基于它的依赖缓存**。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 `message` 没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。\n\n这也同样意味着如下计算属性将不会更新，因为 `Date.now()` 不是响应式依赖：\n\n``` js\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n```\n\n相比而言，每当重新渲染的时候，method 调用**总会**执行函数。\n\n我们为什么需要缓存？假设我们有一个重要的计算属性 **A** ，这个计算属性需要一个巨大的数组遍历和做大量的计算。然后我们可能有其他的计算属性依赖于 **A** 。如果没有缓存，我们将不可避免的多次执行 **A** 的 getter ！如果你不希望有缓存，请用 method 替代。\n\n### 计算属性 vs Watched Property\n\nVue.js 提供了一个方法 `$watch` ，它用于观察 Vue 实例上的数据变动。当一些数据需要根据其它数据变化时， `$watch` 很诱人 —— 特别是如果你来自 AngularJS 。不过，通常更好的办法是使用计算属性而不是一个命令式的 `$watch` 回调。思考下面例子：\n\n``` html\n<div id=\"demo\">{{ fullName }}</div>\n```\n\n``` js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n```\n\n上面代码是命令式的和重复的。跟计算属性对比：\n\n``` js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n})\n```\n\n这样更好，不是吗？\n\n### 计算 setter\n\n计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：\n\n``` js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n```\n\n现在在运行 `vm.fullName = 'John Doe'` 时， setter 会被调用， `vm.firstName` 和 `vm.lastName` 也会被对应更新。\n\n## 观察 Watchers\n\n虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher 。这是为什么 Vue 提供一个更通用的方法通过 `watch` 选项，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。\n\n例如：\n\n```html\n<div id=\"watch-example\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n```\n\n```html\n<!-- Since there is already a rich ecosystem of ajax libraries    -->\n<!-- and collections of general-purpose utility methods, Vue core -->\n<!-- is able to remain small by not reinventing them. This also   -->\n<!-- gives you the freedom to just use what you're familiar with. -->\n<script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 question 发生改变，这个函数就会运行\n    question: function (newQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.getAnswer()\n    }\n  },\n  methods: {\n    // _.debounce 是一个通过 lodash 限制操作频率的函数。\n    // 在这个例子中，我们希望限制访问yesno.wtf/api的频率\n    // ajax请求直到用户输入完毕才会发出\n    // 学习更多关于 _.debounce function (and its cousin\n    // _.throttle), 参考: https://lodash.com/docs#debounce\n    getAnswer: _.debounce(\n      function () {\n        var vm = this\n        if (this.question.indexOf('?') === -1) {\n          vm.answer = 'Questions usually contain a question mark. ;-)'\n          return\n        }\n        vm.answer = 'Thinking...'\n        axios.get('https://yesno.wtf/api')\n          .then(function (response) {\n            vm.answer = _.capitalize(response.data.answer)\n          })\n          .catch(function (error) {\n            vm.answer = 'Error! Could not reach the API. ' + error\n          })\n      },\n      // 这是我们为用户停止输入等待的毫秒数\n      500\n    )\n  }\n})\n</script>\n```\n\n\n结果：\n\n{% raw %}\n<div id=\"watch-example\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n<script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 question 发生改变，这个函数就会运行\n    question: function (newQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.getAnswer()\n    }\n  },\n  methods: {\n    getAnswer: _.debounce(\n      function () {\n        var vm = this\n        if (this.question.indexOf('?') === -1) {\n          vm.answer = 'Questions usually contain a question mark. ;-)'\n          return\n        }\n        vm.answer = 'Thinking...'\n        axios.get('https://yesno.wtf/api')\n          .then(function (response) {\n            vm.answer = _.capitalize(response.data.answer)\n          })\n          .catch(function (error) {\n            vm.answer = 'Error! Could not reach the API. ' + error\n          })\n      },\n      // 这是我们为用户停止输入等待的毫秒数\n      500\n    )\n  }\n})\n</script>\n{% endraw %}\n\n在这个示例中，使用 `watch` 选项允许我们执行异步操作（访问一个 API），限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这是计算属性无法做到的。\n\n除了 `watch` 选项之外，您还可以使用 [vm.$watch API](../api/#vm-watch) 命令。\n\n***\n\n> 原文：http://vuejs.org/guide/computed.html\n\n***\n\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/computed.html","comments":1,"layout":"page","_id":"ciwnajuyf0017jl2dyp73k6oz","content":"<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>在模板中绑定表达式是非常便利的，但是它们实际上只用于简单的操作。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在这种情况下，模板不再简单和清晰。在实现反向显示 <code>message</code> 之前，你应该确认它。这个问题在你不止一次反向显示 message 的时候变得更加糟糕。</p>\n<p>这就是为什么任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p>\n<h3 id=\"基础例子\"><a href=\"#基础例子\" class=\"headerlink\" title=\"基础例子\"></a>基础例子</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Original message: \"&#123;&#123; message &#125;&#125;\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// a computed getter</span></div><div class=\"line\">    reversedMessage: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// `this` points to the vm instance</span></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n<script>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n\n<p>这里我们声明了一个计算属性 <code>reversedMessage</code> 。我们提供的函数将用作属性 <code>vm.reversedMessage</code> 的 getter 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(vm.reversedMessage) <span class=\"comment\">// -&gt; 'olleH'</span></div><div class=\"line\">vm.message = <span class=\"string\">'Goodbye'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(vm.reversedMessage) <span class=\"comment\">// -&gt; 'eybdooG'</span></div></pre></td></tr></table></figure>\n<p>你可以打开浏览器的控制台，修改 vm 。 <code>vm.reversedMessage</code> 的值始终取决于 <code>vm.message</code> 的值。</p>\n<p>你可以像绑定普通属性一样在模板中绑定计算属性。 Vue 知道 <code>vm.reversedMessage</code> 依赖于 <code>vm.message</code> ，因此当 <code>vm.message</code> 发生改变时，依赖于 <code>vm.reversedMessage</code> 的绑定也会更新。而且最妙的是我们是声明式地创建这种依赖关系：计算属性的 getter 是干净无副作用的，因此也是易于测试和理解的。</p>\n<h3 id=\"计算缓存-vs-Methods\"><a href=\"#计算缓存-vs-Methods\" class=\"headerlink\" title=\"计算缓存 vs Methods\"></a>计算缓存 vs Methods</h3><p>你可能已经注意到我们可以通过调用表达式中的method来达到同样的效果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Reversed message: \"&#123;&#123; reverseMessage() &#125;&#125;\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// in component</span></div><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">reverseMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。对于最终的结果，两种方式确实是相同的。然而，不同的是<strong>计算属性是基于它的依赖缓存</strong>。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 <code>message</code> 没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>\n<p>这也同样意味着如下计算属性将不会更新，因为 <code>Date.now()</code> 不是响应式依赖：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">now</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Date</span>.now()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>相比而言，每当重新渲染的时候，method 调用<strong>总会</strong>执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个重要的计算属性 <strong>A</strong> ，这个计算属性需要一个巨大的数组遍历和做大量的计算。然后我们可能有其他的计算属性依赖于 <strong>A</strong> 。如果没有缓存，我们将不可避免的多次执行 <strong>A</strong> 的 getter ！如果你不希望有缓存，请用 method 替代。</p>\n<h3 id=\"计算属性-vs-Watched-Property\"><a href=\"#计算属性-vs-Watched-Property\" class=\"headerlink\" title=\"计算属性 vs Watched Property\"></a>计算属性 vs Watched Property</h3><p>Vue.js 提供了一个方法 <code>$watch</code> ，它用于观察 Vue 实例上的数据变动。当一些数据需要根据其它数据变化时， <code>$watch</code> 很诱人 —— 特别是如果你来自 AngularJS 。不过，通常更好的办法是使用计算属性而不是一个命令式的 <code>$watch</code> 回调。思考下面例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">firstName</span>: <span class=\"string\">'Foo'</span>,</div><div class=\"line\">    <span class=\"attr\">lastName</span>: <span class=\"string\">'Bar'</span>,</div><div class=\"line\">    <span class=\"attr\">fullName</span>: <span class=\"string\">'Foo Bar'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">firstName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.fullName = val + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">lastName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.fullName = <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + val</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>上面代码是命令式的和重复的。跟计算属性对比：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">firstName</span>: <span class=\"string\">'Foo'</span>,</div><div class=\"line\">    <span class=\"attr\">lastName</span>: <span class=\"string\">'Bar'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">fullName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样更好，不是吗？</p>\n<h3 id=\"计算-setter\"><a href=\"#计算-setter\" class=\"headerlink\" title=\"计算 setter\"></a>计算 setter</h3><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">fullName</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// getter</span></div><div class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// setter</span></div><div class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newValue</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> names = newValue.split(<span class=\"string\">' '</span>)</div><div class=\"line\">      <span class=\"keyword\">this</span>.firstName = names[<span class=\"number\">0</span>]</div><div class=\"line\">      <span class=\"keyword\">this</span>.lastName = names[names.length - <span class=\"number\">1</span>]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ...</span></div></pre></td></tr></table></figure>\n<p>现在在运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时， setter 会被调用， <code>vm.firstName</code> 和 <code>vm.lastName</code> 也会被对应更新。</p>\n<h2 id=\"观察-Watchers\"><a href=\"#观察-Watchers\" class=\"headerlink\" title=\"观察 Watchers\"></a>观察 Watchers</h2><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher 。这是为什么 Vue 提供一个更通用的方法通过 <code>watch</code> 选项，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。</p>\n<p>例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"watch-example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    Ask a yes/no question:</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"question\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- Since there is already a rich ecosystem of ajax libraries    --&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- is able to remain small by not reinventing them. This also   --&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- gives you the freedom to just use what you're familiar with. --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"keyword\">var</span> watchExampleVM = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#watch-example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">question</span>: <span class=\"string\">''</span>,</div><div class=\"line\">    <span class=\"attr\">answer</span>: <span class=\"string\">'I cannot give you an answer until you ask a question!'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 如果 question 发生改变，这个函数就会运行</span></div><div class=\"line\">    question: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newQuestion</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.answer = <span class=\"string\">'Waiting for you to stop typing...'</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.getAnswer()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// _.debounce 是一个通过 lodash 限制操作频率的函数。</span></div><div class=\"line\">    <span class=\"comment\">// 在这个例子中，我们希望限制访问yesno.wtf/api的频率</span></div><div class=\"line\">    <span class=\"comment\">// ajax请求直到用户输入完毕才会发出</span></div><div class=\"line\">    <span class=\"comment\">// 学习更多关于 _.debounce function (and its cousin</span></div><div class=\"line\">    <span class=\"comment\">// _.throttle), 参考: https://lodash.com/docs#debounce</span></div><div class=\"line\">    getAnswer: _.debounce(</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.question.indexOf(<span class=\"string\">'?'</span>) === <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">          vm.answer = <span class=\"string\">'Questions usually contain a question mark. ;-)'</span></div><div class=\"line\">          <span class=\"keyword\">return</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        vm.answer = <span class=\"string\">'Thinking...'</span></div><div class=\"line\">        axios.get(<span class=\"string\">'https://yesno.wtf/api'</span>)</div><div class=\"line\">          .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">            vm.answer = _.capitalize(response.data.answer)</div><div class=\"line\">          &#125;)</div><div class=\"line\">          .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">            vm.answer = <span class=\"string\">'Error! Could not reach the API. '</span> + error</div><div class=\"line\">          &#125;)</div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"comment\">// 这是我们为用户停止输入等待的毫秒数</span></div><div class=\"line\">      <span class=\"number\">500</span></div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"watch-example\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n<script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 question 发生改变，这个函数就会运行\n    question: function (newQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.getAnswer()\n    }\n  },\n  methods: {\n    getAnswer: _.debounce(\n      function () {\n        var vm = this\n        if (this.question.indexOf('?') === -1) {\n          vm.answer = 'Questions usually contain a question mark. ;-)'\n          return\n        }\n        vm.answer = 'Thinking...'\n        axios.get('https://yesno.wtf/api')\n          .then(function (response) {\n            vm.answer = _.capitalize(response.data.answer)\n          })\n          .catch(function (error) {\n            vm.answer = 'Error! Could not reach the API. ' + error\n          })\n      },\n      // 这是我们为用户停止输入等待的毫秒数\n      500\n    )\n  }\n})\n</script>\n\n<p>在这个示例中，使用 <code>watch</code> 选项允许我们执行异步操作（访问一个 API），限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这是计算属性无法做到的。</p>\n<p>除了 <code>watch</code> 选项之外，您还可以使用 <a href=\"../api/#vm-watch\">vm.$watch API</a> 命令。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/computed.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/computed.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>在模板中绑定表达式是非常便利的，但是它们实际上只用于简单的操作。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在这种情况下，模板不再简单和清晰。在实现反向显示 <code>message</code> 之前，你应该确认它。这个问题在你不止一次反向显示 message 的时候变得更加糟糕。</p>\n<p>这就是为什么任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p>\n<h3 id=\"基础例子\"><a href=\"#基础例子\" class=\"headerlink\" title=\"基础例子\"></a>基础例子</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Original message: \"&#123;&#123; message &#125;&#125;\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// a computed getter</span></div><div class=\"line\">    reversedMessage: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// `this` points to the vm instance</span></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n<script>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n\n<p>这里我们声明了一个计算属性 <code>reversedMessage</code> 。我们提供的函数将用作属性 <code>vm.reversedMessage</code> 的 getter 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(vm.reversedMessage) <span class=\"comment\">// -&gt; 'olleH'</span></div><div class=\"line\">vm.message = <span class=\"string\">'Goodbye'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(vm.reversedMessage) <span class=\"comment\">// -&gt; 'eybdooG'</span></div></pre></td></tr></table></figure>\n<p>你可以打开浏览器的控制台，修改 vm 。 <code>vm.reversedMessage</code> 的值始终取决于 <code>vm.message</code> 的值。</p>\n<p>你可以像绑定普通属性一样在模板中绑定计算属性。 Vue 知道 <code>vm.reversedMessage</code> 依赖于 <code>vm.message</code> ，因此当 <code>vm.message</code> 发生改变时，依赖于 <code>vm.reversedMessage</code> 的绑定也会更新。而且最妙的是我们是声明式地创建这种依赖关系：计算属性的 getter 是干净无副作用的，因此也是易于测试和理解的。</p>\n<h3 id=\"计算缓存-vs-Methods\"><a href=\"#计算缓存-vs-Methods\" class=\"headerlink\" title=\"计算缓存 vs Methods\"></a>计算缓存 vs Methods</h3><p>你可能已经注意到我们可以通过调用表达式中的method来达到同样的效果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Reversed message: \"&#123;&#123; reverseMessage() &#125;&#125;\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// in component</span></div><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">reverseMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。对于最终的结果，两种方式确实是相同的。然而，不同的是<strong>计算属性是基于它的依赖缓存</strong>。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 <code>message</code> 没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>\n<p>这也同样意味着如下计算属性将不会更新，因为 <code>Date.now()</code> 不是响应式依赖：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">now</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Date</span>.now()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>相比而言，每当重新渲染的时候，method 调用<strong>总会</strong>执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个重要的计算属性 <strong>A</strong> ，这个计算属性需要一个巨大的数组遍历和做大量的计算。然后我们可能有其他的计算属性依赖于 <strong>A</strong> 。如果没有缓存，我们将不可避免的多次执行 <strong>A</strong> 的 getter ！如果你不希望有缓存，请用 method 替代。</p>\n<h3 id=\"计算属性-vs-Watched-Property\"><a href=\"#计算属性-vs-Watched-Property\" class=\"headerlink\" title=\"计算属性 vs Watched Property\"></a>计算属性 vs Watched Property</h3><p>Vue.js 提供了一个方法 <code>$watch</code> ，它用于观察 Vue 实例上的数据变动。当一些数据需要根据其它数据变化时， <code>$watch</code> 很诱人 —— 特别是如果你来自 AngularJS 。不过，通常更好的办法是使用计算属性而不是一个命令式的 <code>$watch</code> 回调。思考下面例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">firstName</span>: <span class=\"string\">'Foo'</span>,</div><div class=\"line\">    <span class=\"attr\">lastName</span>: <span class=\"string\">'Bar'</span>,</div><div class=\"line\">    <span class=\"attr\">fullName</span>: <span class=\"string\">'Foo Bar'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">firstName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.fullName = val + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">lastName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.fullName = <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + val</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>上面代码是命令式的和重复的。跟计算属性对比：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">firstName</span>: <span class=\"string\">'Foo'</span>,</div><div class=\"line\">    <span class=\"attr\">lastName</span>: <span class=\"string\">'Bar'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">fullName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样更好，不是吗？</p>\n<h3 id=\"计算-setter\"><a href=\"#计算-setter\" class=\"headerlink\" title=\"计算 setter\"></a>计算 setter</h3><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">fullName</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// getter</span></div><div class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// setter</span></div><div class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newValue</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> names = newValue.split(<span class=\"string\">' '</span>)</div><div class=\"line\">      <span class=\"keyword\">this</span>.firstName = names[<span class=\"number\">0</span>]</div><div class=\"line\">      <span class=\"keyword\">this</span>.lastName = names[names.length - <span class=\"number\">1</span>]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ...</span></div></pre></td></tr></table></figure>\n<p>现在在运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时， setter 会被调用， <code>vm.firstName</code> 和 <code>vm.lastName</code> 也会被对应更新。</p>\n<h2 id=\"观察-Watchers\"><a href=\"#观察-Watchers\" class=\"headerlink\" title=\"观察 Watchers\"></a>观察 Watchers</h2><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher 。这是为什么 Vue 提供一个更通用的方法通过 <code>watch</code> 选项，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。</p>\n<p>例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"watch-example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    Ask a yes/no question:</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"question\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- Since there is already a rich ecosystem of ajax libraries    --&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- is able to remain small by not reinventing them. This also   --&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- gives you the freedom to just use what you're familiar with. --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\"><span class=\"keyword\">var</span> watchExampleVM = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#watch-example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">question</span>: <span class=\"string\">''</span>,</div><div class=\"line\">    <span class=\"attr\">answer</span>: <span class=\"string\">'I cannot give you an answer until you ask a question!'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 如果 question 发生改变，这个函数就会运行</span></div><div class=\"line\">    question: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newQuestion</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.answer = <span class=\"string\">'Waiting for you to stop typing...'</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.getAnswer()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// _.debounce 是一个通过 lodash 限制操作频率的函数。</span></div><div class=\"line\">    <span class=\"comment\">// 在这个例子中，我们希望限制访问yesno.wtf/api的频率</span></div><div class=\"line\">    <span class=\"comment\">// ajax请求直到用户输入完毕才会发出</span></div><div class=\"line\">    <span class=\"comment\">// 学习更多关于 _.debounce function (and its cousin</span></div><div class=\"line\">    <span class=\"comment\">// _.throttle), 参考: https://lodash.com/docs#debounce</span></div><div class=\"line\">    getAnswer: _.debounce(</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.question.indexOf(<span class=\"string\">'?'</span>) === <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">          vm.answer = <span class=\"string\">'Questions usually contain a question mark. ;-)'</span></div><div class=\"line\">          <span class=\"keyword\">return</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        vm.answer = <span class=\"string\">'Thinking...'</span></div><div class=\"line\">        axios.get(<span class=\"string\">'https://yesno.wtf/api'</span>)</div><div class=\"line\">          .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">            vm.answer = _.capitalize(response.data.answer)</div><div class=\"line\">          &#125;)</div><div class=\"line\">          .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">            vm.answer = <span class=\"string\">'Error! Could not reach the API. '</span> + error</div><div class=\"line\">          &#125;)</div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"comment\">// 这是我们为用户停止输入等待的毫秒数</span></div><div class=\"line\">      <span class=\"number\">500</span></div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"watch-example\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n<script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 question 发生改变，这个函数就会运行\n    question: function (newQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.getAnswer()\n    }\n  },\n  methods: {\n    getAnswer: _.debounce(\n      function () {\n        var vm = this\n        if (this.question.indexOf('?') === -1) {\n          vm.answer = 'Questions usually contain a question mark. ;-)'\n          return\n        }\n        vm.answer = 'Thinking...'\n        axios.get('https://yesno.wtf/api')\n          .then(function (response) {\n            vm.answer = _.capitalize(response.data.answer)\n          })\n          .catch(function (error) {\n            vm.answer = 'Error! Could not reach the API. ' + error\n          })\n      },\n      // 这是我们为用户停止输入等待的毫秒数\n      500\n    )\n  }\n})\n</script>\n\n<p>在这个示例中，使用 <code>watch</code> 选项允许我们执行异步操作（访问一个 API），限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这是计算属性无法做到的。</p>\n<p>除了 <code>watch</code> 选项之外，您还可以使用 <a href=\"../api/#vm-watch\">vm.$watch API</a> 命令。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/computed.html\">http://vuejs.org/guide/computed.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"条件渲染","type":"guide","order":7,"_content":"\n## `v-if`\n\n在字符串模板中，如 Handlebars ，我们得像这样写一个条件块：\n\n``` html\n<!-- Handlebars 模板 -->\n{{#if ok}}\n  <h1>Yes</h1>\n{{/if}}\n```\n\n在 Vue.js ，我们使用 `v-if` 指令实现同样的功能：\n\n``` html\n<h1 v-if=\"ok\">Yes</h1>\n```\n\n也可以用 `v-else` 添加一个 \"else\" 块：\n\n``` html\n<h1 v-if=\"ok\">Yes</h1>\n<h1 v-else>No</h1>\n```\n\n### `<template>` 中 `v-if` 条件组 \n\n因为 `v-if` 是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个 `<template>` 元素当做包装元素，并在上面使用 `v-if`，最终的渲染结果不会包含它。\n\n``` html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n```\n\n### `v-else`\n\n可以用 `v-else` 指令给 `v-if` 添加一个 \"else\" 块：\n\n``` html\n<div v-if=\"Math.random() > 0.5\">\n  Sorry\n</div>\n<div v-else>\n  Not sorry\n</div>\n```\n\n`v-else` 元素必须紧跟在 `v-if` 元素或者 `v-else-if`的后面——否则它不能被识别。\n\n### `v-else-if`\n\n> 2.1.0 新增\n\n`v-else-if`，顾名思义，用作 `v-if` 的 `else-if` 块。可以链式的多次使用：\n\n```html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n\n与 `v-else` 相似,，`v-else-if` 必须跟在 `v-if` 或者 `v-else-if`之后。\n\n### 使用 `key` 控制元素的可重用\n\nVue 尝试尽可能高效的渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 更快之外还可以得到一些好处。如下例，当允许用户在不同的登录方式之间切换:\n\n``` html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n```\n\n在代码中切换 `loginType` 不会删除用户已经输入的内容，两个模版由于使用了相同的元素，`<input>` 会被复用，仅仅是替换了他们的 `placeholder`。\n\n自己动手试一试,输入一些文本，然后点击 「Toggle login type」 进行切换\n\n{% raw %}\n<div id=\"no-key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#no-key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n这样也不总是符合实际需求，所以 Vue 提供一种方式让你可以自己决定是否要复用元素。你要做的是添加一个属性 `key` ，`key` 必须带有唯一的值。\n\n``` html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\" key=\"username-input\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\" key=\"email-input\">\n</template>\n```\n\n现在输入文本将会在每次切换时重新渲染。自动动手试一试。\n\n{% raw %}\n<div id=\"key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\" key=\"username-input\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\" key=\"email-input\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n注意, `<label>` 元素仍然会被复用，因为没有被添加了 `key` 属性。\n\n## `v-show`\n\n另一个根据条件展示元素的选项是 `v-show` 指令。用法大体上一样：\n\n``` html\n<h1 v-show=\"ok\">Hello!</h1>\n```\n\n不同的是有 `v-show` 的元素会始终渲染并保持在 DOM 中。`v-show` 是简单的切换元素的 CSS 属性 `display` 。\n\n<p class=\"tip\">注意 `v-show` 不支持 `<template>` 语法。</p>\n\n\n## `v-if` vs `v-show`\n\n`v-if` 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。\n\n`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。\n\n相比之下， `v-show` 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。\n\n一般来说， `v-if` 有更高的切换消耗而 `v-show` 有更高的初始渲染消耗。因此，如果需要频繁切换使用 `v-show` 较好，如果在运行时条件不大可能改变则使用 `v-if` 较好。\n\n\n***\n\n> 原文：http://vuejs.org/guide/conditional.html\n\n***\n","source":"v2/guide/conditional.md","raw":"---\ntitle: 条件渲染\ntype: guide\norder: 7\n---\n\n## `v-if`\n\n在字符串模板中，如 Handlebars ，我们得像这样写一个条件块：\n\n``` html\n<!-- Handlebars 模板 -->\n{{#if ok}}\n  <h1>Yes</h1>\n{{/if}}\n```\n\n在 Vue.js ，我们使用 `v-if` 指令实现同样的功能：\n\n``` html\n<h1 v-if=\"ok\">Yes</h1>\n```\n\n也可以用 `v-else` 添加一个 \"else\" 块：\n\n``` html\n<h1 v-if=\"ok\">Yes</h1>\n<h1 v-else>No</h1>\n```\n\n### `<template>` 中 `v-if` 条件组 \n\n因为 `v-if` 是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个 `<template>` 元素当做包装元素，并在上面使用 `v-if`，最终的渲染结果不会包含它。\n\n``` html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n```\n\n### `v-else`\n\n可以用 `v-else` 指令给 `v-if` 添加一个 \"else\" 块：\n\n``` html\n<div v-if=\"Math.random() > 0.5\">\n  Sorry\n</div>\n<div v-else>\n  Not sorry\n</div>\n```\n\n`v-else` 元素必须紧跟在 `v-if` 元素或者 `v-else-if`的后面——否则它不能被识别。\n\n### `v-else-if`\n\n> 2.1.0 新增\n\n`v-else-if`，顾名思义，用作 `v-if` 的 `else-if` 块。可以链式的多次使用：\n\n```html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n\n与 `v-else` 相似,，`v-else-if` 必须跟在 `v-if` 或者 `v-else-if`之后。\n\n### 使用 `key` 控制元素的可重用\n\nVue 尝试尽可能高效的渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 更快之外还可以得到一些好处。如下例，当允许用户在不同的登录方式之间切换:\n\n``` html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n```\n\n在代码中切换 `loginType` 不会删除用户已经输入的内容，两个模版由于使用了相同的元素，`<input>` 会被复用，仅仅是替换了他们的 `placeholder`。\n\n自己动手试一试,输入一些文本，然后点击 「Toggle login type」 进行切换\n\n{% raw %}\n<div id=\"no-key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#no-key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n这样也不总是符合实际需求，所以 Vue 提供一种方式让你可以自己决定是否要复用元素。你要做的是添加一个属性 `key` ，`key` 必须带有唯一的值。\n\n``` html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\" key=\"username-input\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\" key=\"email-input\">\n</template>\n```\n\n现在输入文本将会在每次切换时重新渲染。自动动手试一试。\n\n{% raw %}\n<div id=\"key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\" key=\"username-input\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\" key=\"email-input\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n注意, `<label>` 元素仍然会被复用，因为没有被添加了 `key` 属性。\n\n## `v-show`\n\n另一个根据条件展示元素的选项是 `v-show` 指令。用法大体上一样：\n\n``` html\n<h1 v-show=\"ok\">Hello!</h1>\n```\n\n不同的是有 `v-show` 的元素会始终渲染并保持在 DOM 中。`v-show` 是简单的切换元素的 CSS 属性 `display` 。\n\n<p class=\"tip\">注意 `v-show` 不支持 `<template>` 语法。</p>\n\n\n## `v-if` vs `v-show`\n\n`v-if` 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。\n\n`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。\n\n相比之下， `v-show` 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。\n\n一般来说， `v-if` 有更高的切换消耗而 `v-show` 有更高的初始渲染消耗。因此，如果需要频繁切换使用 `v-show` 较好，如果在运行时条件不大可能改变则使用 `v-if` 较好。\n\n\n***\n\n> 原文：http://vuejs.org/guide/conditional.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/conditional.html","comments":1,"layout":"page","_id":"ciwnajuyh0018jl2dfboumsrl","content":"<h2 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a><code>v-if</code></h2><p>在字符串模板中，如 Handlebars ，我们得像这样写一个条件块：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- Handlebars 模板 --&gt;</span></div><div class=\"line\">&#123;&#123;#if ok&#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Yes<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">&#123;&#123;/if&#125;&#125;</div></pre></td></tr></table></figure>\n<p>在 Vue.js ，我们使用 <code>v-if</code> 指令实现同样的功能：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Yes<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>也可以用 <code>v-else</code> 添加一个 “else” 块：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Yes<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-else</span>&gt;</span>No<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"lt-template-gt-中-v-if-条件组\"><a href=\"#lt-template-gt-中-v-if-条件组\" class=\"headerlink\" title=\"&lt;template&gt; 中 v-if 条件组\"></a><code>&lt;template&gt;</code> 中 <code>v-if</code> 条件组</h3><p>因为 <code>v-if</code> 是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个 <code>&lt;template&gt;</code> 元素当做包装元素，并在上面使用 <code>v-if</code>，最终的渲染结果不会包含它。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Paragraph 1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Paragraph 2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a><code>v-else</code></h3><p>可以用 <code>v-else</code> 指令给 <code>v-if</code> 添加一个 “else” 块：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"Math.random() &gt; 0.5\"</span>&gt;</span></div><div class=\"line\">  Sorry</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  Not sorry</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>v-else</code> 元素必须紧跟在 <code>v-if</code> 元素或者 <code>v-else-if</code>的后面——否则它不能被识别。</p>\n<h3 id=\"v-else-if\"><a href=\"#v-else-if\" class=\"headerlink\" title=\"v-else-if\"></a><code>v-else-if</code></h3><blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<p><code>v-else-if</code>，顾名思义，用作 <code>v-if</code> 的 <code>else-if</code> 块。可以链式的多次使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"type === 'A'\"</span>&gt;</span></div><div class=\"line\">  A</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'B'\"</span>&gt;</span></div><div class=\"line\">  B</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'C'\"</span>&gt;</span></div><div class=\"line\">  C</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  Not A/B/C</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>与 <code>v-else</code> 相似,，<code>v-else-if</code> 必须跟在 <code>v-if</code> 或者 <code>v-else-if</code>之后。</p>\n<h3 id=\"使用-key-控制元素的可重用\"><a href=\"#使用-key-控制元素的可重用\" class=\"headerlink\" title=\"使用 key 控制元素的可重用\"></a>使用 <code>key</code> 控制元素的可重用</h3><p>Vue 尝试尽可能高效的渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 更快之外还可以得到一些好处。如下例，当允许用户在不同的登录方式之间切换:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"loginType === 'username'\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Username<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter your username\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Email<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter your email address\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在代码中切换 <code>loginType</code> 不会删除用户已经输入的内容，两个模版由于使用了相同的元素，<code>&lt;input&gt;</code> 会被复用，仅仅是替换了他们的 <code>placeholder</code>。</p>\n<p>自己动手试一试,输入一些文本，然后点击 「Toggle login type」 进行切换</p>\n\n<div id=\"no-key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\">\n    </template>\n    <template v-else=\"\">\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#no-key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n\n<p>这样也不总是符合实际需求，所以 Vue 提供一种方式让你可以自己决定是否要复用元素。你要做的是添加一个属性 <code>key</code> ，<code>key</code> 必须带有唯一的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"loginType === 'username'\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Username<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter your username\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"username-input\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Email<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter your email address\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"email-input\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>现在输入文本将会在每次切换时重新渲染。自动动手试一试。</p>\n\n<div id=\"key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\" key=\"username-input\">\n    </template>\n    <template v-else=\"\">\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\" key=\"email-input\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n\n<p>注意, <code>&lt;label&gt;</code> 元素仍然会被复用，因为没有被添加了 <code>key</code> 属性。</p>\n<h2 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a><code>v-show</code></h2><p>另一个根据条件展示元素的选项是 <code>v-show</code> 指令。用法大体上一样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Hello!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>不同的是有 <code>v-show</code> 的元素会始终渲染并保持在 DOM 中。<code>v-show</code> 是简单的切换元素的 CSS 属性 <code>display</code> 。</p>\n<p class=\"tip\">注意 <code>v-show</code> 不支持 <code>&lt;template&gt;</code> 语法。</p>\n\n\n<h2 id=\"v-if-vs-v-show\"><a href=\"#v-if-vs-v-show\" class=\"headerlink\" title=\"v-if vs v-show\"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。</p>\n<p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。</p>\n<p>相比之下， <code>v-show</code> 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。</p>\n<p>一般来说， <code>v-if</code> 有更高的切换消耗而 <code>v-show</code> 有更高的初始渲染消耗。因此，如果需要频繁切换使用 <code>v-show</code> 较好，如果在运行时条件不大可能改变则使用 <code>v-if</code> 较好。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/conditional.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/conditional.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a><code>v-if</code></h2><p>在字符串模板中，如 Handlebars ，我们得像这样写一个条件块：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- Handlebars 模板 --&gt;</span></div><div class=\"line\">&#123;&#123;#if ok&#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Yes<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">&#123;&#123;/if&#125;&#125;</div></pre></td></tr></table></figure>\n<p>在 Vue.js ，我们使用 <code>v-if</code> 指令实现同样的功能：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Yes<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>也可以用 <code>v-else</code> 添加一个 “else” 块：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Yes<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-else</span>&gt;</span>No<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"lt-template-gt-中-v-if-条件组\"><a href=\"#lt-template-gt-中-v-if-条件组\" class=\"headerlink\" title=\"&lt;template&gt; 中 v-if 条件组\"></a><code>&lt;template&gt;</code> 中 <code>v-if</code> 条件组</h3><p>因为 <code>v-if</code> 是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个 <code>&lt;template&gt;</code> 元素当做包装元素，并在上面使用 <code>v-if</code>，最终的渲染结果不会包含它。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Paragraph 1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Paragraph 2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a><code>v-else</code></h3><p>可以用 <code>v-else</code> 指令给 <code>v-if</code> 添加一个 “else” 块：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"Math.random() &gt; 0.5\"</span>&gt;</span></div><div class=\"line\">  Sorry</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  Not sorry</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>v-else</code> 元素必须紧跟在 <code>v-if</code> 元素或者 <code>v-else-if</code>的后面——否则它不能被识别。</p>\n<h3 id=\"v-else-if\"><a href=\"#v-else-if\" class=\"headerlink\" title=\"v-else-if\"></a><code>v-else-if</code></h3><blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<p><code>v-else-if</code>，顾名思义，用作 <code>v-if</code> 的 <code>else-if</code> 块。可以链式的多次使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"type === 'A'\"</span>&gt;</span></div><div class=\"line\">  A</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'B'\"</span>&gt;</span></div><div class=\"line\">  B</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'C'\"</span>&gt;</span></div><div class=\"line\">  C</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  Not A/B/C</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>与 <code>v-else</code> 相似,，<code>v-else-if</code> 必须跟在 <code>v-if</code> 或者 <code>v-else-if</code>之后。</p>\n<h3 id=\"使用-key-控制元素的可重用\"><a href=\"#使用-key-控制元素的可重用\" class=\"headerlink\" title=\"使用 key 控制元素的可重用\"></a>使用 <code>key</code> 控制元素的可重用</h3><p>Vue 尝试尽可能高效的渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 更快之外还可以得到一些好处。如下例，当允许用户在不同的登录方式之间切换:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"loginType === 'username'\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Username<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter your username\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Email<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter your email address\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在代码中切换 <code>loginType</code> 不会删除用户已经输入的内容，两个模版由于使用了相同的元素，<code>&lt;input&gt;</code> 会被复用，仅仅是替换了他们的 <code>placeholder</code>。</p>\n<p>自己动手试一试,输入一些文本，然后点击 「Toggle login type」 进行切换</p>\n\n<div id=\"no-key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#no-key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n\n<p>这样也不总是符合实际需求，所以 Vue 提供一种方式让你可以自己决定是否要复用元素。你要做的是添加一个属性 <code>key</code> ，<code>key</code> 必须带有唯一的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"loginType === 'username'\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Username<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter your username\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"username-input\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Email<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter your email address\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"email-input\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>现在输入文本将会在每次切换时重新渲染。自动动手试一试。</p>\n\n<div id=\"key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\" key=\"username-input\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\" key=\"email-input\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n\n<p>注意, <code>&lt;label&gt;</code> 元素仍然会被复用，因为没有被添加了 <code>key</code> 属性。</p>\n<h2 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a><code>v-show</code></h2><p>另一个根据条件展示元素的选项是 <code>v-show</code> 指令。用法大体上一样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Hello!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>不同的是有 <code>v-show</code> 的元素会始终渲染并保持在 DOM 中。<code>v-show</code> 是简单的切换元素的 CSS 属性 <code>display</code> 。</p>\n<p class=\"tip\">注意 <code>v-show</code> 不支持 <code>&lt;template&gt;</code> 语法。</p>\n\n\n<h2 id=\"v-if-vs-v-show\"><a href=\"#v-if-vs-v-show\" class=\"headerlink\" title=\"v-if vs v-show\"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。</p>\n<p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。</p>\n<p>相比之下， <code>v-show</code> 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。</p>\n<p>一般来说， <code>v-if</code> 有更高的切换消耗而 <code>v-show</code> 有更高的初始渲染消耗。因此，如果需要频繁切换使用 <code>v-show</code> 较好，如果在运行时条件不大可能改变则使用 <code>v-if</code> 较好。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/conditional.html\">http://vuejs.org/guide/conditional.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"生产环境部署","type":"guide","order":20,"_content":"\n## 删除警告\n\n为了减少文件大小，Vue 精简独立版本已经删除了所有警告，但是当你使用 Webpack 或 Browserify 等工具时，你需要一些额外的配置实现这点。\n\n### Webpack\n\n使用 Webpack 的 [DefinePlugin](http://webpack.github.io/docs/list-of-plugins.html#defineplugin) 来指定生产环境，以便在压缩时可以让 UglifyJS 自动删除代码块内的警告语句。例如配置：\n\n``` js\nvar webpack = require('webpack')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    // ...\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"production\"'\n      }\n    }),\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false\n      }\n    })\n  ]\n}\n```\n\n### Browserify\n\n- 运行打包命令，设置 `NODE_ENV` 为 `\"production\"`。等于告诉 `vueify` 避免引入热重载和开发相关代码。\n- 使用一个全局 [envify](https://github.com/hughsk/envify) 转换你的 bundle 文件。这可以精简掉包含在 Vue 源码中所有环境变量条件相关代码块内的警告语句。例如：\n\n\n``` bash\nNODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js\n```\n\n- 使用 vueify 中包含的 extract-css 插件，提取样式到单独的css文件。\n\n``` bash\nNODE_ENV=production browserify -g envify -p [ vueify/plugins/extract-css -o build.css ] -e main.js | uglifyjs -c -m > build.js\n```\n\n## 跟踪运行时错误\n\n如果在组件渲染时出现运行错误，错误将会被传递至全局 `Vue.config.errorHandler` 配置函数（如果已设置）。利用这个钩子函数和错误跟踪服务（如 [Sentry](https://sentry.io)，它为 Vue 提供[官方集成](https://sentry.io/for/vue/)），可能是个不错的主意。\n\n## 提取 CSS\n\n使用[单文件组件](./single-file-components.html)时，`<style>` 标签在开发运行过程中会被动态实时注入。在生产环境中，你可能需要从所有组件中提取样式到单独的 CSS 文件中。有关如何实现的详细信息，请查阅 [vue-loader](http://vue-loader.vuejs.org/en/configurations/extract-css.html) 和 [vueify](https://github.com/vuejs/vueify#css-extraction) 相应文档。\n\n`vue-cli` 已经配置好了官方的 `webpack` 模板。\n","source":"v2/guide/deployment.md","raw":"---\ntitle: 生产环境部署\ntype: guide\norder: 20\n---\n\n## 删除警告\n\n为了减少文件大小，Vue 精简独立版本已经删除了所有警告，但是当你使用 Webpack 或 Browserify 等工具时，你需要一些额外的配置实现这点。\n\n### Webpack\n\n使用 Webpack 的 [DefinePlugin](http://webpack.github.io/docs/list-of-plugins.html#defineplugin) 来指定生产环境，以便在压缩时可以让 UglifyJS 自动删除代码块内的警告语句。例如配置：\n\n``` js\nvar webpack = require('webpack')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    // ...\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"production\"'\n      }\n    }),\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false\n      }\n    })\n  ]\n}\n```\n\n### Browserify\n\n- 运行打包命令，设置 `NODE_ENV` 为 `\"production\"`。等于告诉 `vueify` 避免引入热重载和开发相关代码。\n- 使用一个全局 [envify](https://github.com/hughsk/envify) 转换你的 bundle 文件。这可以精简掉包含在 Vue 源码中所有环境变量条件相关代码块内的警告语句。例如：\n\n\n``` bash\nNODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js\n```\n\n- 使用 vueify 中包含的 extract-css 插件，提取样式到单独的css文件。\n\n``` bash\nNODE_ENV=production browserify -g envify -p [ vueify/plugins/extract-css -o build.css ] -e main.js | uglifyjs -c -m > build.js\n```\n\n## 跟踪运行时错误\n\n如果在组件渲染时出现运行错误，错误将会被传递至全局 `Vue.config.errorHandler` 配置函数（如果已设置）。利用这个钩子函数和错误跟踪服务（如 [Sentry](https://sentry.io)，它为 Vue 提供[官方集成](https://sentry.io/for/vue/)），可能是个不错的主意。\n\n## 提取 CSS\n\n使用[单文件组件](./single-file-components.html)时，`<style>` 标签在开发运行过程中会被动态实时注入。在生产环境中，你可能需要从所有组件中提取样式到单独的 CSS 文件中。有关如何实现的详细信息，请查阅 [vue-loader](http://vue-loader.vuejs.org/en/configurations/extract-css.html) 和 [vueify](https://github.com/vuejs/vueify#css-extraction) 相应文档。\n\n`vue-cli` 已经配置好了官方的 `webpack` 模板。\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/deployment.html","comments":1,"layout":"page","_id":"ciwnajuyh0019jl2d4f00yx3n","content":"<h2 id=\"删除警告\"><a href=\"#删除警告\" class=\"headerlink\" title=\"删除警告\"></a>删除警告</h2><p>为了减少文件大小，Vue 精简独立版本已经删除了所有警告，但是当你使用 Webpack 或 Browserify 等工具时，你需要一些额外的配置实现这点。</p>\n<h3 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h3><p>使用 Webpack 的 <a href=\"http://webpack.github.io/docs/list-of-plugins.html#defineplugin\" target=\"_blank\" rel=\"external\">DefinePlugin</a> 来指定生产环境，以便在压缩时可以让 UglifyJS 自动删除代码块内的警告语句。例如配置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  plugins: [</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</div><div class=\"line\">      <span class=\"string\">'process.env'</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">NODE_ENV</span>: <span class=\"string\">'\"production\"'</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class=\"line\">      <span class=\"attr\">compress</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">warnings</span>: <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Browserify\"><a href=\"#Browserify\" class=\"headerlink\" title=\"Browserify\"></a>Browserify</h3><ul>\n<li>运行打包命令，设置 <code>NODE_ENV</code> 为 <code>&quot;production&quot;</code>。等于告诉 <code>vueify</code> 避免引入热重载和开发相关代码。</li>\n<li>使用一个全局 <a href=\"https://github.com/hughsk/envify\" target=\"_blank\" rel=\"external\">envify</a> 转换你的 bundle 文件。这可以精简掉包含在 Vue 源码中所有环境变量条件相关代码块内的警告语句。例如：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">NODE_ENV=production browserify -g envify <span class=\"_\">-e</span> main.js | uglifyjs -c -m &gt; build.js</div></pre></td></tr></table></figure>\n<ul>\n<li>使用 vueify 中包含的 extract-css 插件，提取样式到单独的css文件。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">NODE_ENV=production browserify -g envify -p [ vueify/plugins/extract-css -o build.css ] <span class=\"_\">-e</span> main.js | uglifyjs -c -m &gt; build.js</div></pre></td></tr></table></figure>\n<h2 id=\"跟踪运行时错误\"><a href=\"#跟踪运行时错误\" class=\"headerlink\" title=\"跟踪运行时错误\"></a>跟踪运行时错误</h2><p>如果在组件渲染时出现运行错误，错误将会被传递至全局 <code>Vue.config.errorHandler</code> 配置函数（如果已设置）。利用这个钩子函数和错误跟踪服务（如 <a href=\"https://sentry.io\" target=\"_blank\" rel=\"external\">Sentry</a>，它为 Vue 提供<a href=\"https://sentry.io/for/vue/\" target=\"_blank\" rel=\"external\">官方集成</a>），可能是个不错的主意。</p>\n<h2 id=\"提取-CSS\"><a href=\"#提取-CSS\" class=\"headerlink\" title=\"提取 CSS\"></a>提取 CSS</h2><p>使用<a href=\"./single-file-components.html\">单文件组件</a>时，<code>&lt;style&gt;</code> 标签在开发运行过程中会被动态实时注入。在生产环境中，你可能需要从所有组件中提取样式到单独的 CSS 文件中。有关如何实现的详细信息，请查阅 <a href=\"http://vue-loader.vuejs.org/en/configurations/extract-css.html\" target=\"_blank\" rel=\"external\">vue-loader</a> 和 <a href=\"https://github.com/vuejs/vueify#css-extraction\" target=\"_blank\" rel=\"external\">vueify</a> 相应文档。</p>\n<p><code>vue-cli</code> 已经配置好了官方的 <code>webpack</code> 模板。</p>\n","excerpt":"","more":"<h2 id=\"删除警告\"><a href=\"#删除警告\" class=\"headerlink\" title=\"删除警告\"></a>删除警告</h2><p>为了减少文件大小，Vue 精简独立版本已经删除了所有警告，但是当你使用 Webpack 或 Browserify 等工具时，你需要一些额外的配置实现这点。</p>\n<h3 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h3><p>使用 Webpack 的 <a href=\"http://webpack.github.io/docs/list-of-plugins.html#defineplugin\">DefinePlugin</a> 来指定生产环境，以便在压缩时可以让 UglifyJS 自动删除代码块内的警告语句。例如配置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  plugins: [</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</div><div class=\"line\">      <span class=\"string\">'process.env'</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">NODE_ENV</span>: <span class=\"string\">'\"production\"'</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class=\"line\">      <span class=\"attr\">compress</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">warnings</span>: <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Browserify\"><a href=\"#Browserify\" class=\"headerlink\" title=\"Browserify\"></a>Browserify</h3><ul>\n<li>运行打包命令，设置 <code>NODE_ENV</code> 为 <code>&quot;production&quot;</code>。等于告诉 <code>vueify</code> 避免引入热重载和开发相关代码。</li>\n<li>使用一个全局 <a href=\"https://github.com/hughsk/envify\">envify</a> 转换你的 bundle 文件。这可以精简掉包含在 Vue 源码中所有环境变量条件相关代码块内的警告语句。例如：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">NODE_ENV=production browserify -g envify <span class=\"_\">-e</span> main.js | uglifyjs -c -m &gt; build.js</div></pre></td></tr></table></figure>\n<ul>\n<li>使用 vueify 中包含的 extract-css 插件，提取样式到单独的css文件。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">NODE_ENV=production browserify -g envify -p [ vueify/plugins/extract-css -o build.css ] <span class=\"_\">-e</span> main.js | uglifyjs -c -m &gt; build.js</div></pre></td></tr></table></figure>\n<h2 id=\"跟踪运行时错误\"><a href=\"#跟踪运行时错误\" class=\"headerlink\" title=\"跟踪运行时错误\"></a>跟踪运行时错误</h2><p>如果在组件渲染时出现运行错误，错误将会被传递至全局 <code>Vue.config.errorHandler</code> 配置函数（如果已设置）。利用这个钩子函数和错误跟踪服务（如 <a href=\"https://sentry.io\">Sentry</a>，它为 Vue 提供<a href=\"https://sentry.io/for/vue/\">官方集成</a>），可能是个不错的主意。</p>\n<h2 id=\"提取-CSS\"><a href=\"#提取-CSS\" class=\"headerlink\" title=\"提取 CSS\"></a>提取 CSS</h2><p>使用<a href=\"./single-file-components.html\">单文件组件</a>时，<code>&lt;style&gt;</code> 标签在开发运行过程中会被动态实时注入。在生产环境中，你可能需要从所有组件中提取样式到单独的 CSS 文件中。有关如何实现的详细信息，请查阅 <a href=\"http://vue-loader.vuejs.org/en/configurations/extract-css.html\">vue-loader</a> 和 <a href=\"https://github.com/vuejs/vueify#css-extraction\">vueify</a> 相应文档。</p>\n<p><code>vue-cli</code> 已经配置好了官方的 <code>webpack</code> 模板。</p>\n"},{"title":"自定义指令","type":"guide","order":16,"_content":"\n## 简介\n\n除了默认设置的核心指令( `v-model` 和 `v-show` ),Vue 也允许注册自定义指令。注意，在 Vue2.0 里面，代码复用的主要形式和抽象是组件——然而，有的情况下,你仍然需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令。下面这个例子将聚焦一个 input 元素，像这样：\n\n{% raw %}\n<div id=\"simplest-directive-example\" class=\"demo\">\n  <input v-focus>\n</div>\n<script>\nVue.directive('focus', {\n  inserted: function (el) {\n    el.focus()\n  }\n})\nnew Vue({\n  el: '#simplest-directive-example'\n})\n</script>\n{% endraw %}\n\n当页面加载时，元素将获得焦点。事实上，你访问后还没点击任何内容，input 就获得了焦点。现在让我们完善这个指令：\n\n``` js\n// 注册一个全局自定义指令 v-focus\nVue.directive('focus', {\n  // 当绑定元素插入到 DOM 中。\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n```\n\n也可以注册局部指令，组件中接受一个 `directives` 的选项：\n\n``` js\ndirectives: {\n  focus: {\n    // 指令的定义---\n\n  }\n}\n```\n\n然后你可以在模板中任何元素上使用新的 `v-focus` 属性：\n\n``` html\n<input v-focus>\n```\n\n## 钩子函数\n\n指令定义函数提供了几个钩子函数（可选）：\n\n- `bind`: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。\n\n- `inserted`: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。\n  \n- `update`: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。\n\n- `componentUpdated`: 被绑定元素所在模板完成一次更新周期时调用。\n\n- `unbind`: 只调用一次， 指令与元素解绑时调用。\n\n接下来我们来看一下钩子函数的参数 (包括 `el`，`binding`，`vnode`，`oldVnode`) 。\n\n## 钩子函数参数\n\n钩子函数被赋予了以下参数：\n\n- **el**: 指令所绑定的元素，可以用来直接操作 DOM 。\n- **binding**: 一个对象，包含以下属性：\n  - **name**: 指令名，不包括 `v-` 前缀。\n  - **value**: 指令的绑定值， 例如： `v-my-directive=\"1 + 1\"`, value 的值是 `2`。\n  - **oldValue**: 指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\n  - **expression**: 绑定值的字符串形式。 例如 `v-my-directive=\"1 + 1\"` ， expression 的值是 `\"1 + 1\"`。\n  - **arg**: 传给指令的参数。例如 `v-my-directive:foo`， arg 的值是 `\"foo\"`。\n  - **modifiers**: 一个包含修饰符的对象。 例如： `v-my-directive.foo.bar`, 修饰符对象 modifiers 的值是 `{ foo: true, bar: true }`。\n- **vnode**: Vue 编译生成的虚拟节点，查阅 [VNode API](../api/#VNode接口) 了解更多详情。\n- **oldVnode**: 上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\n\n<p class=\"tip\">除了 `el` 之外，其它参数都应该是只读的，尽量不要修改他们。如果需要在钩子之间共享数据，建议通过元素的 [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset) 来进行。</p>\n\n一个使用了这些参数的自定义钩子样例：\n\n``` html\n<div id=\"hook-arguments-example\" v-demo:hello.a.b=\"message\"></div>\n```\n\n``` js\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\n\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n```\n\n{% raw %}\n<div id=\"hook-arguments-example\" v-demo:hello.a.b=\"message\" class=\"demo\"></div>\n<script>\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n</script>\n{% endraw %}\n\n## 函数简写\n\n大多数情况下，我们可能想在 `bind` 和 `update` 钩子上做重复动作，并且不想关心其它的钩子函数。可以这样写:\n\n``` js\nVue.directive('color-swatch', function (el, binding) {\n  el.style.backgroundColor = binding.value\n})\n```\n## 对象字面量\n\n如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法类型的 Javascript 表达式。\n\n``` html\n<div v-demo=\"{ color: 'white', text: 'hello!' }\"></div>\n```\n\n``` js\nVue.directive('demo', function (el, binding) {\n  console.log(binding.value.color) // => \"white\"\n  console.log(binding.value.text)  // => \"hello!\"\n})\n```\n\n***\n\n> 原文：http://vuejs.org/guide/custom-directive.html\n\n***\n","source":"v2/guide/custom-directive.md","raw":"---\ntitle: 自定义指令\ntype: guide\norder: 16\n---\n\n## 简介\n\n除了默认设置的核心指令( `v-model` 和 `v-show` ),Vue 也允许注册自定义指令。注意，在 Vue2.0 里面，代码复用的主要形式和抽象是组件——然而，有的情况下,你仍然需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令。下面这个例子将聚焦一个 input 元素，像这样：\n\n{% raw %}\n<div id=\"simplest-directive-example\" class=\"demo\">\n  <input v-focus>\n</div>\n<script>\nVue.directive('focus', {\n  inserted: function (el) {\n    el.focus()\n  }\n})\nnew Vue({\n  el: '#simplest-directive-example'\n})\n</script>\n{% endraw %}\n\n当页面加载时，元素将获得焦点。事实上，你访问后还没点击任何内容，input 就获得了焦点。现在让我们完善这个指令：\n\n``` js\n// 注册一个全局自定义指令 v-focus\nVue.directive('focus', {\n  // 当绑定元素插入到 DOM 中。\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n```\n\n也可以注册局部指令，组件中接受一个 `directives` 的选项：\n\n``` js\ndirectives: {\n  focus: {\n    // 指令的定义---\n\n  }\n}\n```\n\n然后你可以在模板中任何元素上使用新的 `v-focus` 属性：\n\n``` html\n<input v-focus>\n```\n\n## 钩子函数\n\n指令定义函数提供了几个钩子函数（可选）：\n\n- `bind`: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。\n\n- `inserted`: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。\n  \n- `update`: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。\n\n- `componentUpdated`: 被绑定元素所在模板完成一次更新周期时调用。\n\n- `unbind`: 只调用一次， 指令与元素解绑时调用。\n\n接下来我们来看一下钩子函数的参数 (包括 `el`，`binding`，`vnode`，`oldVnode`) 。\n\n## 钩子函数参数\n\n钩子函数被赋予了以下参数：\n\n- **el**: 指令所绑定的元素，可以用来直接操作 DOM 。\n- **binding**: 一个对象，包含以下属性：\n  - **name**: 指令名，不包括 `v-` 前缀。\n  - **value**: 指令的绑定值， 例如： `v-my-directive=\"1 + 1\"`, value 的值是 `2`。\n  - **oldValue**: 指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\n  - **expression**: 绑定值的字符串形式。 例如 `v-my-directive=\"1 + 1\"` ， expression 的值是 `\"1 + 1\"`。\n  - **arg**: 传给指令的参数。例如 `v-my-directive:foo`， arg 的值是 `\"foo\"`。\n  - **modifiers**: 一个包含修饰符的对象。 例如： `v-my-directive.foo.bar`, 修饰符对象 modifiers 的值是 `{ foo: true, bar: true }`。\n- **vnode**: Vue 编译生成的虚拟节点，查阅 [VNode API](../api/#VNode接口) 了解更多详情。\n- **oldVnode**: 上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\n\n<p class=\"tip\">除了 `el` 之外，其它参数都应该是只读的，尽量不要修改他们。如果需要在钩子之间共享数据，建议通过元素的 [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset) 来进行。</p>\n\n一个使用了这些参数的自定义钩子样例：\n\n``` html\n<div id=\"hook-arguments-example\" v-demo:hello.a.b=\"message\"></div>\n```\n\n``` js\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\n\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n```\n\n{% raw %}\n<div id=\"hook-arguments-example\" v-demo:hello.a.b=\"message\" class=\"demo\"></div>\n<script>\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n</script>\n{% endraw %}\n\n## 函数简写\n\n大多数情况下，我们可能想在 `bind` 和 `update` 钩子上做重复动作，并且不想关心其它的钩子函数。可以这样写:\n\n``` js\nVue.directive('color-swatch', function (el, binding) {\n  el.style.backgroundColor = binding.value\n})\n```\n## 对象字面量\n\n如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法类型的 Javascript 表达式。\n\n``` html\n<div v-demo=\"{ color: 'white', text: 'hello!' }\"></div>\n```\n\n``` js\nVue.directive('demo', function (el, binding) {\n  console.log(binding.value.color) // => \"white\"\n  console.log(binding.value.text)  // => \"hello!\"\n})\n```\n\n***\n\n> 原文：http://vuejs.org/guide/custom-directive.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/custom-directive.html","comments":1,"layout":"page","_id":"ciwnajuyi001ajl2didvpyzg1","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>除了默认设置的核心指令( <code>v-model</code> 和 <code>v-show</code> ),Vue 也允许注册自定义指令。注意，在 Vue2.0 里面，代码复用的主要形式和抽象是组件——然而，有的情况下,你仍然需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令。下面这个例子将聚焦一个 input 元素，像这样：</p>\n\n<div id=\"simplest-directive-example\" class=\"demo\">\n  <input v-focus=\"\">\n</div>\n<script>\nVue.directive('focus', {\n  inserted: function (el) {\n    el.focus()\n  }\n})\nnew Vue({\n  el: '#simplest-directive-example'\n})\n</script>\n\n<p>当页面加载时，元素将获得焦点。事实上，你访问后还没点击任何内容，input 就获得了焦点。现在让我们完善这个指令：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册一个全局自定义指令 v-focus</span></div><div class=\"line\">Vue.directive(<span class=\"string\">'focus'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// 当绑定元素插入到 DOM 中。</span></div><div class=\"line\">  inserted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 聚焦元素</span></div><div class=\"line\">    el.focus()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>也可以注册局部指令，组件中接受一个 <code>directives</code> 的选项：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">directives: &#123;</div><div class=\"line\">  <span class=\"attr\">focus</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 指令的定义---</span></div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> 属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-focus</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h2><p>指令定义函数提供了几个钩子函数（可选）：</p>\n<ul>\n<li><p><code>bind</code>: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</p>\n</li>\n<li><p><code>inserted</code>: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</p>\n</li>\n<li><p><code>update</code>: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</p>\n</li>\n<li><p><code>componentUpdated</code>: 被绑定元素所在模板完成一次更新周期时调用。</p>\n</li>\n<li><p><code>unbind</code>: 只调用一次， 指令与元素解绑时调用。</p>\n</li>\n</ul>\n<p>接下来我们来看一下钩子函数的参数 (包括 <code>el</code>，<code>binding</code>，<code>vnode</code>，<code>oldVnode</code>) 。</p>\n<h2 id=\"钩子函数参数\"><a href=\"#钩子函数参数\" class=\"headerlink\" title=\"钩子函数参数\"></a>钩子函数参数</h2><p>钩子函数被赋予了以下参数：</p>\n<ul>\n<li><strong>el</strong>: 指令所绑定的元素，可以用来直接操作 DOM 。</li>\n<li><strong>binding</strong>: 一个对象，包含以下属性：<ul>\n<li><strong>name</strong>: 指令名，不包括 <code>v-</code> 前缀。</li>\n<li><strong>value</strong>: 指令的绑定值， 例如： <code>v-my-directive=&quot;1 + 1&quot;</code>, value 的值是 <code>2</code>。</li>\n<li><strong>oldValue</strong>: 指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>\n<li><strong>expression</strong>: 绑定值的字符串形式。 例如 <code>v-my-directive=&quot;1 + 1&quot;</code> ， expression 的值是 <code>&quot;1 + 1&quot;</code>。</li>\n<li><strong>arg</strong>: 传给指令的参数。例如 <code>v-my-directive:foo</code>， arg 的值是 <code>&quot;foo&quot;</code>。</li>\n<li><strong>modifiers</strong>: 一个包含修饰符的对象。 例如： <code>v-my-directive.foo.bar</code>, 修饰符对象 modifiers 的值是 <code>{ foo: true, bar: true }</code>。</li>\n</ul>\n</li>\n<li><strong>vnode</strong>: Vue 编译生成的虚拟节点，查阅 <a href=\"../api/#VNode接口\">VNode API</a> 了解更多详情。</li>\n<li><strong>oldVnode</strong>: 上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>\n</ul>\n<p class=\"tip\">除了 <code>el</code> 之外，其它参数都应该是只读的，尽量不要修改他们。如果需要在钩子之间共享数据，建议通过元素的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\" target=\"_blank\" rel=\"external\">dataset</a> 来进行。</p>\n\n<p>一个使用了这些参数的自定义钩子样例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"hook-arguments-example\"</span> <span class=\"attr\">v-demo:hello.a.b</span>=<span class=\"string\">\"message\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.directive(<span class=\"string\">'demo'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">bind</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding, vnode</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"built_in\">JSON</span>.stringify</div><div class=\"line\">    el.innerHTML =</div><div class=\"line\">      <span class=\"string\">'name: '</span>       + s(binding.name) + <span class=\"string\">'&lt;br&gt;'</span> +</div><div class=\"line\">      <span class=\"string\">'value: '</span>      + s(binding.value) + <span class=\"string\">'&lt;br&gt;'</span> +</div><div class=\"line\">      <span class=\"string\">'expression: '</span> + s(binding.expression) + <span class=\"string\">'&lt;br&gt;'</span> +</div><div class=\"line\">      <span class=\"string\">'argument: '</span>   + s(binding.arg) + <span class=\"string\">'&lt;br&gt;'</span> +</div><div class=\"line\">      <span class=\"string\">'modifiers: '</span>  + s(binding.modifiers) + <span class=\"string\">'&lt;br&gt;'</span> +</div><div class=\"line\">      <span class=\"string\">'vnode keys: '</span> + <span class=\"built_in\">Object</span>.keys(vnode).join(<span class=\"string\">', '</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#hook-arguments-example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'hello!'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"hook-arguments-example\" v-demo:hello.a.b=\"message\" class=\"demo\"></div>\n<script>\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n</script>\n\n<h2 id=\"函数简写\"><a href=\"#函数简写\" class=\"headerlink\" title=\"函数简写\"></a>函数简写</h2><p>大多数情况下，我们可能想在 <code>bind</code> 和 <code>update</code> 钩子上做重复动作，并且不想关心其它的钩子函数。可以这样写:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.directive(<span class=\"string\">'color-swatch'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding</span>) </span>&#123;</div><div class=\"line\">  el.style.backgroundColor = binding.value</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h2><p>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法类型的 Javascript 表达式。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-demo</span>=<span class=\"string\">\"&#123; color: 'white', text: 'hello!' &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.directive(<span class=\"string\">'demo'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(binding.value.color) <span class=\"comment\">// =&gt; \"white\"</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(binding.value.text)  <span class=\"comment\">// =&gt; \"hello!\"</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/custom-directive.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/custom-directive.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>除了默认设置的核心指令( <code>v-model</code> 和 <code>v-show</code> ),Vue 也允许注册自定义指令。注意，在 Vue2.0 里面，代码复用的主要形式和抽象是组件——然而，有的情况下,你仍然需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令。下面这个例子将聚焦一个 input 元素，像这样：</p>\n\n<div id=\"simplest-directive-example\" class=\"demo\">\n  <input v-focus>\n</div>\n<script>\nVue.directive('focus', {\n  inserted: function (el) {\n    el.focus()\n  }\n})\nnew Vue({\n  el: '#simplest-directive-example'\n})\n</script>\n\n<p>当页面加载时，元素将获得焦点。事实上，你访问后还没点击任何内容，input 就获得了焦点。现在让我们完善这个指令：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册一个全局自定义指令 v-focus</span></div><div class=\"line\">Vue.directive(<span class=\"string\">'focus'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// 当绑定元素插入到 DOM 中。</span></div><div class=\"line\">  inserted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 聚焦元素</span></div><div class=\"line\">    el.focus()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>也可以注册局部指令，组件中接受一个 <code>directives</code> 的选项：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">directives: &#123;</div><div class=\"line\">  <span class=\"attr\">focus</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 指令的定义---</span></div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> 属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-focus</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h2><p>指令定义函数提供了几个钩子函数（可选）：</p>\n<ul>\n<li><p><code>bind</code>: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</p>\n</li>\n<li><p><code>inserted</code>: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</p>\n</li>\n<li><p><code>update</code>: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</p>\n</li>\n<li><p><code>componentUpdated</code>: 被绑定元素所在模板完成一次更新周期时调用。</p>\n</li>\n<li><p><code>unbind</code>: 只调用一次， 指令与元素解绑时调用。</p>\n</li>\n</ul>\n<p>接下来我们来看一下钩子函数的参数 (包括 <code>el</code>，<code>binding</code>，<code>vnode</code>，<code>oldVnode</code>) 。</p>\n<h2 id=\"钩子函数参数\"><a href=\"#钩子函数参数\" class=\"headerlink\" title=\"钩子函数参数\"></a>钩子函数参数</h2><p>钩子函数被赋予了以下参数：</p>\n<ul>\n<li><strong>el</strong>: 指令所绑定的元素，可以用来直接操作 DOM 。</li>\n<li><strong>binding</strong>: 一个对象，包含以下属性：<ul>\n<li><strong>name</strong>: 指令名，不包括 <code>v-</code> 前缀。</li>\n<li><strong>value</strong>: 指令的绑定值， 例如： <code>v-my-directive=&quot;1 + 1&quot;</code>, value 的值是 <code>2</code>。</li>\n<li><strong>oldValue</strong>: 指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>\n<li><strong>expression</strong>: 绑定值的字符串形式。 例如 <code>v-my-directive=&quot;1 + 1&quot;</code> ， expression 的值是 <code>&quot;1 + 1&quot;</code>。</li>\n<li><strong>arg</strong>: 传给指令的参数。例如 <code>v-my-directive:foo</code>， arg 的值是 <code>&quot;foo&quot;</code>。</li>\n<li><strong>modifiers</strong>: 一个包含修饰符的对象。 例如： <code>v-my-directive.foo.bar</code>, 修饰符对象 modifiers 的值是 <code>{ foo: true, bar: true }</code>。</li>\n</ul>\n</li>\n<li><strong>vnode</strong>: Vue 编译生成的虚拟节点，查阅 <a href=\"../api/#VNode接口\">VNode API</a> 了解更多详情。</li>\n<li><strong>oldVnode</strong>: 上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>\n</ul>\n<p class=\"tip\">除了 <code>el</code> 之外，其它参数都应该是只读的，尽量不要修改他们。如果需要在钩子之间共享数据，建议通过元素的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\">dataset</a> 来进行。</p>\n\n<p>一个使用了这些参数的自定义钩子样例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"hook-arguments-example\"</span> <span class=\"attr\">v-demo:hello.a.b</span>=<span class=\"string\">\"message\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.directive(<span class=\"string\">'demo'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">bind</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding, vnode</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"built_in\">JSON</span>.stringify</div><div class=\"line\">    el.innerHTML =</div><div class=\"line\">      <span class=\"string\">'name: '</span>       + s(binding.name) + <span class=\"string\">'&lt;br&gt;'</span> +</div><div class=\"line\">      <span class=\"string\">'value: '</span>      + s(binding.value) + <span class=\"string\">'&lt;br&gt;'</span> +</div><div class=\"line\">      <span class=\"string\">'expression: '</span> + s(binding.expression) + <span class=\"string\">'&lt;br&gt;'</span> +</div><div class=\"line\">      <span class=\"string\">'argument: '</span>   + s(binding.arg) + <span class=\"string\">'&lt;br&gt;'</span> +</div><div class=\"line\">      <span class=\"string\">'modifiers: '</span>  + s(binding.modifiers) + <span class=\"string\">'&lt;br&gt;'</span> +</div><div class=\"line\">      <span class=\"string\">'vnode keys: '</span> + <span class=\"built_in\">Object</span>.keys(vnode).join(<span class=\"string\">', '</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#hook-arguments-example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'hello!'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"hook-arguments-example\" v-demo:hello.a.b=\"message\" class=\"demo\"></div>\n<script>\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n</script>\n\n<h2 id=\"函数简写\"><a href=\"#函数简写\" class=\"headerlink\" title=\"函数简写\"></a>函数简写</h2><p>大多数情况下，我们可能想在 <code>bind</code> 和 <code>update</code> 钩子上做重复动作，并且不想关心其它的钩子函数。可以这样写:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.directive(<span class=\"string\">'color-swatch'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding</span>) </span>&#123;</div><div class=\"line\">  el.style.backgroundColor = binding.value</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h2><p>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法类型的 Javascript 表达式。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-demo</span>=<span class=\"string\">\"&#123; color: 'white', text: 'hello!' &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.directive(<span class=\"string\">'demo'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(binding.value.color) <span class=\"comment\">// =&gt; \"white\"</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(binding.value.text)  <span class=\"comment\">// =&gt; \"hello!\"</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/custom-directive.html\">http://vuejs.org/guide/custom-directive.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"表单控件绑定","type":"guide","order":10,"_content":"\n## 基础用法\n\n你可以用 `v-model` 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 `v-model` 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。\n\n<p class=\"tip\"> `v-model` 并不关心表单控件初始化所生成的值。因为它会选择 Vue 实例数据来作为具体的值。</p>\n\n<p class=\"tip\" id=\"vmodel-ime-tip\">For languages that require an [IME](https://en.wikipedia.org/wiki/Input_method) (Chinese, Japanese, Korean etc.), you'll notice that `v-model` doesn't get updated during IME composition. If you want to cater for these updates as well, use `input` event instead.</p>\n\n### 文本\n\n``` html\n<input v-model=\"message\" placeholder=\"edit me\">\n<p>Message is: {{ message }}</p>\n```\n\n{% raw %}\n<div id=\"example-1\" class=\"demo\">\n  <input v-model=\"message\" placeholder=\"edit me\">\n  <p>Message is: {{ message }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    message: ''\n  }\n})\n</script>\n{% endraw %}\n\n### 多行文本\n\n``` html\n<span>Multiline message is:</span>\n<p style=\"white-space: pre\">{{ message }}</p>\n<br>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n```\n\n{% raw %}\n<div id=\"example-textarea\" class=\"demo\">\n  <span>Multiline message is:</span>\n  <p style=\"white-space: pre\">{{ message }}</p>\n  <br>\n  <textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n</div>\n<script>\nnew Vue({\n  el: '#example-textarea',\n  data: {\n    message: ''\n  }\n})\n</script>\n{% endraw %}\n\n<p class=\"tip\">在文本区域插值( `<textarea>{{text}}</textarea>` ) 并不会生效，应用 `v-model` 来代替</p>\n\n### 复选框\n\n单个勾选框，逻辑值：\n\n``` html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n<label for=\"checkbox\">{{ checked }}</label>\n```\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n  <label for=\"checkbox\">{{ checked }}</label>\n</div>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    checked: false\n  }\n})\n</script>\n{% endraw %}\n\n多个勾选框，绑定到同一个数组：\n\n``` html\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n<label for=\"mike\">Mike</label>\n<br>\n<span>Checked names: {{ checkedNames }}</span>\n```\n\n``` js\nnew Vue({\n  el: '...',\n  data: {\n    checkedNames: []\n  }\n})\n```\n\n{% raw %}\n<div id=\"example-3\" class=\"demo\">\n  <input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n  <label for=\"jack\">Jack</label>\n  <input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n  <label for=\"john\">John</label>\n  <input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n  <label for=\"mike\">Mike</label>\n  <br>\n  <span>Checked names: {{ checkedNames }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    checkedNames: []\n  }\n})\n</script>\n{% endraw %}\n\n### 单选按钮\n\n\n``` html\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n<label for=\"one\">One</label>\n<br>\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n<label for=\"two\">Two</label>\n<br>\n<span>Picked: {{ picked }}</span>\n```\n{% raw %}\n<div id=\"example-4\" class=\"demo\">\n  <input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n  <label for=\"one\">One</label>\n  <br>\n  <input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n  <label for=\"two\">Two</label>\n  <br>\n  <span>Picked: {{ picked }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    picked: ''\n  }\n})\n</script>\n{% endraw %}\n\n### 选择列表\n\n单选列表:\n\n``` html\n<select v-model=\"selected\">\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n{% raw %}\n<div id=\"example-5\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    selected: null\n  }\n})\n</script>\n{% endraw %}\n\n多选列表（绑定到一个数组）：\n\n``` html\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<br>\n<span>Selected: {{ selected }}</span>\n```\n{% raw %}\n<div id=\"example-6\" class=\"demo\">\n  <select v-model=\"selected\" multiple style=\"width: 50px\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <br>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-6',\n  data: {\n    selected: []\n  }\n})\n</script>\n{% endraw %}\n\n动态选项，用 `v-for` 渲染：\n\n``` html\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" v-bind:value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n``` js\nnew Vue({\n  el: '...',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n```\n{% raw %}\n<div id=\"example-7\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option v-for=\"option in options\" v-bind:value=\"option.value\">\n      {{ option.text }}\n    </option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-7',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\n\n## 绑定 value\n\n对于单选按钮，勾选框及选择列表选项， `v-model` 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：\n\n``` html\n<!-- 当选中时，`picked` 为字符串 \"a\" -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\">\n\n<!-- `toggle` 为 true 或 false -->\n<input type=\"checkbox\" v-model=\"toggle\">\n\n<!-- 当选中时，`selected` 为字符串 \"abc\" -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select>\n```\n\n但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用 `v-bind` 实现，并且这个属性的值可以不是字符串。\n\n### 复选框\n\n``` html\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  v-bind:true-value=\"a\"\n  v-bind:false-value=\"b\"\n>\n```\n\n``` js\n// 当选中时\nvm.toggle === vm.a\n// 当没有选中时\nvm.toggle === vm.b\n```\n\n### 单选按钮\n\n``` html\n<input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\">\n```\n\n``` js\n// 当选中时\nvm.pick === vm.a\n```\n\n### 选择列表设置\n\n``` html\n<select v-model=\"selected\">\n    <!-- 内联对象字面量 -->\n  <option v-bind:value=\"{ number: 123 }\">123</option>\n</select>\n```\n\n``` js\n// 当选中时\ntypeof vm.selected // -> 'object'\nvm.selected.number // -> 123\n```\n\n## 修饰符\n\n### `.lazy`\n\n在默认情况下， `v-model` 在 `input` 事件中同步输入框的值与数据 (除了 [上述](#vmodel-ime-tip) IME 部分)，但你可以添加一个修饰符 `lazy` ，从而转变为在 `change` 事件中同步：\n\n``` html\n<!-- 在 \"change\" 而不是 \"input\" 事件中更新 -->\n<input v-model.lazy=\"msg\" >\n```\n\n\n### `.number`\n\n如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 `number` 给 `v-model` 来处理输入值：\n\n``` html\n<input v-model.number=\"age\" type=\"number\">\n```\n\n这通常很有用，因为在 `type=\"number\"` 时 HTML 中输入的值也总是会返回字符串类型。\n\n\n### `.trim`\n\n如果要自动过滤用户输入的首尾空格，可以添加 `trim` 修饰符到 `v-model` 上过滤输入：\n\n```html\n<input v-model.trim=\"msg\">\n```\n\n## `v-model` 与组件\n\n> 如果你还不熟悉Vue的组件，跳过这里即可。\n\nHTML 内建的 input 类型有时不能满足你的需求。还好，Vue 的组件系统允许你创建一个具有自定义行为可复用的 input 类型，这些 input 类型甚至可以和 `v-model` 一起使用！要了解更多，请参阅[自定义 input 类型](components.html#Form-Input-Components-using-Custom-Events)\n\n***\n\n> 原文：http://vuejs.org/guide/forms.html\n\n***\n\n\n","source":"v2/guide/forms.md","raw":"---\ntitle: 表单控件绑定\ntype: guide\norder: 10\n---\n\n## 基础用法\n\n你可以用 `v-model` 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 `v-model` 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。\n\n<p class=\"tip\"> `v-model` 并不关心表单控件初始化所生成的值。因为它会选择 Vue 实例数据来作为具体的值。</p>\n\n<p class=\"tip\" id=\"vmodel-ime-tip\">For languages that require an [IME](https://en.wikipedia.org/wiki/Input_method) (Chinese, Japanese, Korean etc.), you'll notice that `v-model` doesn't get updated during IME composition. If you want to cater for these updates as well, use `input` event instead.</p>\n\n### 文本\n\n``` html\n<input v-model=\"message\" placeholder=\"edit me\">\n<p>Message is: {{ message }}</p>\n```\n\n{% raw %}\n<div id=\"example-1\" class=\"demo\">\n  <input v-model=\"message\" placeholder=\"edit me\">\n  <p>Message is: {{ message }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    message: ''\n  }\n})\n</script>\n{% endraw %}\n\n### 多行文本\n\n``` html\n<span>Multiline message is:</span>\n<p style=\"white-space: pre\">{{ message }}</p>\n<br>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n```\n\n{% raw %}\n<div id=\"example-textarea\" class=\"demo\">\n  <span>Multiline message is:</span>\n  <p style=\"white-space: pre\">{{ message }}</p>\n  <br>\n  <textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n</div>\n<script>\nnew Vue({\n  el: '#example-textarea',\n  data: {\n    message: ''\n  }\n})\n</script>\n{% endraw %}\n\n<p class=\"tip\">在文本区域插值( `<textarea>{{text}}</textarea>` ) 并不会生效，应用 `v-model` 来代替</p>\n\n### 复选框\n\n单个勾选框，逻辑值：\n\n``` html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n<label for=\"checkbox\">{{ checked }}</label>\n```\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n  <label for=\"checkbox\">{{ checked }}</label>\n</div>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    checked: false\n  }\n})\n</script>\n{% endraw %}\n\n多个勾选框，绑定到同一个数组：\n\n``` html\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n<label for=\"mike\">Mike</label>\n<br>\n<span>Checked names: {{ checkedNames }}</span>\n```\n\n``` js\nnew Vue({\n  el: '...',\n  data: {\n    checkedNames: []\n  }\n})\n```\n\n{% raw %}\n<div id=\"example-3\" class=\"demo\">\n  <input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n  <label for=\"jack\">Jack</label>\n  <input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n  <label for=\"john\">John</label>\n  <input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n  <label for=\"mike\">Mike</label>\n  <br>\n  <span>Checked names: {{ checkedNames }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    checkedNames: []\n  }\n})\n</script>\n{% endraw %}\n\n### 单选按钮\n\n\n``` html\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n<label for=\"one\">One</label>\n<br>\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n<label for=\"two\">Two</label>\n<br>\n<span>Picked: {{ picked }}</span>\n```\n{% raw %}\n<div id=\"example-4\" class=\"demo\">\n  <input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n  <label for=\"one\">One</label>\n  <br>\n  <input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n  <label for=\"two\">Two</label>\n  <br>\n  <span>Picked: {{ picked }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    picked: ''\n  }\n})\n</script>\n{% endraw %}\n\n### 选择列表\n\n单选列表:\n\n``` html\n<select v-model=\"selected\">\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n{% raw %}\n<div id=\"example-5\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    selected: null\n  }\n})\n</script>\n{% endraw %}\n\n多选列表（绑定到一个数组）：\n\n``` html\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<br>\n<span>Selected: {{ selected }}</span>\n```\n{% raw %}\n<div id=\"example-6\" class=\"demo\">\n  <select v-model=\"selected\" multiple style=\"width: 50px\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <br>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-6',\n  data: {\n    selected: []\n  }\n})\n</script>\n{% endraw %}\n\n动态选项，用 `v-for` 渲染：\n\n``` html\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" v-bind:value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n``` js\nnew Vue({\n  el: '...',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n```\n{% raw %}\n<div id=\"example-7\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option v-for=\"option in options\" v-bind:value=\"option.value\">\n      {{ option.text }}\n    </option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-7',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\n\n## 绑定 value\n\n对于单选按钮，勾选框及选择列表选项， `v-model` 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：\n\n``` html\n<!-- 当选中时，`picked` 为字符串 \"a\" -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\">\n\n<!-- `toggle` 为 true 或 false -->\n<input type=\"checkbox\" v-model=\"toggle\">\n\n<!-- 当选中时，`selected` 为字符串 \"abc\" -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select>\n```\n\n但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用 `v-bind` 实现，并且这个属性的值可以不是字符串。\n\n### 复选框\n\n``` html\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  v-bind:true-value=\"a\"\n  v-bind:false-value=\"b\"\n>\n```\n\n``` js\n// 当选中时\nvm.toggle === vm.a\n// 当没有选中时\nvm.toggle === vm.b\n```\n\n### 单选按钮\n\n``` html\n<input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\">\n```\n\n``` js\n// 当选中时\nvm.pick === vm.a\n```\n\n### 选择列表设置\n\n``` html\n<select v-model=\"selected\">\n    <!-- 内联对象字面量 -->\n  <option v-bind:value=\"{ number: 123 }\">123</option>\n</select>\n```\n\n``` js\n// 当选中时\ntypeof vm.selected // -> 'object'\nvm.selected.number // -> 123\n```\n\n## 修饰符\n\n### `.lazy`\n\n在默认情况下， `v-model` 在 `input` 事件中同步输入框的值与数据 (除了 [上述](#vmodel-ime-tip) IME 部分)，但你可以添加一个修饰符 `lazy` ，从而转变为在 `change` 事件中同步：\n\n``` html\n<!-- 在 \"change\" 而不是 \"input\" 事件中更新 -->\n<input v-model.lazy=\"msg\" >\n```\n\n\n### `.number`\n\n如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 `number` 给 `v-model` 来处理输入值：\n\n``` html\n<input v-model.number=\"age\" type=\"number\">\n```\n\n这通常很有用，因为在 `type=\"number\"` 时 HTML 中输入的值也总是会返回字符串类型。\n\n\n### `.trim`\n\n如果要自动过滤用户输入的首尾空格，可以添加 `trim` 修饰符到 `v-model` 上过滤输入：\n\n```html\n<input v-model.trim=\"msg\">\n```\n\n## `v-model` 与组件\n\n> 如果你还不熟悉Vue的组件，跳过这里即可。\n\nHTML 内建的 input 类型有时不能满足你的需求。还好，Vue 的组件系统允许你创建一个具有自定义行为可复用的 input 类型，这些 input 类型甚至可以和 `v-model` 一起使用！要了解更多，请参阅[自定义 input 类型](components.html#Form-Input-Components-using-Custom-Events)\n\n***\n\n> 原文：http://vuejs.org/guide/forms.html\n\n***\n\n\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/forms.html","comments":1,"layout":"page","_id":"ciwnajuyi001bjl2d731bkogz","content":"<h2 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h2><p>你可以用 <code>v-model</code> 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。</p>\n<p class=\"tip\"> <code>v-model</code> 并不关心表单控件初始化所生成的值。因为它会选择 Vue 实例数据来作为具体的值。</p>\n\n<p class=\"tip\" id=\"vmodel-ime-tip\">For languages that require an <a href=\"https://en.wikipedia.org/wiki/Input_method\" target=\"_blank\" rel=\"external\">IME</a> (Chinese, Japanese, Korean etc.), you’ll notice that <code>v-model</code> doesn’t get updated during IME composition. If you want to cater for these updates as well, use <code>input</code> event instead.</p>\n\n<h3 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"edit me\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-1\" class=\"demo\">\n  <input v-model=\"message\" placeholder=\"edit me\">\n  <p>Message is: {{ message }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    message: ''\n  }\n})\n</script>\n\n<h3 id=\"多行文本\"><a href=\"#多行文本\" class=\"headerlink\" title=\"多行文本\"></a>多行文本</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Multiline message is:<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"white-space: pre\"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"add multiple lines\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-textarea\" class=\"demo\">\n  <span>Multiline message is:</span>\n  <p style=\"white-space: pre\">{{ message }}</p>\n  <br>\n  <textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n</div>\n<script>\nnew Vue({\n  el: '#example-textarea',\n  data: {\n    message: ''\n  }\n})\n</script>\n\n<p class=\"tip\">在文本区域插值( <code>&lt;textarea&gt;&lt;/textarea&gt;</code> ) 并不会生效，应用 <code>v-model</code> 来代替</p>\n\n<h3 id=\"复选框\"><a href=\"#复选框\" class=\"headerlink\" title=\"复选框\"></a>复选框</h3><p>单个勾选框，逻辑值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checked\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"checkbox\"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-2\" class=\"demo\">\n  <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n  <label for=\"checkbox\">{{ checked }}</label>\n</div>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    checked: false\n  }\n})\n</script>\n\n<p>多个勾选框，绑定到同一个数组：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"jack\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Jack\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"jack\"</span>&gt;</span>Jack<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"john\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"John\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"john\"</span>&gt;</span>John<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mike\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Mike\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"mike\"</span>&gt;</span>Mike<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'...'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">checkedNames</span>: []</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"example-3\" class=\"demo\">\n  <input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n  <label for=\"jack\">Jack</label>\n  <input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n  <label for=\"john\">John</label>\n  <input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n  <label for=\"mike\">Mike</label>\n  <br>\n  <span>Checked names: {{ checkedNames }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    checkedNames: []\n  }\n})\n</script>\n\n<h3 id=\"单选按钮\"><a href=\"#单选按钮\" class=\"headerlink\" title=\"单选按钮\"></a>单选按钮</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"one\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"One\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"picked\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"one\"</span>&gt;</span>One<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"two\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Two\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"picked\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"two\"</span>&gt;</span>Two<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-4\" class=\"demo\">\n  <input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n  <label for=\"one\">One</label>\n  <br>\n  <input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n  <label for=\"two\">Two</label>\n  <br>\n  <span>Picked: {{ picked }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    picked: ''\n  }\n})\n</script>\n\n<h3 id=\"选择列表\"><a href=\"#选择列表\" class=\"headerlink\" title=\"选择列表\"></a>选择列表</h3><p>单选列表:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>C<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-5\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    selected: null\n  }\n})\n</script>\n\n<p>多选列表（绑定到一个数组）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span> <span class=\"attr\">multiple</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>C<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-6\" class=\"demo\">\n  <select v-model=\"selected\" multiple style=\"width: 50px\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <br>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-6',\n  data: {\n    selected: []\n  }\n})\n</script>\n\n<p>动态选项，用 <code>v-for</code> 渲染：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"option in options\"</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"option.value\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; option.text &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'...'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">selected</span>: <span class=\"string\">'A'</span>,</div><div class=\"line\">    <span class=\"attr\">options</span>: [</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'One'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'A'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Two'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'B'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Three'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'C'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"example-7\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option v-for=\"option in options\" v-bind:value=\"option.value\">\n      {{ option.text }}\n    </option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-7',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n</script>\n\n<h2 id=\"绑定-value\"><a href=\"#绑定-value\" class=\"headerlink\" title=\"绑定 value\"></a>绑定 value</h2><p>对于单选按钮，勾选框及选择列表选项， <code>v-model</code> 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 当选中时，`picked` 为字符串 \"a\" --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"picked\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"a\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- `toggle` 为 true 或 false --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"toggle\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 当选中时，`selected` 为字符串 \"abc\" --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"abc\"</span>&gt;</span>ABC<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用 <code>v-bind</code> 实现，并且这个属性的值可以不是字符串。</p>\n<h3 id=\"复选框-1\"><a href=\"#复选框-1\" class=\"headerlink\" title=\"复选框\"></a>复选框</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span></span></div><div class=\"line\">  <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span></div><div class=\"line\">  <span class=\"attr\">v-model</span>=<span class=\"string\">\"toggle\"</span></div><div class=\"line\">  <span class=\"attr\">v-bind:true-value</span>=<span class=\"string\">\"a\"</span></div><div class=\"line\">  <span class=\"attr\">v-bind:false-value</span>=<span class=\"string\">\"b\"</span></div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 当选中时</span></div><div class=\"line\">vm.toggle === vm.a</div><div class=\"line\"><span class=\"comment\">// 当没有选中时</span></div><div class=\"line\">vm.toggle === vm.b</div></pre></td></tr></table></figure>\n<h3 id=\"单选按钮-1\"><a href=\"#单选按钮-1\" class=\"headerlink\" title=\"单选按钮\"></a>单选按钮</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"pick\"</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"a\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 当选中时</span></div><div class=\"line\">vm.pick === vm.a</div></pre></td></tr></table></figure>\n<h3 id=\"选择列表设置\"><a href=\"#选择列表设置\" class=\"headerlink\" title=\"选择列表设置\"></a>选择列表设置</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 内联对象字面量 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"&#123; number: 123 &#125;\"</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 当选中时</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> vm.selected <span class=\"comment\">// -&gt; 'object'</span></div><div class=\"line\">vm.selected.number <span class=\"comment\">// -&gt; 123</span></div></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><h3 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a><code>.lazy</code></h3><p>在默认情况下， <code>v-model</code> 在 <code>input</code> 事件中同步输入框的值与数据 (除了 <a href=\"#vmodel-ime-tip\">上述</a> IME 部分)，但你可以添加一个修饰符 <code>lazy</code> ，从而转变为在 <code>change</code> 事件中同步：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 在 \"change\" 而不是 \"input\" 事件中更新 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.lazy</span>=<span class=\"string\">\"msg\"</span> &gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a><code>.number</code></h3><p>如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 <code>number</code> 给 <code>v-model</code> 来处理输入值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这通常很有用，因为在 <code>type=&quot;number&quot;</code> 时 HTML 中输入的值也总是会返回字符串类型。</p>\n<h3 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a><code>.trim</code></h3><p>如果要自动过滤用户输入的首尾空格，可以添加 <code>trim</code> 修饰符到 <code>v-model</code> 上过滤输入：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.trim</span>=<span class=\"string\">\"msg\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"v-model-与组件\"><a href=\"#v-model-与组件\" class=\"headerlink\" title=\"v-model 与组件\"></a><code>v-model</code> 与组件</h2><blockquote>\n<p>如果你还不熟悉Vue的组件，跳过这里即可。</p>\n</blockquote>\n<p>HTML 内建的 input 类型有时不能满足你的需求。还好，Vue 的组件系统允许你创建一个具有自定义行为可复用的 input 类型，这些 input 类型甚至可以和 <code>v-model</code> 一起使用！要了解更多，请参阅<a href=\"components.html#Form-Input-Components-using-Custom-Events\">自定义 input 类型</a></p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/forms.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/forms.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h2><p>你可以用 <code>v-model</code> 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。</p>\n<p class=\"tip\"> <code>v-model</code> 并不关心表单控件初始化所生成的值。因为它会选择 Vue 实例数据来作为具体的值。</p>\n\n<p class=\"tip\" id=\"vmodel-ime-tip\">For languages that require an <a href=\"https://en.wikipedia.org/wiki/Input_method\">IME</a> (Chinese, Japanese, Korean etc.), you’ll notice that <code>v-model</code> doesn’t get updated during IME composition. If you want to cater for these updates as well, use <code>input</code> event instead.</p>\n\n<h3 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"edit me\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-1\" class=\"demo\">\n  <input v-model=\"message\" placeholder=\"edit me\">\n  <p>Message is: {{ message }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    message: ''\n  }\n})\n</script>\n\n<h3 id=\"多行文本\"><a href=\"#多行文本\" class=\"headerlink\" title=\"多行文本\"></a>多行文本</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Multiline message is:<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"white-space: pre\"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"add multiple lines\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-textarea\" class=\"demo\">\n  <span>Multiline message is:</span>\n  <p style=\"white-space: pre\">{{ message }}</p>\n  <br>\n  <textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n</div>\n<script>\nnew Vue({\n  el: '#example-textarea',\n  data: {\n    message: ''\n  }\n})\n</script>\n\n<p class=\"tip\">在文本区域插值( <code>&lt;textarea&gt;&lt;/textarea&gt;</code> ) 并不会生效，应用 <code>v-model</code> 来代替</p>\n\n<h3 id=\"复选框\"><a href=\"#复选框\" class=\"headerlink\" title=\"复选框\"></a>复选框</h3><p>单个勾选框，逻辑值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checked\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"checkbox\"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-2\" class=\"demo\">\n  <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n  <label for=\"checkbox\">{{ checked }}</label>\n</div>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    checked: false\n  }\n})\n</script>\n\n<p>多个勾选框，绑定到同一个数组：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"jack\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Jack\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"jack\"</span>&gt;</span>Jack<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"john\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"John\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"john\"</span>&gt;</span>John<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mike\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Mike\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"mike\"</span>&gt;</span>Mike<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'...'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">checkedNames</span>: []</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"example-3\" class=\"demo\">\n  <input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n  <label for=\"jack\">Jack</label>\n  <input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n  <label for=\"john\">John</label>\n  <input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n  <label for=\"mike\">Mike</label>\n  <br>\n  <span>Checked names: {{ checkedNames }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    checkedNames: []\n  }\n})\n</script>\n\n<h3 id=\"单选按钮\"><a href=\"#单选按钮\" class=\"headerlink\" title=\"单选按钮\"></a>单选按钮</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"one\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"One\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"picked\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"one\"</span>&gt;</span>One<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"two\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Two\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"picked\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"two\"</span>&gt;</span>Two<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-4\" class=\"demo\">\n  <input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n  <label for=\"one\">One</label>\n  <br>\n  <input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n  <label for=\"two\">Two</label>\n  <br>\n  <span>Picked: {{ picked }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    picked: ''\n  }\n})\n</script>\n\n<h3 id=\"选择列表\"><a href=\"#选择列表\" class=\"headerlink\" title=\"选择列表\"></a>选择列表</h3><p>单选列表:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>C<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-5\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    selected: null\n  }\n})\n</script>\n\n<p>多选列表（绑定到一个数组）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span> <span class=\"attr\">multiple</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>C<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"example-6\" class=\"demo\">\n  <select v-model=\"selected\" multiple style=\"width: 50px\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <br>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-6',\n  data: {\n    selected: []\n  }\n})\n</script>\n\n<p>动态选项，用 <code>v-for</code> 渲染：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"option in options\"</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"option.value\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; option.text &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'...'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">selected</span>: <span class=\"string\">'A'</span>,</div><div class=\"line\">    <span class=\"attr\">options</span>: [</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'One'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'A'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Two'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'B'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Three'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'C'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"example-7\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option v-for=\"option in options\" v-bind:value=\"option.value\">\n      {{ option.text }}\n    </option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-7',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n</script>\n\n<h2 id=\"绑定-value\"><a href=\"#绑定-value\" class=\"headerlink\" title=\"绑定 value\"></a>绑定 value</h2><p>对于单选按钮，勾选框及选择列表选项， <code>v-model</code> 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 当选中时，`picked` 为字符串 \"a\" --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"picked\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"a\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- `toggle` 为 true 或 false --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"toggle\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 当选中时，`selected` 为字符串 \"abc\" --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"abc\"</span>&gt;</span>ABC<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用 <code>v-bind</code> 实现，并且这个属性的值可以不是字符串。</p>\n<h3 id=\"复选框-1\"><a href=\"#复选框-1\" class=\"headerlink\" title=\"复选框\"></a>复选框</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span></div><div class=\"line\">  <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span></div><div class=\"line\">  <span class=\"attr\">v-model</span>=<span class=\"string\">\"toggle\"</span></div><div class=\"line\">  <span class=\"attr\">v-bind:true-value</span>=<span class=\"string\">\"a\"</span></div><div class=\"line\">  <span class=\"attr\">v-bind:false-value</span>=<span class=\"string\">\"b\"</span></div><div class=\"line\">&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 当选中时</span></div><div class=\"line\">vm.toggle === vm.a</div><div class=\"line\"><span class=\"comment\">// 当没有选中时</span></div><div class=\"line\">vm.toggle === vm.b</div></pre></td></tr></table></figure>\n<h3 id=\"单选按钮-1\"><a href=\"#单选按钮-1\" class=\"headerlink\" title=\"单选按钮\"></a>单选按钮</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"pick\"</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"a\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 当选中时</span></div><div class=\"line\">vm.pick === vm.a</div></pre></td></tr></table></figure>\n<h3 id=\"选择列表设置\"><a href=\"#选择列表设置\" class=\"headerlink\" title=\"选择列表设置\"></a>选择列表设置</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 内联对象字面量 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"&#123; number: 123 &#125;\"</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 当选中时</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> vm.selected <span class=\"comment\">// -&gt; 'object'</span></div><div class=\"line\">vm.selected.number <span class=\"comment\">// -&gt; 123</span></div></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><h3 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a><code>.lazy</code></h3><p>在默认情况下， <code>v-model</code> 在 <code>input</code> 事件中同步输入框的值与数据 (除了 <a href=\"#vmodel-ime-tip\">上述</a> IME 部分)，但你可以添加一个修饰符 <code>lazy</code> ，从而转变为在 <code>change</code> 事件中同步：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 在 \"change\" 而不是 \"input\" 事件中更新 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.lazy</span>=<span class=\"string\">\"msg\"</span> &gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a><code>.number</code></h3><p>如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 <code>number</code> 给 <code>v-model</code> 来处理输入值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这通常很有用，因为在 <code>type=&quot;number&quot;</code> 时 HTML 中输入的值也总是会返回字符串类型。</p>\n<h3 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a><code>.trim</code></h3><p>如果要自动过滤用户输入的首尾空格，可以添加 <code>trim</code> 修饰符到 <code>v-model</code> 上过滤输入：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.trim</span>=<span class=\"string\">\"msg\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"v-model-与组件\"><a href=\"#v-model-与组件\" class=\"headerlink\" title=\"v-model 与组件\"></a><code>v-model</code> 与组件</h2><blockquote>\n<p>如果你还不熟悉Vue的组件，跳过这里即可。</p>\n</blockquote>\n<p>HTML 内建的 input 类型有时不能满足你的需求。还好，Vue 的组件系统允许你创建一个具有自定义行为可复用的 input 类型，这些 input 类型甚至可以和 <code>v-model</code> 一起使用！要了解更多，请参阅<a href=\"components.html#Form-Input-Components-using-Custom-Events\">自定义 input 类型</a></p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/forms.html\">http://vuejs.org/guide/forms.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"事件处理器","type":"guide","order":9,"_content":"\n## 监听事件\n\n可以用 `v-on` 指令监听 DOM 事件来触发一些 JavaScript 代码。\n\n示例：\n\n``` html\n<div id=\"example-1\">\n  <button v-on:click=\"counter += 1\">增加 1</button>\n  <p>这个按钮被点击了 {{ counter }} 次。</p>\n</div>\n```\n``` js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n```\n\n结果：\n\n{% raw %}\n<div id=\"example-1\" class=\"demo\">\n  <button v-on:click=\"counter += 1\">增加 1</button>\n  <p>这个按钮被点击了 {{ counter }} 次。</p>\n</div>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n</script>\n{% endraw %}\n\n## 方法事件处理器\n\n许多事件处理的逻辑都很复杂，所以直接把 JavaScript 代码写在 `v-on` 指令中是不可行的。因此 `v-on` 可以接收一个定义的方法来调用。\n\n示例：\n\n``` html\n<div id=\"example-2\">\n  <!-- `greet` 是在下面定义的方法名 -->\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n```\n\n``` js\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  // 在 `methods` 对象中定义方法\n  methods: {\n    greet: function (event) {\n      // `this` 在方法里指当前 Vue 实例\n      alert('Hello ' + this.name + '!')\n      // `event` 是原生 DOM 事件\n      alert(event.target.tagName)\n    }\n  }\n})\n\n// 也可以用 JavaScript 直接调用方法\nexample2.greet() // -> 'Hello Vue.js!'\n```\n\n结果：\n\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  methods: {\n    greet: function (event) {\n      alert('Hello ' + this.name + '!')\n      alert(event.target.tagName)\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## 内联处理器方法\n\n除了直接绑定到一个方法，也可以用内联 JavaScript 语句：\n\n``` html\n<div id=\"example-3\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n```\n``` js\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n```\n\n结果：\n\n{% raw %}\n<div id=\"example-3\" class=\"demo\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n</script>\n{% endraw %}\n\n\n有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 `$event` 把它传入方法：\n\n``` html\n<button v-on:click=\"warn('Form cannot be submitted yet.', $event)\">Submit</button>\n```\n\n``` js\n// ...\nmethods: {\n  warn: function (message, event) {\n    // 现在我们可以访问原生事件对象\n    if (event) event.preventDefault()\n    alert(message)\n  }\n}\n```\n\n## 事件修饰符\n\n在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。\n\n为了解决这个问题， Vue.js 为 `v-on` 提供了 **事件修饰符**。通过由点(.)表示的指令后缀来调用修饰符。\n\n- `.stop`\n- `.prevent`\n- `.capture`\n- `.self`\n- `.once`\n\n``` html\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n> 2.1.4 新增\n\n``` html\n<!-- the click event will be triggered at most once -->\n<a v-on:click.once=\"doThis\"></a>\n```\n\nUnlike the other modifiers, which are exclusive to native DOM events, the `.once` modifier can also be used on [component events](components.html#Using-v-on-with-Custom-Events). If you haven't read about components yet, don't worry about this for now.\n\n## 按键修饰符\n\n在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符：\n\n``` html\n<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->\n<input v-on:keyup.13=\"submit\">\n```\n\n记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：\n\n``` html\n<!-- 同上 -->\n<input v-on:keyup.enter=\"submit\">\n\n<!-- 缩写语法 -->\n<input @keyup.enter=\"submit\">\n```\n\n全部的按键别名：\n\n- `.enter`\n- `.tab`\n- `.delete` (捕获 “删除” 和 “退格” 键)\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`\n\n可以通过全局 `config.keyCodes` 对象[自定义按键修饰符别名](../api/#keyCodes)：\n\n``` js\n// 可以使用 v-on:keyup.f1\nVue.config.keyCodes.f1 = 112\n```\n\n## 按键修饰符\n\n> 2.1.0 新增\n\n可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。\n\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n> Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.\n\nFor example:\n\n```html\n<!-- Alt + C -->\n<input @keyup.alt.67=\"clear\">\n\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n```\n\n## 为什么在 HTML 中监听事件?\n\n你可能注意到这种事件监听的方式违背了关注点分离（separation of concern）传统理念。不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 `v-on` 有几个好处：\n\n1. 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。\n\n2. 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。\n\n3. 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。\n\n***\n\n> 原文：http://vuejs.org/guide/events.html\n\n***\n\n\n","source":"v2/guide/events.md","raw":"---\ntitle: 事件处理器\ntype: guide\norder: 9\n---\n\n## 监听事件\n\n可以用 `v-on` 指令监听 DOM 事件来触发一些 JavaScript 代码。\n\n示例：\n\n``` html\n<div id=\"example-1\">\n  <button v-on:click=\"counter += 1\">增加 1</button>\n  <p>这个按钮被点击了 {{ counter }} 次。</p>\n</div>\n```\n``` js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n```\n\n结果：\n\n{% raw %}\n<div id=\"example-1\" class=\"demo\">\n  <button v-on:click=\"counter += 1\">增加 1</button>\n  <p>这个按钮被点击了 {{ counter }} 次。</p>\n</div>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n</script>\n{% endraw %}\n\n## 方法事件处理器\n\n许多事件处理的逻辑都很复杂，所以直接把 JavaScript 代码写在 `v-on` 指令中是不可行的。因此 `v-on` 可以接收一个定义的方法来调用。\n\n示例：\n\n``` html\n<div id=\"example-2\">\n  <!-- `greet` 是在下面定义的方法名 -->\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n```\n\n``` js\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  // 在 `methods` 对象中定义方法\n  methods: {\n    greet: function (event) {\n      // `this` 在方法里指当前 Vue 实例\n      alert('Hello ' + this.name + '!')\n      // `event` 是原生 DOM 事件\n      alert(event.target.tagName)\n    }\n  }\n})\n\n// 也可以用 JavaScript 直接调用方法\nexample2.greet() // -> 'Hello Vue.js!'\n```\n\n结果：\n\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  methods: {\n    greet: function (event) {\n      alert('Hello ' + this.name + '!')\n      alert(event.target.tagName)\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## 内联处理器方法\n\n除了直接绑定到一个方法，也可以用内联 JavaScript 语句：\n\n``` html\n<div id=\"example-3\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n```\n``` js\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n```\n\n结果：\n\n{% raw %}\n<div id=\"example-3\" class=\"demo\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n</script>\n{% endraw %}\n\n\n有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 `$event` 把它传入方法：\n\n``` html\n<button v-on:click=\"warn('Form cannot be submitted yet.', $event)\">Submit</button>\n```\n\n``` js\n// ...\nmethods: {\n  warn: function (message, event) {\n    // 现在我们可以访问原生事件对象\n    if (event) event.preventDefault()\n    alert(message)\n  }\n}\n```\n\n## 事件修饰符\n\n在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。\n\n为了解决这个问题， Vue.js 为 `v-on` 提供了 **事件修饰符**。通过由点(.)表示的指令后缀来调用修饰符。\n\n- `.stop`\n- `.prevent`\n- `.capture`\n- `.self`\n- `.once`\n\n``` html\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n> 2.1.4 新增\n\n``` html\n<!-- the click event will be triggered at most once -->\n<a v-on:click.once=\"doThis\"></a>\n```\n\nUnlike the other modifiers, which are exclusive to native DOM events, the `.once` modifier can also be used on [component events](components.html#Using-v-on-with-Custom-Events). If you haven't read about components yet, don't worry about this for now.\n\n## 按键修饰符\n\n在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符：\n\n``` html\n<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->\n<input v-on:keyup.13=\"submit\">\n```\n\n记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：\n\n``` html\n<!-- 同上 -->\n<input v-on:keyup.enter=\"submit\">\n\n<!-- 缩写语法 -->\n<input @keyup.enter=\"submit\">\n```\n\n全部的按键别名：\n\n- `.enter`\n- `.tab`\n- `.delete` (捕获 “删除” 和 “退格” 键)\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`\n\n可以通过全局 `config.keyCodes` 对象[自定义按键修饰符别名](../api/#keyCodes)：\n\n``` js\n// 可以使用 v-on:keyup.f1\nVue.config.keyCodes.f1 = 112\n```\n\n## 按键修饰符\n\n> 2.1.0 新增\n\n可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。\n\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n> Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.\n\nFor example:\n\n```html\n<!-- Alt + C -->\n<input @keyup.alt.67=\"clear\">\n\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n```\n\n## 为什么在 HTML 中监听事件?\n\n你可能注意到这种事件监听的方式违背了关注点分离（separation of concern）传统理念。不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 `v-on` 有几个好处：\n\n1. 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。\n\n2. 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。\n\n3. 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。\n\n***\n\n> 原文：http://vuejs.org/guide/events.html\n\n***\n\n\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/events.html","comments":1,"layout":"page","_id":"ciwnajuyj001cjl2d8evgs8xs","content":"<h2 id=\"监听事件\"><a href=\"#监听事件\" class=\"headerlink\" title=\"监听事件\"></a>监听事件</h2><p>可以用 <code>v-on</code> 指令监听 DOM 事件来触发一些 JavaScript 代码。</p>\n<p>示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-1\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"counter += 1\"</span>&gt;</span>增加 1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> example1 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-1'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">counter</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"example-1\" class=\"demo\">\n  <button v-on:click=\"counter += 1\">增加 1</button>\n  <p>这个按钮被点击了 {{ counter }} 次。</p>\n</div>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n</script>\n\n<h2 id=\"方法事件处理器\"><a href=\"#方法事件处理器\" class=\"headerlink\" title=\"方法事件处理器\"></a>方法事件处理器</h2><p>许多事件处理的逻辑都很复杂，所以直接把 JavaScript 代码写在 <code>v-on</code> 指令中是不可行的。因此 <code>v-on</code> 可以接收一个定义的方法来调用。</p>\n<p>示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"greet\"</span>&gt;</span>Greet<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-2'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">'Vue.js'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 在 `methods` 对象中定义方法</span></div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    <span class=\"attr\">greet</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// `this` 在方法里指当前 Vue 实例</span></div><div class=\"line\">      alert(<span class=\"string\">'Hello '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>)</div><div class=\"line\">      <span class=\"comment\">// `event` 是原生 DOM 事件</span></div><div class=\"line\">      alert(event.target.tagName)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 也可以用 JavaScript 直接调用方法</span></div><div class=\"line\">example2.greet() <span class=\"comment\">// -&gt; 'Hello Vue.js!'</span></div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"example-2\" class=\"demo\">\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  methods: {\n    greet: function (event) {\n      alert('Hello ' + this.name + '!')\n      alert(event.target.tagName)\n    }\n  }\n})\n</script>\n\n<h2 id=\"内联处理器方法\"><a href=\"#内联处理器方法\" class=\"headerlink\" title=\"内联处理器方法\"></a>内联处理器方法</h2><p>除了直接绑定到一个方法，也可以用内联 JavaScript 语句：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-3\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"say('hi')\"</span>&gt;</span>Say hi<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"say('what')\"</span>&gt;</span>Say what<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-3'</span>,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message</span>) </span>&#123;</div><div class=\"line\">      alert(message)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"example-3\" class=\"demo\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n</script>\n\n<p>有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"warn('Form cannot be submitted yet.', $event)\"</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">warn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message, event</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 现在我们可以访问原生事件对象</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (event) event.preventDefault()</div><div class=\"line\">    alert(message)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>\n<p>为了解决这个问题， Vue.js 为 <code>v-on</code> 提供了 <strong>事件修饰符</strong>。通过由点(.)表示的指令后缀来调用修饰符。</p>\n<ul>\n<li><code>.stop</code></li>\n<li><code>.prevent</code></li>\n<li><code>.capture</code></li>\n<li><code>.self</code></li>\n<li><code>.once</code></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 阻止单击事件冒泡 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.stop</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 提交事件不再重载页面 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 修饰符可以串联  --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.stop.prevent</span>=<span class=\"string\">\"doThat\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 只有修饰符 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:click.capture</span>=<span class=\"string\">\"doThis\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:click.self</span>=<span class=\"string\">\"doThat\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>2.1.4 新增</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- the click event will be triggered at most once --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.once</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Unlike the other modifiers, which are exclusive to native DOM events, the <code>.once</code> modifier can also be used on <a href=\"components.html#Using-v-on-with-Custom-Events\">component events</a>. If you haven’t read about components yet, don’t worry about this for now.</p>\n<h2 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup.13</span>=<span class=\"string\">\"submit\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 同上 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup.enter</span>=<span class=\"string\">\"submit\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 缩写语法 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.enter</span>=<span class=\"string\">\"submit\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>全部的按键别名：</p>\n<ul>\n<li><code>.enter</code></li>\n<li><code>.tab</code></li>\n<li><code>.delete</code> (捕获 “删除” 和 “退格” 键)</li>\n<li><code>.esc</code></li>\n<li><code>.space</code></li>\n<li><code>.up</code></li>\n<li><code>.down</code></li>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n</ul>\n<p>可以通过全局 <code>config.keyCodes</code> 对象<a href=\"../api/#keyCodes\">自定义按键修饰符别名</a>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 可以使用 v-on:keyup.f1</span></div><div class=\"line\">Vue.config.keyCodes.f1 = <span class=\"number\">112</span></div></pre></td></tr></table></figure>\n<h2 id=\"按键修饰符-1\"><a href=\"#按键修饰符-1\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h2><blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<p>可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。</p>\n<ul>\n<li><code>.ctrl</code></li>\n<li><code>.alt</code></li>\n<li><code>.shift</code></li>\n<li><code>.meta</code></li>\n</ul>\n<blockquote>\n<p>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.</p>\n</blockquote>\n<p>For example:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- Alt + C --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.alt.67</span>=<span class=\"string\">\"clear\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- Ctrl + Click --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> @<span class=\"attr\">click.ctrl</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span>Do something<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"为什么在-HTML-中监听事件\"><a href=\"#为什么在-HTML-中监听事件\" class=\"headerlink\" title=\"为什么在 HTML 中监听事件?\"></a>为什么在 HTML 中监听事件?</h2><p>你可能注意到这种事件监听的方式违背了关注点分离（separation of concern）传统理念。不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 <code>v-on</code> 有几个好处：</p>\n<ol>\n<li><p>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</p>\n</li>\n<li><p>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</p>\n</li>\n<li><p>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</p>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/events.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/events.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"监听事件\"><a href=\"#监听事件\" class=\"headerlink\" title=\"监听事件\"></a>监听事件</h2><p>可以用 <code>v-on</code> 指令监听 DOM 事件来触发一些 JavaScript 代码。</p>\n<p>示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-1\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"counter += 1\"</span>&gt;</span>增加 1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> example1 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-1'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">counter</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"example-1\" class=\"demo\">\n  <button v-on:click=\"counter += 1\">增加 1</button>\n  <p>这个按钮被点击了 {{ counter }} 次。</p>\n</div>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n</script>\n\n<h2 id=\"方法事件处理器\"><a href=\"#方法事件处理器\" class=\"headerlink\" title=\"方法事件处理器\"></a>方法事件处理器</h2><p>许多事件处理的逻辑都很复杂，所以直接把 JavaScript 代码写在 <code>v-on</code> 指令中是不可行的。因此 <code>v-on</code> 可以接收一个定义的方法来调用。</p>\n<p>示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"greet\"</span>&gt;</span>Greet<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-2'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">'Vue.js'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 在 `methods` 对象中定义方法</span></div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    <span class=\"attr\">greet</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// `this` 在方法里指当前 Vue 实例</span></div><div class=\"line\">      alert(<span class=\"string\">'Hello '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>)</div><div class=\"line\">      <span class=\"comment\">// `event` 是原生 DOM 事件</span></div><div class=\"line\">      alert(event.target.tagName)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 也可以用 JavaScript 直接调用方法</span></div><div class=\"line\">example2.greet() <span class=\"comment\">// -&gt; 'Hello Vue.js!'</span></div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"example-2\" class=\"demo\">\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  methods: {\n    greet: function (event) {\n      alert('Hello ' + this.name + '!')\n      alert(event.target.tagName)\n    }\n  }\n})\n</script>\n\n<h2 id=\"内联处理器方法\"><a href=\"#内联处理器方法\" class=\"headerlink\" title=\"内联处理器方法\"></a>内联处理器方法</h2><p>除了直接绑定到一个方法，也可以用内联 JavaScript 语句：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-3\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"say('hi')\"</span>&gt;</span>Say hi<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"say('what')\"</span>&gt;</span>Say what<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-3'</span>,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message</span>) </span>&#123;</div><div class=\"line\">      alert(message)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"example-3\" class=\"demo\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n</script>\n\n<p>有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"warn('Form cannot be submitted yet.', $event)\"</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">warn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message, event</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 现在我们可以访问原生事件对象</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (event) event.preventDefault()</div><div class=\"line\">    alert(message)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>\n<p>为了解决这个问题， Vue.js 为 <code>v-on</code> 提供了 <strong>事件修饰符</strong>。通过由点(.)表示的指令后缀来调用修饰符。</p>\n<ul>\n<li><code>.stop</code></li>\n<li><code>.prevent</code></li>\n<li><code>.capture</code></li>\n<li><code>.self</code></li>\n<li><code>.once</code></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 阻止单击事件冒泡 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.stop</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 提交事件不再重载页面 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 修饰符可以串联  --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.stop.prevent</span>=<span class=\"string\">\"doThat\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 只有修饰符 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:click.capture</span>=<span class=\"string\">\"doThis\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:click.self</span>=<span class=\"string\">\"doThat\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>2.1.4 新增</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- the click event will be triggered at most once --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.once</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Unlike the other modifiers, which are exclusive to native DOM events, the <code>.once</code> modifier can also be used on <a href=\"components.html#Using-v-on-with-Custom-Events\">component events</a>. If you haven’t read about components yet, don’t worry about this for now.</p>\n<h2 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup.13</span>=<span class=\"string\">\"submit\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 同上 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup.enter</span>=<span class=\"string\">\"submit\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 缩写语法 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.enter</span>=<span class=\"string\">\"submit\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>全部的按键别名：</p>\n<ul>\n<li><code>.enter</code></li>\n<li><code>.tab</code></li>\n<li><code>.delete</code> (捕获 “删除” 和 “退格” 键)</li>\n<li><code>.esc</code></li>\n<li><code>.space</code></li>\n<li><code>.up</code></li>\n<li><code>.down</code></li>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n</ul>\n<p>可以通过全局 <code>config.keyCodes</code> 对象<a href=\"../api/#keyCodes\">自定义按键修饰符别名</a>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 可以使用 v-on:keyup.f1</span></div><div class=\"line\">Vue.config.keyCodes.f1 = <span class=\"number\">112</span></div></pre></td></tr></table></figure>\n<h2 id=\"按键修饰符-1\"><a href=\"#按键修饰符-1\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h2><blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<p>可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。</p>\n<ul>\n<li><code>.ctrl</code></li>\n<li><code>.alt</code></li>\n<li><code>.shift</code></li>\n<li><code>.meta</code></li>\n</ul>\n<blockquote>\n<p>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.</p>\n</blockquote>\n<p>For example:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- Alt + C --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.alt.67</span>=<span class=\"string\">\"clear\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- Ctrl + Click --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> @<span class=\"attr\">click.ctrl</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span>Do something<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"为什么在-HTML-中监听事件\"><a href=\"#为什么在-HTML-中监听事件\" class=\"headerlink\" title=\"为什么在 HTML 中监听事件?\"></a>为什么在 HTML 中监听事件?</h2><p>你可能注意到这种事件监听的方式违背了关注点分离（separation of concern）传统理念。不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 <code>v-on</code> 有几个好处：</p>\n<ol>\n<li><p>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</p>\n</li>\n<li><p>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</p>\n</li>\n<li><p>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</p>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/events.html\">http://vuejs.org/guide/events.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"介绍","type":"guide","order":2,"_content":"\n## Vue.js 是什么\n\nVue.js（读音 /vjuː/, 类似于 **view**） 是一套构建用户界面的 **渐进式框架**。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用[单文件组件](single-file-components.html)和 [Vue 生态系统支持的库](//github.com/vuejs/awesome-vue#libraries--plugins)开发的复杂单页应用。\n\nVue.js 的目标是通过尽可能简单的 API 实现**响应的数据绑定**和**组合的视图组件**。\n\n如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看[对比其它框架](comparison.html)。\n\n## 起步\n\n<p class=\"tip\">官方指南假设你已有 HTML、CSS 和 JavaScript 中级前端知识。如果你是全新的前端开发者，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来！之前有其他框架的使用经验是有帮助的，但不是必需的。</p>\n\n尝试 Vue.js 最简单的方法是使用 [JSFiddle Hello World 例子](https://jsfiddle.net/chrisvfritz/50wL7mdz/)。你可以在浏览器新标签页中打开它，跟着我们学习一些基础示例。或者你也可以创建一个本地的 `.html` 文件，然后通过如下方式引入 Vue:\n\n``` html\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n```\n\n你可以查看[安装指南](/guide/installation.html)来了解其他安装 Vue 的选项。请注意我们**不推荐**新手直接使用 `vue-cli`，尤其是对 Node.js 构建工具不够了解的同学。\n\n\n## 声明式渲染\n\nVue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统：\n\n``` html\n<div id=\"app\">\n  {{ message }}\n</div>\n```\n``` js\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n```\n{% raw %}\n<div id=\"app\" class=\"demo\">\n  {{ message }}\n</div>\n<script>\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n</script>\n{% endraw %}\n\n我们已经生成了我们的第一个 Vue 应用！看起来这跟单单渲染一个字符串模板非常类似，但是 Vue.js 在背后做了大量工作。现在数据和 DOM 已经被绑定在一起，所有的元素都是**响应式的**。我们如何知道？打开你的浏览器的控制台，并修改 `app.message`，你将看到上例相应地更新。\n\n除了绑定插入的文本内容，我们还可以采用这样的方式绑定 DOM 元素属性：\n\n``` html\n<div id=\"app-2\">\n  <span v-bind:title=\"message\">\n    Hover your mouse over me for a few seconds to see my dynamically bound title!\n  </span>\n</div>\n```\n``` js\nvar app2 = new Vue({\n  el: '#app-2',\n  data: {\n    message: 'You loaded this page on ' + new Date()\n  }\n})\n```\n{% raw %}\n<div id=\"app-2\" class=\"demo\">\n  <span v-bind:title=\"message\">\n    Hover your mouse over me for a few seconds to see my dynamically bound title!\n  </span>\n</div>\n<script>\nvar app2 = new Vue({\n  el: '#app-2',\n  data: {\n    message: 'You loaded this page on ' + new Date()\n  }\n})\n</script>\n{% endraw %}\n\n这里我们遇到点新东西。你看到的 `v-bind` 属性被称为**指令**。指令带有前缀 `v-`，以表示它们是 Vue.js 提供的特殊属性。可能你已经猜到了，它们会在渲染过的 DOM 上应用特殊的响应式行为。这个指令的简单含义是说：将这个元素节点的 `title` 属性和 Vue 实例的 `message` 属性绑定到一起。\n\n你再次打开浏览器的控制台输入 `app2.message = 'some new message'`，你就会再一次看到这个绑定了`title`属性的HTML已经进行了更新。\n\n## 条件与循环\n\n控制切换一个元素的显示也相当简单：\n\n``` html\n<div id=\"app-3\">\n  <p v-if=\"seen\">Now you see me</p>\n</div>\n```\n``` js\nvar app3 = new Vue({\n  el: '#app-3',\n  data: {\n    seen: true\n  }\n})\n```\n{% raw %}\n<div id=\"app-3\" class=\"demo\">\n  <span v-if=\"seen\">Now you see me</span>\n</div>\n<script>\nvar app3 = new Vue({\n  el: '#app-3',\n  data: {\n    seen: true\n  }\n})\n</script>\n{% endraw %}\n\n继续在控制台设置 `app3.seen = false`，你会发现 “Now you see me” 消失了。\n\n这个例子演示了我们不仅可以绑定 DOM 文本到数据，也可以绑定 DOM **结构**到数据。而且，Vue.js 也提供一个强大的过渡效果系统，可以在 Vue 插入/删除元素时自动应用[过渡效果](transitions.html)。\n\n也有一些其它指令，每个都有特殊的功能。例如， `v-for` 指令可以绑定数据到数组来渲染一个列表：\n\n``` html\n<div id=\"app-4\">\n  <ol>\n    <li v-for=\"todo in todos\">\n      {{ todo.text }}\n    </li>\n  </ol>\n</div>\n```\n``` js\nvar app4 = new Vue({\n  el: '#app-4',\n  data: {\n    todos: [\n      { text: 'Learn JavaScript' },\n      { text: 'Learn Vue' },\n      { text: 'Build something awesome' }\n    ]\n  }\n})\n```\n{% raw %}\n<div id=\"app-4\" class=\"demo\">\n  <ol>\n    <li v-for=\"todo in todos\">\n      {{ todo.text }}\n    </li>\n  </ol>\n</div>\n<script>\nvar app4 = new Vue({\n  el: '#app-4',\n  data: {\n    todos: [\n      { text: 'Learn JavaScript' },\n      { text: 'Learn Vue' },\n      { text: 'Build something awesome' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\n在控制台里，输入 `app4.todos.push({ text: 'New item' })`。你会发现列表中多了一栏新内容。\n\n## 处理用户输入\n\n为了让用户和你的应用进行互动，我们可以用 `v-on` 指令绑定一个监听事件用于调用我们 Vue 实例中定义的方法：\n\n``` html\n<div id=\"app-5\">\n  <p>{{ message }}</p>\n  <button v-on:click=\"reverseMessage\">Reverse Message</button>\n</div>\n```\n``` js\nvar app5 = new Vue({\n  el: '#app-5',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n{% raw %}\n<div id=\"app-5\" class=\"demo\">\n  <p>{{ message }}</p>\n  <button v-on:click=\"reverseMessage\">Reverse Message</button>\n</div>\n<script>\nvar app5 = new Vue({\n  el: '#app-5',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n{% endraw %}\n\n在 `reverseMessage` 方法中，我们在没有接触 DOM 的情况下更新了应用的状态 - 所有的 DOM 操作都由 Vue 来处理，你写的代码只需要关注基本逻辑。\n\nVue 也提供了 `v-model` 指令，它使得在表单输入和应用状态中做双向数据绑定变得非常轻巧。\n\n``` html\n<div id=\"app-6\">\n  <p>{{ message }}</p>\n  <input v-model=\"message\">\n</div>\n```\n``` js\nvar app6 = new Vue({\n  el: '#app-6',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n```\n{% raw %}\n<div id=\"app-6\" class=\"demo\">\n  <p>{{ message }}</p>\n  <input v-model=\"message\">\n</div>\n<script>\nvar app6 = new Vue({\n  el: '#app-6',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n</script>\n{% endraw %}\n\n## 用组件构建（应用）\n\n组件系统是 Vue.js 另一个重要概念，因为它提供了一种抽象，让我们可以用独立可复用的小组件来构建大型应用。如果我们考虑到这点，几乎任意类型的应用的界面都可以抽象为一个组件树：\n\n![Component Tree](/images/components.png)\n\n在 Vue 里，一个组件实质上是一个拥有预定义选项的一个 Vue 实例：\n\n``` js\n// Define a new component called todo-item\nVue.component('todo-item', {\n  template: '<li>This is a todo</li>'\n})\n```\n\n现在你可以另一个组件模板中写入它：\n\n``` html\n<ol>\n  <!-- Create an instance of the todo-item component -->\n  <todo-item></todo-item>\n</ol>\n```\n\n但是这样会为每个 todo 渲染同样的文本，这看起来并不是很酷。我们应该将数据从父作用域传到子组件。让我们来修改一下组件的定义，使得它能够接受一个 [`prop`](components.html#Props) 字段：\n\n``` js\nVue.component('todo-item', {\n  // The todo-item component now accepts a\n  // \"prop\", which is like a custom attribute.\n  // This prop is called todo.\n  props: ['todo'],\n  template: '<li>{{ todo.text }}</li>'\n})\n```\n\n现在，我们可以使用 `v-bind` 指令将 todo 传到每一个重复的组件中：\n\n``` html\n<div id=\"app-7\">\n  <ol>\n    <!-- Now we provide each todo-item with the todo object    -->\n    <!-- it's representing, so that its content can be dynamic -->\n    <todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\"></todo-item>\n  </ol>\n</div>\n```\n\n``` js\nVue.component('todo-item', {\n  props: ['todo'],\n  template: '<li>{{ todo.text }}</li>'\n})\n\nvar app7 = new Vue({\n  el: '#app-7',\n  data: {\n    groceryList: [\n      { text: 'Vegetables' },\n      { text: 'Cheese' },\n      { text: 'Whatever else humans are supposed to eat' }\n    ]\n  }\n})\n```\n{% raw %}\n<div id=\"app-7\" class=\"demo\">\n  <ol>\n    <todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\"></todo-item>\n  </ol>\n</div>\n<script>\nVue.component('todo-item', {\n  props: ['todo'],\n  template: '<li>{{ todo.text }}</li>'\n})\nvar app7 = new Vue({\n  el: '#app-7',\n  data: {\n    groceryList: [\n      { text: 'Vegetables' },\n      { text: 'Cheese' },\n      { text: 'Whatever else humans are supposed to eat' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\n这只是一个假设的例子，但是我们已经将应用分割成了两个更小的单元，子元素通过 `props` 接口实现了与父亲元素很好的解耦。我们现在可以在不影响到父应用的基础上，进一步为我们的 `todo` 组件改进更多复杂的模板和逻辑。\n\n在一个大型应用中，为了使得开发过程可控，有必要将应用整体分割成一个个的组件。在[后面的教程](components.html)中我们将详述组件，不过这里有一个（假想）的例子，看看使用了组件的应用模板是什么样的：\n\n``` html\n<div id=\"app\">\n  <app-nav></app-nav>\n  <app-view>\n    <app-sidebar></app-sidebar>\n    <app-content></app-content>\n  </app-view>\n</div>\n```\n\n## 与自定义元素的关系\n\n你可能已经注意到 Vue.js 组件非常类似于**自定义元素**——它是 [Web 组件规范](//www.w3.org/wiki/WebComponents/)的一部分。实际上 Vue.js 的组件语法参考了该规范。例如 Vue 组件实现了 [Slot API](//github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md) 与 `is` 特性。但是，有几个关键的不同：\n\n1. Web 组件规范仍然远未完成，并且没有浏览器实现。相比之下，Vue.js 组件不需要任何补丁，并且在所有支持的浏览器（IE9 及更高版本）之下表现一致。必要时，Vue.js 组件也可以放在原生自定义元素之内。\n\n2. Vue.js 组件提供了原生自定义元素所不具备的一些重要功能，比如组件间的数据流，自定义事件系统，以及动态的、带特效的组件替换。\n\n## 准备好探索更广阔的世界了？\n\n我们刚才简单介绍了 Vue.js 核心的一些最基本的特征 - 本指南的其余部分将用更详尽的篇幅去描述其他的一些高级特性，所以一定要阅读完所有的内容哦！\n\n***\n\n> 原文：http://vuejs.org/guide/index.html\n\n***\n","source":"v2/guide/index.md","raw":"---\ntitle: 介绍\ntype: guide\norder: 2\n---\n\n## Vue.js 是什么\n\nVue.js（读音 /vjuː/, 类似于 **view**） 是一套构建用户界面的 **渐进式框架**。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用[单文件组件](single-file-components.html)和 [Vue 生态系统支持的库](//github.com/vuejs/awesome-vue#libraries--plugins)开发的复杂单页应用。\n\nVue.js 的目标是通过尽可能简单的 API 实现**响应的数据绑定**和**组合的视图组件**。\n\n如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看[对比其它框架](comparison.html)。\n\n## 起步\n\n<p class=\"tip\">官方指南假设你已有 HTML、CSS 和 JavaScript 中级前端知识。如果你是全新的前端开发者，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来！之前有其他框架的使用经验是有帮助的，但不是必需的。</p>\n\n尝试 Vue.js 最简单的方法是使用 [JSFiddle Hello World 例子](https://jsfiddle.net/chrisvfritz/50wL7mdz/)。你可以在浏览器新标签页中打开它，跟着我们学习一些基础示例。或者你也可以创建一个本地的 `.html` 文件，然后通过如下方式引入 Vue:\n\n``` html\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n```\n\n你可以查看[安装指南](/guide/installation.html)来了解其他安装 Vue 的选项。请注意我们**不推荐**新手直接使用 `vue-cli`，尤其是对 Node.js 构建工具不够了解的同学。\n\n\n## 声明式渲染\n\nVue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统：\n\n``` html\n<div id=\"app\">\n  {{ message }}\n</div>\n```\n``` js\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n```\n{% raw %}\n<div id=\"app\" class=\"demo\">\n  {{ message }}\n</div>\n<script>\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n</script>\n{% endraw %}\n\n我们已经生成了我们的第一个 Vue 应用！看起来这跟单单渲染一个字符串模板非常类似，但是 Vue.js 在背后做了大量工作。现在数据和 DOM 已经被绑定在一起，所有的元素都是**响应式的**。我们如何知道？打开你的浏览器的控制台，并修改 `app.message`，你将看到上例相应地更新。\n\n除了绑定插入的文本内容，我们还可以采用这样的方式绑定 DOM 元素属性：\n\n``` html\n<div id=\"app-2\">\n  <span v-bind:title=\"message\">\n    Hover your mouse over me for a few seconds to see my dynamically bound title!\n  </span>\n</div>\n```\n``` js\nvar app2 = new Vue({\n  el: '#app-2',\n  data: {\n    message: 'You loaded this page on ' + new Date()\n  }\n})\n```\n{% raw %}\n<div id=\"app-2\" class=\"demo\">\n  <span v-bind:title=\"message\">\n    Hover your mouse over me for a few seconds to see my dynamically bound title!\n  </span>\n</div>\n<script>\nvar app2 = new Vue({\n  el: '#app-2',\n  data: {\n    message: 'You loaded this page on ' + new Date()\n  }\n})\n</script>\n{% endraw %}\n\n这里我们遇到点新东西。你看到的 `v-bind` 属性被称为**指令**。指令带有前缀 `v-`，以表示它们是 Vue.js 提供的特殊属性。可能你已经猜到了，它们会在渲染过的 DOM 上应用特殊的响应式行为。这个指令的简单含义是说：将这个元素节点的 `title` 属性和 Vue 实例的 `message` 属性绑定到一起。\n\n你再次打开浏览器的控制台输入 `app2.message = 'some new message'`，你就会再一次看到这个绑定了`title`属性的HTML已经进行了更新。\n\n## 条件与循环\n\n控制切换一个元素的显示也相当简单：\n\n``` html\n<div id=\"app-3\">\n  <p v-if=\"seen\">Now you see me</p>\n</div>\n```\n``` js\nvar app3 = new Vue({\n  el: '#app-3',\n  data: {\n    seen: true\n  }\n})\n```\n{% raw %}\n<div id=\"app-3\" class=\"demo\">\n  <span v-if=\"seen\">Now you see me</span>\n</div>\n<script>\nvar app3 = new Vue({\n  el: '#app-3',\n  data: {\n    seen: true\n  }\n})\n</script>\n{% endraw %}\n\n继续在控制台设置 `app3.seen = false`，你会发现 “Now you see me” 消失了。\n\n这个例子演示了我们不仅可以绑定 DOM 文本到数据，也可以绑定 DOM **结构**到数据。而且，Vue.js 也提供一个强大的过渡效果系统，可以在 Vue 插入/删除元素时自动应用[过渡效果](transitions.html)。\n\n也有一些其它指令，每个都有特殊的功能。例如， `v-for` 指令可以绑定数据到数组来渲染一个列表：\n\n``` html\n<div id=\"app-4\">\n  <ol>\n    <li v-for=\"todo in todos\">\n      {{ todo.text }}\n    </li>\n  </ol>\n</div>\n```\n``` js\nvar app4 = new Vue({\n  el: '#app-4',\n  data: {\n    todos: [\n      { text: 'Learn JavaScript' },\n      { text: 'Learn Vue' },\n      { text: 'Build something awesome' }\n    ]\n  }\n})\n```\n{% raw %}\n<div id=\"app-4\" class=\"demo\">\n  <ol>\n    <li v-for=\"todo in todos\">\n      {{ todo.text }}\n    </li>\n  </ol>\n</div>\n<script>\nvar app4 = new Vue({\n  el: '#app-4',\n  data: {\n    todos: [\n      { text: 'Learn JavaScript' },\n      { text: 'Learn Vue' },\n      { text: 'Build something awesome' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\n在控制台里，输入 `app4.todos.push({ text: 'New item' })`。你会发现列表中多了一栏新内容。\n\n## 处理用户输入\n\n为了让用户和你的应用进行互动，我们可以用 `v-on` 指令绑定一个监听事件用于调用我们 Vue 实例中定义的方法：\n\n``` html\n<div id=\"app-5\">\n  <p>{{ message }}</p>\n  <button v-on:click=\"reverseMessage\">Reverse Message</button>\n</div>\n```\n``` js\nvar app5 = new Vue({\n  el: '#app-5',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n{% raw %}\n<div id=\"app-5\" class=\"demo\">\n  <p>{{ message }}</p>\n  <button v-on:click=\"reverseMessage\">Reverse Message</button>\n</div>\n<script>\nvar app5 = new Vue({\n  el: '#app-5',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n{% endraw %}\n\n在 `reverseMessage` 方法中，我们在没有接触 DOM 的情况下更新了应用的状态 - 所有的 DOM 操作都由 Vue 来处理，你写的代码只需要关注基本逻辑。\n\nVue 也提供了 `v-model` 指令，它使得在表单输入和应用状态中做双向数据绑定变得非常轻巧。\n\n``` html\n<div id=\"app-6\">\n  <p>{{ message }}</p>\n  <input v-model=\"message\">\n</div>\n```\n``` js\nvar app6 = new Vue({\n  el: '#app-6',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n```\n{% raw %}\n<div id=\"app-6\" class=\"demo\">\n  <p>{{ message }}</p>\n  <input v-model=\"message\">\n</div>\n<script>\nvar app6 = new Vue({\n  el: '#app-6',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n</script>\n{% endraw %}\n\n## 用组件构建（应用）\n\n组件系统是 Vue.js 另一个重要概念，因为它提供了一种抽象，让我们可以用独立可复用的小组件来构建大型应用。如果我们考虑到这点，几乎任意类型的应用的界面都可以抽象为一个组件树：\n\n![Component Tree](/images/components.png)\n\n在 Vue 里，一个组件实质上是一个拥有预定义选项的一个 Vue 实例：\n\n``` js\n// Define a new component called todo-item\nVue.component('todo-item', {\n  template: '<li>This is a todo</li>'\n})\n```\n\n现在你可以另一个组件模板中写入它：\n\n``` html\n<ol>\n  <!-- Create an instance of the todo-item component -->\n  <todo-item></todo-item>\n</ol>\n```\n\n但是这样会为每个 todo 渲染同样的文本，这看起来并不是很酷。我们应该将数据从父作用域传到子组件。让我们来修改一下组件的定义，使得它能够接受一个 [`prop`](components.html#Props) 字段：\n\n``` js\nVue.component('todo-item', {\n  // The todo-item component now accepts a\n  // \"prop\", which is like a custom attribute.\n  // This prop is called todo.\n  props: ['todo'],\n  template: '<li>{{ todo.text }}</li>'\n})\n```\n\n现在，我们可以使用 `v-bind` 指令将 todo 传到每一个重复的组件中：\n\n``` html\n<div id=\"app-7\">\n  <ol>\n    <!-- Now we provide each todo-item with the todo object    -->\n    <!-- it's representing, so that its content can be dynamic -->\n    <todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\"></todo-item>\n  </ol>\n</div>\n```\n\n``` js\nVue.component('todo-item', {\n  props: ['todo'],\n  template: '<li>{{ todo.text }}</li>'\n})\n\nvar app7 = new Vue({\n  el: '#app-7',\n  data: {\n    groceryList: [\n      { text: 'Vegetables' },\n      { text: 'Cheese' },\n      { text: 'Whatever else humans are supposed to eat' }\n    ]\n  }\n})\n```\n{% raw %}\n<div id=\"app-7\" class=\"demo\">\n  <ol>\n    <todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\"></todo-item>\n  </ol>\n</div>\n<script>\nVue.component('todo-item', {\n  props: ['todo'],\n  template: '<li>{{ todo.text }}</li>'\n})\nvar app7 = new Vue({\n  el: '#app-7',\n  data: {\n    groceryList: [\n      { text: 'Vegetables' },\n      { text: 'Cheese' },\n      { text: 'Whatever else humans are supposed to eat' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\n这只是一个假设的例子，但是我们已经将应用分割成了两个更小的单元，子元素通过 `props` 接口实现了与父亲元素很好的解耦。我们现在可以在不影响到父应用的基础上，进一步为我们的 `todo` 组件改进更多复杂的模板和逻辑。\n\n在一个大型应用中，为了使得开发过程可控，有必要将应用整体分割成一个个的组件。在[后面的教程](components.html)中我们将详述组件，不过这里有一个（假想）的例子，看看使用了组件的应用模板是什么样的：\n\n``` html\n<div id=\"app\">\n  <app-nav></app-nav>\n  <app-view>\n    <app-sidebar></app-sidebar>\n    <app-content></app-content>\n  </app-view>\n</div>\n```\n\n## 与自定义元素的关系\n\n你可能已经注意到 Vue.js 组件非常类似于**自定义元素**——它是 [Web 组件规范](//www.w3.org/wiki/WebComponents/)的一部分。实际上 Vue.js 的组件语法参考了该规范。例如 Vue 组件实现了 [Slot API](//github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md) 与 `is` 特性。但是，有几个关键的不同：\n\n1. Web 组件规范仍然远未完成，并且没有浏览器实现。相比之下，Vue.js 组件不需要任何补丁，并且在所有支持的浏览器（IE9 及更高版本）之下表现一致。必要时，Vue.js 组件也可以放在原生自定义元素之内。\n\n2. Vue.js 组件提供了原生自定义元素所不具备的一些重要功能，比如组件间的数据流，自定义事件系统，以及动态的、带特效的组件替换。\n\n## 准备好探索更广阔的世界了？\n\n我们刚才简单介绍了 Vue.js 核心的一些最基本的特征 - 本指南的其余部分将用更详尽的篇幅去描述其他的一些高级特性，所以一定要阅读完所有的内容哦！\n\n***\n\n> 原文：http://vuejs.org/guide/index.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/index.html","comments":1,"layout":"page","_id":"ciwnajuyl001djl2d108okzno","content":"<h2 id=\"Vue-js-是什么\"><a href=\"#Vue-js-是什么\" class=\"headerlink\" title=\"Vue.js 是什么\"></a>Vue.js 是什么</h2><p>Vue.js（读音 /vjuː/, 类似于 <strong>view</strong>） 是一套构建用户界面的 <strong>渐进式框架</strong>。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用<a href=\"single-file-components.html\">单文件组件</a>和 <a href=\"//github.com/vuejs/awesome-vue#libraries--plugins\">Vue 生态系统支持的库</a>开发的复杂单页应用。</p>\n<p>Vue.js 的目标是通过尽可能简单的 API 实现<strong>响应的数据绑定</strong>和<strong>组合的视图组件</strong>。</p>\n<p>如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看<a href=\"comparison.html\">对比其它框架</a>。</p>\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><p class=\"tip\">官方指南假设你已有 HTML、CSS 和 JavaScript 中级前端知识。如果你是全新的前端开发者，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来！之前有其他框架的使用经验是有帮助的，但不是必需的。</p>\n\n<p>尝试 Vue.js 最简单的方法是使用 <a href=\"https://jsfiddle.net/chrisvfritz/50wL7mdz/\" target=\"_blank\" rel=\"external\">JSFiddle Hello World 例子</a>。你可以在浏览器新标签页中打开它，跟着我们学习一些基础示例。或者你也可以创建一个本地的 <code>.html</code> 文件，然后通过如下方式引入 Vue:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/vue/dist/vue.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你可以查看<a href=\"/guide/installation.html\">安装指南</a>来了解其他安装 Vue 的选项。请注意我们<strong>不推荐</strong>新手直接使用 <code>vue-cli</code>，尤其是对 Node.js 构建工具不够了解的同学。</p>\n<h2 id=\"声明式渲染\"><a href=\"#声明式渲染\" class=\"headerlink\" title=\"声明式渲染\"></a>声明式渲染</h2><p>Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; message &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello Vue!'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app\" class=\"demo\">\n  {{ message }}\n</div>\n<script>\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n</script>\n\n<p>我们已经生成了我们的第一个 Vue 应用！看起来这跟单单渲染一个字符串模板非常类似，但是 Vue.js 在背后做了大量工作。现在数据和 DOM 已经被绑定在一起，所有的元素都是<strong>响应式的</strong>。我们如何知道？打开你的浏览器的控制台，并修改 <code>app.message</code>，你将看到上例相应地更新。</p>\n<p>除了绑定插入的文本内容，我们还可以采用这样的方式绑定 DOM 元素属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"message\"</span>&gt;</span></div><div class=\"line\">    Hover your mouse over me for a few seconds to see my dynamically bound title!</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app2 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-2'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'You loaded this page on '</span> + <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-2\" class=\"demo\">\n  <span v-bind:title=\"message\">\n    Hover your mouse over me for a few seconds to see my dynamically bound title!\n  </span>\n</div>\n<script>\nvar app2 = new Vue({\n  el: '#app-2',\n  data: {\n    message: 'You loaded this page on ' + new Date()\n  }\n})\n</script>\n\n<p>这里我们遇到点新东西。你看到的 <code>v-bind</code> 属性被称为<strong>指令</strong>。指令带有前缀 <code>v-</code>，以表示它们是 Vue.js 提供的特殊属性。可能你已经猜到了，它们会在渲染过的 DOM 上应用特殊的响应式行为。这个指令的简单含义是说：将这个元素节点的 <code>title</code> 属性和 Vue 实例的 <code>message</code> 属性绑定到一起。</p>\n<p>你再次打开浏览器的控制台输入 <code>app2.message = &#39;some new message&#39;</code>，你就会再一次看到这个绑定了<code>title</code>属性的HTML已经进行了更新。</p>\n<h2 id=\"条件与循环\"><a href=\"#条件与循环\" class=\"headerlink\" title=\"条件与循环\"></a>条件与循环</h2><p>控制切换一个元素的显示也相当简单：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-3\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"seen\"</span>&gt;</span>Now you see me<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app3 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-3'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">seen</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-3\" class=\"demo\">\n  <span v-if=\"seen\">Now you see me</span>\n</div>\n<script>\nvar app3 = new Vue({\n  el: '#app-3',\n  data: {\n    seen: true\n  }\n})\n</script>\n\n<p>继续在控制台设置 <code>app3.seen = false</code>，你会发现 “Now you see me” 消失了。</p>\n<p>这个例子演示了我们不仅可以绑定 DOM 文本到数据，也可以绑定 DOM <strong>结构</strong>到数据。而且，Vue.js 也提供一个强大的过渡效果系统，可以在 Vue 插入/删除元素时自动应用<a href=\"transitions.html\">过渡效果</a>。</p>\n<p>也有一些其它指令，每个都有特殊的功能。例如， <code>v-for</code> 指令可以绑定数据到数组来渲染一个列表：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-4\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"todo in todos\"</span>&gt;</span></div><div class=\"line\">      &#123;&#123; todo.text &#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app4 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-4'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">todos</span>: [</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Learn JavaScript'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Learn Vue'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Build something awesome'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-4\" class=\"demo\">\n  <ol>\n    <li v-for=\"todo in todos\">\n      {{ todo.text }}\n    </li>\n  </ol>\n</div>\n<script>\nvar app4 = new Vue({\n  el: '#app-4',\n  data: {\n    todos: [\n      { text: 'Learn JavaScript' },\n      { text: 'Learn Vue' },\n      { text: 'Build something awesome' }\n    ]\n  }\n})\n</script>\n\n<p>在控制台里，输入 <code>app4.todos.push({ text: &#39;New item&#39; })</code>。你会发现列表中多了一栏新内容。</p>\n<h2 id=\"处理用户输入\"><a href=\"#处理用户输入\" class=\"headerlink\" title=\"处理用户输入\"></a>处理用户输入</h2><p>为了让用户和你的应用进行互动，我们可以用 <code>v-on</code> 指令绑定一个监听事件用于调用我们 Vue 实例中定义的方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-5\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"reverseMessage\"</span>&gt;</span>Reverse Message<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app5 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-5'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello Vue.js!'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">reverseMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.message = <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-5\" class=\"demo\">\n  <p>{{ message }}</p>\n  <button v-on:click=\"reverseMessage\">Reverse Message</button>\n</div>\n<script>\nvar app5 = new Vue({\n  el: '#app-5',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n\n<p>在 <code>reverseMessage</code> 方法中，我们在没有接触 DOM 的情况下更新了应用的状态 - 所有的 DOM 操作都由 Vue 来处理，你写的代码只需要关注基本逻辑。</p>\n<p>Vue 也提供了 <code>v-model</code> 指令，它使得在表单输入和应用状态中做双向数据绑定变得非常轻巧。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-6\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app6 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-6'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello Vue!'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-6\" class=\"demo\">\n  <p>{{ message }}</p>\n  <input v-model=\"message\">\n</div>\n<script>\nvar app6 = new Vue({\n  el: '#app-6',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n</script>\n\n<h2 id=\"用组件构建（应用）\"><a href=\"#用组件构建（应用）\" class=\"headerlink\" title=\"用组件构建（应用）\"></a>用组件构建（应用）</h2><p>组件系统是 Vue.js 另一个重要概念，因为它提供了一种抽象，让我们可以用独立可复用的小组件来构建大型应用。如果我们考虑到这点，几乎任意类型的应用的界面都可以抽象为一个组件树：</p>\n<p><img src=\"/images/components.png\" alt=\"Component Tree\"></p>\n<p>在 Vue 里，一个组件实质上是一个拥有预定义选项的一个 Vue 实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Define a new component called todo-item</span></div><div class=\"line\">Vue.component(<span class=\"string\">'todo-item'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;li&gt;This is a todo&lt;/li&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>现在你可以另一个组件模板中写入它：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- Create an instance of the todo-item component --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">todo-item</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">todo-item</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>但是这样会为每个 todo 渲染同样的文本，这看起来并不是很酷。我们应该将数据从父作用域传到子组件。让我们来修改一下组件的定义，使得它能够接受一个 <a href=\"components.html#Props\"><code>prop</code></a> 字段：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'todo-item'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// The todo-item component now accepts a</span></div><div class=\"line\">  <span class=\"comment\">// \"prop\", which is like a custom attribute.</span></div><div class=\"line\">  <span class=\"comment\">// This prop is called todo.</span></div><div class=\"line\">  props: [<span class=\"string\">'todo'</span>],</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>现在，我们可以使用 <code>v-bind</code> 指令将 todo 传到每一个重复的组件中：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-7\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- Now we provide each todo-item with the todo object    --&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- it's representing, so that its content can be dynamic --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">todo-item</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in groceryList\"</span> <span class=\"attr\">v-bind:todo</span>=<span class=\"string\">\"item\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">todo-item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'todo-item'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'todo'</span>],</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> app7 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-7'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">groceryList</span>: [</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Vegetables'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Cheese'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Whatever else humans are supposed to eat'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-7\" class=\"demo\">\n  <ol>\n    <todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\"></todo-item>\n  </ol>\n</div>\n<script>\nVue.component('todo-item', {\n  props: ['todo'],\n  template: '<li>{{ todo.text }}</li>'\n})\nvar app7 = new Vue({\n  el: '#app-7',\n  data: {\n    groceryList: [\n      { text: 'Vegetables' },\n      { text: 'Cheese' },\n      { text: 'Whatever else humans are supposed to eat' }\n    ]\n  }\n})\n</script>\n\n<p>这只是一个假设的例子，但是我们已经将应用分割成了两个更小的单元，子元素通过 <code>props</code> 接口实现了与父亲元素很好的解耦。我们现在可以在不影响到父应用的基础上，进一步为我们的 <code>todo</code> 组件改进更多复杂的模板和逻辑。</p>\n<p>在一个大型应用中，为了使得开发过程可控，有必要将应用整体分割成一个个的组件。在<a href=\"components.html\">后面的教程</a>中我们将详述组件，不过这里有一个（假想）的例子，看看使用了组件的应用模板是什么样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">app-nav</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-nav</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">app-view</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">app-sidebar</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-sidebar</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">app-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-content</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">app-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"与自定义元素的关系\"><a href=\"#与自定义元素的关系\" class=\"headerlink\" title=\"与自定义元素的关系\"></a>与自定义元素的关系</h2><p>你可能已经注意到 Vue.js 组件非常类似于<strong>自定义元素</strong>——它是 <a href=\"//www.w3.org/wiki/WebComponents/\">Web 组件规范</a>的一部分。实际上 Vue.js 的组件语法参考了该规范。例如 Vue 组件实现了 <a href=\"//github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md\">Slot API</a> 与 <code>is</code> 特性。但是，有几个关键的不同：</p>\n<ol>\n<li><p>Web 组件规范仍然远未完成，并且没有浏览器实现。相比之下，Vue.js 组件不需要任何补丁，并且在所有支持的浏览器（IE9 及更高版本）之下表现一致。必要时，Vue.js 组件也可以放在原生自定义元素之内。</p>\n</li>\n<li><p>Vue.js 组件提供了原生自定义元素所不具备的一些重要功能，比如组件间的数据流，自定义事件系统，以及动态的、带特效的组件替换。</p>\n</li>\n</ol>\n<h2 id=\"准备好探索更广阔的世界了？\"><a href=\"#准备好探索更广阔的世界了？\" class=\"headerlink\" title=\"准备好探索更广阔的世界了？\"></a>准备好探索更广阔的世界了？</h2><p>我们刚才简单介绍了 Vue.js 核心的一些最基本的特征 - 本指南的其余部分将用更详尽的篇幅去描述其他的一些高级特性，所以一定要阅读完所有的内容哦！</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/index.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/index.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"Vue-js-是什么\"><a href=\"#Vue-js-是什么\" class=\"headerlink\" title=\"Vue.js 是什么\"></a>Vue.js 是什么</h2><p>Vue.js（读音 /vjuː/, 类似于 <strong>view</strong>） 是一套构建用户界面的 <strong>渐进式框架</strong>。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用<a href=\"single-file-components.html\">单文件组件</a>和 <a href=\"//github.com/vuejs/awesome-vue#libraries--plugins\">Vue 生态系统支持的库</a>开发的复杂单页应用。</p>\n<p>Vue.js 的目标是通过尽可能简单的 API 实现<strong>响应的数据绑定</strong>和<strong>组合的视图组件</strong>。</p>\n<p>如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看<a href=\"comparison.html\">对比其它框架</a>。</p>\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><p class=\"tip\">官方指南假设你已有 HTML、CSS 和 JavaScript 中级前端知识。如果你是全新的前端开发者，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来！之前有其他框架的使用经验是有帮助的，但不是必需的。</p>\n\n<p>尝试 Vue.js 最简单的方法是使用 <a href=\"https://jsfiddle.net/chrisvfritz/50wL7mdz/\">JSFiddle Hello World 例子</a>。你可以在浏览器新标签页中打开它，跟着我们学习一些基础示例。或者你也可以创建一个本地的 <code>.html</code> 文件，然后通过如下方式引入 Vue:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/vue/dist/vue.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你可以查看<a href=\"/guide/installation.html\">安装指南</a>来了解其他安装 Vue 的选项。请注意我们<strong>不推荐</strong>新手直接使用 <code>vue-cli</code>，尤其是对 Node.js 构建工具不够了解的同学。</p>\n<h2 id=\"声明式渲染\"><a href=\"#声明式渲染\" class=\"headerlink\" title=\"声明式渲染\"></a>声明式渲染</h2><p>Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; message &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello Vue!'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app\" class=\"demo\">\n  {{ message }}\n</div>\n<script>\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n</script>\n\n<p>我们已经生成了我们的第一个 Vue 应用！看起来这跟单单渲染一个字符串模板非常类似，但是 Vue.js 在背后做了大量工作。现在数据和 DOM 已经被绑定在一起，所有的元素都是<strong>响应式的</strong>。我们如何知道？打开你的浏览器的控制台，并修改 <code>app.message</code>，你将看到上例相应地更新。</p>\n<p>除了绑定插入的文本内容，我们还可以采用这样的方式绑定 DOM 元素属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"message\"</span>&gt;</span></div><div class=\"line\">    Hover your mouse over me for a few seconds to see my dynamically bound title!</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app2 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-2'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'You loaded this page on '</span> + <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-2\" class=\"demo\">\n  <span v-bind:title=\"message\">\n    Hover your mouse over me for a few seconds to see my dynamically bound title!\n  </span>\n</div>\n<script>\nvar app2 = new Vue({\n  el: '#app-2',\n  data: {\n    message: 'You loaded this page on ' + new Date()\n  }\n})\n</script>\n\n<p>这里我们遇到点新东西。你看到的 <code>v-bind</code> 属性被称为<strong>指令</strong>。指令带有前缀 <code>v-</code>，以表示它们是 Vue.js 提供的特殊属性。可能你已经猜到了，它们会在渲染过的 DOM 上应用特殊的响应式行为。这个指令的简单含义是说：将这个元素节点的 <code>title</code> 属性和 Vue 实例的 <code>message</code> 属性绑定到一起。</p>\n<p>你再次打开浏览器的控制台输入 <code>app2.message = &#39;some new message&#39;</code>，你就会再一次看到这个绑定了<code>title</code>属性的HTML已经进行了更新。</p>\n<h2 id=\"条件与循环\"><a href=\"#条件与循环\" class=\"headerlink\" title=\"条件与循环\"></a>条件与循环</h2><p>控制切换一个元素的显示也相当简单：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-3\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"seen\"</span>&gt;</span>Now you see me<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app3 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-3'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">seen</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-3\" class=\"demo\">\n  <span v-if=\"seen\">Now you see me</span>\n</div>\n<script>\nvar app3 = new Vue({\n  el: '#app-3',\n  data: {\n    seen: true\n  }\n})\n</script>\n\n<p>继续在控制台设置 <code>app3.seen = false</code>，你会发现 “Now you see me” 消失了。</p>\n<p>这个例子演示了我们不仅可以绑定 DOM 文本到数据，也可以绑定 DOM <strong>结构</strong>到数据。而且，Vue.js 也提供一个强大的过渡效果系统，可以在 Vue 插入/删除元素时自动应用<a href=\"transitions.html\">过渡效果</a>。</p>\n<p>也有一些其它指令，每个都有特殊的功能。例如， <code>v-for</code> 指令可以绑定数据到数组来渲染一个列表：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-4\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"todo in todos\"</span>&gt;</span></div><div class=\"line\">      &#123;&#123; todo.text &#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app4 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-4'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">todos</span>: [</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Learn JavaScript'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Learn Vue'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Build something awesome'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-4\" class=\"demo\">\n  <ol>\n    <li v-for=\"todo in todos\">\n      {{ todo.text }}\n    </li>\n  </ol>\n</div>\n<script>\nvar app4 = new Vue({\n  el: '#app-4',\n  data: {\n    todos: [\n      { text: 'Learn JavaScript' },\n      { text: 'Learn Vue' },\n      { text: 'Build something awesome' }\n    ]\n  }\n})\n</script>\n\n<p>在控制台里，输入 <code>app4.todos.push({ text: &#39;New item&#39; })</code>。你会发现列表中多了一栏新内容。</p>\n<h2 id=\"处理用户输入\"><a href=\"#处理用户输入\" class=\"headerlink\" title=\"处理用户输入\"></a>处理用户输入</h2><p>为了让用户和你的应用进行互动，我们可以用 <code>v-on</code> 指令绑定一个监听事件用于调用我们 Vue 实例中定义的方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-5\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"reverseMessage\"</span>&gt;</span>Reverse Message<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app5 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-5'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello Vue.js!'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">reverseMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.message = <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-5\" class=\"demo\">\n  <p>{{ message }}</p>\n  <button v-on:click=\"reverseMessage\">Reverse Message</button>\n</div>\n<script>\nvar app5 = new Vue({\n  el: '#app-5',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n\n<p>在 <code>reverseMessage</code> 方法中，我们在没有接触 DOM 的情况下更新了应用的状态 - 所有的 DOM 操作都由 Vue 来处理，你写的代码只需要关注基本逻辑。</p>\n<p>Vue 也提供了 <code>v-model</code> 指令，它使得在表单输入和应用状态中做双向数据绑定变得非常轻巧。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-6\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app6 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-6'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello Vue!'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-6\" class=\"demo\">\n  <p>{{ message }}</p>\n  <input v-model=\"message\">\n</div>\n<script>\nvar app6 = new Vue({\n  el: '#app-6',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n</script>\n\n<h2 id=\"用组件构建（应用）\"><a href=\"#用组件构建（应用）\" class=\"headerlink\" title=\"用组件构建（应用）\"></a>用组件构建（应用）</h2><p>组件系统是 Vue.js 另一个重要概念，因为它提供了一种抽象，让我们可以用独立可复用的小组件来构建大型应用。如果我们考虑到这点，几乎任意类型的应用的界面都可以抽象为一个组件树：</p>\n<p><img src=\"/images/components.png\" alt=\"Component Tree\"></p>\n<p>在 Vue 里，一个组件实质上是一个拥有预定义选项的一个 Vue 实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Define a new component called todo-item</span></div><div class=\"line\">Vue.component(<span class=\"string\">'todo-item'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;li&gt;This is a todo&lt;/li&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>现在你可以另一个组件模板中写入它：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- Create an instance of the todo-item component --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">todo-item</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">todo-item</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>但是这样会为每个 todo 渲染同样的文本，这看起来并不是很酷。我们应该将数据从父作用域传到子组件。让我们来修改一下组件的定义，使得它能够接受一个 <a href=\"components.html#Props\"><code>prop</code></a> 字段：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'todo-item'</span>, &#123;</div><div class=\"line\">  <span class=\"comment\">// The todo-item component now accepts a</span></div><div class=\"line\">  <span class=\"comment\">// \"prop\", which is like a custom attribute.</span></div><div class=\"line\">  <span class=\"comment\">// This prop is called todo.</span></div><div class=\"line\">  props: [<span class=\"string\">'todo'</span>],</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>现在，我们可以使用 <code>v-bind</code> 指令将 todo 传到每一个重复的组件中：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-7\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- Now we provide each todo-item with the todo object    --&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- it's representing, so that its content can be dynamic --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">todo-item</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in groceryList\"</span> <span class=\"attr\">v-bind:todo</span>=<span class=\"string\">\"item\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">todo-item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'todo-item'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'todo'</span>],</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> app7 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app-7'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">groceryList</span>: [</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Vegetables'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Cheese'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">text</span>: <span class=\"string\">'Whatever else humans are supposed to eat'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"app-7\" class=\"demo\">\n  <ol>\n    <todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\"></todo-item>\n  </ol>\n</div>\n<script>\nVue.component('todo-item', {\n  props: ['todo'],\n  template: '<li>{{ todo.text }}</li>'\n})\nvar app7 = new Vue({\n  el: '#app-7',\n  data: {\n    groceryList: [\n      { text: 'Vegetables' },\n      { text: 'Cheese' },\n      { text: 'Whatever else humans are supposed to eat' }\n    ]\n  }\n})\n</script>\n\n<p>这只是一个假设的例子，但是我们已经将应用分割成了两个更小的单元，子元素通过 <code>props</code> 接口实现了与父亲元素很好的解耦。我们现在可以在不影响到父应用的基础上，进一步为我们的 <code>todo</code> 组件改进更多复杂的模板和逻辑。</p>\n<p>在一个大型应用中，为了使得开发过程可控，有必要将应用整体分割成一个个的组件。在<a href=\"components.html\">后面的教程</a>中我们将详述组件，不过这里有一个（假想）的例子，看看使用了组件的应用模板是什么样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">app-nav</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-nav</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">app-view</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">app-sidebar</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-sidebar</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">app-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-content</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">app-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"与自定义元素的关系\"><a href=\"#与自定义元素的关系\" class=\"headerlink\" title=\"与自定义元素的关系\"></a>与自定义元素的关系</h2><p>你可能已经注意到 Vue.js 组件非常类似于<strong>自定义元素</strong>——它是 <a href=\"//www.w3.org/wiki/WebComponents/\">Web 组件规范</a>的一部分。实际上 Vue.js 的组件语法参考了该规范。例如 Vue 组件实现了 <a href=\"//github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md\">Slot API</a> 与 <code>is</code> 特性。但是，有几个关键的不同：</p>\n<ol>\n<li><p>Web 组件规范仍然远未完成，并且没有浏览器实现。相比之下，Vue.js 组件不需要任何补丁，并且在所有支持的浏览器（IE9 及更高版本）之下表现一致。必要时，Vue.js 组件也可以放在原生自定义元素之内。</p>\n</li>\n<li><p>Vue.js 组件提供了原生自定义元素所不具备的一些重要功能，比如组件间的数据流，自定义事件系统，以及动态的、带特效的组件替换。</p>\n</li>\n</ol>\n<h2 id=\"准备好探索更广阔的世界了？\"><a href=\"#准备好探索更广阔的世界了？\" class=\"headerlink\" title=\"准备好探索更广阔的世界了？\"></a>准备好探索更广阔的世界了？</h2><p>我们刚才简单介绍了 Vue.js 核心的一些最基本的特征 - 本指南的其余部分将用更详尽的篇幅去描述其他的一些高级特性，所以一定要阅读完所有的内容哦！</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/index.html\">http://vuejs.org/guide/index.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"安装","type":"guide","order":1,"vue_version":"2.1.3","dev_size":"206.14","min_size":"67.60","gz_size":"24.72","ro_gz_size":"17.14","_content":"\n### 兼容性\n\nVue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性。 Vue.js 支持所有[兼容 ECMAScript 5 的浏览器](http://caniuse.com/#feat=es5)。\n\n### 更新日志\n\n每个版本的更新日志见 [GitHub](https://github.com/vuejs/vue/releases)。\n\n## 独立版本\n\n直接下载并用 `<script>` 标签引入，`Vue` 会被注册为一个全局变量。**重要提示：在开发时请用开发版本，遇到常见错误它会给出友好的警告。**\n\n<p class=\"tip\">开发环境不要用最小压缩版，不然就失去了错误提示和警告!</p>\n\n<div id=\"downloads\">\n<a class=\"button\" href=\"http://vuejs.org/js/vue.js\" download>开发版本</a><span class=\"light info\">包含完整的警告和调试模式</span>\n\n<a class=\"button\" href=\"http://vuejs.org/js/vue.min.js\" download>生产版本</a><span class=\"light info\">删除了警告，{{gz_size}}kb min+gzip</span>\n</div>\n\n### CDN\n\n\n推荐：[unpkg](https://unpkg.com/vue/dist/vue.js), 会保持和 npm 发布的最新的版本一致。可以在 [unpkg.com/vue/](https://unpkg.com/vue/) 浏览 npm 包资源。\n\n也可以从 [jsdelivr](//cdn.jsdelivr.net/vue/{{vue_version}}/vue.js) 或 [cdnjs](//cdnjs.cloudflare.com/ajax/libs/vue/{{vue_version}}/vue.js) 获取，不过这两个服务版本更新可能略滞后。\n\n## NPM\n\n\n在用 Vue.js 构建大型应用时推荐使用 NPM 安装， NPM 能很好地和诸如 [Webpack](http://webpack.github.io/) 或 [Browserify](http://browserify.org/) 模块打包器配合使用。 Vue.js 也提供配套工具来开发[单文件组件](single-file-components.html)。\n\n\n``` bash\n# 最新稳定版\n$ npm install vue\n```\n\n### 独立构建 vs 运行时构建\n\n有两种构建方式，独立构建和运行构建。它们的区别在于前者包含**模板编译器**而后者不包含。\n\n模板编译用于编译 Vue 模板字符串成纯 JavaScript 渲染函数。如果你想用 `template` 选项， 你需要编译。\n\n模板编译器的职责是将模板字符串编译为纯 JavaScript 的渲染函数。如果你想要在组件中使用 `template` 选项，你就需要编译器。\n\n- 独立构建包含模板编译器并支持 `template` 选项。 **它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。**\n\n- 运行时构建不包含模板编译器，因此不支持 `template` 选项，只能用 `render` 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 `render` 函数。运行时构建比独立构建要轻量30%，只有  {{ro_gz_size}} Kb min+gzip大小。\n\n默认 NPM 包导出的是 **运行时** 构建。为了使用独立构建，在 webpack 配置中添加下面的别名：\n\n``` js\nresolve: {\n  alias: {\n    'vue$': 'vue/dist/vue.common.js'\n  }\n}\n```\n\n对于Browserify，可以添加一个别名到 package.json 中：\n\n``` js\n\"browser\": {\n  \"vue\": \"vue/dist/vue.common\"\n},\n```\n\n### CSP 环境\n\n有些环境，如 Google Chrome Apps ，强制应用内容安全策略 (CSP) ，不能使用 new Function() 对表达式求值。这时可以用 CSP 兼容版本。独立的构建取决于该功能编译模板，所以无法使用这些环境。\n\n\n另一方面，运行时构建的是完全兼容 CSP 的。当通过 [Webpack + vue-loader](https://github.com/vuejs-templates/webpack-simple) 或者 [Browserify + vueify](https://github.com/vuejs-templates/browserify-simple) 构建时，在 CSP 环境中模板将被完美预编译到 `render` 函数中。\n\n## 命令行工具\n\nVue.js 提供一个[官方命令行工具](https://github.com/vuejs/vue-cli)，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：\n\n``` bash\n# 全局安装 vue-cli\n$ npm install --global vue-cli\n# 创建一个基于 webpack 模板的新项目\n$ vue init webpack my-project\n# 安装依赖，走你\n$ cd my-project\n$ npm install\n$ npm run dev\n```\n<p class=\"tip\">The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through <a href=\"./\">the guide</a> without any build tools before using the CLI.</p>\n\n<p class=\"tip\">CLI 默认了用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读[指南](/guide/)，熟悉 Vue 本身之后再研究 CLI。</p>\n\n<p class=\"tip\">对于大陆用户，建议将 npm 的注册表源[设置为国内的镜像](http://riny.net/2014/cnpm/)，可以大幅提升安装速度。</p>\n\n## 开发版本\n\n**重要**: Github 仓库的 `/dist` 文件夹只有在新版本发布时才会更新。如果想要使用 Github 上 Vue 最新的源码，你需要自己构建。\n\n``` bash\ngit clone https://github.com/vuejs/vue.git node_modules/vue\ncd node_modules/vue\nnpm install\nnpm run build\n```\n\n## Bower\n\n``` bash\n# 最新稳定版本\n$ bower install vue\n```\n\n## AMD 模块加载器\n\n独立下载版本或通过 Bower 安装的版本已用 UMD 包装，因此它们可以直接用作 AMD 模块。\n\n***\n\n> 原文：http://vuejs.org/guide/installation.html\n\n***\n","source":"v2/guide/installation.md","raw":"---\ntitle: 安装\ntype: guide\norder: 1\nvue_version: 2.1.3\ndev_size: \"206.14\"\nmin_size: \"67.60\"\ngz_size: \"24.72\"\nro_gz_size: \"17.14\"\n---\n\n### 兼容性\n\nVue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性。 Vue.js 支持所有[兼容 ECMAScript 5 的浏览器](http://caniuse.com/#feat=es5)。\n\n### 更新日志\n\n每个版本的更新日志见 [GitHub](https://github.com/vuejs/vue/releases)。\n\n## 独立版本\n\n直接下载并用 `<script>` 标签引入，`Vue` 会被注册为一个全局变量。**重要提示：在开发时请用开发版本，遇到常见错误它会给出友好的警告。**\n\n<p class=\"tip\">开发环境不要用最小压缩版，不然就失去了错误提示和警告!</p>\n\n<div id=\"downloads\">\n<a class=\"button\" href=\"http://vuejs.org/js/vue.js\" download>开发版本</a><span class=\"light info\">包含完整的警告和调试模式</span>\n\n<a class=\"button\" href=\"http://vuejs.org/js/vue.min.js\" download>生产版本</a><span class=\"light info\">删除了警告，{{gz_size}}kb min+gzip</span>\n</div>\n\n### CDN\n\n\n推荐：[unpkg](https://unpkg.com/vue/dist/vue.js), 会保持和 npm 发布的最新的版本一致。可以在 [unpkg.com/vue/](https://unpkg.com/vue/) 浏览 npm 包资源。\n\n也可以从 [jsdelivr](//cdn.jsdelivr.net/vue/{{vue_version}}/vue.js) 或 [cdnjs](//cdnjs.cloudflare.com/ajax/libs/vue/{{vue_version}}/vue.js) 获取，不过这两个服务版本更新可能略滞后。\n\n## NPM\n\n\n在用 Vue.js 构建大型应用时推荐使用 NPM 安装， NPM 能很好地和诸如 [Webpack](http://webpack.github.io/) 或 [Browserify](http://browserify.org/) 模块打包器配合使用。 Vue.js 也提供配套工具来开发[单文件组件](single-file-components.html)。\n\n\n``` bash\n# 最新稳定版\n$ npm install vue\n```\n\n### 独立构建 vs 运行时构建\n\n有两种构建方式，独立构建和运行构建。它们的区别在于前者包含**模板编译器**而后者不包含。\n\n模板编译用于编译 Vue 模板字符串成纯 JavaScript 渲染函数。如果你想用 `template` 选项， 你需要编译。\n\n模板编译器的职责是将模板字符串编译为纯 JavaScript 的渲染函数。如果你想要在组件中使用 `template` 选项，你就需要编译器。\n\n- 独立构建包含模板编译器并支持 `template` 选项。 **它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。**\n\n- 运行时构建不包含模板编译器，因此不支持 `template` 选项，只能用 `render` 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 `render` 函数。运行时构建比独立构建要轻量30%，只有  {{ro_gz_size}} Kb min+gzip大小。\n\n默认 NPM 包导出的是 **运行时** 构建。为了使用独立构建，在 webpack 配置中添加下面的别名：\n\n``` js\nresolve: {\n  alias: {\n    'vue$': 'vue/dist/vue.common.js'\n  }\n}\n```\n\n对于Browserify，可以添加一个别名到 package.json 中：\n\n``` js\n\"browser\": {\n  \"vue\": \"vue/dist/vue.common\"\n},\n```\n\n### CSP 环境\n\n有些环境，如 Google Chrome Apps ，强制应用内容安全策略 (CSP) ，不能使用 new Function() 对表达式求值。这时可以用 CSP 兼容版本。独立的构建取决于该功能编译模板，所以无法使用这些环境。\n\n\n另一方面，运行时构建的是完全兼容 CSP 的。当通过 [Webpack + vue-loader](https://github.com/vuejs-templates/webpack-simple) 或者 [Browserify + vueify](https://github.com/vuejs-templates/browserify-simple) 构建时，在 CSP 环境中模板将被完美预编译到 `render` 函数中。\n\n## 命令行工具\n\nVue.js 提供一个[官方命令行工具](https://github.com/vuejs/vue-cli)，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：\n\n``` bash\n# 全局安装 vue-cli\n$ npm install --global vue-cli\n# 创建一个基于 webpack 模板的新项目\n$ vue init webpack my-project\n# 安装依赖，走你\n$ cd my-project\n$ npm install\n$ npm run dev\n```\n<p class=\"tip\">The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through <a href=\"./\">the guide</a> without any build tools before using the CLI.</p>\n\n<p class=\"tip\">CLI 默认了用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读[指南](/guide/)，熟悉 Vue 本身之后再研究 CLI。</p>\n\n<p class=\"tip\">对于大陆用户，建议将 npm 的注册表源[设置为国内的镜像](http://riny.net/2014/cnpm/)，可以大幅提升安装速度。</p>\n\n## 开发版本\n\n**重要**: Github 仓库的 `/dist` 文件夹只有在新版本发布时才会更新。如果想要使用 Github 上 Vue 最新的源码，你需要自己构建。\n\n``` bash\ngit clone https://github.com/vuejs/vue.git node_modules/vue\ncd node_modules/vue\nnpm install\nnpm run build\n```\n\n## Bower\n\n``` bash\n# 最新稳定版本\n$ bower install vue\n```\n\n## AMD 模块加载器\n\n独立下载版本或通过 Bower 安装的版本已用 UMD 包装，因此它们可以直接用作 AMD 模块。\n\n***\n\n> 原文：http://vuejs.org/guide/installation.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/installation.html","comments":1,"layout":"page","_id":"ciwnajuyn001ejl2d73cn9oqn","content":"<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性。 Vue.js 支持所有<a href=\"http://caniuse.com/#feat=es5\" target=\"_blank\" rel=\"external\">兼容 ECMAScript 5 的浏览器</a>。</p>\n<h3 id=\"更新日志\"><a href=\"#更新日志\" class=\"headerlink\" title=\"更新日志\"></a>更新日志</h3><p>每个版本的更新日志见 <a href=\"https://github.com/vuejs/vue/releases\" target=\"_blank\" rel=\"external\">GitHub</a>。</p>\n<h2 id=\"独立版本\"><a href=\"#独立版本\" class=\"headerlink\" title=\"独立版本\"></a>独立版本</h2><p>直接下载并用 <code>&lt;script&gt;</code> 标签引入，<code>Vue</code> 会被注册为一个全局变量。<strong>重要提示：在开发时请用开发版本，遇到常见错误它会给出友好的警告。</strong></p>\n<p class=\"tip\">开发环境不要用最小压缩版，不然就失去了错误提示和警告!</p>\n\n<div id=\"downloads\"><br><a class=\"button\" href=\"http://vuejs.org/js/vue.js\" download=\"\" target=\"_blank\" rel=\"external\">开发版本</a><span class=\"light info\">包含完整的警告和调试模式</span><br><br><a class=\"button\" href=\"http://vuejs.org/js/vue.min.js\" download=\"\" target=\"_blank\" rel=\"external\">生产版本</a><span class=\"light info\">删除了警告，24.72kb min+gzip</span><br></div>\n\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p>推荐：<a href=\"https://unpkg.com/vue/dist/vue.js\" target=\"_blank\" rel=\"external\">unpkg</a>, 会保持和 npm 发布的最新的版本一致。可以在 <a href=\"https://unpkg.com/vue/\" target=\"_blank\" rel=\"external\">unpkg.com/vue/</a> 浏览 npm 包资源。</p>\n<p>也可以从 <a href=\"//cdn.jsdelivr.net/vue/2.1.3/vue.js\">jsdelivr</a> 或 <a href=\"//cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js\">cdnjs</a> 获取，不过这两个服务版本更新可能略滞后。</p>\n<h2 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h2><p>在用 Vue.js 构建大型应用时推荐使用 NPM 安装， NPM 能很好地和诸如 <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"external\">Webpack</a> 或 <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"external\">Browserify</a> 模块打包器配合使用。 Vue.js 也提供配套工具来开发<a href=\"single-file-components.html\">单文件组件</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 最新稳定版</span></div><div class=\"line\">$ npm install vue</div></pre></td></tr></table></figure>\n<h3 id=\"独立构建-vs-运行时构建\"><a href=\"#独立构建-vs-运行时构建\" class=\"headerlink\" title=\"独立构建 vs 运行时构建\"></a>独立构建 vs 运行时构建</h3><p>有两种构建方式，独立构建和运行构建。它们的区别在于前者包含<strong>模板编译器</strong>而后者不包含。</p>\n<p>模板编译用于编译 Vue 模板字符串成纯 JavaScript 渲染函数。如果你想用 <code>template</code> 选项， 你需要编译。</p>\n<p>模板编译器的职责是将模板字符串编译为纯 JavaScript 的渲染函数。如果你想要在组件中使用 <code>template</code> 选项，你就需要编译器。</p>\n<ul>\n<li><p>独立构建包含模板编译器并支持 <code>template</code> 选项。 <strong>它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。</strong></p>\n</li>\n<li><p>运行时构建不包含模板编译器，因此不支持 <code>template</code> 选项，只能用 <code>render</code> 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 <code>render</code> 函数。运行时构建比独立构建要轻量30%，只有  17.14 Kb min+gzip大小。</p>\n</li>\n</ul>\n<p>默认 NPM 包导出的是 <strong>运行时</strong> 构建。为了使用独立构建，在 webpack 配置中添加下面的别名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">resolve: &#123;</div><div class=\"line\">  <span class=\"attr\">alias</span>: &#123;</div><div class=\"line\">    <span class=\"string\">'vue$'</span>: <span class=\"string\">'vue/dist/vue.common.js'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于Browserify，可以添加一个别名到 package.json 中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"browser\"</span>: &#123;</div><div class=\"line\">  <span class=\"string\">\"vue\"</span>: <span class=\"string\">\"vue/dist/vue.common\"</span></div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<h3 id=\"CSP-环境\"><a href=\"#CSP-环境\" class=\"headerlink\" title=\"CSP 环境\"></a>CSP 环境</h3><p>有些环境，如 Google Chrome Apps ，强制应用内容安全策略 (CSP) ，不能使用 new Function() 对表达式求值。这时可以用 CSP 兼容版本。独立的构建取决于该功能编译模板，所以无法使用这些环境。</p>\n<p>另一方面，运行时构建的是完全兼容 CSP 的。当通过 <a href=\"https://github.com/vuejs-templates/webpack-simple\" target=\"_blank\" rel=\"external\">Webpack + vue-loader</a> 或者 <a href=\"https://github.com/vuejs-templates/browserify-simple\" target=\"_blank\" rel=\"external\">Browserify + vueify</a> 构建时，在 CSP 环境中模板将被完美预编译到 <code>render</code> 函数中。</p>\n<h2 id=\"命令行工具\"><a href=\"#命令行工具\" class=\"headerlink\" title=\"命令行工具\"></a>命令行工具</h2><p>Vue.js 提供一个<a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"external\">官方命令行工具</a>，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 全局安装 vue-cli</span></div><div class=\"line\">$ npm install --global vue-cli</div><div class=\"line\"><span class=\"comment\"># 创建一个基于 webpack 模板的新项目</span></div><div class=\"line\">$ vue init webpack my-project</div><div class=\"line\"><span class=\"comment\"># 安装依赖，走你</span></div><div class=\"line\">$ <span class=\"built_in\">cd</span> my-project</div><div class=\"line\">$ npm install</div><div class=\"line\">$ npm run dev</div></pre></td></tr></table></figure>\n<p class=\"tip\">The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through <a href=\"./\">the guide</a> without any build tools before using the CLI.</p>\n\n<p class=\"tip\">CLI 默认了用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读<a href=\"/guide/\">指南</a>，熟悉 Vue 本身之后再研究 CLI。</p>\n\n<p class=\"tip\">对于大陆用户，建议将 npm 的注册表源<a href=\"http://riny.net/2014/cnpm/\" target=\"_blank\" rel=\"external\">设置为国内的镜像</a>，可以大幅提升安装速度。</p>\n\n<h2 id=\"开发版本\"><a href=\"#开发版本\" class=\"headerlink\" title=\"开发版本\"></a>开发版本</h2><p><strong>重要</strong>: Github 仓库的 <code>/dist</code> 文件夹只有在新版本发布时才会更新。如果想要使用 Github 上 Vue 最新的源码，你需要自己构建。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/vuejs/vue.git node_modules/vue</div><div class=\"line\"><span class=\"built_in\">cd</span> node_modules/vue</div><div class=\"line\">npm install</div><div class=\"line\">npm run build</div></pre></td></tr></table></figure>\n<h2 id=\"Bower\"><a href=\"#Bower\" class=\"headerlink\" title=\"Bower\"></a>Bower</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 最新稳定版本</span></div><div class=\"line\">$ bower install vue</div></pre></td></tr></table></figure>\n<h2 id=\"AMD-模块加载器\"><a href=\"#AMD-模块加载器\" class=\"headerlink\" title=\"AMD 模块加载器\"></a>AMD 模块加载器</h2><p>独立下载版本或通过 Bower 安装的版本已用 UMD 包装，因此它们可以直接用作 AMD 模块。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/installation.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/installation.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性。 Vue.js 支持所有<a href=\"http://caniuse.com/#feat=es5\">兼容 ECMAScript 5 的浏览器</a>。</p>\n<h3 id=\"更新日志\"><a href=\"#更新日志\" class=\"headerlink\" title=\"更新日志\"></a>更新日志</h3><p>每个版本的更新日志见 <a href=\"https://github.com/vuejs/vue/releases\">GitHub</a>。</p>\n<h2 id=\"独立版本\"><a href=\"#独立版本\" class=\"headerlink\" title=\"独立版本\"></a>独立版本</h2><p>直接下载并用 <code>&lt;script&gt;</code> 标签引入，<code>Vue</code> 会被注册为一个全局变量。<strong>重要提示：在开发时请用开发版本，遇到常见错误它会给出友好的警告。</strong></p>\n<p class=\"tip\">开发环境不要用最小压缩版，不然就失去了错误提示和警告!</p>\n\n<div id=\"downloads\"><br><a class=\"button\" href=\"http://vuejs.org/js/vue.js\" download>开发版本</a><span class=\"light info\">包含完整的警告和调试模式</span><br><br><a class=\"button\" href=\"http://vuejs.org/js/vue.min.js\" download>生产版本</a><span class=\"light info\">删除了警告，24.72kb min+gzip</span><br></div>\n\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p>推荐：<a href=\"https://unpkg.com/vue/dist/vue.js\">unpkg</a>, 会保持和 npm 发布的最新的版本一致。可以在 <a href=\"https://unpkg.com/vue/\">unpkg.com/vue/</a> 浏览 npm 包资源。</p>\n<p>也可以从 <a href=\"//cdn.jsdelivr.net/vue/2.1.3/vue.js\">jsdelivr</a> 或 <a href=\"//cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js\">cdnjs</a> 获取，不过这两个服务版本更新可能略滞后。</p>\n<h2 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h2><p>在用 Vue.js 构建大型应用时推荐使用 NPM 安装， NPM 能很好地和诸如 <a href=\"http://webpack.github.io/\">Webpack</a> 或 <a href=\"http://browserify.org/\">Browserify</a> 模块打包器配合使用。 Vue.js 也提供配套工具来开发<a href=\"single-file-components.html\">单文件组件</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 最新稳定版</span></div><div class=\"line\">$ npm install vue</div></pre></td></tr></table></figure>\n<h3 id=\"独立构建-vs-运行时构建\"><a href=\"#独立构建-vs-运行时构建\" class=\"headerlink\" title=\"独立构建 vs 运行时构建\"></a>独立构建 vs 运行时构建</h3><p>有两种构建方式，独立构建和运行构建。它们的区别在于前者包含<strong>模板编译器</strong>而后者不包含。</p>\n<p>模板编译用于编译 Vue 模板字符串成纯 JavaScript 渲染函数。如果你想用 <code>template</code> 选项， 你需要编译。</p>\n<p>模板编译器的职责是将模板字符串编译为纯 JavaScript 的渲染函数。如果你想要在组件中使用 <code>template</code> 选项，你就需要编译器。</p>\n<ul>\n<li><p>独立构建包含模板编译器并支持 <code>template</code> 选项。 <strong>它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。</strong></p>\n</li>\n<li><p>运行时构建不包含模板编译器，因此不支持 <code>template</code> 选项，只能用 <code>render</code> 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 <code>render</code> 函数。运行时构建比独立构建要轻量30%，只有  17.14 Kb min+gzip大小。</p>\n</li>\n</ul>\n<p>默认 NPM 包导出的是 <strong>运行时</strong> 构建。为了使用独立构建，在 webpack 配置中添加下面的别名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">resolve: &#123;</div><div class=\"line\">  <span class=\"attr\">alias</span>: &#123;</div><div class=\"line\">    <span class=\"string\">'vue$'</span>: <span class=\"string\">'vue/dist/vue.common.js'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于Browserify，可以添加一个别名到 package.json 中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"browser\"</span>: &#123;</div><div class=\"line\">  <span class=\"string\">\"vue\"</span>: <span class=\"string\">\"vue/dist/vue.common\"</span></div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<h3 id=\"CSP-环境\"><a href=\"#CSP-环境\" class=\"headerlink\" title=\"CSP 环境\"></a>CSP 环境</h3><p>有些环境，如 Google Chrome Apps ，强制应用内容安全策略 (CSP) ，不能使用 new Function() 对表达式求值。这时可以用 CSP 兼容版本。独立的构建取决于该功能编译模板，所以无法使用这些环境。</p>\n<p>另一方面，运行时构建的是完全兼容 CSP 的。当通过 <a href=\"https://github.com/vuejs-templates/webpack-simple\">Webpack + vue-loader</a> 或者 <a href=\"https://github.com/vuejs-templates/browserify-simple\">Browserify + vueify</a> 构建时，在 CSP 环境中模板将被完美预编译到 <code>render</code> 函数中。</p>\n<h2 id=\"命令行工具\"><a href=\"#命令行工具\" class=\"headerlink\" title=\"命令行工具\"></a>命令行工具</h2><p>Vue.js 提供一个<a href=\"https://github.com/vuejs/vue-cli\">官方命令行工具</a>，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 全局安装 vue-cli</span></div><div class=\"line\">$ npm install --global vue-cli</div><div class=\"line\"><span class=\"comment\"># 创建一个基于 webpack 模板的新项目</span></div><div class=\"line\">$ vue init webpack my-project</div><div class=\"line\"><span class=\"comment\"># 安装依赖，走你</span></div><div class=\"line\">$ <span class=\"built_in\">cd</span> my-project</div><div class=\"line\">$ npm install</div><div class=\"line\">$ npm run dev</div></pre></td></tr></table></figure>\n<p class=\"tip\">The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through <a href=\"./\">the guide</a> without any build tools before using the CLI.</p>\n\n<p class=\"tip\">CLI 默认了用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读<a href=\"/guide/\">指南</a>，熟悉 Vue 本身之后再研究 CLI。</p>\n\n<p class=\"tip\">对于大陆用户，建议将 npm 的注册表源<a href=\"http://riny.net/2014/cnpm/\">设置为国内的镜像</a>，可以大幅提升安装速度。</p>\n\n<h2 id=\"开发版本\"><a href=\"#开发版本\" class=\"headerlink\" title=\"开发版本\"></a>开发版本</h2><p><strong>重要</strong>: Github 仓库的 <code>/dist</code> 文件夹只有在新版本发布时才会更新。如果想要使用 Github 上 Vue 最新的源码，你需要自己构建。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/vuejs/vue.git node_modules/vue</div><div class=\"line\"><span class=\"built_in\">cd</span> node_modules/vue</div><div class=\"line\">npm install</div><div class=\"line\">npm run build</div></pre></td></tr></table></figure>\n<h2 id=\"Bower\"><a href=\"#Bower\" class=\"headerlink\" title=\"Bower\"></a>Bower</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 最新稳定版本</span></div><div class=\"line\">$ bower install vue</div></pre></td></tr></table></figure>\n<h2 id=\"AMD-模块加载器\"><a href=\"#AMD-模块加载器\" class=\"headerlink\" title=\"AMD 模块加载器\"></a>AMD 模块加载器</h2><p>独立下载版本或通过 Bower 安装的版本已用 UMD 包装，因此它们可以直接用作 AMD 模块。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/installation.html\">http://vuejs.org/guide/installation.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"加入Vue.js社区","type":"guide","order":29,"_content":"\nVue.js 的社区正在急速增长中，如果你正在阅读本文，这是你准备好加入 Vue.js 社区的大好机会。欢迎！\n\n现在我们来解答你能从社区中获得什么以及你能为社区做什么。\n\n## 你将享受的资源\n\n### 获取帮助\n\n- [论坛](http://forum.vuejs.org/)：询问与 Vue 及其生态的相关问题的最佳地点。\n- [Gitter 频道](https://gitter.im/vuejs/vue)：开发者聊天室。你也可以在这儿提问，不过最好在论坛提问，因为论坛提供板块。\n- [Github](https://github.com/vuejs)：如果你想报告 bug 或者提交请求，欢迎来 Github 提交 issues 。我们也非常欢迎 pull requests！\n\n### 探索生态\n\n- [Awesome Vue](https://github.com/vuejs/awesome-vue)：一览其他牛人发布的优秀资源。\n- [\"Show and Tell\" 子论坛](http://forum.vuejs.org/c/show-and-tell)：又一个好地方，可以看看他人借助 Vue 生态完成的作品，以及他人为不断壮大的 Vue 生态的贡献。\n\n\n## 你力所能及的\n\n### 贡献代码\n\n和所有的项目一样，贡献代码是有规范的。为了保证我们能尽快地帮助你解决问题或者接受你的 pull requests，请先阅读这份[贡献指南](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md)。\n\n阅读之后，你应该已经准备好向 Vue 的核心仓库贡献代码了：\n\n- [vue](https://github.com/vuejs/vue): 核心库\n- [vuex](https://github.com/vuejs/vuex): 类 Flux 的状态管理架构\n- [vue-router](https://github.com/vuejs/vue-router): 为单页面应用提供的路由系统\n\n...还有许多小型的官方[同伴库](https://github.com/vuejs)。\n\n## 分享（并构筑）你的见识\n\n除了在论坛域 Gitter 频道回答问题、分享资源外，还有一些更小众的方式可以分享并增长你的见识：\n\n- **开发学习资料。**常说最好的学习方式就是教导。如果你正在用 Vue 做一些有趣的事情，你可以写一篇博客、组织研讨会、甚至创建一个gist，然后分享到社交平台：这些都能加强你的专项知识。\n- **关注（watch）你关心的仓库。**这样无论何时该仓库有新的动静，它都会第一时间通知你，提供关于正在进行的讨论以及即将到来的新特性的新鲜情报。这是超棒的提高专门知识的方法，然后你将终于有能力来解决问题（issues）并提交 pull requests。\n\n### 翻译文档\n\nVue 已经在全球范围内传播开来，核心团队成员甚至来自至少 6 个时区。[论坛](http://forum.vuejs.org/) 已有 7 种语言，数字还在持续增长。我们许多文档都有[积极维护的翻译](https://github.com/vuejs?utf8=%E2%9C%93&query=vuejs.org)。我们非常为 Vue 的国际影响力骄傲，但我们还能做得更好。\n\n我希望现在你正在使用你的首选语言阅读这个句子。如果不是，你愿意帮我们实现它吗？\n\n如果你愿意的话，请随时为[这些文档](https://github.com/vuejs/vuejs.org/)，或者官方维护的其他文档 fork 这个仓库，然后开始翻译吧。只要你取得了进展，就请在主仓库开一个 issue 或者 pull request，我们将号召更多的贡献者来帮助你。\n\n***\n\n> 原文： http://vuejs.org/guide/join.html\n\n***\n","source":"v2/guide/join.md","raw":"---\ntitle: 加入Vue.js社区\ntype: guide\norder: 29\n---\n\nVue.js 的社区正在急速增长中，如果你正在阅读本文，这是你准备好加入 Vue.js 社区的大好机会。欢迎！\n\n现在我们来解答你能从社区中获得什么以及你能为社区做什么。\n\n## 你将享受的资源\n\n### 获取帮助\n\n- [论坛](http://forum.vuejs.org/)：询问与 Vue 及其生态的相关问题的最佳地点。\n- [Gitter 频道](https://gitter.im/vuejs/vue)：开发者聊天室。你也可以在这儿提问，不过最好在论坛提问，因为论坛提供板块。\n- [Github](https://github.com/vuejs)：如果你想报告 bug 或者提交请求，欢迎来 Github 提交 issues 。我们也非常欢迎 pull requests！\n\n### 探索生态\n\n- [Awesome Vue](https://github.com/vuejs/awesome-vue)：一览其他牛人发布的优秀资源。\n- [\"Show and Tell\" 子论坛](http://forum.vuejs.org/c/show-and-tell)：又一个好地方，可以看看他人借助 Vue 生态完成的作品，以及他人为不断壮大的 Vue 生态的贡献。\n\n\n## 你力所能及的\n\n### 贡献代码\n\n和所有的项目一样，贡献代码是有规范的。为了保证我们能尽快地帮助你解决问题或者接受你的 pull requests，请先阅读这份[贡献指南](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md)。\n\n阅读之后，你应该已经准备好向 Vue 的核心仓库贡献代码了：\n\n- [vue](https://github.com/vuejs/vue): 核心库\n- [vuex](https://github.com/vuejs/vuex): 类 Flux 的状态管理架构\n- [vue-router](https://github.com/vuejs/vue-router): 为单页面应用提供的路由系统\n\n...还有许多小型的官方[同伴库](https://github.com/vuejs)。\n\n## 分享（并构筑）你的见识\n\n除了在论坛域 Gitter 频道回答问题、分享资源外，还有一些更小众的方式可以分享并增长你的见识：\n\n- **开发学习资料。**常说最好的学习方式就是教导。如果你正在用 Vue 做一些有趣的事情，你可以写一篇博客、组织研讨会、甚至创建一个gist，然后分享到社交平台：这些都能加强你的专项知识。\n- **关注（watch）你关心的仓库。**这样无论何时该仓库有新的动静，它都会第一时间通知你，提供关于正在进行的讨论以及即将到来的新特性的新鲜情报。这是超棒的提高专门知识的方法，然后你将终于有能力来解决问题（issues）并提交 pull requests。\n\n### 翻译文档\n\nVue 已经在全球范围内传播开来，核心团队成员甚至来自至少 6 个时区。[论坛](http://forum.vuejs.org/) 已有 7 种语言，数字还在持续增长。我们许多文档都有[积极维护的翻译](https://github.com/vuejs?utf8=%E2%9C%93&query=vuejs.org)。我们非常为 Vue 的国际影响力骄傲，但我们还能做得更好。\n\n我希望现在你正在使用你的首选语言阅读这个句子。如果不是，你愿意帮我们实现它吗？\n\n如果你愿意的话，请随时为[这些文档](https://github.com/vuejs/vuejs.org/)，或者官方维护的其他文档 fork 这个仓库，然后开始翻译吧。只要你取得了进展，就请在主仓库开一个 issue 或者 pull request，我们将号召更多的贡献者来帮助你。\n\n***\n\n> 原文： http://vuejs.org/guide/join.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/join.html","comments":1,"layout":"page","_id":"ciwnajuyo001fjl2dot2j5o13","content":"<p>Vue.js 的社区正在急速增长中，如果你正在阅读本文，这是你准备好加入 Vue.js 社区的大好机会。欢迎！</p>\n<p>现在我们来解答你能从社区中获得什么以及你能为社区做什么。</p>\n<h2 id=\"你将享受的资源\"><a href=\"#你将享受的资源\" class=\"headerlink\" title=\"你将享受的资源\"></a>你将享受的资源</h2><h3 id=\"获取帮助\"><a href=\"#获取帮助\" class=\"headerlink\" title=\"获取帮助\"></a>获取帮助</h3><ul>\n<li><a href=\"http://forum.vuejs.org/\" target=\"_blank\" rel=\"external\">论坛</a>：询问与 Vue 及其生态的相关问题的最佳地点。</li>\n<li><a href=\"https://gitter.im/vuejs/vue\" target=\"_blank\" rel=\"external\">Gitter 频道</a>：开发者聊天室。你也可以在这儿提问，不过最好在论坛提问，因为论坛提供板块。</li>\n<li><a href=\"https://github.com/vuejs\" target=\"_blank\" rel=\"external\">Github</a>：如果你想报告 bug 或者提交请求，欢迎来 Github 提交 issues 。我们也非常欢迎 pull requests！</li>\n</ul>\n<h3 id=\"探索生态\"><a href=\"#探索生态\" class=\"headerlink\" title=\"探索生态\"></a>探索生态</h3><ul>\n<li><a href=\"https://github.com/vuejs/awesome-vue\" target=\"_blank\" rel=\"external\">Awesome Vue</a>：一览其他牛人发布的优秀资源。</li>\n<li><a href=\"http://forum.vuejs.org/c/show-and-tell\" target=\"_blank\" rel=\"external\">“Show and Tell” 子论坛</a>：又一个好地方，可以看看他人借助 Vue 生态完成的作品，以及他人为不断壮大的 Vue 生态的贡献。</li>\n</ul>\n<h2 id=\"你力所能及的\"><a href=\"#你力所能及的\" class=\"headerlink\" title=\"你力所能及的\"></a>你力所能及的</h2><h3 id=\"贡献代码\"><a href=\"#贡献代码\" class=\"headerlink\" title=\"贡献代码\"></a>贡献代码</h3><p>和所有的项目一样，贡献代码是有规范的。为了保证我们能尽快地帮助你解决问题或者接受你的 pull requests，请先阅读这份<a href=\"https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md\" target=\"_blank\" rel=\"external\">贡献指南</a>。</p>\n<p>阅读之后，你应该已经准备好向 Vue 的核心仓库贡献代码了：</p>\n<ul>\n<li><a href=\"https://github.com/vuejs/vue\" target=\"_blank\" rel=\"external\">vue</a>: 核心库</li>\n<li><a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">vuex</a>: 类 Flux 的状态管理架构</li>\n<li><a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"external\">vue-router</a>: 为单页面应用提供的路由系统</li>\n</ul>\n<p>…还有许多小型的官方<a href=\"https://github.com/vuejs\" target=\"_blank\" rel=\"external\">同伴库</a>。</p>\n<h2 id=\"分享（并构筑）你的见识\"><a href=\"#分享（并构筑）你的见识\" class=\"headerlink\" title=\"分享（并构筑）你的见识\"></a>分享（并构筑）你的见识</h2><p>除了在论坛域 Gitter 频道回答问题、分享资源外，还有一些更小众的方式可以分享并增长你的见识：</p>\n<ul>\n<li><strong>开发学习资料。</strong>常说最好的学习方式就是教导。如果你正在用 Vue 做一些有趣的事情，你可以写一篇博客、组织研讨会、甚至创建一个gist，然后分享到社交平台：这些都能加强你的专项知识。</li>\n<li><strong>关注（watch）你关心的仓库。</strong>这样无论何时该仓库有新的动静，它都会第一时间通知你，提供关于正在进行的讨论以及即将到来的新特性的新鲜情报。这是超棒的提高专门知识的方法，然后你将终于有能力来解决问题（issues）并提交 pull requests。</li>\n</ul>\n<h3 id=\"翻译文档\"><a href=\"#翻译文档\" class=\"headerlink\" title=\"翻译文档\"></a>翻译文档</h3><p>Vue 已经在全球范围内传播开来，核心团队成员甚至来自至少 6 个时区。<a href=\"http://forum.vuejs.org/\" target=\"_blank\" rel=\"external\">论坛</a> 已有 7 种语言，数字还在持续增长。我们许多文档都有<a href=\"https://github.com/vuejs?utf8=%E2%9C%93&amp;query=vuejs.org\" target=\"_blank\" rel=\"external\">积极维护的翻译</a>。我们非常为 Vue 的国际影响力骄傲，但我们还能做得更好。</p>\n<p>我希望现在你正在使用你的首选语言阅读这个句子。如果不是，你愿意帮我们实现它吗？</p>\n<p>如果你愿意的话，请随时为<a href=\"https://github.com/vuejs/vuejs.org/\" target=\"_blank\" rel=\"external\">这些文档</a>，或者官方维护的其他文档 fork 这个仓库，然后开始翻译吧。只要你取得了进展，就请在主仓库开一个 issue 或者 pull request，我们将号召更多的贡献者来帮助你。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/join.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/join.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<p>Vue.js 的社区正在急速增长中，如果你正在阅读本文，这是你准备好加入 Vue.js 社区的大好机会。欢迎！</p>\n<p>现在我们来解答你能从社区中获得什么以及你能为社区做什么。</p>\n<h2 id=\"你将享受的资源\"><a href=\"#你将享受的资源\" class=\"headerlink\" title=\"你将享受的资源\"></a>你将享受的资源</h2><h3 id=\"获取帮助\"><a href=\"#获取帮助\" class=\"headerlink\" title=\"获取帮助\"></a>获取帮助</h3><ul>\n<li><a href=\"http://forum.vuejs.org/\">论坛</a>：询问与 Vue 及其生态的相关问题的最佳地点。</li>\n<li><a href=\"https://gitter.im/vuejs/vue\">Gitter 频道</a>：开发者聊天室。你也可以在这儿提问，不过最好在论坛提问，因为论坛提供板块。</li>\n<li><a href=\"https://github.com/vuejs\">Github</a>：如果你想报告 bug 或者提交请求，欢迎来 Github 提交 issues 。我们也非常欢迎 pull requests！</li>\n</ul>\n<h3 id=\"探索生态\"><a href=\"#探索生态\" class=\"headerlink\" title=\"探索生态\"></a>探索生态</h3><ul>\n<li><a href=\"https://github.com/vuejs/awesome-vue\">Awesome Vue</a>：一览其他牛人发布的优秀资源。</li>\n<li><a href=\"http://forum.vuejs.org/c/show-and-tell\">“Show and Tell” 子论坛</a>：又一个好地方，可以看看他人借助 Vue 生态完成的作品，以及他人为不断壮大的 Vue 生态的贡献。</li>\n</ul>\n<h2 id=\"你力所能及的\"><a href=\"#你力所能及的\" class=\"headerlink\" title=\"你力所能及的\"></a>你力所能及的</h2><h3 id=\"贡献代码\"><a href=\"#贡献代码\" class=\"headerlink\" title=\"贡献代码\"></a>贡献代码</h3><p>和所有的项目一样，贡献代码是有规范的。为了保证我们能尽快地帮助你解决问题或者接受你的 pull requests，请先阅读这份<a href=\"https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md\">贡献指南</a>。</p>\n<p>阅读之后，你应该已经准备好向 Vue 的核心仓库贡献代码了：</p>\n<ul>\n<li><a href=\"https://github.com/vuejs/vue\">vue</a>: 核心库</li>\n<li><a href=\"https://github.com/vuejs/vuex\">vuex</a>: 类 Flux 的状态管理架构</li>\n<li><a href=\"https://github.com/vuejs/vue-router\">vue-router</a>: 为单页面应用提供的路由系统</li>\n</ul>\n<p>…还有许多小型的官方<a href=\"https://github.com/vuejs\">同伴库</a>。</p>\n<h2 id=\"分享（并构筑）你的见识\"><a href=\"#分享（并构筑）你的见识\" class=\"headerlink\" title=\"分享（并构筑）你的见识\"></a>分享（并构筑）你的见识</h2><p>除了在论坛域 Gitter 频道回答问题、分享资源外，还有一些更小众的方式可以分享并增长你的见识：</p>\n<ul>\n<li><strong>开发学习资料。</strong>常说最好的学习方式就是教导。如果你正在用 Vue 做一些有趣的事情，你可以写一篇博客、组织研讨会、甚至创建一个gist，然后分享到社交平台：这些都能加强你的专项知识。</li>\n<li><strong>关注（watch）你关心的仓库。</strong>这样无论何时该仓库有新的动静，它都会第一时间通知你，提供关于正在进行的讨论以及即将到来的新特性的新鲜情报。这是超棒的提高专门知识的方法，然后你将终于有能力来解决问题（issues）并提交 pull requests。</li>\n</ul>\n<h3 id=\"翻译文档\"><a href=\"#翻译文档\" class=\"headerlink\" title=\"翻译文档\"></a>翻译文档</h3><p>Vue 已经在全球范围内传播开来，核心团队成员甚至来自至少 6 个时区。<a href=\"http://forum.vuejs.org/\">论坛</a> 已有 7 种语言，数字还在持续增长。我们许多文档都有<a href=\"https://github.com/vuejs?utf8=%E2%9C%93&amp;query=vuejs.org\">积极维护的翻译</a>。我们非常为 Vue 的国际影响力骄傲，但我们还能做得更好。</p>\n<p>我希望现在你正在使用你的首选语言阅读这个句子。如果不是，你愿意帮我们实现它吗？</p>\n<p>如果你愿意的话，请随时为<a href=\"https://github.com/vuejs/vuejs.org/\">这些文档</a>，或者官方维护的其他文档 fork 这个仓库，然后开始翻译吧。只要你取得了进展，就请在主仓库开一个 issue 或者 pull request，我们将号召更多的贡献者来帮助你。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/join.html\">http://vuejs.org/guide/join.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"Vue 实例","type":"guide","order":3,"_content":"\n## 构造器\n\n每个 Vue.js 应用都是通过构造函数 `Vue` 创建一个 **Vue 的根实例** 启动的：\n\n``` js\nvar vm = new Vue({\n  // 选项\n})\n```\n\n虽然没有完全遵循 [MVVM 模式](https://en.wikipedia.org/wiki/Model_View_ViewModel)， Vue 的设计无疑受到了它的启发。因此在文档中经常会使用 `vm` 这个变量名表示 Vue 实例。\n\n在实例化 Vue 时，需要传入一个**选项对象**，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。全部的选项可以在 [API 文档](../api)中查看。\n\n可以扩展 `Vue` 构造器，从而用预定义选项创建可复用的**组件构造器**：\n\n``` js\nvar MyComponent = Vue.extend({\n  // 扩展选项\n})\n\n// 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建\nvar myComponentInstance = new MyComponent()\n```\n\n尽管可以命令式地创建扩展实例，不过在多数情况下建议将组件构造器注册为一个自定义元素，然后声明式地用在模板中。我们将在后面详细说明[组件系统](/guide/components.html)。现在你只需知道所有的 Vue.js 组件其实都是被扩展的 Vue 实例。\n\n\n## 属性与方法\n\n每个 Vue 实例都会**代理**其 `data` 对象里所有的属性：\n\n``` js\nvar data = { a: 1 }\nvar vm = new Vue({\n  data: data\n})\n\nvm.a === data.a // -> true\n\n// 设置属性也会影响到原始数据\nvm.a = 2\ndata.a // -> 2\n\n// ... 反之亦然\ndata.a = 3\nvm.a // -> 3\n```\n\n注意只有这些被代理的属性是**响应的**。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。我们将在后面详细讨论响应系统。\n\n除了 data 属性， Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 `$`，以便与代理的 data 属性区分。例如：\n\n``` js\nvar data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // -> true\nvm.$el === document.getElementById('example') // -> true\n\n// $watch 是一个实例方法\nvm.$watch('a', function (newVal, oldVal) {\n  // 这个回调将在 `vm.a`  改变后调用\n})\n```\n\n<p class=\"tip\">注意，不要在实例属性或者回调函数中（如 `vm.$watch('a', newVal => this.myMethod())`）使用[箭头函数](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions)。因为箭头函数绑定父上下文，所以 `this` 不会像预想的一样是 Vue 实例，而是 `this.myMethod` 未被定义。</p>\n\n实例属性和方法的完整列表中查阅 [API 参考](../api)。\n\n## 实例生命周期\n\n每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 **生命周期钩子** ，这就给我们提供了执行自定义逻辑的机会。例如，`created` 这个钩子在实例被创建之后被调用：\n\n``` js\nvar vm = new Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` 指向 vm 实例\n    console.log('a is: ' + this.a)\n  }\n})\n// -> \"a is: 1\"\n```\n\n也有一些其它的钩子，在实例生命周期的不同阶段调用，如 `mounted`、 `updated` 、`destroyed` 。钩子的 `this` 指向调用它的 Vue 实例。一些用户可能会问 Vue.js 是否有“控制器”的概念？答案是，没有。组件的自定义逻辑可以分布在这些钩子中。\n\n\n## 生命周期图示\n\n下图说明了实例的生命周期。你不需要立马弄明白所有的东西，不过以后它会有帮助。\n\n![Lifecycle](/images/lifecycle.png)\n\n\n***\n\n> 原文： http://vuejs.org/guide/instance.html\n\n***\n","source":"v2/guide/instance.md","raw":"---\ntitle: Vue 实例\ntype: guide\norder: 3\n---\n\n## 构造器\n\n每个 Vue.js 应用都是通过构造函数 `Vue` 创建一个 **Vue 的根实例** 启动的：\n\n``` js\nvar vm = new Vue({\n  // 选项\n})\n```\n\n虽然没有完全遵循 [MVVM 模式](https://en.wikipedia.org/wiki/Model_View_ViewModel)， Vue 的设计无疑受到了它的启发。因此在文档中经常会使用 `vm` 这个变量名表示 Vue 实例。\n\n在实例化 Vue 时，需要传入一个**选项对象**，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。全部的选项可以在 [API 文档](../api)中查看。\n\n可以扩展 `Vue` 构造器，从而用预定义选项创建可复用的**组件构造器**：\n\n``` js\nvar MyComponent = Vue.extend({\n  // 扩展选项\n})\n\n// 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建\nvar myComponentInstance = new MyComponent()\n```\n\n尽管可以命令式地创建扩展实例，不过在多数情况下建议将组件构造器注册为一个自定义元素，然后声明式地用在模板中。我们将在后面详细说明[组件系统](/guide/components.html)。现在你只需知道所有的 Vue.js 组件其实都是被扩展的 Vue 实例。\n\n\n## 属性与方法\n\n每个 Vue 实例都会**代理**其 `data` 对象里所有的属性：\n\n``` js\nvar data = { a: 1 }\nvar vm = new Vue({\n  data: data\n})\n\nvm.a === data.a // -> true\n\n// 设置属性也会影响到原始数据\nvm.a = 2\ndata.a // -> 2\n\n// ... 反之亦然\ndata.a = 3\nvm.a // -> 3\n```\n\n注意只有这些被代理的属性是**响应的**。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。我们将在后面详细讨论响应系统。\n\n除了 data 属性， Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 `$`，以便与代理的 data 属性区分。例如：\n\n``` js\nvar data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // -> true\nvm.$el === document.getElementById('example') // -> true\n\n// $watch 是一个实例方法\nvm.$watch('a', function (newVal, oldVal) {\n  // 这个回调将在 `vm.a`  改变后调用\n})\n```\n\n<p class=\"tip\">注意，不要在实例属性或者回调函数中（如 `vm.$watch('a', newVal => this.myMethod())`）使用[箭头函数](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions)。因为箭头函数绑定父上下文，所以 `this` 不会像预想的一样是 Vue 实例，而是 `this.myMethod` 未被定义。</p>\n\n实例属性和方法的完整列表中查阅 [API 参考](../api)。\n\n## 实例生命周期\n\n每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 **生命周期钩子** ，这就给我们提供了执行自定义逻辑的机会。例如，`created` 这个钩子在实例被创建之后被调用：\n\n``` js\nvar vm = new Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` 指向 vm 实例\n    console.log('a is: ' + this.a)\n  }\n})\n// -> \"a is: 1\"\n```\n\n也有一些其它的钩子，在实例生命周期的不同阶段调用，如 `mounted`、 `updated` 、`destroyed` 。钩子的 `this` 指向调用它的 Vue 实例。一些用户可能会问 Vue.js 是否有“控制器”的概念？答案是，没有。组件的自定义逻辑可以分布在这些钩子中。\n\n\n## 生命周期图示\n\n下图说明了实例的生命周期。你不需要立马弄明白所有的东西，不过以后它会有帮助。\n\n![Lifecycle](/images/lifecycle.png)\n\n\n***\n\n> 原文： http://vuejs.org/guide/instance.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/instance.html","comments":1,"layout":"page","_id":"ciwnajuyp001gjl2d7ga6s8rk","content":"<h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h2><p>每个 Vue.js 应用都是通过构造函数 <code>Vue</code> 创建一个 <strong>Vue 的根实例</strong> 启动的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"comment\">// 选项</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>虽然没有完全遵循 <a href=\"https://en.wikipedia.org/wiki/Model_View_ViewModel\" target=\"_blank\" rel=\"external\">MVVM 模式</a>， Vue 的设计无疑受到了它的启发。因此在文档中经常会使用 <code>vm</code> 这个变量名表示 Vue 实例。</p>\n<p>在实例化 Vue 时，需要传入一个<strong>选项对象</strong>，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。全部的选项可以在 <a href=\"../api\">API 文档</a>中查看。</p>\n<p>可以扩展 <code>Vue</code> 构造器，从而用预定义选项创建可复用的<strong>组件构造器</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"comment\">// 扩展选项</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建</span></div><div class=\"line\"><span class=\"keyword\">var</span> myComponentInstance = <span class=\"keyword\">new</span> MyComponent()</div></pre></td></tr></table></figure>\n<p>尽管可以命令式地创建扩展实例，不过在多数情况下建议将组件构造器注册为一个自定义元素，然后声明式地用在模板中。我们将在后面详细说明<a href=\"/guide/components.html\">组件系统</a>。现在你只需知道所有的 Vue.js 组件其实都是被扩展的 Vue 实例。</p>\n<h2 id=\"属性与方法\"><a href=\"#属性与方法\" class=\"headerlink\" title=\"属性与方法\"></a>属性与方法</h2><p>每个 Vue 实例都会<strong>代理</strong>其 <code>data</code> 对象里所有的属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: data</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">vm.a === data.a <span class=\"comment\">// -&gt; true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置属性也会影响到原始数据</span></div><div class=\"line\">vm.a = <span class=\"number\">2</span></div><div class=\"line\">data.a <span class=\"comment\">// -&gt; 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ... 反之亦然</span></div><div class=\"line\">data.a = <span class=\"number\">3</span></div><div class=\"line\">vm.a <span class=\"comment\">// -&gt; 3</span></div></pre></td></tr></table></figure>\n<p>注意只有这些被代理的属性是<strong>响应的</strong>。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。我们将在后面详细讨论响应系统。</p>\n<p>除了 data 属性， Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 <code>$</code>，以便与代理的 data 属性区分。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: data</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">vm.$data === data <span class=\"comment\">// -&gt; true</span></div><div class=\"line\">vm.$el === <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>) <span class=\"comment\">// -&gt; true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// $watch 是一个实例方法</span></div><div class=\"line\">vm.$watch(<span class=\"string\">'a'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 这个回调将在 `vm.a`  改变后调用</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">注意，不要在实例属性或者回调函数中（如 <code>vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())</code>）使用<a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"external\">箭头函数</a>。因为箭头函数绑定父上下文，所以 <code>this</code> 不会像预想的一样是 Vue 实例，而是 <code>this.myMethod</code> 未被定义。</p>\n\n<p>实例属性和方法的完整列表中查阅 <a href=\"../api\">API 参考</a>。</p>\n<h2 id=\"实例生命周期\"><a href=\"#实例生命周期\" class=\"headerlink\" title=\"实例生命周期\"></a>实例生命周期</h2><p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 <strong>生命周期钩子</strong> ，这就给我们提供了执行自定义逻辑的机会。例如，<code>created</code> 这个钩子在实例被创建之后被调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// `this` 指向 vm 实例</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a is: '</span> + <span class=\"keyword\">this</span>.a)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// -&gt; \"a is: 1\"</span></div></pre></td></tr></table></figure>\n<p>也有一些其它的钩子，在实例生命周期的不同阶段调用，如 <code>mounted</code>、 <code>updated</code> 、<code>destroyed</code> 。钩子的 <code>this</code> 指向调用它的 Vue 实例。一些用户可能会问 Vue.js 是否有“控制器”的概念？答案是，没有。组件的自定义逻辑可以分布在这些钩子中。</p>\n<h2 id=\"生命周期图示\"><a href=\"#生命周期图示\" class=\"headerlink\" title=\"生命周期图示\"></a>生命周期图示</h2><p>下图说明了实例的生命周期。你不需要立马弄明白所有的东西，不过以后它会有帮助。</p>\n<p><img src=\"/images/lifecycle.png\" alt=\"Lifecycle\"></p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/instance.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/instance.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h2><p>每个 Vue.js 应用都是通过构造函数 <code>Vue</code> 创建一个 <strong>Vue 的根实例</strong> 启动的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"comment\">// 选项</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>虽然没有完全遵循 <a href=\"https://en.wikipedia.org/wiki/Model_View_ViewModel\">MVVM 模式</a>， Vue 的设计无疑受到了它的启发。因此在文档中经常会使用 <code>vm</code> 这个变量名表示 Vue 实例。</p>\n<p>在实例化 Vue 时，需要传入一个<strong>选项对象</strong>，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。全部的选项可以在 <a href=\"../api\">API 文档</a>中查看。</p>\n<p>可以扩展 <code>Vue</code> 构造器，从而用预定义选项创建可复用的<strong>组件构造器</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"comment\">// 扩展选项</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建</span></div><div class=\"line\"><span class=\"keyword\">var</span> myComponentInstance = <span class=\"keyword\">new</span> MyComponent()</div></pre></td></tr></table></figure>\n<p>尽管可以命令式地创建扩展实例，不过在多数情况下建议将组件构造器注册为一个自定义元素，然后声明式地用在模板中。我们将在后面详细说明<a href=\"/guide/components.html\">组件系统</a>。现在你只需知道所有的 Vue.js 组件其实都是被扩展的 Vue 实例。</p>\n<h2 id=\"属性与方法\"><a href=\"#属性与方法\" class=\"headerlink\" title=\"属性与方法\"></a>属性与方法</h2><p>每个 Vue 实例都会<strong>代理</strong>其 <code>data</code> 对象里所有的属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: data</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">vm.a === data.a <span class=\"comment\">// -&gt; true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置属性也会影响到原始数据</span></div><div class=\"line\">vm.a = <span class=\"number\">2</span></div><div class=\"line\">data.a <span class=\"comment\">// -&gt; 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ... 反之亦然</span></div><div class=\"line\">data.a = <span class=\"number\">3</span></div><div class=\"line\">vm.a <span class=\"comment\">// -&gt; 3</span></div></pre></td></tr></table></figure>\n<p>注意只有这些被代理的属性是<strong>响应的</strong>。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。我们将在后面详细讨论响应系统。</p>\n<p>除了 data 属性， Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 <code>$</code>，以便与代理的 data 属性区分。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: data</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">vm.$data === data <span class=\"comment\">// -&gt; true</span></div><div class=\"line\">vm.$el === <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>) <span class=\"comment\">// -&gt; true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// $watch 是一个实例方法</span></div><div class=\"line\">vm.$watch(<span class=\"string\">'a'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 这个回调将在 `vm.a`  改变后调用</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">注意，不要在实例属性或者回调函数中（如 <code>vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())</code>）使用<a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a>。因为箭头函数绑定父上下文，所以 <code>this</code> 不会像预想的一样是 Vue 实例，而是 <code>this.myMethod</code> 未被定义。</p>\n\n<p>实例属性和方法的完整列表中查阅 <a href=\"../api\">API 参考</a>。</p>\n<h2 id=\"实例生命周期\"><a href=\"#实例生命周期\" class=\"headerlink\" title=\"实例生命周期\"></a>实例生命周期</h2><p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 <strong>生命周期钩子</strong> ，这就给我们提供了执行自定义逻辑的机会。例如，<code>created</code> 这个钩子在实例被创建之后被调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// `this` 指向 vm 实例</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a is: '</span> + <span class=\"keyword\">this</span>.a)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// -&gt; \"a is: 1\"</span></div></pre></td></tr></table></figure>\n<p>也有一些其它的钩子，在实例生命周期的不同阶段调用，如 <code>mounted</code>、 <code>updated</code> 、<code>destroyed</code> 。钩子的 <code>this</code> 指向调用它的 Vue 实例。一些用户可能会问 Vue.js 是否有“控制器”的概念？答案是，没有。组件的自定义逻辑可以分布在这些钩子中。</p>\n<h2 id=\"生命周期图示\"><a href=\"#生命周期图示\" class=\"headerlink\" title=\"生命周期图示\"></a>生命周期图示</h2><p>下图说明了实例的生命周期。你不需要立马弄明白所有的东西，不过以后它会有帮助。</p>\n<p><img src=\"/images/lifecycle.png\" alt=\"Lifecycle\"></p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/instance.html\">http://vuejs.org/guide/instance.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"列表渲染","type":"guide","order":8,"_content":"\n## `v-for`\n\n我们用 `v-for` 指令根据一组数组的选项列表进行渲染。 `v-for` 指令需要以 `item in items` 形式的特殊语法， `items` 是源数据数组并且 `item` 是数组元素迭代的别名。\n\n### 基本用法\n\n``` html\n<ul id=\"example-1\">\n  <li v-for=\"item in items\">\n    {{ item.message }}\n  </li>\n</ul>\n```\n\n``` js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      {message: 'Foo' },\n      {message: 'Bar' }\n    ]\n  }\n})\n```\n\n结果：\n\n{% raw %}\n<ul id=\"example-1\" class=\"demo\">\n  <li v-for=\"item in items\">\n    {{item.message}}\n  </li>\n</ul>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  },\n  watch: {\n    items: function () {\n      smoothScroll.animateScroll(null, '#example-1')\n    }\n  }\n})\n</script>\n{% endraw %}\n\n在 `v-for` 块中，我们拥有对父作用域属性的完全访问权限。 `v-for` 还支持一个可选的第二个参数为当前项的索引。\n\n``` html\n<ul id=\"example-2\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n```\n\n``` js\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n```\n\n结果：\n\n{% raw%}\n<ul id=\"example-2\" class=\"demo\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  },\n  watch: {\n    items: function () {\n      smoothScroll.animateScroll(null, '#example-2')\n    }\n  }\n})\n</script>\n{% endraw %}\n\n你也可以用 `of` 替代 `in` 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：\n\n``` html\n<div v-for=\"item of items\"></div>\n```\n\n### Template v-for\n\n如同 `v-if` 模板，你也可以用带有 `v-for` 的 `<template>` 标签来渲染多个元素块。例如： \n\n``` html\n<ul>\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\"></li>\n  </template>\n</ul>\n```\n\n### 对象迭代 v-for\n\n你也可以用 `v-for` 通过一个对象的属性来迭代。\n\n``` html\n<ul id=\"repeat-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n```\n\n``` js\nnew Vue({\n  el: '#repeat-object',\n  data: {\n    object: {\n      FirstName: 'John',\n      LastName: 'Doe',\n      Age: 30\n    }\n  }\n})\n```\n\n结果：\n\n{% raw %}\n<ul id=\"repeat-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n<script>\nnew Vue({\n  el: '#repeat-object',\n  data: {\n    object: {\n      FirstName: 'John',\n      LastName: 'Doe',\n      Age: 30\n    }\n  }\n})\n</script>\n{% endraw %}\n\n你也可以提供第二个的参数为键名：\n\n``` html\n<div v-for=\"(value, key) in object\">\n  {{ key }} : {{ value }}\n</div>\n```\n\n第三个参数为索引：\n\n``` html\n<div v-for=\"(value, key, index) in object\">\n  {{ index }}. {{ key }} : {{ value }}\n</div>\n```\n\n<p class=\"tip\">在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。</p>\n\n### 整数迭代 v-for \n\n`v-for` 也可以取整数。在这种情况下，它将重复多次模板。\n\n``` html\n<div>\n  <span v-for=\"n in 10\">{{ n }}</span>\n</div>\n```\n\n结果：\n\n{% raw %}\n<div id=\"range\" class=\"demo\">\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n<script>\nnew Vue({ el: '#range' })\n</script>\n{% endraw %}\n\n### 组件 和 v-for\n\n> 了解组件相关知识，查看 [组件](components.html) 。完全可以先跳过它，以后再回来查看。\n\n在自定义组件里，你可以像任何普通元素一样用 `v-for` 。\n\n``` html\n<my-component v-for=\"item in items\"></my-component>\n```\n\n然而他不能自动传递数据到组件里，因为组件有自己独立的作用域。为了传递迭代数据到组件里，我们要用 `props` ：\n\n``` html\n<my-component\n  v-for=\"(item, index) in items\"\n  v-bind:item=\"item\"\n  v-bind:index=\"index\">\n</my-component>\n```\n\n不自动注入 `item` 到组件里的原因是，因为这使得组件会紧密耦合到 `v-for` 如何运作。在一些情况下，明确数据的来源可以使组件可重用。\n\n下面是一个简单的 todo list 完整的例子：\n\n``` html\n<div id=\"todo-list-example\">\n  <input\n    v-model=\"newTodoText\"\n    v-on:keyup.enter=\"addNewTodo\"\n    placeholder=\"Add a todo\"\n  >\n  <ul>\n    <li\n      is=\"todo-item\"\n      v-for=\"(todo, index) in todos\"\n      v-bind:title=\"todo\"\n      v-on:remove=\"todos.splice(index, 1)\"\n    ></li>\n  </ul>\n</div>\n```\n\n``` js\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">X</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\n\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      'Do the dishes',\n      'Take out the trash',\n      'Mow the lawn'\n    ]\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push(this.newTodoText)\n      this.newTodoText = ''\n    }\n  }\n})\n```\n\n{% raw %}\n<div id=\"todo-list-example\" class=\"demo\">\n  <input\n    v-model=\"newTodoText\" v\n    v-on:keyup.enter=\"addNewTodo\"\n    placeholder=\"Add a todo\"\n  >\n  <ul>\n    <li\n      is=\"todo-item\"\n      v-for=\"(todo, index) in todos\"\n      v-bind:title=\"todo\"\n      v-on:remove=\"todos.splice(index, 1)\"\n    ></li>\n  </ul>\n</div>\n<script>\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">X</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      'Do the dishes',\n      'Take out the trash',\n      'Mow the lawn'\n    ]\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push(this.newTodoText)\n      this.newTodoText = ''\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## key\n\n当 Vue.js 用 `v-for` 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序，  而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 `track-by=\"$index\"` 。\n\n这个默认的模式是有效的，但是只适用于不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出。\n\n为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` 属性。理想的 `key` 值是每项都有唯一 id。这个特殊的属性相当于 Vue 1.x 的 `track-by` ，但它的工作方式类似于一个属性，所以你需要用 `v-bind` 来绑定动态值（在这里使用简写）：\n\n``` html\n<div v-for=\"item in items\" :key=\"item.id\">\n  <!-- 内容 -->\n</div>\n```\n\n建议尽可能使用 `v-for` 来提供 `key` ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。\n\n因为它是 Vue 识别节点的一个通用机制， `key` 并不特别与 `v-for` 关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。\n\n## 数组更新检测\n\n### 变异方法\n\nVue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：\n\n- `push()`\n- `pop()`\n- `shift()`\n- `unshift()`\n- `splice()`\n- `sort()`\n- `reverse()`\n\n你打开控制台，然后用前面例子的 `items` 数组调用变异方法：`example1.items.push({ message: 'Baz' })` 。\n\n### 重塑数组\n\n变异方法(mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异(non-mutating method)方法，例如： `filter()`, `concat()`, `slice()` 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：\n\n``` js\nexample1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})\n```\n\n你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。 Vue 实现了一些智能启发式方法来最大化 DOM 元素重用，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。\n\n### 注意事项\n\n由于 JavaScript 的限制， Vue 不能检测以下变动的数组：\n\n1. 当你直接设置一个项的索引时，例如： `vm.items[indexOfItem] = newValue`\n2. 当你修改数组的长度时，例如： `vm.items.length = newLength`\n\n为了避免第一种情况，以下两种方式将达到像 `vm.items[indexOfItem] = newValue` 的效果， 同时也将触发状态更新：\n\n``` js\n// Vue.set\nVue.set(example1.items, indexOfItem, newValue)\n```\n``` js\n// Array.prototype.splice`\nexample1.items.splice(indexOfItem, 1, newValue)\n```\n\n避免第二种情况，使用 `splice`：\n\n``` js\nexample1.items.splice(newLength)\n```\n\n## 显示过滤/排序结果\n\n有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。\n\n例如：\n\n``` html\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n```\n\n``` js\ndata: {\n  numbers: [ 1, 2, 3, 4, 5 ]\n},\ncomputed: {\n  evenNumbers: function () {\n    return this.numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n\n或者，您也可以在计算属性不适用的情况下 (例如，在嵌套 `v-for` 循环中) 使用 method 方法：\n\n``` html\n<li v-for=\"n in even(numbers)\">{{ n }}</li>\n```\n\n``` js\ndata: {\n  numbers: [ 1, 2, 3, 4, 5 ]\n},\nmethods: {\n  even: function (numbers) {\n    return numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n\n***\n\n> 原文： http://vuejs.org/guide/list.html\n\n***\n","source":"v2/guide/list.md","raw":"---\ntitle: 列表渲染\ntype: guide\norder: 8\n---\n\n## `v-for`\n\n我们用 `v-for` 指令根据一组数组的选项列表进行渲染。 `v-for` 指令需要以 `item in items` 形式的特殊语法， `items` 是源数据数组并且 `item` 是数组元素迭代的别名。\n\n### 基本用法\n\n``` html\n<ul id=\"example-1\">\n  <li v-for=\"item in items\">\n    {{ item.message }}\n  </li>\n</ul>\n```\n\n``` js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      {message: 'Foo' },\n      {message: 'Bar' }\n    ]\n  }\n})\n```\n\n结果：\n\n{% raw %}\n<ul id=\"example-1\" class=\"demo\">\n  <li v-for=\"item in items\">\n    {{item.message}}\n  </li>\n</ul>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  },\n  watch: {\n    items: function () {\n      smoothScroll.animateScroll(null, '#example-1')\n    }\n  }\n})\n</script>\n{% endraw %}\n\n在 `v-for` 块中，我们拥有对父作用域属性的完全访问权限。 `v-for` 还支持一个可选的第二个参数为当前项的索引。\n\n``` html\n<ul id=\"example-2\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n```\n\n``` js\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n```\n\n结果：\n\n{% raw%}\n<ul id=\"example-2\" class=\"demo\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  },\n  watch: {\n    items: function () {\n      smoothScroll.animateScroll(null, '#example-2')\n    }\n  }\n})\n</script>\n{% endraw %}\n\n你也可以用 `of` 替代 `in` 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：\n\n``` html\n<div v-for=\"item of items\"></div>\n```\n\n### Template v-for\n\n如同 `v-if` 模板，你也可以用带有 `v-for` 的 `<template>` 标签来渲染多个元素块。例如： \n\n``` html\n<ul>\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\"></li>\n  </template>\n</ul>\n```\n\n### 对象迭代 v-for\n\n你也可以用 `v-for` 通过一个对象的属性来迭代。\n\n``` html\n<ul id=\"repeat-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n```\n\n``` js\nnew Vue({\n  el: '#repeat-object',\n  data: {\n    object: {\n      FirstName: 'John',\n      LastName: 'Doe',\n      Age: 30\n    }\n  }\n})\n```\n\n结果：\n\n{% raw %}\n<ul id=\"repeat-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n<script>\nnew Vue({\n  el: '#repeat-object',\n  data: {\n    object: {\n      FirstName: 'John',\n      LastName: 'Doe',\n      Age: 30\n    }\n  }\n})\n</script>\n{% endraw %}\n\n你也可以提供第二个的参数为键名：\n\n``` html\n<div v-for=\"(value, key) in object\">\n  {{ key }} : {{ value }}\n</div>\n```\n\n第三个参数为索引：\n\n``` html\n<div v-for=\"(value, key, index) in object\">\n  {{ index }}. {{ key }} : {{ value }}\n</div>\n```\n\n<p class=\"tip\">在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。</p>\n\n### 整数迭代 v-for \n\n`v-for` 也可以取整数。在这种情况下，它将重复多次模板。\n\n``` html\n<div>\n  <span v-for=\"n in 10\">{{ n }}</span>\n</div>\n```\n\n结果：\n\n{% raw %}\n<div id=\"range\" class=\"demo\">\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n<script>\nnew Vue({ el: '#range' })\n</script>\n{% endraw %}\n\n### 组件 和 v-for\n\n> 了解组件相关知识，查看 [组件](components.html) 。完全可以先跳过它，以后再回来查看。\n\n在自定义组件里，你可以像任何普通元素一样用 `v-for` 。\n\n``` html\n<my-component v-for=\"item in items\"></my-component>\n```\n\n然而他不能自动传递数据到组件里，因为组件有自己独立的作用域。为了传递迭代数据到组件里，我们要用 `props` ：\n\n``` html\n<my-component\n  v-for=\"(item, index) in items\"\n  v-bind:item=\"item\"\n  v-bind:index=\"index\">\n</my-component>\n```\n\n不自动注入 `item` 到组件里的原因是，因为这使得组件会紧密耦合到 `v-for` 如何运作。在一些情况下，明确数据的来源可以使组件可重用。\n\n下面是一个简单的 todo list 完整的例子：\n\n``` html\n<div id=\"todo-list-example\">\n  <input\n    v-model=\"newTodoText\"\n    v-on:keyup.enter=\"addNewTodo\"\n    placeholder=\"Add a todo\"\n  >\n  <ul>\n    <li\n      is=\"todo-item\"\n      v-for=\"(todo, index) in todos\"\n      v-bind:title=\"todo\"\n      v-on:remove=\"todos.splice(index, 1)\"\n    ></li>\n  </ul>\n</div>\n```\n\n``` js\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">X</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\n\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      'Do the dishes',\n      'Take out the trash',\n      'Mow the lawn'\n    ]\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push(this.newTodoText)\n      this.newTodoText = ''\n    }\n  }\n})\n```\n\n{% raw %}\n<div id=\"todo-list-example\" class=\"demo\">\n  <input\n    v-model=\"newTodoText\" v\n    v-on:keyup.enter=\"addNewTodo\"\n    placeholder=\"Add a todo\"\n  >\n  <ul>\n    <li\n      is=\"todo-item\"\n      v-for=\"(todo, index) in todos\"\n      v-bind:title=\"todo\"\n      v-on:remove=\"todos.splice(index, 1)\"\n    ></li>\n  </ul>\n</div>\n<script>\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">X</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      'Do the dishes',\n      'Take out the trash',\n      'Mow the lawn'\n    ]\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push(this.newTodoText)\n      this.newTodoText = ''\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## key\n\n当 Vue.js 用 `v-for` 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序，  而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 `track-by=\"$index\"` 。\n\n这个默认的模式是有效的，但是只适用于不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出。\n\n为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` 属性。理想的 `key` 值是每项都有唯一 id。这个特殊的属性相当于 Vue 1.x 的 `track-by` ，但它的工作方式类似于一个属性，所以你需要用 `v-bind` 来绑定动态值（在这里使用简写）：\n\n``` html\n<div v-for=\"item in items\" :key=\"item.id\">\n  <!-- 内容 -->\n</div>\n```\n\n建议尽可能使用 `v-for` 来提供 `key` ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。\n\n因为它是 Vue 识别节点的一个通用机制， `key` 并不特别与 `v-for` 关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。\n\n## 数组更新检测\n\n### 变异方法\n\nVue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：\n\n- `push()`\n- `pop()`\n- `shift()`\n- `unshift()`\n- `splice()`\n- `sort()`\n- `reverse()`\n\n你打开控制台，然后用前面例子的 `items` 数组调用变异方法：`example1.items.push({ message: 'Baz' })` 。\n\n### 重塑数组\n\n变异方法(mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异(non-mutating method)方法，例如： `filter()`, `concat()`, `slice()` 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：\n\n``` js\nexample1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})\n```\n\n你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。 Vue 实现了一些智能启发式方法来最大化 DOM 元素重用，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。\n\n### 注意事项\n\n由于 JavaScript 的限制， Vue 不能检测以下变动的数组：\n\n1. 当你直接设置一个项的索引时，例如： `vm.items[indexOfItem] = newValue`\n2. 当你修改数组的长度时，例如： `vm.items.length = newLength`\n\n为了避免第一种情况，以下两种方式将达到像 `vm.items[indexOfItem] = newValue` 的效果， 同时也将触发状态更新：\n\n``` js\n// Vue.set\nVue.set(example1.items, indexOfItem, newValue)\n```\n``` js\n// Array.prototype.splice`\nexample1.items.splice(indexOfItem, 1, newValue)\n```\n\n避免第二种情况，使用 `splice`：\n\n``` js\nexample1.items.splice(newLength)\n```\n\n## 显示过滤/排序结果\n\n有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。\n\n例如：\n\n``` html\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n```\n\n``` js\ndata: {\n  numbers: [ 1, 2, 3, 4, 5 ]\n},\ncomputed: {\n  evenNumbers: function () {\n    return this.numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n\n或者，您也可以在计算属性不适用的情况下 (例如，在嵌套 `v-for` 循环中) 使用 method 方法：\n\n``` html\n<li v-for=\"n in even(numbers)\">{{ n }}</li>\n```\n\n``` js\ndata: {\n  numbers: [ 1, 2, 3, 4, 5 ]\n},\nmethods: {\n  even: function (numbers) {\n    return numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n\n***\n\n> 原文： http://vuejs.org/guide/list.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/list.html","comments":1,"layout":"page","_id":"ciwnajuyp001hjl2d5z8kkl9q","content":"<h2 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a><code>v-for</code></h2><p>我们用 <code>v-for</code> 指令根据一组数组的选项列表进行渲染。 <code>v-for</code> 指令需要以 <code>item in items</code> 形式的特殊语法， <code>items</code> 是源数据数组并且 <code>item</code> 是数组元素迭代的别名。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-1\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; item.message &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> example1 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-1'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">items</span>: [</div><div class=\"line\">      &#123;<span class=\"attr\">message</span>: <span class=\"string\">'Foo'</span> &#125;,</div><div class=\"line\">      &#123;<span class=\"attr\">message</span>: <span class=\"string\">'Bar'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<ul id=\"example-1\" class=\"demo\">\n  <li v-for=\"item in items\">\n    {{item.message}}\n  </li>\n</ul>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  },\n  watch: {\n    items: function () {\n      smoothScroll.animateScroll(null, '#example-1')\n    }\n  }\n})\n</script>\n\n<p>在 <code>v-for</code> 块中，我们拥有对父作用域属性的完全访问权限。 <code>v-for</code> 还支持一个可选的第二个参数为当前项的索引。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-2'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">parentMessage</span>: <span class=\"string\">'Parent'</span>,</div><div class=\"line\">    <span class=\"attr\">items</span>: [</div><div class=\"line\">      &#123; <span class=\"attr\">message</span>: <span class=\"string\">'Foo'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">message</span>: <span class=\"string\">'Bar'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<ul id=\"example-2\" class=\"demo\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  },\n  watch: {\n    items: function () {\n      smoothScroll.animateScroll(null, '#example-2')\n    }\n  }\n})\n</script>\n\n<p>你也可以用 <code>of</code> 替代 <code>in</code> 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item of items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"Template-v-for\"><a href=\"#Template-v-for\" class=\"headerlink\" title=\"Template v-for\"></a>Template v-for</h3><p>如同 <code>v-if</code> 模板，你也可以用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 标签来渲染多个元素块。例如： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"divider\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"对象迭代-v-for\"><a href=\"#对象迭代-v-for\" class=\"headerlink\" title=\"对象迭代 v-for\"></a>对象迭代 v-for</h3><p>你也可以用 <code>v-for</code> 通过一个对象的属性来迭代。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"repeat-object\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"value in object\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; value &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#repeat-object'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">object</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">FirstName</span>: <span class=\"string\">'John'</span>,</div><div class=\"line\">      <span class=\"attr\">LastName</span>: <span class=\"string\">'Doe'</span>,</div><div class=\"line\">      <span class=\"attr\">Age</span>: <span class=\"number\">30</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<ul id=\"repeat-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n<script>\nnew Vue({\n  el: '#repeat-object',\n  data: {\n    object: {\n      FirstName: 'John',\n      LastName: 'Doe',\n      Age: 30\n    }\n  }\n})\n</script>\n\n<p>你也可以提供第二个的参数为键名：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(value, key) in object\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>第三个参数为索引：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(value, key, index) in object\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。</p>\n\n<h3 id=\"整数迭代-v-for\"><a href=\"#整数迭代-v-for\" class=\"headerlink\" title=\"整数迭代 v-for\"></a>整数迭代 v-for</h3><p><code>v-for</code> 也可以取整数。在这种情况下，它将重复多次模板。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in 10\"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"range\" class=\"demo\">\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n<script>\nnew Vue({ el: '#range' })\n</script>\n\n<h3 id=\"组件-和-v-for\"><a href=\"#组件-和-v-for\" class=\"headerlink\" title=\"组件 和 v-for\"></a>组件 和 v-for</h3><blockquote>\n<p>了解组件相关知识，查看 <a href=\"components.html\">组件</a> 。完全可以先跳过它，以后再回来查看。</p>\n</blockquote>\n<p>在自定义组件里，你可以像任何普通元素一样用 <code>v-for</code> 。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>然而他不能自动传递数据到组件里，因为组件有自己独立的作用域。为了传递迭代数据到组件里，我们要用 <code>props</code> ：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span></span></div><div class=\"line\">  <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span></div><div class=\"line\">  <span class=\"attr\">v-bind:item</span>=<span class=\"string\">\"item\"</span></div><div class=\"line\">  <span class=\"attr\">v-bind:index</span>=<span class=\"string\">\"index\"</span>&gt;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>不自动注入 <code>item</code> 到组件里的原因是，因为这使得组件会紧密耦合到 <code>v-for</code> 如何运作。在一些情况下，明确数据的来源可以使组件可重用。</p>\n<p>下面是一个简单的 todo list 完整的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"todo-list-example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span></span></div><div class=\"line\">    <span class=\"attr\">v-model</span>=<span class=\"string\">\"newTodoText\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:keyup.enter</span>=<span class=\"string\">\"addNewTodo\"</span></div><div class=\"line\">    <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Add a todo\"</span></div><div class=\"line\">  &gt;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span></span></div><div class=\"line\">      <span class=\"attr\">is</span>=<span class=\"string\">\"todo-item\"</span></div><div class=\"line\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"(todo, index) in todos\"</span></div><div class=\"line\">      <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"todo\"</span></div><div class=\"line\">      <span class=\"attr\">v-on:remove</span>=<span class=\"string\">\"todos.splice(index, 1)\"</span></div><div class=\"line\">    &gt;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'todo-item'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'\\</span></div><div class=\"line\">    &lt;li&gt;\\</div><div class=\"line\">      &#123;&#123; title &#125;&#125;\\</div><div class=\"line\">      &lt;button v-on:click=\"$emit(\\'remove\\')\"&gt;X&lt;/button&gt;\\</div><div class=\"line\">    &lt;/li&gt;\\</div><div class=\"line\">  ',</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'title'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#todo-list-example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">newTodoText</span>: <span class=\"string\">''</span>,</div><div class=\"line\">    <span class=\"attr\">todos</span>: [</div><div class=\"line\">      <span class=\"string\">'Do the dishes'</span>,</div><div class=\"line\">      <span class=\"string\">'Take out the trash'</span>,</div><div class=\"line\">      <span class=\"string\">'Mow the lawn'</span></div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">addNewTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.todos.push(<span class=\"keyword\">this</span>.newTodoText)</div><div class=\"line\">      <span class=\"keyword\">this</span>.newTodoText = <span class=\"string\">''</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"todo-list-example\" class=\"demo\">\n  <input v-model=\"newTodoText\" v=\"\" v-on:keyup.enter=\"addNewTodo\" placeholder=\"Add a todo\">\n  <ul>\n    <li is=\"todo-item\" v-for=\"(todo, index) in todos\" v-bind:title=\"todo\" v-on:remove=\"todos.splice(index, 1)\"></li>\n  </ul>\n</div>\n<script>\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">X</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      'Do the dishes',\n      'Take out the trash',\n      'Mow the lawn'\n    ]\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push(this.newTodoText)\n      this.newTodoText = ''\n    }\n  }\n})\n</script>\n\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序，  而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 <code>track-by=&quot;$index&quot;</code> 。</p>\n<p>这个默认的模式是有效的，但是只适用于不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出。</p>\n<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。理想的 <code>key</code> 值是每项都有唯一 id。这个特殊的属性相当于 Vue 1.x 的 <code>track-by</code> ，但它的工作方式类似于一个属性，所以你需要用 <code>v-bind</code> 来绑定动态值（在这里使用简写）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 内容 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>建议尽可能使用 <code>v-for</code> 来提供 <code>key</code> ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。</p>\n<p>因为它是 Vue 识别节点的一个通用机制， <code>key</code> 并不特别与 <code>v-for</code> 关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。</p>\n<h2 id=\"数组更新检测\"><a href=\"#数组更新检测\" class=\"headerlink\" title=\"数组更新检测\"></a>数组更新检测</h2><h3 id=\"变异方法\"><a href=\"#变异方法\" class=\"headerlink\" title=\"变异方法\"></a>变异方法</h3><p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：</p>\n<ul>\n<li><code>push()</code></li>\n<li><code>pop()</code></li>\n<li><code>shift()</code></li>\n<li><code>unshift()</code></li>\n<li><code>splice()</code></li>\n<li><code>sort()</code></li>\n<li><code>reverse()</code></li>\n</ul>\n<p>你打开控制台，然后用前面例子的 <code>items</code> 数组调用变异方法：<code>example1.items.push({ message: &#39;Baz&#39; })</code> 。</p>\n<h3 id=\"重塑数组\"><a href=\"#重塑数组\" class=\"headerlink\" title=\"重塑数组\"></a>重塑数组</h3><p>变异方法(mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异(non-mutating method)方法，例如： <code>filter()</code>, <code>concat()</code>, <code>slice()</code> 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">example1.items = example1.items.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> item.message.match(<span class=\"regexp\">/Foo/</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。 Vue 实现了一些智能启发式方法来最大化 DOM 元素重用，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>由于 JavaScript 的限制， Vue 不能检测以下变动的数组：</p>\n<ol>\n<li>当你直接设置一个项的索引时，例如： <code>vm.items[indexOfItem] = newValue</code></li>\n<li>当你修改数组的长度时，例如： <code>vm.items.length = newLength</code></li>\n</ol>\n<p>为了避免第一种情况，以下两种方式将达到像 <code>vm.items[indexOfItem] = newValue</code> 的效果， 同时也将触发状态更新：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Vue.set</span></div><div class=\"line\">Vue.set(example1.items, indexOfItem, newValue)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Array.prototype.splice`</span></div><div class=\"line\">example1.items.splice(indexOfItem, <span class=\"number\">1</span>, newValue)</div></pre></td></tr></table></figure>\n<p>避免第二种情况，使用 <code>splice</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">example1.items.splice(newLength)</div></pre></td></tr></table></figure>\n<h2 id=\"显示过滤-排序结果\"><a href=\"#显示过滤-排序结果\" class=\"headerlink\" title=\"显示过滤/排序结果\"></a>显示过滤/排序结果</h2><p>有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。</p>\n<p>例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in evenNumbers\"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">numbers</span>: [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ]</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">evenNumbers</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.numbers.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">number</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> number % <span class=\"number\">2</span> === <span class=\"number\">0</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或者，您也可以在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 使用 method 方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in even(numbers)\"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">numbers</span>: [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ]</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">even</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">numbers</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> numbers.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">number</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> number % <span class=\"number\">2</span> === <span class=\"number\">0</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/list.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/list.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a><code>v-for</code></h2><p>我们用 <code>v-for</code> 指令根据一组数组的选项列表进行渲染。 <code>v-for</code> 指令需要以 <code>item in items</code> 形式的特殊语法， <code>items</code> 是源数据数组并且 <code>item</code> 是数组元素迭代的别名。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-1\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; item.message &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> example1 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-1'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">items</span>: [</div><div class=\"line\">      &#123;<span class=\"attr\">message</span>: <span class=\"string\">'Foo'</span> &#125;,</div><div class=\"line\">      &#123;<span class=\"attr\">message</span>: <span class=\"string\">'Bar'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<ul id=\"example-1\" class=\"demo\">\n  <li v-for=\"item in items\">\n    {{item.message}}\n  </li>\n</ul>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  },\n  watch: {\n    items: function () {\n      smoothScroll.animateScroll(null, '#example-1')\n    }\n  }\n})\n</script>\n\n<p>在 <code>v-for</code> 块中，我们拥有对父作用域属性的完全访问权限。 <code>v-for</code> 还支持一个可选的第二个参数为当前项的索引。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-2'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">parentMessage</span>: <span class=\"string\">'Parent'</span>,</div><div class=\"line\">    <span class=\"attr\">items</span>: [</div><div class=\"line\">      &#123; <span class=\"attr\">message</span>: <span class=\"string\">'Foo'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">message</span>: <span class=\"string\">'Bar'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<ul id=\"example-2\" class=\"demo\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  },\n  watch: {\n    items: function () {\n      smoothScroll.animateScroll(null, '#example-2')\n    }\n  }\n})\n</script>\n\n<p>你也可以用 <code>of</code> 替代 <code>in</code> 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item of items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"Template-v-for\"><a href=\"#Template-v-for\" class=\"headerlink\" title=\"Template v-for\"></a>Template v-for</h3><p>如同 <code>v-if</code> 模板，你也可以用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 标签来渲染多个元素块。例如： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"divider\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"对象迭代-v-for\"><a href=\"#对象迭代-v-for\" class=\"headerlink\" title=\"对象迭代 v-for\"></a>对象迭代 v-for</h3><p>你也可以用 <code>v-for</code> 通过一个对象的属性来迭代。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"repeat-object\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"value in object\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; value &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#repeat-object'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">object</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">FirstName</span>: <span class=\"string\">'John'</span>,</div><div class=\"line\">      <span class=\"attr\">LastName</span>: <span class=\"string\">'Doe'</span>,</div><div class=\"line\">      <span class=\"attr\">Age</span>: <span class=\"number\">30</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<ul id=\"repeat-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n<script>\nnew Vue({\n  el: '#repeat-object',\n  data: {\n    object: {\n      FirstName: 'John',\n      LastName: 'Doe',\n      Age: 30\n    }\n  }\n})\n</script>\n\n<p>你也可以提供第二个的参数为键名：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(value, key) in object\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>第三个参数为索引：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(value, key, index) in object\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。</p>\n\n<h3 id=\"整数迭代-v-for\"><a href=\"#整数迭代-v-for\" class=\"headerlink\" title=\"整数迭代 v-for\"></a>整数迭代 v-for</h3><p><code>v-for</code> 也可以取整数。在这种情况下，它将重复多次模板。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in 10\"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>结果：</p>\n\n<div id=\"range\" class=\"demo\">\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n<script>\nnew Vue({ el: '#range' })\n</script>\n\n<h3 id=\"组件-和-v-for\"><a href=\"#组件-和-v-for\" class=\"headerlink\" title=\"组件 和 v-for\"></a>组件 和 v-for</h3><blockquote>\n<p>了解组件相关知识，查看 <a href=\"components.html\">组件</a> 。完全可以先跳过它，以后再回来查看。</p>\n</blockquote>\n<p>在自定义组件里，你可以像任何普通元素一样用 <code>v-for</code> 。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>然而他不能自动传递数据到组件里，因为组件有自己独立的作用域。为了传递迭代数据到组件里，我们要用 <code>props</code> ：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span></div><div class=\"line\">  <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span></div><div class=\"line\">  <span class=\"attr\">v-bind:item</span>=<span class=\"string\">\"item\"</span></div><div class=\"line\">  <span class=\"attr\">v-bind:index</span>=<span class=\"string\">\"index\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>不自动注入 <code>item</code> 到组件里的原因是，因为这使得组件会紧密耦合到 <code>v-for</code> 如何运作。在一些情况下，明确数据的来源可以使组件可重用。</p>\n<p>下面是一个简单的 todo list 完整的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"todo-list-example\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span></div><div class=\"line\">    <span class=\"attr\">v-model</span>=<span class=\"string\">\"newTodoText\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:keyup.enter</span>=<span class=\"string\">\"addNewTodo\"</span></div><div class=\"line\">    <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Add a todo\"</span></div><div class=\"line\">  &gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span></div><div class=\"line\">      <span class=\"attr\">is</span>=<span class=\"string\">\"todo-item\"</span></div><div class=\"line\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"(todo, index) in todos\"</span></div><div class=\"line\">      <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"todo\"</span></div><div class=\"line\">      <span class=\"attr\">v-on:remove</span>=<span class=\"string\">\"todos.splice(index, 1)\"</span></div><div class=\"line\">    &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'todo-item'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'\\</div><div class=\"line\">    &lt;li&gt;\\</div><div class=\"line\">      &#123;&#123; title &#125;&#125;\\</div><div class=\"line\">      &lt;button v-on:click=\"$emit(\\'remove\\')\"&gt;X&lt;/button&gt;\\</div><div class=\"line\">    &lt;/li&gt;\\</div><div class=\"line\">  '</span>,</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'title'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#todo-list-example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">newTodoText</span>: <span class=\"string\">''</span>,</div><div class=\"line\">    <span class=\"attr\">todos</span>: [</div><div class=\"line\">      <span class=\"string\">'Do the dishes'</span>,</div><div class=\"line\">      <span class=\"string\">'Take out the trash'</span>,</div><div class=\"line\">      <span class=\"string\">'Mow the lawn'</span></div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">addNewTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.todos.push(<span class=\"keyword\">this</span>.newTodoText)</div><div class=\"line\">      <span class=\"keyword\">this</span>.newTodoText = <span class=\"string\">''</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"todo-list-example\" class=\"demo\">\n  <input\n    v-model=\"newTodoText\" v\n    v-on:keyup.enter=\"addNewTodo\"\n    placeholder=\"Add a todo\"\n  >\n  <ul>\n    <li\n      is=\"todo-item\"\n      v-for=\"(todo, index) in todos\"\n      v-bind:title=\"todo\"\n      v-on:remove=\"todos.splice(index, 1)\"\n    ></li>\n  </ul>\n</div>\n<script>\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">X</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      'Do the dishes',\n      'Take out the trash',\n      'Mow the lawn'\n    ]\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push(this.newTodoText)\n      this.newTodoText = ''\n    }\n  }\n})\n</script>\n\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序，  而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 <code>track-by=&quot;$index&quot;</code> 。</p>\n<p>这个默认的模式是有效的，但是只适用于不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出。</p>\n<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。理想的 <code>key</code> 值是每项都有唯一 id。这个特殊的属性相当于 Vue 1.x 的 <code>track-by</code> ，但它的工作方式类似于一个属性，所以你需要用 <code>v-bind</code> 来绑定动态值（在这里使用简写）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 内容 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>建议尽可能使用 <code>v-for</code> 来提供 <code>key</code> ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。</p>\n<p>因为它是 Vue 识别节点的一个通用机制， <code>key</code> 并不特别与 <code>v-for</code> 关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。</p>\n<h2 id=\"数组更新检测\"><a href=\"#数组更新检测\" class=\"headerlink\" title=\"数组更新检测\"></a>数组更新检测</h2><h3 id=\"变异方法\"><a href=\"#变异方法\" class=\"headerlink\" title=\"变异方法\"></a>变异方法</h3><p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：</p>\n<ul>\n<li><code>push()</code></li>\n<li><code>pop()</code></li>\n<li><code>shift()</code></li>\n<li><code>unshift()</code></li>\n<li><code>splice()</code></li>\n<li><code>sort()</code></li>\n<li><code>reverse()</code></li>\n</ul>\n<p>你打开控制台，然后用前面例子的 <code>items</code> 数组调用变异方法：<code>example1.items.push({ message: &#39;Baz&#39; })</code> 。</p>\n<h3 id=\"重塑数组\"><a href=\"#重塑数组\" class=\"headerlink\" title=\"重塑数组\"></a>重塑数组</h3><p>变异方法(mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异(non-mutating method)方法，例如： <code>filter()</code>, <code>concat()</code>, <code>slice()</code> 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">example1.items = example1.items.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> item.message.match(<span class=\"regexp\">/Foo/</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。 Vue 实现了一些智能启发式方法来最大化 DOM 元素重用，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>由于 JavaScript 的限制， Vue 不能检测以下变动的数组：</p>\n<ol>\n<li>当你直接设置一个项的索引时，例如： <code>vm.items[indexOfItem] = newValue</code></li>\n<li>当你修改数组的长度时，例如： <code>vm.items.length = newLength</code></li>\n</ol>\n<p>为了避免第一种情况，以下两种方式将达到像 <code>vm.items[indexOfItem] = newValue</code> 的效果， 同时也将触发状态更新：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Vue.set</span></div><div class=\"line\">Vue.set(example1.items, indexOfItem, newValue)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Array.prototype.splice`</span></div><div class=\"line\">example1.items.splice(indexOfItem, <span class=\"number\">1</span>, newValue)</div></pre></td></tr></table></figure>\n<p>避免第二种情况，使用 <code>splice</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">example1.items.splice(newLength)</div></pre></td></tr></table></figure>\n<h2 id=\"显示过滤-排序结果\"><a href=\"#显示过滤-排序结果\" class=\"headerlink\" title=\"显示过滤/排序结果\"></a>显示过滤/排序结果</h2><p>有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。</p>\n<p>例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in evenNumbers\"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">numbers</span>: [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ]</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">evenNumbers</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.numbers.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">number</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> number % <span class=\"number\">2</span> === <span class=\"number\">0</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或者，您也可以在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 使用 method 方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in even(numbers)\"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">numbers</span>: [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ]</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">even</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">numbers</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> numbers.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">number</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> number % <span class=\"number\">2</span> === <span class=\"number\">0</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/list.html\">http://vuejs.org/guide/list.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"从 Vue Router 0.7.x 迁移","type":"guide","order":26,"_content":"\n> 只有 Vue Router 2 是与 Vue 2 相互兼容的，所以如果你更新了 Vue ，你也需要更新 Vue Router 。这也是我们在主文档中将迁移路径的详情添加进来的原因。\n有关使用 Vue Router 2 的完整教程，请参阅 [ Vue Router 文档](http://router.vuejs.org/en/)。\n\n## Router 初始化\n\n### `router.start` <sup>替换</sup>\n\n不再会有一个特殊的 API 用来初始化包含 Vue Router 的 app ，这意味着不再是：\n\n``` js\nrouter.start({\n  template: '<router-view></router-view>'\n}, '#app')\n```\n\n你只需要传一个路由属性给 Vue 实例：\n\n``` js\nnew Vue({\n  el: '#app',\n  router: router,\n  template: '<router-view></router-view>'\n})\n```\n\n或者，如果你使用的是运行时构建 (runtime-only) 方式：\n\n``` js\nnew Vue({\n  el: '#app',\n  router: router,\n  render: h => h('router-view')\n})\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.start</code> 被调用的示例。</p>\n</div>\n{% endraw %}\n\n## Route 定义\n\n### `router.map` <sup>替换</sup>\n\n路由现在被定义为一个在 router 实例里的一个[`routes` 选项](http://router.vuejs.org/en/essentials/getting-started.html#javascript)数组。所以这些路由：\n\n``` js\nrouter.map({\n  '/foo': {\n    component: Foo\n  },\n  '/bar': {\n    component: Bar\n  }\n})\n```\n\n会以这种方式定义：\n\n``` js\nvar router = new VueRouter({\n  routes: [\n    { path: '/foo', component: Foo },\n    { path: '/bar', component: Bar }\n  ]\n})\n```\n\n考虑到不同浏览器中遍历对象不能保证会使用相同的键值，这种数组的语法可以保证更多可预测的路由匹配。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.map</code> 被调用的示例。</p>\n</div>\n{% endraw %}\n\n### `router.on` <sup>移除</sup>\n\n如果你需要在启动的 app 时通过代码生成路由，你可以动态地向路由数组推送定义来完成这个操作。举个例子：\n\n``` js\n// 普通的路由\nvar routes = [\n  // ...\n]\n\n// 动态生成的路由\nmarketingPages.forEach(function (page) {\n  routes.push({\n    path: '/marketing/' + page.slug\n    component: {\n      extends: MarketingComponent\n      data: function () {\n        return { page: page }\n      }\n    }\n  })\n})\n\nvar router = new Router({\n  routes: routes\n})\n```\n\n如果你需要在 router 被实例化后增加新的路由，你可以把 router 原来的匹配方式换成一个包括你新添的加路由的匹配方式：\n\n``` js\nrouter.match = createMatcher(\n  [{\n    path: '/my/new/path',\n    component: MyComponent\n  }].concat(router.options.routes)\n)\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.on</code> 被调用的示例。</p>\n</div>\n{% endraw %}\n\n### `subRoutes` <sup>换名</sup>\n\n出于 Vue Router 和其他路由库一致性的考虑，重命名为[`children`](http://router.vuejs.org/en/essentials/nested-routes.html)\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>subRoutes</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n### `router.redirect` <sup>替换</sup>\n\n现在用一个[路由定义的选项](http://router.vuejs.org/en/essentials/redirect-and-alias.html)作为代替。 举个例子，你将会更新：\n\n``` js\nrouter.redirect({\n  '/tos': '/terms-of-service'\n})\n```\n\n成像下面的`routes`配置里定义的样子：\n\n``` js\n{\n  path: '/tos',\n  redirect: '/terms-of-service'\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.redirect</code> 被调用的示例。</p>\n</div>\n{% endraw %}\n\n### `router.alias` <sup>替换</sup>\n\n现在是你进行 alias 操作的[路由定义里的一个选项](http://router.vuejs.org/en/essentials/redirect-and-alias.html)。举个例子，你需要在你的`routes`定义里将：\n\n``` js\nrouter.alias({\n  '/manage': '/admin'\n})\n```\n\n配置这个样子：\n\n``` js\n{\n  path: '/admin',\n  component: AdminPanel,\n  alias: '/manage'\n}\n```\n\n如果你需要进行多次 alias 操作，你也可以使用一个数组语法去实现：\n\n``` js\nalias: ['/manage', '/administer', '/administrate']\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a>找到 <code>router.alias</code> 被调用的示例。</p>\n</div>\n{% endraw %}\n\n### 任意的 Route 属性 <sup>替换</sup>\n\n现在任意的 route 属性必须在新 meta 属性的作用域内，以避免和以后的新特性发生冲突。举个例子，如果你以前这样定义：\n\n``` js\n'/admin': {\n  component: AdminPanel,\n  requiresAuth: true\n}\n```\n\n你现在需要把它更新成：\n\n``` js\n{\n  path: '/admin',\n  component: AdminPanel,\n  meta: {\n    requiresAuth: true\n  }\n}\n```\n\n\n如果在一个路由上访问一个属性，你仍然会通过 meta 。举个例子：\n\n``` js\nif (route.meta.requiresAuth) {\n  // ...\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到任意的路由不在 meta 作用域下的示例。</p>\n</div>\n{% endraw %}\n\n## Route 匹配\n\n路由匹配现在使用 [path-to-regexp](https://github.com/pillarjs/path-to-regexp) 这个包，这将会使得工作与之前相比更加灵活。\n\n### 一个或者更多的命名参数 <sup>改变</sup>\n\n语法稍微有些许改变，所以以`/category/*tags`为例，应该被更新为`/category/:tags+`。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到弃用路由语法的示例。</p>\n</div>\n{% endraw %}\n\n## 链接\n\n### `v-link` <sup>替换</sup>\n\n`v-link`指令已经被一个新的[`<router-link>` 组件](http://router.vuejs.org/en/api/router-link.html)指令替代，这一部分的工作已经被 Vue 2 中的组件完成。这将意味着在任何情况下，如果你拥有这样一个链接：\n\n``` html\n<a v-link=\"'/about'\">About</a>\n```\n\n你需要把它更新成：\n\n``` html\n<router-link to=\"/about\">About</router-link>\n```\n\nNote that `target=\"_blank\"` is not supported on `<router-link>`, so if you need to open a link in a new tab, you have to use `<a>` instead.\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>v-link</code> 指令的示例。</p>\n</div>\n{% endraw %}\n\n### `v-link-active` <sup>替换</sup>\n\nThe `v-link-active` directive has also been replaced by the `tag` attribute on [the `<router-link>` component](http://router.vuejs.org/en/api/router-link.html). So for example, you'll update this:\n\n`v-link-active`也因为指定了一个在[ `<router-link>` 组件](http://router.vuejs.org/en/api/router-link.html)上的 tag 属性而被弃用了。举个例子，你需要更新：\n\n``` html\n<li v-link-active>\n  <a v-link=\"'/about'\">About</a>\n</li>\n```\n\n成这个写法:\n\n``` html\n<router-link tag=\"li\" to=\"/about\">\n  <a>About</a>\n</router-link>\n```\n\n `<a>`标签将会成为真实的链接（并且可以获取到正确的跳转），但是激活的类将会被应用在外部的`<li>`标签上。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>v-link-active</code> 指令的示例</p>\n</div>  \n{% endraw %}\n\n## 编程导航\n\n### `router.go` <sup>改变</sup>\n\n为了与 [HTML5 History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) 保持一致性，`router.go` 已经被用来作为 [后退/前进导航](https://router.vuejs.org/en/essentials/navigation.html#routergon)，[`router.push` ](http://router.vuejs.org/en/essentials/navigation.html#routerpushlocation) 用来导向特殊页面。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> ，找到 <code>router.go</code> 和 <code>router.push</code> 指令被调用的示例。</p>\n</div>\n{% endraw %}\n\n## 路由选择：Modes\n\n### `hashbang: false` <sup>移除</sup>\n\nHashbangs 将不再为谷歌需要去爬去一个网址，所以他们将不再成为哈希策略的默认选项。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>hashbang: false</code> 选项的示。</p>\n</div>\n{% endraw %}\n\n### `history: true` <sup>替换</sup>\n\n所有路由模型选项将被简化成一个单个的[`mode` 选项](http://router.vuejs.org/en/api/options.html#mode)。 你需要更新：\n\n``` js\nvar router = new VueRouter({\n  history: 'true'\n})\n```\n\n成这个写法：\n\n``` js\nvar router = new VueRouter({\n  mode: 'history'\n})\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>history: true</code> 选项的示。</p>\n</div>\n{% endraw %}\n\n### `abstract: true` <sup>替换</sup>\n\n所有路由模型选项将被简化成一个单个的[`mode` 选项](http://router.vuejs.org/en/api/options.html#mode)。 你需要更新：\n\n``` js\nvar router = new VueRouter({\n  abstract: 'true'\n})\n```\n\n成这个写法：\n\n``` js\nvar router = new VueRouter({\n  mode: 'abstract'\n})\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>abstract: true</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n## 路由选项：Misc\n\n### `saveScrollPosition` <sup>替换</sup>\n\n它已经被替换为可以接受一个函数的[`scrollBehavior` 选项](http://router.vuejs.org/en/advanced/scroll-behavior.html)，所以滑动行为可以完全的被定制化处理 - 甚至为每次路由进行定制也可以满足。这将会开启很多新的可能，但是简单的复制旧的行为:\n\n``` js\nsaveScrollPosition: true\n```\n\n你可以替换为:\n\n``` js\nscrollBehavior: function (to, from, savedPosition) {\n  return savedPosition || { x: 0, y: 0 }\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>saveScrollPosition: true</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n### `root` <sup>换名</sup>\n\n为了与[HTML 的`<base>`标签](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base)保持一致性，重命名为`base`。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>root</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n### `transitionOnLoad` <sup>移除</sup>\n\n由于 Vue 的过渡系统[`appear` transition control](transitions.html#Transitions-on-Initial-Render)的存在，这个选项将不再需要。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>transitionOnLoad: true</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n### `suppressTransitionError` <sup>移除</sup>\n\n出于简化钩子的考虑被移除。如果你真的需要抑制过渡错误，你可以使用 [`try`...`catch`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch)作为替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移指令</a> 找到 <code>suppressTransitionError: true</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n## 路由挂钩\n\n### `activate` <sup>替换</sup>\n\n使用[`beforeRouteEnter`](http://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards)这一组件进行替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>beforeRouteEnter</code> 钩子的示例。</p>\n</div>\n{% endraw %}\n\n### `canActivate` <sup>替换</sup>\n\n使用[`beforeEnter`](http://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard) 在路由中作为替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>canActivate</code> 钩子的示例。</p>\n</div>\n{% endraw %}\n\n### `deactivate` <sup>移除</sup>\n\n使用[`beforeDestroy`](../api/#beforeDestroy) 或者 [`destroyed`](../api/#destroyed) 钩子作为替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>deactivate</code> 钩子的示例。</p>\n</div>\n{% endraw %}\n\n### `canDeactivate` <sup>替换</sup>\n\n在组件中使用[`beforeRouteLeave`](http://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards) 作为替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>canDeactivate</code> 钩子的示例。</p>\n</div>\n{% endraw %}\n\n### `canReuse: false` <sup>移除</sup>\n\n在新的 Vue 路由中将不再被使用。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>canReuse: false</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n### `data` <sup>替换</sup>\n\n`$route`属性是响应式的，所有你可以就使用一个 watcher 去响应路由的改变，就像这样：\n\n\n``` js\nwatch: {\n  '$route': 'fetchData'\n},\nmethods: {\n  fetchData: function () {\n    // ...\n  }\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>data</code> 钩子的示例。</p>\n</div>\n{% endraw %}\n\n### `$loadingRouteData` <sup>移除</sup>\n\n定义你自己的属性（例如：`isLoading`），然后在路由上的 watcher 中更新加载状态。举个例子，如果使用[axios](https://github.com/mzabriskie/axios)获取数据：\n\n``` js\ndata: function () {\n  return {\n    posts: [],\n    isLoading: false,\n    fetchError: null\n  }\n},\nwatch: {\n  '$route': function () {\n    var self = this\n    self.isLoading = true\n    self.fetchData().then(function () {\n      self.isLoading = false\n    })\n  }\n},\nmethods: {\n  fetchData: function () {\n    var self = this\n    return axios.get('/api/posts')\n      .then(function (response) {\n        self.posts = response.data.posts\n      })\n      .catch(function (error) {\n        self.fetchError = error\n      })\n  }\n}\n```\n\n\n***\n\n> 原文： http://vuejs.org/guide/migration-vue-router.html\n\n*** \n","source":"v2/guide/migration-vue-router.md","raw":"---\ntitle: 从 Vue Router 0.7.x 迁移\ntype: guide\norder: 26\n---\n\n> 只有 Vue Router 2 是与 Vue 2 相互兼容的，所以如果你更新了 Vue ，你也需要更新 Vue Router 。这也是我们在主文档中将迁移路径的详情添加进来的原因。\n有关使用 Vue Router 2 的完整教程，请参阅 [ Vue Router 文档](http://router.vuejs.org/en/)。\n\n## Router 初始化\n\n### `router.start` <sup>替换</sup>\n\n不再会有一个特殊的 API 用来初始化包含 Vue Router 的 app ，这意味着不再是：\n\n``` js\nrouter.start({\n  template: '<router-view></router-view>'\n}, '#app')\n```\n\n你只需要传一个路由属性给 Vue 实例：\n\n``` js\nnew Vue({\n  el: '#app',\n  router: router,\n  template: '<router-view></router-view>'\n})\n```\n\n或者，如果你使用的是运行时构建 (runtime-only) 方式：\n\n``` js\nnew Vue({\n  el: '#app',\n  router: router,\n  render: h => h('router-view')\n})\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.start</code> 被调用的示例。</p>\n</div>\n{% endraw %}\n\n## Route 定义\n\n### `router.map` <sup>替换</sup>\n\n路由现在被定义为一个在 router 实例里的一个[`routes` 选项](http://router.vuejs.org/en/essentials/getting-started.html#javascript)数组。所以这些路由：\n\n``` js\nrouter.map({\n  '/foo': {\n    component: Foo\n  },\n  '/bar': {\n    component: Bar\n  }\n})\n```\n\n会以这种方式定义：\n\n``` js\nvar router = new VueRouter({\n  routes: [\n    { path: '/foo', component: Foo },\n    { path: '/bar', component: Bar }\n  ]\n})\n```\n\n考虑到不同浏览器中遍历对象不能保证会使用相同的键值，这种数组的语法可以保证更多可预测的路由匹配。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.map</code> 被调用的示例。</p>\n</div>\n{% endraw %}\n\n### `router.on` <sup>移除</sup>\n\n如果你需要在启动的 app 时通过代码生成路由，你可以动态地向路由数组推送定义来完成这个操作。举个例子：\n\n``` js\n// 普通的路由\nvar routes = [\n  // ...\n]\n\n// 动态生成的路由\nmarketingPages.forEach(function (page) {\n  routes.push({\n    path: '/marketing/' + page.slug\n    component: {\n      extends: MarketingComponent\n      data: function () {\n        return { page: page }\n      }\n    }\n  })\n})\n\nvar router = new Router({\n  routes: routes\n})\n```\n\n如果你需要在 router 被实例化后增加新的路由，你可以把 router 原来的匹配方式换成一个包括你新添的加路由的匹配方式：\n\n``` js\nrouter.match = createMatcher(\n  [{\n    path: '/my/new/path',\n    component: MyComponent\n  }].concat(router.options.routes)\n)\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.on</code> 被调用的示例。</p>\n</div>\n{% endraw %}\n\n### `subRoutes` <sup>换名</sup>\n\n出于 Vue Router 和其他路由库一致性的考虑，重命名为[`children`](http://router.vuejs.org/en/essentials/nested-routes.html)\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>subRoutes</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n### `router.redirect` <sup>替换</sup>\n\n现在用一个[路由定义的选项](http://router.vuejs.org/en/essentials/redirect-and-alias.html)作为代替。 举个例子，你将会更新：\n\n``` js\nrouter.redirect({\n  '/tos': '/terms-of-service'\n})\n```\n\n成像下面的`routes`配置里定义的样子：\n\n``` js\n{\n  path: '/tos',\n  redirect: '/terms-of-service'\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.redirect</code> 被调用的示例。</p>\n</div>\n{% endraw %}\n\n### `router.alias` <sup>替换</sup>\n\n现在是你进行 alias 操作的[路由定义里的一个选项](http://router.vuejs.org/en/essentials/redirect-and-alias.html)。举个例子，你需要在你的`routes`定义里将：\n\n``` js\nrouter.alias({\n  '/manage': '/admin'\n})\n```\n\n配置这个样子：\n\n``` js\n{\n  path: '/admin',\n  component: AdminPanel,\n  alias: '/manage'\n}\n```\n\n如果你需要进行多次 alias 操作，你也可以使用一个数组语法去实现：\n\n``` js\nalias: ['/manage', '/administer', '/administrate']\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a>找到 <code>router.alias</code> 被调用的示例。</p>\n</div>\n{% endraw %}\n\n### 任意的 Route 属性 <sup>替换</sup>\n\n现在任意的 route 属性必须在新 meta 属性的作用域内，以避免和以后的新特性发生冲突。举个例子，如果你以前这样定义：\n\n``` js\n'/admin': {\n  component: AdminPanel,\n  requiresAuth: true\n}\n```\n\n你现在需要把它更新成：\n\n``` js\n{\n  path: '/admin',\n  component: AdminPanel,\n  meta: {\n    requiresAuth: true\n  }\n}\n```\n\n\n如果在一个路由上访问一个属性，你仍然会通过 meta 。举个例子：\n\n``` js\nif (route.meta.requiresAuth) {\n  // ...\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到任意的路由不在 meta 作用域下的示例。</p>\n</div>\n{% endraw %}\n\n## Route 匹配\n\n路由匹配现在使用 [path-to-regexp](https://github.com/pillarjs/path-to-regexp) 这个包，这将会使得工作与之前相比更加灵活。\n\n### 一个或者更多的命名参数 <sup>改变</sup>\n\n语法稍微有些许改变，所以以`/category/*tags`为例，应该被更新为`/category/:tags+`。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到弃用路由语法的示例。</p>\n</div>\n{% endraw %}\n\n## 链接\n\n### `v-link` <sup>替换</sup>\n\n`v-link`指令已经被一个新的[`<router-link>` 组件](http://router.vuejs.org/en/api/router-link.html)指令替代，这一部分的工作已经被 Vue 2 中的组件完成。这将意味着在任何情况下，如果你拥有这样一个链接：\n\n``` html\n<a v-link=\"'/about'\">About</a>\n```\n\n你需要把它更新成：\n\n``` html\n<router-link to=\"/about\">About</router-link>\n```\n\nNote that `target=\"_blank\"` is not supported on `<router-link>`, so if you need to open a link in a new tab, you have to use `<a>` instead.\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>v-link</code> 指令的示例。</p>\n</div>\n{% endraw %}\n\n### `v-link-active` <sup>替换</sup>\n\nThe `v-link-active` directive has also been replaced by the `tag` attribute on [the `<router-link>` component](http://router.vuejs.org/en/api/router-link.html). So for example, you'll update this:\n\n`v-link-active`也因为指定了一个在[ `<router-link>` 组件](http://router.vuejs.org/en/api/router-link.html)上的 tag 属性而被弃用了。举个例子，你需要更新：\n\n``` html\n<li v-link-active>\n  <a v-link=\"'/about'\">About</a>\n</li>\n```\n\n成这个写法:\n\n``` html\n<router-link tag=\"li\" to=\"/about\">\n  <a>About</a>\n</router-link>\n```\n\n `<a>`标签将会成为真实的链接（并且可以获取到正确的跳转），但是激活的类将会被应用在外部的`<li>`标签上。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>v-link-active</code> 指令的示例</p>\n</div>  \n{% endraw %}\n\n## 编程导航\n\n### `router.go` <sup>改变</sup>\n\n为了与 [HTML5 History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) 保持一致性，`router.go` 已经被用来作为 [后退/前进导航](https://router.vuejs.org/en/essentials/navigation.html#routergon)，[`router.push` ](http://router.vuejs.org/en/essentials/navigation.html#routerpushlocation) 用来导向特殊页面。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> ，找到 <code>router.go</code> 和 <code>router.push</code> 指令被调用的示例。</p>\n</div>\n{% endraw %}\n\n## 路由选择：Modes\n\n### `hashbang: false` <sup>移除</sup>\n\nHashbangs 将不再为谷歌需要去爬去一个网址，所以他们将不再成为哈希策略的默认选项。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>hashbang: false</code> 选项的示。</p>\n</div>\n{% endraw %}\n\n### `history: true` <sup>替换</sup>\n\n所有路由模型选项将被简化成一个单个的[`mode` 选项](http://router.vuejs.org/en/api/options.html#mode)。 你需要更新：\n\n``` js\nvar router = new VueRouter({\n  history: 'true'\n})\n```\n\n成这个写法：\n\n``` js\nvar router = new VueRouter({\n  mode: 'history'\n})\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>history: true</code> 选项的示。</p>\n</div>\n{% endraw %}\n\n### `abstract: true` <sup>替换</sup>\n\n所有路由模型选项将被简化成一个单个的[`mode` 选项](http://router.vuejs.org/en/api/options.html#mode)。 你需要更新：\n\n``` js\nvar router = new VueRouter({\n  abstract: 'true'\n})\n```\n\n成这个写法：\n\n``` js\nvar router = new VueRouter({\n  mode: 'abstract'\n})\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>abstract: true</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n## 路由选项：Misc\n\n### `saveScrollPosition` <sup>替换</sup>\n\n它已经被替换为可以接受一个函数的[`scrollBehavior` 选项](http://router.vuejs.org/en/advanced/scroll-behavior.html)，所以滑动行为可以完全的被定制化处理 - 甚至为每次路由进行定制也可以满足。这将会开启很多新的可能，但是简单的复制旧的行为:\n\n``` js\nsaveScrollPosition: true\n```\n\n你可以替换为:\n\n``` js\nscrollBehavior: function (to, from, savedPosition) {\n  return savedPosition || { x: 0, y: 0 }\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>saveScrollPosition: true</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n### `root` <sup>换名</sup>\n\n为了与[HTML 的`<base>`标签](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base)保持一致性，重命名为`base`。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>root</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n### `transitionOnLoad` <sup>移除</sup>\n\n由于 Vue 的过渡系统[`appear` transition control](transitions.html#Transitions-on-Initial-Render)的存在，这个选项将不再需要。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>transitionOnLoad: true</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n### `suppressTransitionError` <sup>移除</sup>\n\n出于简化钩子的考虑被移除。如果你真的需要抑制过渡错误，你可以使用 [`try`...`catch`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch)作为替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移指令</a> 找到 <code>suppressTransitionError: true</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n## 路由挂钩\n\n### `activate` <sup>替换</sup>\n\n使用[`beforeRouteEnter`](http://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards)这一组件进行替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>beforeRouteEnter</code> 钩子的示例。</p>\n</div>\n{% endraw %}\n\n### `canActivate` <sup>替换</sup>\n\n使用[`beforeEnter`](http://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard) 在路由中作为替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>canActivate</code> 钩子的示例。</p>\n</div>\n{% endraw %}\n\n### `deactivate` <sup>移除</sup>\n\n使用[`beforeDestroy`](../api/#beforeDestroy) 或者 [`destroyed`](../api/#destroyed) 钩子作为替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>deactivate</code> 钩子的示例。</p>\n</div>\n{% endraw %}\n\n### `canDeactivate` <sup>替换</sup>\n\n在组件中使用[`beforeRouteLeave`](http://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards) 作为替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>canDeactivate</code> 钩子的示例。</p>\n</div>\n{% endraw %}\n\n### `canReuse: false` <sup>移除</sup>\n\n在新的 Vue 路由中将不再被使用。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>canReuse: false</code> 选项的示例。</p>\n</div>\n{% endraw %}\n\n### `data` <sup>替换</sup>\n\n`$route`属性是响应式的，所有你可以就使用一个 watcher 去响应路由的改变，就像这样：\n\n\n``` js\nwatch: {\n  '$route': 'fetchData'\n},\nmethods: {\n  fetchData: function () {\n    // ...\n  }\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>data</code> 钩子的示例。</p>\n</div>\n{% endraw %}\n\n### `$loadingRouteData` <sup>移除</sup>\n\n定义你自己的属性（例如：`isLoading`），然后在路由上的 watcher 中更新加载状态。举个例子，如果使用[axios](https://github.com/mzabriskie/axios)获取数据：\n\n``` js\ndata: function () {\n  return {\n    posts: [],\n    isLoading: false,\n    fetchError: null\n  }\n},\nwatch: {\n  '$route': function () {\n    var self = this\n    self.isLoading = true\n    self.fetchData().then(function () {\n      self.isLoading = false\n    })\n  }\n},\nmethods: {\n  fetchData: function () {\n    var self = this\n    return axios.get('/api/posts')\n      .then(function (response) {\n        self.posts = response.data.posts\n      })\n      .catch(function (error) {\n        self.fetchError = error\n      })\n  }\n}\n```\n\n\n***\n\n> 原文： http://vuejs.org/guide/migration-vue-router.html\n\n*** \n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/migration-vue-router.html","comments":1,"layout":"page","_id":"ciwnajuyq001ijl2d0258blia","content":"<blockquote>\n<p>只有 Vue Router 2 是与 Vue 2 相互兼容的，所以如果你更新了 Vue ，你也需要更新 Vue Router 。这也是我们在主文档中将迁移路径的详情添加进来的原因。<br>有关使用 Vue Router 2 的完整教程，请参阅 <a href=\"http://router.vuejs.org/en/\" target=\"_blank\" rel=\"external\"> Vue Router 文档</a>。</p>\n</blockquote>\n<h2 id=\"Router-初始化\"><a href=\"#Router-初始化\" class=\"headerlink\" title=\"Router 初始化\"></a>Router 初始化</h2><h3 id=\"router-start-替换\"><a href=\"#router-start-替换\" class=\"headerlink\" title=\"router.start 替换\"></a><code>router.start</code> <sup>替换</sup></h3><p>不再会有一个特殊的 API 用来初始化包含 Vue Router 的 app ，这意味着不再是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">router.start(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;router-view&gt;&lt;/router-view&gt;'</span></div><div class=\"line\">&#125;, <span class=\"string\">'#app'</span>)</div></pre></td></tr></table></figure>\n<p>你只需要传一个路由属性给 Vue 实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">router</span>: router,</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;router-view&gt;&lt;/router-view&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>或者，如果你使用的是运行时构建 (runtime-only) 方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">router</span>: router,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(<span class=\"string\">'router-view'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>router.start</code> 被调用的示例。</p>\n</div>\n\n<h2 id=\"Route-定义\"><a href=\"#Route-定义\" class=\"headerlink\" title=\"Route 定义\"></a>Route 定义</h2><h3 id=\"router-map-替换\"><a href=\"#router-map-替换\" class=\"headerlink\" title=\"router.map 替换\"></a><code>router.map</code> <sup>替换</sup></h3><p>路由现在被定义为一个在 router 实例里的一个<a href=\"http://router.vuejs.org/en/essentials/getting-started.html#javascript\" target=\"_blank\" rel=\"external\"><code>routes</code> 选项</a>数组。所以这些路由：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">router.map(&#123;</div><div class=\"line\">  <span class=\"string\">'/foo'</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">component</span>: Foo</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"string\">'/bar'</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">component</span>: Bar</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>会以这种方式定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">routes</span>: [</div><div class=\"line\">    &#123; <span class=\"attr\">path</span>: <span class=\"string\">'/foo'</span>, <span class=\"attr\">component</span>: Foo &#125;,</div><div class=\"line\">    &#123; <span class=\"attr\">path</span>: <span class=\"string\">'/bar'</span>, <span class=\"attr\">component</span>: Bar &#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>考虑到不同浏览器中遍历对象不能保证会使用相同的键值，这种数组的语法可以保证更多可预测的路由匹配。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>router.map</code> 被调用的示例。</p>\n</div>\n\n<h3 id=\"router-on-移除\"><a href=\"#router-on-移除\" class=\"headerlink\" title=\"router.on 移除\"></a><code>router.on</code> <sup>移除</sup></h3><p>如果你需要在启动的 app 时通过代码生成路由，你可以动态地向路由数组推送定义来完成这个操作。举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 普通的路由</span></div><div class=\"line\"><span class=\"keyword\">var</span> routes = [</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 动态生成的路由</span></div><div class=\"line\">marketingPages.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">page</span>) </span>&#123;</div><div class=\"line\">  routes.push(&#123;</div><div class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">'/marketing/'</span> + page.slug</div><div class=\"line\">    component: &#123;</div><div class=\"line\">      <span class=\"attr\">extends</span>: MarketingComponent</div><div class=\"line\">      data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"attr\">page</span>: page &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> Router(&#123;</div><div class=\"line\">  <span class=\"attr\">routes</span>: routes</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>如果你需要在 router 被实例化后增加新的路由，你可以把 router 原来的匹配方式换成一个包括你新添的加路由的匹配方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">router.match = createMatcher(</div><div class=\"line\">  [&#123;</div><div class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">'/my/new/path'</span>,</div><div class=\"line\">    <span class=\"attr\">component</span>: MyComponent</div><div class=\"line\">  &#125;].concat(router.options.routes)</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>router.on</code> 被调用的示例。</p>\n</div>\n\n<h3 id=\"subRoutes-换名\"><a href=\"#subRoutes-换名\" class=\"headerlink\" title=\"subRoutes 换名\"></a><code>subRoutes</code> <sup>换名</sup></h3><p>出于 Vue Router 和其他路由库一致性的考虑，重命名为<a href=\"http://router.vuejs.org/en/essentials/nested-routes.html\" target=\"_blank\" rel=\"external\"><code>children</code></a></p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>subRoutes</code> 选项的示例。</p>\n</div>\n\n<h3 id=\"router-redirect-替换\"><a href=\"#router-redirect-替换\" class=\"headerlink\" title=\"router.redirect 替换\"></a><code>router.redirect</code> <sup>替换</sup></h3><p>现在用一个<a href=\"http://router.vuejs.org/en/essentials/redirect-and-alias.html\" target=\"_blank\" rel=\"external\">路由定义的选项</a>作为代替。 举个例子，你将会更新：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">router.redirect(&#123;</div><div class=\"line\">  <span class=\"string\">'/tos'</span>: <span class=\"string\">'/terms-of-service'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>成像下面的<code>routes</code>配置里定义的样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'/tos'</span>,</div><div class=\"line\">  <span class=\"attr\">redirect</span>: <span class=\"string\">'/terms-of-service'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>router.redirect</code> 被调用的示例。</p>\n</div>\n\n<h3 id=\"router-alias-替换\"><a href=\"#router-alias-替换\" class=\"headerlink\" title=\"router.alias 替换\"></a><code>router.alias</code> <sup>替换</sup></h3><p>现在是你进行 alias 操作的<a href=\"http://router.vuejs.org/en/essentials/redirect-and-alias.html\" target=\"_blank\" rel=\"external\">路由定义里的一个选项</a>。举个例子，你需要在你的<code>routes</code>定义里将：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">router.alias(&#123;</div><div class=\"line\">  <span class=\"string\">'/manage'</span>: <span class=\"string\">'/admin'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>配置这个样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'/admin'</span>,</div><div class=\"line\">  <span class=\"attr\">component</span>: AdminPanel,</div><div class=\"line\">  <span class=\"attr\">alias</span>: <span class=\"string\">'/manage'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你需要进行多次 alias 操作，你也可以使用一个数组语法去实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">alias: [<span class=\"string\">'/manage'</span>, <span class=\"string\">'/administer'</span>, <span class=\"string\">'/administrate'</span>]</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a>找到 <code>router.alias</code> 被调用的示例。</p>\n</div>\n\n<h3 id=\"任意的-Route-属性-替换\"><a href=\"#任意的-Route-属性-替换\" class=\"headerlink\" title=\"任意的 Route 属性 替换\"></a>任意的 Route 属性 <sup>替换</sup></h3><p>现在任意的 route 属性必须在新 meta 属性的作用域内，以避免和以后的新特性发生冲突。举个例子，如果你以前这样定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'/admin'</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">component</span>: AdminPanel,</div><div class=\"line\">  <span class=\"attr\">requiresAuth</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你现在需要把它更新成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'/admin'</span>,</div><div class=\"line\">  <span class=\"attr\">component</span>: AdminPanel,</div><div class=\"line\">  <span class=\"attr\">meta</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">requiresAuth</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果在一个路由上访问一个属性，你仍然会通过 meta 。举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (route.meta.requiresAuth) &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到任意的路由不在 meta 作用域下的示例。</p>\n</div>\n\n<h2 id=\"Route-匹配\"><a href=\"#Route-匹配\" class=\"headerlink\" title=\"Route 匹配\"></a>Route 匹配</h2><p>路由匹配现在使用 <a href=\"https://github.com/pillarjs/path-to-regexp\" target=\"_blank\" rel=\"external\">path-to-regexp</a> 这个包，这将会使得工作与之前相比更加灵活。</p>\n<h3 id=\"一个或者更多的命名参数-改变\"><a href=\"#一个或者更多的命名参数-改变\" class=\"headerlink\" title=\"一个或者更多的命名参数 改变\"></a>一个或者更多的命名参数 <sup>改变</sup></h3><p>语法稍微有些许改变，所以以<code>/category/*tags</code>为例，应该被更新为<code>/category/:tags+</code>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到弃用路由语法的示例。</p>\n</div>\n\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><h3 id=\"v-link-替换\"><a href=\"#v-link-替换\" class=\"headerlink\" title=\"v-link 替换\"></a><code>v-link</code> <sup>替换</sup></h3><p><code>v-link</code>指令已经被一个新的<a href=\"http://router.vuejs.org/en/api/router-link.html\" target=\"_blank\" rel=\"external\"><code>&lt;router-link&gt;</code> 组件</a>指令替代，这一部分的工作已经被 Vue 2 中的组件完成。这将意味着在任何情况下，如果你拥有这样一个链接：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-link</span>=<span class=\"string\">\"'/about'\"</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你需要把它更新成：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/about\"</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Note that <code>target=&quot;_blank&quot;</code> is not supported on <code>&lt;router-link&gt;</code>, so if you need to open a link in a new tab, you have to use <code>&lt;a&gt;</code> instead.</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>v-link</code> 指令的示例。</p>\n</div>\n\n<h3 id=\"v-link-active-替换\"><a href=\"#v-link-active-替换\" class=\"headerlink\" title=\"v-link-active 替换\"></a><code>v-link-active</code> <sup>替换</sup></h3><p>The <code>v-link-active</code> directive has also been replaced by the <code>tag</code> attribute on <a href=\"http://router.vuejs.org/en/api/router-link.html\" target=\"_blank\" rel=\"external\">the <code>&lt;router-link&gt;</code> component</a>. So for example, you’ll update this:</p>\n<p><code>v-link-active</code>也因为指定了一个在<a href=\"http://router.vuejs.org/en/api/router-link.html\" target=\"_blank\" rel=\"external\"> <code>&lt;router-link&gt;</code> 组件</a>上的 tag 属性而被弃用了。举个例子，你需要更新：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-link-active</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-link</span>=<span class=\"string\">\"'/about'\"</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>成这个写法:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"li\"</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/about\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div></pre></td></tr></table></figure>\n<p> <code>&lt;a&gt;</code>标签将会成为真实的链接（并且可以获取到正确的跳转），但是激活的类将会被应用在外部的<code>&lt;li&gt;</code>标签上。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>v-link-active</code> 指令的示例</p>\n</div>  \n\n<h2 id=\"编程导航\"><a href=\"#编程导航\" class=\"headerlink\" title=\"编程导航\"></a>编程导航</h2><h3 id=\"router-go-改变\"><a href=\"#router-go-改变\" class=\"headerlink\" title=\"router.go 改变\"></a><code>router.go</code> <sup>改变</sup></h3><p>为了与 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API\" target=\"_blank\" rel=\"external\">HTML5 History API</a> 保持一致性，<code>router.go</code> 已经被用来作为 <a href=\"https://router.vuejs.org/en/essentials/navigation.html#routergon\" target=\"_blank\" rel=\"external\">后退/前进导航</a>，<a href=\"http://router.vuejs.org/en/essentials/navigation.html#routerpushlocation\" target=\"_blank\" rel=\"external\"><code>router.push</code> </a> 用来导向特殊页面。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> ，找到 <code>router.go</code> 和 <code>router.push</code> 指令被调用的示例。</p>\n</div>\n\n<h2 id=\"路由选择：Modes\"><a href=\"#路由选择：Modes\" class=\"headerlink\" title=\"路由选择：Modes\"></a>路由选择：Modes</h2><h3 id=\"hashbang-false-移除\"><a href=\"#hashbang-false-移除\" class=\"headerlink\" title=\"hashbang: false 移除\"></a><code>hashbang: false</code> <sup>移除</sup></h3><p>Hashbangs 将不再为谷歌需要去爬去一个网址，所以他们将不再成为哈希策略的默认选项。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>hashbang: false</code> 选项的示。</p>\n</div>\n\n<h3 id=\"history-true-替换\"><a href=\"#history-true-替换\" class=\"headerlink\" title=\"history: true 替换\"></a><code>history: true</code> <sup>替换</sup></h3><p>所有路由模型选项将被简化成一个单个的<a href=\"http://router.vuejs.org/en/api/options.html#mode\" target=\"_blank\" rel=\"external\"><code>mode</code> 选项</a>。 你需要更新：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">history</span>: <span class=\"string\">'true'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>成这个写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">'history'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>history: true</code> 选项的示。</p>\n</div>\n\n<h3 id=\"abstract-true-替换\"><a href=\"#abstract-true-替换\" class=\"headerlink\" title=\"abstract: true 替换\"></a><code>abstract: true</code> <sup>替换</sup></h3><p>所有路由模型选项将被简化成一个单个的<a href=\"http://router.vuejs.org/en/api/options.html#mode\" target=\"_blank\" rel=\"external\"><code>mode</code> 选项</a>。 你需要更新：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">abstract</span>: <span class=\"string\">'true'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>成这个写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">'abstract'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>abstract: true</code> 选项的示例。</p>\n</div>\n\n<h2 id=\"路由选项：Misc\"><a href=\"#路由选项：Misc\" class=\"headerlink\" title=\"路由选项：Misc\"></a>路由选项：Misc</h2><h3 id=\"saveScrollPosition-替换\"><a href=\"#saveScrollPosition-替换\" class=\"headerlink\" title=\"saveScrollPosition 替换\"></a><code>saveScrollPosition</code> <sup>替换</sup></h3><p>它已经被替换为可以接受一个函数的<a href=\"http://router.vuejs.org/en/advanced/scroll-behavior.html\" target=\"_blank\" rel=\"external\"><code>scrollBehavior</code> 选项</a>，所以滑动行为可以完全的被定制化处理 - 甚至为每次路由进行定制也可以满足。这将会开启很多新的可能，但是简单的复制旧的行为:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">saveScrollPosition: <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>你可以替换为:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">scrollBehavior: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">to, from, savedPosition</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> savedPosition || &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移路径</a> 找到 <code>saveScrollPosition: true</code> 选项的示例。</p>\n</div>\n\n<h3 id=\"root-换名\"><a href=\"#root-换名\" class=\"headerlink\" title=\"root 换名\"></a><code>root</code> <sup>换名</sup></h3><p>为了与<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" target=\"_blank\" rel=\"external\">HTML 的<code>&lt;base&gt;</code>标签</a>保持一致性，重命名为<code>base</code>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移路径</a> 找到 <code>root</code> 选项的示例。</p>\n</div>\n\n<h3 id=\"transitionOnLoad-移除\"><a href=\"#transitionOnLoad-移除\" class=\"headerlink\" title=\"transitionOnLoad 移除\"></a><code>transitionOnLoad</code> <sup>移除</sup></h3><p>由于 Vue 的过渡系统<a href=\"transitions.html#Transitions-on-Initial-Render\"><code>appear</code> transition control</a>的存在，这个选项将不再需要。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移路径</a> 找到 <code>transitionOnLoad: true</code> 选项的示例。</p>\n</div>\n\n<h3 id=\"suppressTransitionError-移除\"><a href=\"#suppressTransitionError-移除\" class=\"headerlink\" title=\"suppressTransitionError 移除\"></a><code>suppressTransitionError</code> <sup>移除</sup></h3><p>出于简化钩子的考虑被移除。如果你真的需要抑制过渡错误，你可以使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch\" target=\"_blank\" rel=\"external\"><code>try</code>…<code>catch</code></a>作为替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移指令</a> 找到 <code>suppressTransitionError: true</code> 选项的示例。</p>\n</div>\n\n<h2 id=\"路由挂钩\"><a href=\"#路由挂钩\" class=\"headerlink\" title=\"路由挂钩\"></a>路由挂钩</h2><h3 id=\"activate-替换\"><a href=\"#activate-替换\" class=\"headerlink\" title=\"activate 替换\"></a><code>activate</code> <sup>替换</sup></h3><p>使用<a href=\"http://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards\" target=\"_blank\" rel=\"external\"><code>beforeRouteEnter</code></a>这一组件进行替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移路径</a> 找到 <code>beforeRouteEnter</code> 钩子的示例。</p>\n</div>\n\n<h3 id=\"canActivate-替换\"><a href=\"#canActivate-替换\" class=\"headerlink\" title=\"canActivate 替换\"></a><code>canActivate</code> <sup>替换</sup></h3><p>使用<a href=\"http://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard\" target=\"_blank\" rel=\"external\"><code>beforeEnter</code></a> 在路由中作为替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移路径</a> 找到 <code>canActivate</code> 钩子的示例。</p>\n</div>\n\n<h3 id=\"deactivate-移除\"><a href=\"#deactivate-移除\" class=\"headerlink\" title=\"deactivate 移除\"></a><code>deactivate</code> <sup>移除</sup></h3><p>使用<a href=\"../api/#beforeDestroy\"><code>beforeDestroy</code></a> 或者 <a href=\"../api/#destroyed\"><code>destroyed</code></a> 钩子作为替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移路径</a> 找到 <code>deactivate</code> 钩子的示例。</p>\n</div>\n\n<h3 id=\"canDeactivate-替换\"><a href=\"#canDeactivate-替换\" class=\"headerlink\" title=\"canDeactivate 替换\"></a><code>canDeactivate</code> <sup>替换</sup></h3><p>在组件中使用<a href=\"http://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards\" target=\"_blank\" rel=\"external\"><code>beforeRouteLeave</code></a> 作为替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移路径</a> 找到 <code>canDeactivate</code> 钩子的示例。</p>\n</div>\n\n<h3 id=\"canReuse-false-移除\"><a href=\"#canReuse-false-移除\" class=\"headerlink\" title=\"canReuse: false 移除\"></a><code>canReuse: false</code> <sup>移除</sup></h3><p>在新的 Vue 路由中将不再被使用。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>canReuse: false</code> 选项的示例。</p>\n</div>\n\n<h3 id=\"data-替换\"><a href=\"#data-替换\" class=\"headerlink\" title=\"data 替换\"></a><code>data</code> <sup>替换</sup></h3><p><code>$route</code>属性是响应式的，所有你可以就使用一个 watcher 去响应路由的改变，就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">watch: &#123;</div><div class=\"line\">  <span class=\"string\">'$route'</span>: <span class=\"string\">'fetchData'</span></div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">fetchData</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移助手</a> 找到 <code>data</code> 钩子的示例。</p>\n</div>\n\n<h3 id=\"loadingRouteData-移除\"><a href=\"#loadingRouteData-移除\" class=\"headerlink\" title=\"$loadingRouteData 移除\"></a><code>$loadingRouteData</code> <sup>移除</sup></h3><p>定义你自己的属性（例如：<code>isLoading</code>），然后在路由上的 watcher 中更新加载状态。举个例子，如果使用<a href=\"https://github.com/mzabriskie/axios\" target=\"_blank\" rel=\"external\">axios</a>获取数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">posts</span>: [],</div><div class=\"line\">    <span class=\"attr\">isLoading</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">fetchError</span>: <span class=\"literal\">null</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">  <span class=\"string\">'$route'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">    self.isLoading = <span class=\"literal\">true</span></div><div class=\"line\">    self.fetchData().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      self.isLoading = <span class=\"literal\">false</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">fetchData</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">    <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/api/posts'</span>)</div><div class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">        self.posts = response.data.posts</div><div class=\"line\">      &#125;)</div><div class=\"line\">      .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">        self.fetchError = error</div><div class=\"line\">      &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/migration-vue-router.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/migration-vue-router.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<blockquote>\n<p>只有 Vue Router 2 是与 Vue 2 相互兼容的，所以如果你更新了 Vue ，你也需要更新 Vue Router 。这也是我们在主文档中将迁移路径的详情添加进来的原因。<br>有关使用 Vue Router 2 的完整教程，请参阅 <a href=\"http://router.vuejs.org/en/\"> Vue Router 文档</a>。</p>\n</blockquote>\n<h2 id=\"Router-初始化\"><a href=\"#Router-初始化\" class=\"headerlink\" title=\"Router 初始化\"></a>Router 初始化</h2><h3 id=\"router-start-替换\"><a href=\"#router-start-替换\" class=\"headerlink\" title=\"router.start 替换\"></a><code>router.start</code> <sup>替换</sup></h3><p>不再会有一个特殊的 API 用来初始化包含 Vue Router 的 app ，这意味着不再是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">router.start(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;router-view&gt;&lt;/router-view&gt;'</span></div><div class=\"line\">&#125;, <span class=\"string\">'#app'</span>)</div></pre></td></tr></table></figure>\n<p>你只需要传一个路由属性给 Vue 实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">router</span>: router,</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;router-view&gt;&lt;/router-view&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>或者，如果你使用的是运行时构建 (runtime-only) 方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">router</span>: router,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(<span class=\"string\">'router-view'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.start</code> 被调用的示例。</p>\n</div>\n\n<h2 id=\"Route-定义\"><a href=\"#Route-定义\" class=\"headerlink\" title=\"Route 定义\"></a>Route 定义</h2><h3 id=\"router-map-替换\"><a href=\"#router-map-替换\" class=\"headerlink\" title=\"router.map 替换\"></a><code>router.map</code> <sup>替换</sup></h3><p>路由现在被定义为一个在 router 实例里的一个<a href=\"http://router.vuejs.org/en/essentials/getting-started.html#javascript\"><code>routes</code> 选项</a>数组。所以这些路由：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">router.map(&#123;</div><div class=\"line\">  <span class=\"string\">'/foo'</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">component</span>: Foo</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"string\">'/bar'</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">component</span>: Bar</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>会以这种方式定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">routes</span>: [</div><div class=\"line\">    &#123; <span class=\"attr\">path</span>: <span class=\"string\">'/foo'</span>, <span class=\"attr\">component</span>: Foo &#125;,</div><div class=\"line\">    &#123; <span class=\"attr\">path</span>: <span class=\"string\">'/bar'</span>, <span class=\"attr\">component</span>: Bar &#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>考虑到不同浏览器中遍历对象不能保证会使用相同的键值，这种数组的语法可以保证更多可预测的路由匹配。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.map</code> 被调用的示例。</p>\n</div>\n\n<h3 id=\"router-on-移除\"><a href=\"#router-on-移除\" class=\"headerlink\" title=\"router.on 移除\"></a><code>router.on</code> <sup>移除</sup></h3><p>如果你需要在启动的 app 时通过代码生成路由，你可以动态地向路由数组推送定义来完成这个操作。举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 普通的路由</span></div><div class=\"line\"><span class=\"keyword\">var</span> routes = [</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 动态生成的路由</span></div><div class=\"line\">marketingPages.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">page</span>) </span>&#123;</div><div class=\"line\">  routes.push(&#123;</div><div class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">'/marketing/'</span> + page.slug</div><div class=\"line\">    component: &#123;</div><div class=\"line\">      <span class=\"attr\">extends</span>: MarketingComponent</div><div class=\"line\">      data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"attr\">page</span>: page &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> Router(&#123;</div><div class=\"line\">  <span class=\"attr\">routes</span>: routes</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>如果你需要在 router 被实例化后增加新的路由，你可以把 router 原来的匹配方式换成一个包括你新添的加路由的匹配方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">router.match = createMatcher(</div><div class=\"line\">  [&#123;</div><div class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">'/my/new/path'</span>,</div><div class=\"line\">    <span class=\"attr\">component</span>: MyComponent</div><div class=\"line\">  &#125;].concat(router.options.routes)</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.on</code> 被调用的示例。</p>\n</div>\n\n<h3 id=\"subRoutes-换名\"><a href=\"#subRoutes-换名\" class=\"headerlink\" title=\"subRoutes 换名\"></a><code>subRoutes</code> <sup>换名</sup></h3><p>出于 Vue Router 和其他路由库一致性的考虑，重命名为<a href=\"http://router.vuejs.org/en/essentials/nested-routes.html\"><code>children</code></a></p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>subRoutes</code> 选项的示例。</p>\n</div>\n\n<h3 id=\"router-redirect-替换\"><a href=\"#router-redirect-替换\" class=\"headerlink\" title=\"router.redirect 替换\"></a><code>router.redirect</code> <sup>替换</sup></h3><p>现在用一个<a href=\"http://router.vuejs.org/en/essentials/redirect-and-alias.html\">路由定义的选项</a>作为代替。 举个例子，你将会更新：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">router.redirect(&#123;</div><div class=\"line\">  <span class=\"string\">'/tos'</span>: <span class=\"string\">'/terms-of-service'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>成像下面的<code>routes</code>配置里定义的样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'/tos'</span>,</div><div class=\"line\">  <span class=\"attr\">redirect</span>: <span class=\"string\">'/terms-of-service'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>router.redirect</code> 被调用的示例。</p>\n</div>\n\n<h3 id=\"router-alias-替换\"><a href=\"#router-alias-替换\" class=\"headerlink\" title=\"router.alias 替换\"></a><code>router.alias</code> <sup>替换</sup></h3><p>现在是你进行 alias 操作的<a href=\"http://router.vuejs.org/en/essentials/redirect-and-alias.html\">路由定义里的一个选项</a>。举个例子，你需要在你的<code>routes</code>定义里将：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">router.alias(&#123;</div><div class=\"line\">  <span class=\"string\">'/manage'</span>: <span class=\"string\">'/admin'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>配置这个样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'/admin'</span>,</div><div class=\"line\">  <span class=\"attr\">component</span>: AdminPanel,</div><div class=\"line\">  <span class=\"attr\">alias</span>: <span class=\"string\">'/manage'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你需要进行多次 alias 操作，你也可以使用一个数组语法去实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">alias: [<span class=\"string\">'/manage'</span>, <span class=\"string\">'/administer'</span>, <span class=\"string\">'/administrate'</span>]</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a>找到 <code>router.alias</code> 被调用的示例。</p>\n</div>\n\n<h3 id=\"任意的-Route-属性-替换\"><a href=\"#任意的-Route-属性-替换\" class=\"headerlink\" title=\"任意的 Route 属性 替换\"></a>任意的 Route 属性 <sup>替换</sup></h3><p>现在任意的 route 属性必须在新 meta 属性的作用域内，以避免和以后的新特性发生冲突。举个例子，如果你以前这样定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'/admin'</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">component</span>: AdminPanel,</div><div class=\"line\">  <span class=\"attr\">requiresAuth</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你现在需要把它更新成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'/admin'</span>,</div><div class=\"line\">  <span class=\"attr\">component</span>: AdminPanel,</div><div class=\"line\">  <span class=\"attr\">meta</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">requiresAuth</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果在一个路由上访问一个属性，你仍然会通过 meta 。举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (route.meta.requiresAuth) &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到任意的路由不在 meta 作用域下的示例。</p>\n</div>\n\n<h2 id=\"Route-匹配\"><a href=\"#Route-匹配\" class=\"headerlink\" title=\"Route 匹配\"></a>Route 匹配</h2><p>路由匹配现在使用 <a href=\"https://github.com/pillarjs/path-to-regexp\">path-to-regexp</a> 这个包，这将会使得工作与之前相比更加灵活。</p>\n<h3 id=\"一个或者更多的命名参数-改变\"><a href=\"#一个或者更多的命名参数-改变\" class=\"headerlink\" title=\"一个或者更多的命名参数 改变\"></a>一个或者更多的命名参数 <sup>改变</sup></h3><p>语法稍微有些许改变，所以以<code>/category/*tags</code>为例，应该被更新为<code>/category/:tags+</code>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到弃用路由语法的示例。</p>\n</div>\n\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><h3 id=\"v-link-替换\"><a href=\"#v-link-替换\" class=\"headerlink\" title=\"v-link 替换\"></a><code>v-link</code> <sup>替换</sup></h3><p><code>v-link</code>指令已经被一个新的<a href=\"http://router.vuejs.org/en/api/router-link.html\"><code>&lt;router-link&gt;</code> 组件</a>指令替代，这一部分的工作已经被 Vue 2 中的组件完成。这将意味着在任何情况下，如果你拥有这样一个链接：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-link</span>=<span class=\"string\">\"'/about'\"</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你需要把它更新成：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/about\"</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Note that <code>target=&quot;_blank&quot;</code> is not supported on <code>&lt;router-link&gt;</code>, so if you need to open a link in a new tab, you have to use <code>&lt;a&gt;</code> instead.</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>v-link</code> 指令的示例。</p>\n</div>\n\n<h3 id=\"v-link-active-替换\"><a href=\"#v-link-active-替换\" class=\"headerlink\" title=\"v-link-active 替换\"></a><code>v-link-active</code> <sup>替换</sup></h3><p>The <code>v-link-active</code> directive has also been replaced by the <code>tag</code> attribute on <a href=\"http://router.vuejs.org/en/api/router-link.html\">the <code>&lt;router-link&gt;</code> component</a>. So for example, you’ll update this:</p>\n<p><code>v-link-active</code>也因为指定了一个在<a href=\"http://router.vuejs.org/en/api/router-link.html\"> <code>&lt;router-link&gt;</code> 组件</a>上的 tag 属性而被弃用了。举个例子，你需要更新：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-link-active</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-link</span>=<span class=\"string\">\"'/about'\"</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>成这个写法:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"li\"</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/about\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div></pre></td></tr></table></figure>\n<p> <code>&lt;a&gt;</code>标签将会成为真实的链接（并且可以获取到正确的跳转），但是激活的类将会被应用在外部的<code>&lt;li&gt;</code>标签上。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>v-link-active</code> 指令的示例</p>\n</div>  \n\n<h2 id=\"编程导航\"><a href=\"#编程导航\" class=\"headerlink\" title=\"编程导航\"></a>编程导航</h2><h3 id=\"router-go-改变\"><a href=\"#router-go-改变\" class=\"headerlink\" title=\"router.go 改变\"></a><code>router.go</code> <sup>改变</sup></h3><p>为了与 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API\">HTML5 History API</a> 保持一致性，<code>router.go</code> 已经被用来作为 <a href=\"https://router.vuejs.org/en/essentials/navigation.html#routergon\">后退/前进导航</a>，<a href=\"http://router.vuejs.org/en/essentials/navigation.html#routerpushlocation\"><code>router.push</code> </a> 用来导向特殊页面。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> ，找到 <code>router.go</code> 和 <code>router.push</code> 指令被调用的示例。</p>\n</div>\n\n<h2 id=\"路由选择：Modes\"><a href=\"#路由选择：Modes\" class=\"headerlink\" title=\"路由选择：Modes\"></a>路由选择：Modes</h2><h3 id=\"hashbang-false-移除\"><a href=\"#hashbang-false-移除\" class=\"headerlink\" title=\"hashbang: false 移除\"></a><code>hashbang: false</code> <sup>移除</sup></h3><p>Hashbangs 将不再为谷歌需要去爬去一个网址，所以他们将不再成为哈希策略的默认选项。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>hashbang: false</code> 选项的示。</p>\n</div>\n\n<h3 id=\"history-true-替换\"><a href=\"#history-true-替换\" class=\"headerlink\" title=\"history: true 替换\"></a><code>history: true</code> <sup>替换</sup></h3><p>所有路由模型选项将被简化成一个单个的<a href=\"http://router.vuejs.org/en/api/options.html#mode\"><code>mode</code> 选项</a>。 你需要更新：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">history</span>: <span class=\"string\">'true'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>成这个写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">'history'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>history: true</code> 选项的示。</p>\n</div>\n\n<h3 id=\"abstract-true-替换\"><a href=\"#abstract-true-替换\" class=\"headerlink\" title=\"abstract: true 替换\"></a><code>abstract: true</code> <sup>替换</sup></h3><p>所有路由模型选项将被简化成一个单个的<a href=\"http://router.vuejs.org/en/api/options.html#mode\"><code>mode</code> 选项</a>。 你需要更新：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">abstract</span>: <span class=\"string\">'true'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>成这个写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">'abstract'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>abstract: true</code> 选项的示例。</p>\n</div>\n\n<h2 id=\"路由选项：Misc\"><a href=\"#路由选项：Misc\" class=\"headerlink\" title=\"路由选项：Misc\"></a>路由选项：Misc</h2><h3 id=\"saveScrollPosition-替换\"><a href=\"#saveScrollPosition-替换\" class=\"headerlink\" title=\"saveScrollPosition 替换\"></a><code>saveScrollPosition</code> <sup>替换</sup></h3><p>它已经被替换为可以接受一个函数的<a href=\"http://router.vuejs.org/en/advanced/scroll-behavior.html\"><code>scrollBehavior</code> 选项</a>，所以滑动行为可以完全的被定制化处理 - 甚至为每次路由进行定制也可以满足。这将会开启很多新的可能，但是简单的复制旧的行为:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">saveScrollPosition: <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>你可以替换为:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">scrollBehavior: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">to, from, savedPosition</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> savedPosition || &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>saveScrollPosition: true</code> 选项的示例。</p>\n</div>\n\n<h3 id=\"root-换名\"><a href=\"#root-换名\" class=\"headerlink\" title=\"root 换名\"></a><code>root</code> <sup>换名</sup></h3><p>为了与<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\">HTML 的<code>&lt;base&gt;</code>标签</a>保持一致性，重命名为<code>base</code>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>root</code> 选项的示例。</p>\n</div>\n\n<h3 id=\"transitionOnLoad-移除\"><a href=\"#transitionOnLoad-移除\" class=\"headerlink\" title=\"transitionOnLoad 移除\"></a><code>transitionOnLoad</code> <sup>移除</sup></h3><p>由于 Vue 的过渡系统<a href=\"transitions.html#Transitions-on-Initial-Render\"><code>appear</code> transition control</a>的存在，这个选项将不再需要。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>transitionOnLoad: true</code> 选项的示例。</p>\n</div>\n\n<h3 id=\"suppressTransitionError-移除\"><a href=\"#suppressTransitionError-移除\" class=\"headerlink\" title=\"suppressTransitionError 移除\"></a><code>suppressTransitionError</code> <sup>移除</sup></h3><p>出于简化钩子的考虑被移除。如果你真的需要抑制过渡错误，你可以使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch\"><code>try</code>…<code>catch</code></a>作为替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移指令</a> 找到 <code>suppressTransitionError: true</code> 选项的示例。</p>\n</div>\n\n<h2 id=\"路由挂钩\"><a href=\"#路由挂钩\" class=\"headerlink\" title=\"路由挂钩\"></a>路由挂钩</h2><h3 id=\"activate-替换\"><a href=\"#activate-替换\" class=\"headerlink\" title=\"activate 替换\"></a><code>activate</code> <sup>替换</sup></h3><p>使用<a href=\"http://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards\"><code>beforeRouteEnter</code></a>这一组件进行替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>beforeRouteEnter</code> 钩子的示例。</p>\n</div>\n\n<h3 id=\"canActivate-替换\"><a href=\"#canActivate-替换\" class=\"headerlink\" title=\"canActivate 替换\"></a><code>canActivate</code> <sup>替换</sup></h3><p>使用<a href=\"http://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard\"><code>beforeEnter</code></a> 在路由中作为替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>canActivate</code> 钩子的示例。</p>\n</div>\n\n<h3 id=\"deactivate-移除\"><a href=\"#deactivate-移除\" class=\"headerlink\" title=\"deactivate 移除\"></a><code>deactivate</code> <sup>移除</sup></h3><p>使用<a href=\"../api/#beforeDestroy\"><code>beforeDestroy</code></a> 或者 <a href=\"../api/#destroyed\"><code>destroyed</code></a> 钩子作为替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>deactivate</code> 钩子的示例。</p>\n</div>\n\n<h3 id=\"canDeactivate-替换\"><a href=\"#canDeactivate-替换\" class=\"headerlink\" title=\"canDeactivate 替换\"></a><code>canDeactivate</code> <sup>替换</sup></h3><p>在组件中使用<a href=\"http://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards\"><code>beforeRouteLeave</code></a> 作为替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移路径</a> 找到 <code>canDeactivate</code> 钩子的示例。</p>\n</div>\n\n<h3 id=\"canReuse-false-移除\"><a href=\"#canReuse-false-移除\" class=\"headerlink\" title=\"canReuse: false 移除\"></a><code>canReuse: false</code> <sup>移除</sup></h3><p>在新的 Vue 路由中将不再被使用。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>canReuse: false</code> 选项的示例。</p>\n</div>\n\n<h3 id=\"data-替换\"><a href=\"#data-替换\" class=\"headerlink\" title=\"data 替换\"></a><code>data</code> <sup>替换</sup></h3><p><code>$route</code>属性是响应式的，所有你可以就使用一个 watcher 去响应路由的改变，就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">watch: &#123;</div><div class=\"line\">  <span class=\"string\">'$route'</span>: <span class=\"string\">'fetchData'</span></div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">fetchData</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级路径</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移助手</a> 找到 <code>data</code> 钩子的示例。</p>\n</div>\n\n<h3 id=\"loadingRouteData-移除\"><a href=\"#loadingRouteData-移除\" class=\"headerlink\" title=\"$loadingRouteData 移除\"></a><code>$loadingRouteData</code> <sup>移除</sup></h3><p>定义你自己的属性（例如：<code>isLoading</code>），然后在路由上的 watcher 中更新加载状态。举个例子，如果使用<a href=\"https://github.com/mzabriskie/axios\">axios</a>获取数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">posts</span>: [],</div><div class=\"line\">    <span class=\"attr\">isLoading</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">fetchError</span>: <span class=\"literal\">null</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">  <span class=\"string\">'$route'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">    self.isLoading = <span class=\"literal\">true</span></div><div class=\"line\">    self.fetchData().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      self.isLoading = <span class=\"literal\">false</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">fetchData</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">    <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/api/posts'</span>)</div><div class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">        self.posts = response.data.posts</div><div class=\"line\">      &#125;)</div><div class=\"line\">      .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">        self.fetchError = error</div><div class=\"line\">      &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/migration-vue-router.html\">http://vuejs.org/guide/migration-vue-router.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"从 Vuex 0.6.x 迁移到 1.0","type":"guide","order":27,"_content":"\n> Vuex 2.0 已经发布了，但是这份指南只涵盖迁移到 1.0？这是打错了吗？此外，似乎 Vuex 1.0 和 2.0 也同时发布。这是怎么回事？我该用哪一个并且哪一个兼容 Vue 2.0呢？\n\nVuex 1.0 和 2.0 如下：\n\n- 都完全支持 Vue 1.0 和 2.0\n- 将在可预见的未来保留支持\n\n然而它们的目标用户稍微有所不同。\n\n__Vuex 2.0__ 从根本上重新设计并且提供简洁的 API，用于帮助正在开始一个新项目的用户，或想要用客户端状态管理前沿技术的用户。__此迁移指南不涵盖 Vuex 2.0 相关内容__，因此如果你想了解更多，请查阅 [Vuex 2.0 文档](https://vuex.vuejs.org/en/index.html)。\n\n__Vuex 1.0__ 主要是向下兼容，所以升级只需要很小的改动。推荐拥有大量现存代码库的用户，或只想尽可能平滑升级 Vue 2.0 的用户。这份指南致力促进这一过程，但仅包括迁移说明。完整使用指南请查阅 [Vuex 1.0 文档](https://github.com/vuejs/vuex/tree/1.0/docs/en)。\n\n## 带字符串属性路径的 `store.watch` <sup>替换</sup>\n\n## 传入字符串属性路径的 `store.watch` <sup>废弃</sup>\n\n\n`store.watch` 现在只接受函数。因此，下面例子你需要替换：\n\n``` js\nstore.watch('user.notifications', callback)\n```\n\n为：\n\n``` js\nstore.watch(\n  // 当返回结果改变...\n  function (state) {\n    return state.user.notifications\n  },\n  // 执行回调函数\n  callback\n)\n```\n\n这帮助你更加完善的控制那些需要监听的响应式属性。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方法</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，查找在 <code>store.watch</code> 中使用字符串作为第一个参数的事例。</p>\n</div>\n{% endraw %}\n\n## Store 的事件触发器 <sup>移除</sup>\n\nstore 实例不再暴露事件触发器(event emitter)接口(`on`, `off`, `emit`)。如果你之前使用 store 作为全局的 event bus，迁移说明相关内容请查阅[此章节](migration.html#dispatch-and-broadcast-removed)。\n\n为了替换正在使用观察 store 自身触发事件的这些接口，（例如：`store.on('mutation', callback)`），我们引入新的方法 `store.subscribe`。在插件中的典型使用方式如下：\n\n``` js\nvar myPlugin = store => {\n  store.subscribe(function (mutation, state) {\n    // Do something...\n  })\n}\n\n```\n\n更多信息请查阅[插件文档](https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md)的示例。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，查找使用了 <code>store.on</code>, <code>store.off</code>, <code>store.emit</code> 的事例。</p>\n</div>\n{% endraw %}\n\n## 中间件 <sup>替换</sup>\n\n中间件被替换为插件。插件是接收 store 作为仅有参数的基本函数，能够监听 store 中的 mutation 事件：\n\n``` js\nconst myPlugins = store => {\n  store.subscribe('mutation', (mutation, state) => {\n    // Do something...\n  })\n}\n```\n\n更多详情, 请查阅 [插件文档](https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方法</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，查找使用了 <code>middlewares</code> 选项的事例。</p>\n</div>\n{% endraw %}\n","source":"v2/guide/migration-vuex.md","raw":"---\ntitle: 从 Vuex 0.6.x 迁移到 1.0\ntype: guide\norder: 27\n---\n\n> Vuex 2.0 已经发布了，但是这份指南只涵盖迁移到 1.0？这是打错了吗？此外，似乎 Vuex 1.0 和 2.0 也同时发布。这是怎么回事？我该用哪一个并且哪一个兼容 Vue 2.0呢？\n\nVuex 1.0 和 2.0 如下：\n\n- 都完全支持 Vue 1.0 和 2.0\n- 将在可预见的未来保留支持\n\n然而它们的目标用户稍微有所不同。\n\n__Vuex 2.0__ 从根本上重新设计并且提供简洁的 API，用于帮助正在开始一个新项目的用户，或想要用客户端状态管理前沿技术的用户。__此迁移指南不涵盖 Vuex 2.0 相关内容__，因此如果你想了解更多，请查阅 [Vuex 2.0 文档](https://vuex.vuejs.org/en/index.html)。\n\n__Vuex 1.0__ 主要是向下兼容，所以升级只需要很小的改动。推荐拥有大量现存代码库的用户，或只想尽可能平滑升级 Vue 2.0 的用户。这份指南致力促进这一过程，但仅包括迁移说明。完整使用指南请查阅 [Vuex 1.0 文档](https://github.com/vuejs/vuex/tree/1.0/docs/en)。\n\n## 带字符串属性路径的 `store.watch` <sup>替换</sup>\n\n## 传入字符串属性路径的 `store.watch` <sup>废弃</sup>\n\n\n`store.watch` 现在只接受函数。因此，下面例子你需要替换：\n\n``` js\nstore.watch('user.notifications', callback)\n```\n\n为：\n\n``` js\nstore.watch(\n  // 当返回结果改变...\n  function (state) {\n    return state.user.notifications\n  },\n  // 执行回调函数\n  callback\n)\n```\n\n这帮助你更加完善的控制那些需要监听的响应式属性。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方法</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，查找在 <code>store.watch</code> 中使用字符串作为第一个参数的事例。</p>\n</div>\n{% endraw %}\n\n## Store 的事件触发器 <sup>移除</sup>\n\nstore 实例不再暴露事件触发器(event emitter)接口(`on`, `off`, `emit`)。如果你之前使用 store 作为全局的 event bus，迁移说明相关内容请查阅[此章节](migration.html#dispatch-and-broadcast-removed)。\n\n为了替换正在使用观察 store 自身触发事件的这些接口，（例如：`store.on('mutation', callback)`），我们引入新的方法 `store.subscribe`。在插件中的典型使用方式如下：\n\n``` js\nvar myPlugin = store => {\n  store.subscribe(function (mutation, state) {\n    // Do something...\n  })\n}\n\n```\n\n更多信息请查阅[插件文档](https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md)的示例。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，查找使用了 <code>store.on</code>, <code>store.off</code>, <code>store.emit</code> 的事例。</p>\n</div>\n{% endraw %}\n\n## 中间件 <sup>替换</sup>\n\n中间件被替换为插件。插件是接收 store 作为仅有参数的基本函数，能够监听 store 中的 mutation 事件：\n\n``` js\nconst myPlugins = store => {\n  store.subscribe('mutation', (mutation, state) => {\n    // Do something...\n  })\n}\n```\n\n更多详情, 请查阅 [插件文档](https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方法</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，查找使用了 <code>middlewares</code> 选项的事例。</p>\n</div>\n{% endraw %}\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/migration-vuex.html","comments":1,"layout":"page","_id":"ciwnajuyq001jjl2dp6utf5q2","content":"<blockquote>\n<p>Vuex 2.0 已经发布了，但是这份指南只涵盖迁移到 1.0？这是打错了吗？此外，似乎 Vuex 1.0 和 2.0 也同时发布。这是怎么回事？我该用哪一个并且哪一个兼容 Vue 2.0呢？</p>\n</blockquote>\n<p>Vuex 1.0 和 2.0 如下：</p>\n<ul>\n<li>都完全支持 Vue 1.0 和 2.0</li>\n<li>将在可预见的未来保留支持</li>\n</ul>\n<p>然而它们的目标用户稍微有所不同。</p>\n<p><strong>Vuex 2.0</strong> 从根本上重新设计并且提供简洁的 API，用于帮助正在开始一个新项目的用户，或想要用客户端状态管理前沿技术的用户。<strong>此迁移指南不涵盖 Vuex 2.0 相关内容</strong>，因此如果你想了解更多，请查阅 <a href=\"https://vuex.vuejs.org/en/index.html\" target=\"_blank\" rel=\"external\">Vuex 2.0 文档</a>。</p>\n<p><strong>Vuex 1.0</strong> 主要是向下兼容，所以升级只需要很小的改动。推荐拥有大量现存代码库的用户，或只想尽可能平滑升级 Vue 2.0 的用户。这份指南致力促进这一过程，但仅包括迁移说明。完整使用指南请查阅 <a href=\"https://github.com/vuejs/vuex/tree/1.0/docs/en\" target=\"_blank\" rel=\"external\">Vuex 1.0 文档</a>。</p>\n<h2 id=\"带字符串属性路径的-store-watch-替换\"><a href=\"#带字符串属性路径的-store-watch-替换\" class=\"headerlink\" title=\"带字符串属性路径的 store.watch 替换\"></a>带字符串属性路径的 <code>store.watch</code> <sup>替换</sup></h2><h2 id=\"传入字符串属性路径的-store-watch-废弃\"><a href=\"#传入字符串属性路径的-store-watch-废弃\" class=\"headerlink\" title=\"传入字符串属性路径的 store.watch 废弃\"></a>传入字符串属性路径的 <code>store.watch</code> <sup>废弃</sup></h2><p><code>store.watch</code> 现在只接受函数。因此，下面例子你需要替换：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">store.watch(<span class=\"string\">'user.notifications'</span>, callback)</div></pre></td></tr></table></figure>\n<p>为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">store.watch(</div><div class=\"line\">  <span class=\"comment\">// 当返回结果改变...</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">state</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> state.user.notifications</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 执行回调函数</span></div><div class=\"line\">  callback</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>这帮助你更加完善的控制那些需要监听的响应式属性。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方法</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>，查找在 <code>store.watch</code> 中使用字符串作为第一个参数的事例。</p>\n</div>\n\n<h2 id=\"Store-的事件触发器-移除\"><a href=\"#Store-的事件触发器-移除\" class=\"headerlink\" title=\"Store 的事件触发器 移除\"></a>Store 的事件触发器 <sup>移除</sup></h2><p>store 实例不再暴露事件触发器(event emitter)接口(<code>on</code>, <code>off</code>, <code>emit</code>)。如果你之前使用 store 作为全局的 event bus，迁移说明相关内容请查阅<a href=\"migration.html#dispatch-and-broadcast-removed\">此章节</a>。</p>\n<p>为了替换正在使用观察 store 自身触发事件的这些接口，（例如：<code>store.on(&#39;mutation&#39;, callback)</code>），我们引入新的方法 <code>store.subscribe</code>。在插件中的典型使用方式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myPlugin = <span class=\"function\"><span class=\"params\">store</span> =&gt;</span> &#123;</div><div class=\"line\">  store.subscribe(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mutation, state</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Do something...</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>更多信息请查阅<a href=\"https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md\" target=\"_blank\" rel=\"external\">插件文档</a>的示例。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>，查找使用了 <code>store.on</code>, <code>store.off</code>, <code>store.emit</code> 的事例。</p>\n</div>\n\n<h2 id=\"中间件-替换\"><a href=\"#中间件-替换\" class=\"headerlink\" title=\"中间件 替换\"></a>中间件 <sup>替换</sup></h2><p>中间件被替换为插件。插件是接收 store 作为仅有参数的基本函数，能够监听 store 中的 mutation 事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> myPlugins = <span class=\"function\"><span class=\"params\">store</span> =&gt;</span> &#123;</div><div class=\"line\">  store.subscribe(<span class=\"string\">'mutation'</span>, (mutation, state) =&gt; &#123;</div><div class=\"line\">    <span class=\"comment\">// Do something...</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>更多详情, 请查阅 <a href=\"https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md\" target=\"_blank\" rel=\"external\">插件文档</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方法</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>，查找使用了 <code>middlewares</code> 选项的事例。</p>\n</div>\n\n","excerpt":"","more":"<blockquote>\n<p>Vuex 2.0 已经发布了，但是这份指南只涵盖迁移到 1.0？这是打错了吗？此外，似乎 Vuex 1.0 和 2.0 也同时发布。这是怎么回事？我该用哪一个并且哪一个兼容 Vue 2.0呢？</p>\n</blockquote>\n<p>Vuex 1.0 和 2.0 如下：</p>\n<ul>\n<li>都完全支持 Vue 1.0 和 2.0</li>\n<li>将在可预见的未来保留支持</li>\n</ul>\n<p>然而它们的目标用户稍微有所不同。</p>\n<p><strong>Vuex 2.0</strong> 从根本上重新设计并且提供简洁的 API，用于帮助正在开始一个新项目的用户，或想要用客户端状态管理前沿技术的用户。<strong>此迁移指南不涵盖 Vuex 2.0 相关内容</strong>，因此如果你想了解更多，请查阅 <a href=\"https://vuex.vuejs.org/en/index.html\">Vuex 2.0 文档</a>。</p>\n<p><strong>Vuex 1.0</strong> 主要是向下兼容，所以升级只需要很小的改动。推荐拥有大量现存代码库的用户，或只想尽可能平滑升级 Vue 2.0 的用户。这份指南致力促进这一过程，但仅包括迁移说明。完整使用指南请查阅 <a href=\"https://github.com/vuejs/vuex/tree/1.0/docs/en\">Vuex 1.0 文档</a>。</p>\n<h2 id=\"带字符串属性路径的-store-watch-替换\"><a href=\"#带字符串属性路径的-store-watch-替换\" class=\"headerlink\" title=\"带字符串属性路径的 store.watch 替换\"></a>带字符串属性路径的 <code>store.watch</code> <sup>替换</sup></h2><h2 id=\"传入字符串属性路径的-store-watch-废弃\"><a href=\"#传入字符串属性路径的-store-watch-废弃\" class=\"headerlink\" title=\"传入字符串属性路径的 store.watch 废弃\"></a>传入字符串属性路径的 <code>store.watch</code> <sup>废弃</sup></h2><p><code>store.watch</code> 现在只接受函数。因此，下面例子你需要替换：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">store.watch(<span class=\"string\">'user.notifications'</span>, callback)</div></pre></td></tr></table></figure>\n<p>为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">store.watch(</div><div class=\"line\">  <span class=\"comment\">// 当返回结果改变...</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">state</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> state.user.notifications</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 执行回调函数</span></div><div class=\"line\">  callback</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>这帮助你更加完善的控制那些需要监听的响应式属性。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方法</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，查找在 <code>store.watch</code> 中使用字符串作为第一个参数的事例。</p>\n</div>\n\n<h2 id=\"Store-的事件触发器-移除\"><a href=\"#Store-的事件触发器-移除\" class=\"headerlink\" title=\"Store 的事件触发器 移除\"></a>Store 的事件触发器 <sup>移除</sup></h2><p>store 实例不再暴露事件触发器(event emitter)接口(<code>on</code>, <code>off</code>, <code>emit</code>)。如果你之前使用 store 作为全局的 event bus，迁移说明相关内容请查阅<a href=\"migration.html#dispatch-and-broadcast-removed\">此章节</a>。</p>\n<p>为了替换正在使用观察 store 自身触发事件的这些接口，（例如：<code>store.on(&#39;mutation&#39;, callback)</code>），我们引入新的方法 <code>store.subscribe</code>。在插件中的典型使用方式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myPlugin = <span class=\"function\"><span class=\"params\">store</span> =&gt;</span> &#123;</div><div class=\"line\">  store.subscribe(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mutation, state</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Do something...</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>更多信息请查阅<a href=\"https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md\">插件文档</a>的示例。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，查找使用了 <code>store.on</code>, <code>store.off</code>, <code>store.emit</code> 的事例。</p>\n</div>\n\n<h2 id=\"中间件-替换\"><a href=\"#中间件-替换\" class=\"headerlink\" title=\"中间件 替换\"></a>中间件 <sup>替换</sup></h2><p>中间件被替换为插件。插件是接收 store 作为仅有参数的基本函数，能够监听 store 中的 mutation 事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> myPlugins = <span class=\"function\"><span class=\"params\">store</span> =&gt;</span> &#123;</div><div class=\"line\">  store.subscribe(<span class=\"string\">'mutation'</span>, (mutation, state) =&gt; &#123;</div><div class=\"line\">    <span class=\"comment\">// Do something...</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>更多详情, 请查阅 <a href=\"https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md\">插件文档</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方法</h4>\n  <p>在代码库运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，查找使用了 <code>middlewares</code> 选项的事例。</p>\n</div>\n\n"},{"title":"混合","type":"guide","order":17,"_content":"\n## 基础\n\n混合是一种灵活的分布式复用 Vue 组件的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。\n\n例子：\n\n``` js\n// 定义一个混合对象\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log('hello from mixin!')\n    }\n  }\n}\n\n// 定义一个使用混合对象的组件\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\n\nvar component = new Component() // -> \"hello from mixin!\"\n```\n\n## 选项合并\n\n当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 **之前** 调用 ：\n\n``` js\nvar mixin = {\n  created: function () {\n    console.log('mixin hook called')\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  created: function () {\n    console.log('component hook called')\n  }\n})\n\n// -> \"混合对象的钩子被调用\"\n// -> \"组件钩子被调用\"\n```\n\n值为对象的选项，例如 `methods`, `components` 和 `directives`，将被混合为同一个对象。 两个对象键名冲突时，取组件对象的键值对。\n\n``` js\nvar mixin = {\n  methods: {\n    foo: function () {\n      console.log('foo')\n    },\n    conflicting: function () {\n      console.log('from mixin')\n    }\n  }\n}\n\nvar vm = new Vue({\n  mixins: [mixin],\n  methods: {\n    bar: function () {\n      console.log('bar')\n    },\n    conflicting: function () {\n      console.log('from self')\n    }\n  }\n})\n\nvm.foo() // -> \"foo\"\nvm.bar() // -> \"bar\"\nvm.conflicting() // -> \"from self\"\n```\n\n注意： `Vue.extend()` 也使用同样的策略进行合并。\n\n## 全局混合\n\n也可以全局注册混合对象。 注意使用！ 一旦使用全局混合对象，将会影响到 **所有** 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。\n\n``` js\n// 为自定义的选项 'myOption' 注入一个处理器。 \nVue.mixin({\n  created: function () {\n    var myOption = this.$options.myOption\n    if (myOption) {\n      console.log(myOption)\n    }\n  }\n})\n\nnew Vue({\n  myOption: 'hello!'\n})\n// -> \"hello!\"\n```\n\n<p class=\"tip\">谨慎使用全局混合对象，因为会影响到每个单独创建的 Vue 实例（包括第三方模板）。大多数情况下，只应当应用于自定义选项，就像上面示例一样。 也可以将其用作 [Plugins](plugins.html) 以避免产生重复应用</p>\n\n## 自定义选项混合策略\n\n自定义选项将使用默认策略，即简单地覆盖已有值。 如果想让自定义选项以自定义逻辑混合，可以向 `Vue.config.optionMergeStrategies` 添加一个函数：\n\n``` js\nVue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {\n  // return mergedVal\n}\n```\n\n对于大多数对象选项，可以使用 `methods` 的合并策略:\n\n``` js\nvar strategies = Vue.config.optionMergeStrategies\nstrategies.myOption = strategies.methods\n```\n\n更多高级的例子可以在 [Vuex](https://github.com/vuejs/vuex) 1.x的混合策略里找到:\n\n``` js\nconst merge = Vue.config.optionMergeStrategies.computed\nVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {\n  if (!toVal) return fromVal\n  if (!fromVal) return toVal\n  return {\n    getters: merge(toVal.getters, fromVal.getters),\n    state: merge(toVal.state, fromVal.state),\n    actions: merge(toVal.actions, fromVal.actions)\n  }\n}\n```\n\n***\n\n> 原文： http://vuejs.org/guide/mixins.html\n\n***\n","source":"v2/guide/mixins.md","raw":"---\ntitle: 混合\ntype: guide\norder: 17\n---\n\n## 基础\n\n混合是一种灵活的分布式复用 Vue 组件的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。\n\n例子：\n\n``` js\n// 定义一个混合对象\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log('hello from mixin!')\n    }\n  }\n}\n\n// 定义一个使用混合对象的组件\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\n\nvar component = new Component() // -> \"hello from mixin!\"\n```\n\n## 选项合并\n\n当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 **之前** 调用 ：\n\n``` js\nvar mixin = {\n  created: function () {\n    console.log('mixin hook called')\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  created: function () {\n    console.log('component hook called')\n  }\n})\n\n// -> \"混合对象的钩子被调用\"\n// -> \"组件钩子被调用\"\n```\n\n值为对象的选项，例如 `methods`, `components` 和 `directives`，将被混合为同一个对象。 两个对象键名冲突时，取组件对象的键值对。\n\n``` js\nvar mixin = {\n  methods: {\n    foo: function () {\n      console.log('foo')\n    },\n    conflicting: function () {\n      console.log('from mixin')\n    }\n  }\n}\n\nvar vm = new Vue({\n  mixins: [mixin],\n  methods: {\n    bar: function () {\n      console.log('bar')\n    },\n    conflicting: function () {\n      console.log('from self')\n    }\n  }\n})\n\nvm.foo() // -> \"foo\"\nvm.bar() // -> \"bar\"\nvm.conflicting() // -> \"from self\"\n```\n\n注意： `Vue.extend()` 也使用同样的策略进行合并。\n\n## 全局混合\n\n也可以全局注册混合对象。 注意使用！ 一旦使用全局混合对象，将会影响到 **所有** 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。\n\n``` js\n// 为自定义的选项 'myOption' 注入一个处理器。 \nVue.mixin({\n  created: function () {\n    var myOption = this.$options.myOption\n    if (myOption) {\n      console.log(myOption)\n    }\n  }\n})\n\nnew Vue({\n  myOption: 'hello!'\n})\n// -> \"hello!\"\n```\n\n<p class=\"tip\">谨慎使用全局混合对象，因为会影响到每个单独创建的 Vue 实例（包括第三方模板）。大多数情况下，只应当应用于自定义选项，就像上面示例一样。 也可以将其用作 [Plugins](plugins.html) 以避免产生重复应用</p>\n\n## 自定义选项混合策略\n\n自定义选项将使用默认策略，即简单地覆盖已有值。 如果想让自定义选项以自定义逻辑混合，可以向 `Vue.config.optionMergeStrategies` 添加一个函数：\n\n``` js\nVue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {\n  // return mergedVal\n}\n```\n\n对于大多数对象选项，可以使用 `methods` 的合并策略:\n\n``` js\nvar strategies = Vue.config.optionMergeStrategies\nstrategies.myOption = strategies.methods\n```\n\n更多高级的例子可以在 [Vuex](https://github.com/vuejs/vuex) 1.x的混合策略里找到:\n\n``` js\nconst merge = Vue.config.optionMergeStrategies.computed\nVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {\n  if (!toVal) return fromVal\n  if (!fromVal) return toVal\n  return {\n    getters: merge(toVal.getters, fromVal.getters),\n    state: merge(toVal.state, fromVal.state),\n    actions: merge(toVal.actions, fromVal.actions)\n  }\n}\n```\n\n***\n\n> 原文： http://vuejs.org/guide/mixins.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/mixins.html","comments":1,"layout":"page","_id":"ciwnajuyr001kjl2d99gsl2fz","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>混合是一种灵活的分布式复用 Vue 组件的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义一个混合对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> myMixin = &#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.hello()</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">hello</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello from mixin!'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义一个使用混合对象的组件</span></div><div class=\"line\"><span class=\"keyword\">var</span> Component = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">mixins</span>: [myMixin]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> component = <span class=\"keyword\">new</span> Component() <span class=\"comment\">// -&gt; \"hello from mixin!\"</span></div></pre></td></tr></table></figure>\n<h2 id=\"选项合并\"><a href=\"#选项合并\" class=\"headerlink\" title=\"选项合并\"></a>选项合并</h2><p>当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 <strong>之前</strong> 调用 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'mixin hook called'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">mixins</span>: [mixin],</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'component hook called'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// -&gt; \"混合对象的钩子被调用\"</span></div><div class=\"line\"><span class=\"comment\">// -&gt; \"组件钩子被调用\"</span></div></pre></td></tr></table></figure>\n<p>值为对象的选项，例如 <code>methods</code>, <code>components</code> 和 <code>directives</code>，将被混合为同一个对象。 两个对象键名冲突时，取组件对象的键值对。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">conflicting</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'from mixin'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">mixins</span>: [mixin],</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">bar</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">conflicting</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'from self'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">vm.foo() <span class=\"comment\">// -&gt; \"foo\"</span></div><div class=\"line\">vm.bar() <span class=\"comment\">// -&gt; \"bar\"</span></div><div class=\"line\">vm.conflicting() <span class=\"comment\">// -&gt; \"from self\"</span></div></pre></td></tr></table></figure>\n<p>注意： <code>Vue.extend()</code> 也使用同样的策略进行合并。</p>\n<h2 id=\"全局混合\"><a href=\"#全局混合\" class=\"headerlink\" title=\"全局混合\"></a>全局混合</h2><p>也可以全局注册混合对象。 注意使用！ 一旦使用全局混合对象，将会影响到 <strong>所有</strong> 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 为自定义的选项 'myOption' 注入一个处理器。 </span></div><div class=\"line\">Vue.mixin(&#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> myOption = <span class=\"keyword\">this</span>.$options.myOption</div><div class=\"line\">    <span class=\"keyword\">if</span> (myOption) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(myOption)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">myOption</span>: <span class=\"string\">'hello!'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// -&gt; \"hello!\"</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">谨慎使用全局混合对象，因为会影响到每个单独创建的 Vue 实例（包括第三方模板）。大多数情况下，只应当应用于自定义选项，就像上面示例一样。 也可以将其用作 <a href=\"plugins.html\">Plugins</a> 以避免产生重复应用</p>\n\n<h2 id=\"自定义选项混合策略\"><a href=\"#自定义选项混合策略\" class=\"headerlink\" title=\"自定义选项混合策略\"></a>自定义选项混合策略</h2><p>自定义选项将使用默认策略，即简单地覆盖已有值。 如果想让自定义选项以自定义逻辑混合，可以向 <code>Vue.config.optionMergeStrategies</code> 添加一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.optionMergeStrategies.myOption = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">toVal, fromVal</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// return mergedVal</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于大多数对象选项，可以使用 <code>methods</code> 的合并策略:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> strategies = Vue.config.optionMergeStrategies</div><div class=\"line\">strategies.myOption = strategies.methods</div></pre></td></tr></table></figure>\n<p>更多高级的例子可以在 <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">Vuex</a> 1.x的混合策略里找到:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> merge = Vue.config.optionMergeStrategies.computed</div><div class=\"line\">Vue.config.optionMergeStrategies.vuex = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">toVal, fromVal</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!toVal) <span class=\"keyword\">return</span> fromVal</div><div class=\"line\">  <span class=\"keyword\">if</span> (!fromVal) <span class=\"keyword\">return</span> toVal</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">getters</span>: merge(toVal.getters, fromVal.getters),</div><div class=\"line\">    <span class=\"attr\">state</span>: merge(toVal.state, fromVal.state),</div><div class=\"line\">    <span class=\"attr\">actions</span>: merge(toVal.actions, fromVal.actions)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/mixins.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/mixins.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>混合是一种灵活的分布式复用 Vue 组件的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义一个混合对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> myMixin = &#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.hello()</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">hello</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello from mixin!'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义一个使用混合对象的组件</span></div><div class=\"line\"><span class=\"keyword\">var</span> Component = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">mixins</span>: [myMixin]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> component = <span class=\"keyword\">new</span> Component() <span class=\"comment\">// -&gt; \"hello from mixin!\"</span></div></pre></td></tr></table></figure>\n<h2 id=\"选项合并\"><a href=\"#选项合并\" class=\"headerlink\" title=\"选项合并\"></a>选项合并</h2><p>当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 <strong>之前</strong> 调用 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'mixin hook called'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">mixins</span>: [mixin],</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'component hook called'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// -&gt; \"混合对象的钩子被调用\"</span></div><div class=\"line\"><span class=\"comment\">// -&gt; \"组件钩子被调用\"</span></div></pre></td></tr></table></figure>\n<p>值为对象的选项，例如 <code>methods</code>, <code>components</code> 和 <code>directives</code>，将被混合为同一个对象。 两个对象键名冲突时，取组件对象的键值对。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">conflicting</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'from mixin'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">mixins</span>: [mixin],</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">bar</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">conflicting</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'from self'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">vm.foo() <span class=\"comment\">// -&gt; \"foo\"</span></div><div class=\"line\">vm.bar() <span class=\"comment\">// -&gt; \"bar\"</span></div><div class=\"line\">vm.conflicting() <span class=\"comment\">// -&gt; \"from self\"</span></div></pre></td></tr></table></figure>\n<p>注意： <code>Vue.extend()</code> 也使用同样的策略进行合并。</p>\n<h2 id=\"全局混合\"><a href=\"#全局混合\" class=\"headerlink\" title=\"全局混合\"></a>全局混合</h2><p>也可以全局注册混合对象。 注意使用！ 一旦使用全局混合对象，将会影响到 <strong>所有</strong> 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 为自定义的选项 'myOption' 注入一个处理器。 </span></div><div class=\"line\">Vue.mixin(&#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> myOption = <span class=\"keyword\">this</span>.$options.myOption</div><div class=\"line\">    <span class=\"keyword\">if</span> (myOption) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(myOption)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">myOption</span>: <span class=\"string\">'hello!'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// -&gt; \"hello!\"</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">谨慎使用全局混合对象，因为会影响到每个单独创建的 Vue 实例（包括第三方模板）。大多数情况下，只应当应用于自定义选项，就像上面示例一样。 也可以将其用作 <a href=\"plugins.html\">Plugins</a> 以避免产生重复应用</p>\n\n<h2 id=\"自定义选项混合策略\"><a href=\"#自定义选项混合策略\" class=\"headerlink\" title=\"自定义选项混合策略\"></a>自定义选项混合策略</h2><p>自定义选项将使用默认策略，即简单地覆盖已有值。 如果想让自定义选项以自定义逻辑混合，可以向 <code>Vue.config.optionMergeStrategies</code> 添加一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.optionMergeStrategies.myOption = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">toVal, fromVal</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// return mergedVal</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于大多数对象选项，可以使用 <code>methods</code> 的合并策略:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> strategies = Vue.config.optionMergeStrategies</div><div class=\"line\">strategies.myOption = strategies.methods</div></pre></td></tr></table></figure>\n<p>更多高级的例子可以在 <a href=\"https://github.com/vuejs/vuex\">Vuex</a> 1.x的混合策略里找到:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> merge = Vue.config.optionMergeStrategies.computed</div><div class=\"line\">Vue.config.optionMergeStrategies.vuex = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">toVal, fromVal</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!toVal) <span class=\"keyword\">return</span> fromVal</div><div class=\"line\">  <span class=\"keyword\">if</span> (!fromVal) <span class=\"keyword\">return</span> toVal</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">getters</span>: merge(toVal.getters, fromVal.getters),</div><div class=\"line\">    <span class=\"attr\">state</span>: merge(toVal.state, fromVal.state),</div><div class=\"line\">    <span class=\"attr\">actions</span>: merge(toVal.actions, fromVal.actions)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/mixins.html\">http://vuejs.org/guide/mixins.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"插件","type":"guide","order":18,"_content":"\n## 开发插件\n\n\n插件通常会为Vue添加全局功能。插件的范围没有限制——一般有下面几种：\n\n1. 添加全局方法或者属性，如: [vue-element](https://github.com/vuejs/vue-element) \n\n2. 添加全局资源：指令/过滤器/过渡等，如 [vue-touch](https://github.com/vuejs/vue-touch)\n\n3. 通过全局 mixin方法添加一些组件选项，如: [vuex](https://github.com/vuejs/vuex)\n\n4. 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。\n\n5. 一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 [vue-router](https://github.com/vuejs/vue-router)\n\nVue.js 的插件应当有一个公开方法 `install` 。这个方法的第一个参数是 `Vue` 构造器 , 第二个参数是一个可选的选项对象:\n\n``` js\nMyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或属性\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (options) {\n    // 逻辑...\n  }\n}\n```\n\n## 使用插件\n\n通过全局方法 Vue.use() 使用插件:\n\n``` js\n// 调用 `MyPlugin.install(Vue)`\nVue.use(MyPlugin)\n```\n\n也可以传入一个选项对象:\n\n``` js\nVue.use(MyPlugin, { someOption: true })\n```\n\n`Vue.use` 会自动阻止注册相同插件多次，届时只会注册一次该插件。\n\n一些插件，如 `vue-router` 如果 `Vue` 是全局变量则自动调用 `Vue.use()` 。不过在模块环境中应当始终显式调用 `Vue.use()` :\n\n``` js\n// 通过 Browserify 或 Webpack 使用 CommonJS 兼容模块\nvar Vue = require('vue')\nvar VueRouter = require('vue-router')\n\n// 不要忘了调用此方法\nVue.use(VueRouter)\n```\n\n[awesome-vue](https://github.com/vuejs/awesome-vue#libraries--plugins) 集合了来自社区贡献的数以千计的插件和库。\n\n\n\n\n***\n\n> 原文： http://vuejs.org/guide/plugins.html\n\n***\n","source":"v2/guide/plugins.md","raw":"---\ntitle: 插件\ntype: guide\norder: 18\n---\n\n## 开发插件\n\n\n插件通常会为Vue添加全局功能。插件的范围没有限制——一般有下面几种：\n\n1. 添加全局方法或者属性，如: [vue-element](https://github.com/vuejs/vue-element) \n\n2. 添加全局资源：指令/过滤器/过渡等，如 [vue-touch](https://github.com/vuejs/vue-touch)\n\n3. 通过全局 mixin方法添加一些组件选项，如: [vuex](https://github.com/vuejs/vuex)\n\n4. 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。\n\n5. 一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 [vue-router](https://github.com/vuejs/vue-router)\n\nVue.js 的插件应当有一个公开方法 `install` 。这个方法的第一个参数是 `Vue` 构造器 , 第二个参数是一个可选的选项对象:\n\n``` js\nMyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或属性\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (options) {\n    // 逻辑...\n  }\n}\n```\n\n## 使用插件\n\n通过全局方法 Vue.use() 使用插件:\n\n``` js\n// 调用 `MyPlugin.install(Vue)`\nVue.use(MyPlugin)\n```\n\n也可以传入一个选项对象:\n\n``` js\nVue.use(MyPlugin, { someOption: true })\n```\n\n`Vue.use` 会自动阻止注册相同插件多次，届时只会注册一次该插件。\n\n一些插件，如 `vue-router` 如果 `Vue` 是全局变量则自动调用 `Vue.use()` 。不过在模块环境中应当始终显式调用 `Vue.use()` :\n\n``` js\n// 通过 Browserify 或 Webpack 使用 CommonJS 兼容模块\nvar Vue = require('vue')\nvar VueRouter = require('vue-router')\n\n// 不要忘了调用此方法\nVue.use(VueRouter)\n```\n\n[awesome-vue](https://github.com/vuejs/awesome-vue#libraries--plugins) 集合了来自社区贡献的数以千计的插件和库。\n\n\n\n\n***\n\n> 原文： http://vuejs.org/guide/plugins.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/plugins.html","comments":1,"layout":"page","_id":"ciwnajuyt001ljl2dsdw1pbiu","content":"<h2 id=\"开发插件\"><a href=\"#开发插件\" class=\"headerlink\" title=\"开发插件\"></a>开发插件</h2><p>插件通常会为Vue添加全局功能。插件的范围没有限制——一般有下面几种：</p>\n<ol>\n<li><p>添加全局方法或者属性，如: <a href=\"https://github.com/vuejs/vue-element\" target=\"_blank\" rel=\"external\">vue-element</a> </p>\n</li>\n<li><p>添加全局资源：指令/过滤器/过渡等，如 <a href=\"https://github.com/vuejs/vue-touch\" target=\"_blank\" rel=\"external\">vue-touch</a></p>\n</li>\n<li><p>通过全局 mixin方法添加一些组件选项，如: <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">vuex</a></p>\n</li>\n<li><p>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</p>\n</li>\n<li><p>一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"external\">vue-router</a></p>\n</li>\n</ol>\n<p>Vue.js 的插件应当有一个公开方法 <code>install</code> 。这个方法的第一个参数是 <code>Vue</code> 构造器 , 第二个参数是一个可选的选项对象:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">MyPlugin.install = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Vue, options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 1. 添加全局方法或属性</span></div><div class=\"line\">  Vue.myGlobalMethod = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 逻辑...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 2. 添加全局资源</span></div><div class=\"line\">  Vue.directive(<span class=\"string\">'my-directive'</span>, &#123;</div><div class=\"line\">    bind (el, binding, vnode, oldVnode) &#123;</div><div class=\"line\">      <span class=\"comment\">// 逻辑...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 3. 注入组件</span></div><div class=\"line\">  Vue.mixin(&#123;</div><div class=\"line\">    <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 逻辑...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 4. 添加实例方法</span></div><div class=\"line\">  Vue.prototype.$myMethod = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 逻辑...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"使用插件\"><a href=\"#使用插件\" class=\"headerlink\" title=\"使用插件\"></a>使用插件</h2><p>通过全局方法 Vue.use() 使用插件:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 调用 `MyPlugin.install(Vue)`</span></div><div class=\"line\">Vue.use(MyPlugin)</div></pre></td></tr></table></figure>\n<p>也可以传入一个选项对象:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.use(MyPlugin, &#123; <span class=\"attr\">someOption</span>: <span class=\"literal\">true</span> &#125;)</div></pre></td></tr></table></figure>\n<p><code>Vue.use</code> 会自动阻止注册相同插件多次，届时只会注册一次该插件。</p>\n<p>一些插件，如 <code>vue-router</code> 如果 <code>Vue</code> 是全局变量则自动调用 <code>Vue.use()</code> 。不过在模块环境中应当始终显式调用 <code>Vue.use()</code> :</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 通过 Browserify 或 Webpack 使用 CommonJS 兼容模块</span></div><div class=\"line\"><span class=\"keyword\">var</span> Vue = <span class=\"built_in\">require</span>(<span class=\"string\">'vue'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> VueRouter = <span class=\"built_in\">require</span>(<span class=\"string\">'vue-router'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 不要忘了调用此方法</span></div><div class=\"line\">Vue.use(VueRouter)</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/vuejs/awesome-vue#libraries--plugins\" target=\"_blank\" rel=\"external\">awesome-vue</a> 集合了来自社区贡献的数以千计的插件和库。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/plugins.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/plugins.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"开发插件\"><a href=\"#开发插件\" class=\"headerlink\" title=\"开发插件\"></a>开发插件</h2><p>插件通常会为Vue添加全局功能。插件的范围没有限制——一般有下面几种：</p>\n<ol>\n<li><p>添加全局方法或者属性，如: <a href=\"https://github.com/vuejs/vue-element\">vue-element</a> </p>\n</li>\n<li><p>添加全局资源：指令/过滤器/过渡等，如 <a href=\"https://github.com/vuejs/vue-touch\">vue-touch</a></p>\n</li>\n<li><p>通过全局 mixin方法添加一些组件选项，如: <a href=\"https://github.com/vuejs/vuex\">vuex</a></p>\n</li>\n<li><p>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</p>\n</li>\n<li><p>一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 <a href=\"https://github.com/vuejs/vue-router\">vue-router</a></p>\n</li>\n</ol>\n<p>Vue.js 的插件应当有一个公开方法 <code>install</code> 。这个方法的第一个参数是 <code>Vue</code> 构造器 , 第二个参数是一个可选的选项对象:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">MyPlugin.install = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Vue, options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 1. 添加全局方法或属性</span></div><div class=\"line\">  Vue.myGlobalMethod = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 逻辑...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 2. 添加全局资源</span></div><div class=\"line\">  Vue.directive(<span class=\"string\">'my-directive'</span>, &#123;</div><div class=\"line\">    bind (el, binding, vnode, oldVnode) &#123;</div><div class=\"line\">      <span class=\"comment\">// 逻辑...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 3. 注入组件</span></div><div class=\"line\">  Vue.mixin(&#123;</div><div class=\"line\">    <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 逻辑...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 4. 添加实例方法</span></div><div class=\"line\">  Vue.prototype.$myMethod = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 逻辑...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"使用插件\"><a href=\"#使用插件\" class=\"headerlink\" title=\"使用插件\"></a>使用插件</h2><p>通过全局方法 Vue.use() 使用插件:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 调用 `MyPlugin.install(Vue)`</span></div><div class=\"line\">Vue.use(MyPlugin)</div></pre></td></tr></table></figure>\n<p>也可以传入一个选项对象:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.use(MyPlugin, &#123; <span class=\"attr\">someOption</span>: <span class=\"literal\">true</span> &#125;)</div></pre></td></tr></table></figure>\n<p><code>Vue.use</code> 会自动阻止注册相同插件多次，届时只会注册一次该插件。</p>\n<p>一些插件，如 <code>vue-router</code> 如果 <code>Vue</code> 是全局变量则自动调用 <code>Vue.use()</code> 。不过在模块环境中应当始终显式调用 <code>Vue.use()</code> :</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 通过 Browserify 或 Webpack 使用 CommonJS 兼容模块</span></div><div class=\"line\"><span class=\"keyword\">var</span> Vue = <span class=\"built_in\">require</span>(<span class=\"string\">'vue'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> VueRouter = <span class=\"built_in\">require</span>(<span class=\"string\">'vue-router'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 不要忘了调用此方法</span></div><div class=\"line\">Vue.use(VueRouter)</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/vuejs/awesome-vue#libraries--plugins\">awesome-vue</a> 集合了来自社区贡献的数以千计的插件和库。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/plugins.html\">http://vuejs.org/guide/plugins.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"从 Vue 1.x 迁移","type":"guide","order":25,"_content":"\n## FAQ\n\n> 哇，非常长的一页！是否意味着 Vue 2.0 已经完全不同了呢，是否需要从头学起呢，Vue 1.0 的项目是不是没法迁移了？\n\n非常开心地告诉你，并不是！几乎 90% 的 API 和核心概念都没有变。因为本节包含了很多详尽的阐述以及许多迁移的例子，所以显得有点长。不用担心，__你不必从头到尾把本节读一遍！__\n\n> 我该从哪里开始项目迁移呢？\n\n1. 首先，在当前项目下运行[迁移工具](https://github.com/vuejs/vue-migration-helper)。我们非常谨慎地把高级 Vue 升级过程简化为使用一个简单的命令行工具。当工具识别出旧有的特性后，就会告知你并给出建议，同时附上关于详细信息的链接。\n\n2. 然后，浏览本页面的侧边栏列出的内容。如果发现有的标题对你的项目有影响，但是迁移工具没有给出提示，请检查自己的项目。\n\n3. 如果你的项目有测试代码，运行并查看仍然失败的地方。如果没有测试代码，在浏览器中打开你的程序，通过导航环顾并留意那些报错或警告信息。\n\n4. 现在，你的应用程序应该已彻底完成迁移。如果你渴望了解更多，可以阅读本页面剩余部分 - 或者从[介绍](index.html)部分，从头开始深入新的文档和改进过的指南。由于你已经熟悉一些核心概念，所以许多部分已经被删除掉。\n\n> 将 Vue 1.x 版本的应用程序迁移到 2.0 要花多长时间？\n\n这取决于几个因素：\n\n- 取决于你应用程序的规模（中小型的基本上一天内就可以搞定）。\n\n- 取决于你分心和开始 2.0 最酷的新功能的次数。 😉 &nbsp;无法判断时间，我们构建 2.0 应用的时候也经常发生这种事！\n\n- 取决于你使用了哪些旧有的特性。大部分可以通过查找和替换(find-and-replace)来实现升级，但有一些可能还是要花点时间。如果你没有遵循最佳实践，Vue 2.0 会尽力强迫你去遵循。这有利于项目的长期运行，但也可能意味着重大重构（尽管有些需要重构的部分可能已经过时）。\n\n> 如果我升级到到 Vue 2 ，我还必须同时升级 Vuex 和 Vue-Router？\n\n只有 Vue-Router 2 与 Vue 2 保持兼容，所以 Vue-Router 是需要升级的，你必须遵循 [Vue-Router 迁移方式](migration-vue-router.html)来处理。幸运的是， 大多数应用没有很多 router 相关代码，所以迁移可能不会超过一个小时。\n\n对于 Vuex ，版本 0.8+ 与 Vue 2 保持兼容，所以部分不必强制升级。可以促使你立即升级的唯一理由，是你想要使用那些 Vuex 2 中新的高级特性，比如模块(modules)和减少的样板文件(reduced boilerplate)。\n\n## 模板\n\n### 片段实例 <sup>移除</sup>\n\n每个组件必须只有一个根元素。不再允许片段实例，如果你有这样的模板：\n\n``` html\n<p>foo</p>\n<p>bar</p>\n```\n\n最好把整个内容都简单包裹到一个新的元素里，如下所示：\n\n``` html\n<div>\n  <p>foo</p>\n  <p>bar</p>\n</div>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>升级后运行端到端测试套件(end-to-end test suite)或运行应用程序，并查看<strong>控制台警告(console warnings)</strong>来找出那些模板中有多个根元素的地方。\n</div>\n{% endraw %}\n\n## 生命周期钩子函数\n\n### `beforeCompile` <sup>移除</sup>\n\n使用 `created` 钩子函数替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n### `compiled` <sup>替换</sup>\n\n使用 `mounted` 钩子函数替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n### `attached` <sup>移除</sup>\n\n使用其他钩子函数内置的 DOM 检测(DOM check)方法。例如，替换如下：\n\n``` js\nattached: function () {\n  doSomething()\n}\n```\n\n可以这样使用：\n\n``` js\nmounted: function () {\n  this.$nextTick(function () {\n    doSomething()\n  })\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n### `detached` <sup>移除</sup>\n\n使用其他钩子函数内的 DOM 检测(DOM check)方法。例如，替换如下：\n\n``` js\ndetached: function () {\n  doSomething()\n}\n```\n\n可以这样使用：\n\n``` js\ndestroyed: function () {\n  this.$nextTick(function () {\n    doSomething()\n  })\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n### `init` <sup>重新命名</sup>\n\n使用新的 `beforeCreate` 钩子函数替代，本质上 beforeCreate 和 init 完全相同。init 被重新命名是为了和其他的生命周期方法的命名方式保持一致。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n### `ready` <sup>替换</sup>\n\n使用新的 `mounted` 钩子函数替代。应该注意的是，使用 `mounted` 并不能保证钩子函数中的 this.$el 在 document 中。为此还应该引入 `Vue.nextTick`/`vm.$nextTick`。例如：\n\n``` js\nmounted: function () {\n  this.$nextTick(function () {\n    // 代码保证 this.$el 在 document 中\n  })\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n## `v-for`\n\n### `v-for` 遍历数组时的参数顺序 <sup>变更</sup>\n\n当包含 `index` 时，之前遍历数组时的参数顺序是 `(index, value)`。现在是 `(value, index)` ，来和 JavaScript 的原生数组方法（例如 `forEach` 和 `map`）保持一致。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出那些使用旧有参数顺序的示例。注意，如果你将你的 index 参数命名为一些不通用的名字（例如 <code>position</code> 或 <code>num</code>），迁移工具将不会把它们标记出来。</p>\n</div>\n{% endraw %}\n\n### `v-for` 遍历对象时的参数顺序 <sup>变更</sup>\n\n当包含 `key` 时，之前遍历对象的参数顺序是 `(key, value)`。现在是 `(value, key)`，来和常见的对象迭代器（例如 lodash）保持一致。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出那些使用旧有参数顺序的示例。注意，如果你将你的 key 参数命名为一些不通用的名字（例如 <code>name</code> 或 <code>property</code>），迁移工具将不会把它们标记出来。</p>\n</div>\n{% endraw %}\n\n### `$index` and `$key` <sup>移除</sup>\n\n已经移除了 `$index` 和 `$key` 这两个隐式声明变量，以便在 `v-for` 中显式定义。这可以使没有太多 Vue 开发经验的开发者更好地阅读代码，并且在处理嵌套循环时也能产生更清晰的行为。\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出使用这些移除变量的示例。如果你没有找到，也可以在<strong>控制台错误</strong>中查找（例如 <code>Uncaught ReferenceError: $index is not defined</code>）。</p>\n</div>\n{% endraw %}\n\n### `track-by` <sup>替换</sup>\n\n`track-by` 已经替换为 `key`，它的工作方式与其他属性一样，没有 `v-bind` 或者 `:` 前缀，它会被作为一个字符串处理。多数情况下，你需要使用具有完整表达式的动态绑定(dynamic binding)来替换静态的 key。例如，替换：\n\n``` html\n<div v-for=\"item in items\" track-by=\"id\">\n```\n\n你现在应该写为：\n\n``` html\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出那些使用<code>track-by</code>的示例。</p>\n</div>\n{% endraw %}\n\n### `v-for` 范围值 <sup>变更</sup>\n\n之前，`v-for=\"number in 10\"` 的 `number` 从 0 开始到 9 结束，现在从 1 开始，到 10 结束。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中使用正则 <code>/\\w+ in \\d+/</code>搜索。当出现在 <code>v-for</code> 中，请检查是否受到影响。</p>\n</div>\n{% endraw %}\n\n## Props\n\n### `coerce` Prop的参数 <sup>移除</sup>\n\n如果需要检查 prop 的值，创建一个内部的 computed 值，而不再在 props 内部去定义，例如：\n\n``` js\nprops: {\n  username: {\n    type: String,\n    coerce: function (value) {\n      return value\n        .toLowerCase()\n        .replace(/\\s+/, '-')\n    }\n  }\n}\n```\n\n现在应该写为：\n\n``` js\nprops: {\n  username: String,\n},\ncomputed: {\n  normalizedUsername: function () {\n    return this.username\n      .toLowerCase()\n      .replace(/\\s+/, '-')\n  }\n}\n```\n\n这样有一些好处：\n\n- 你可以对保持原始 prop 值的操作权限。\n- 通过给予验证后的值一个不同的命名，强制开发者使用显式申明。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出包含 <code>coerce</code> 选项的实例。</p>\n</div>\n{% endraw %}\n\n### `twoWay` Prop 的参数 <sup>移除</sup>\n\nProps 现在只能单项传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。详见：\n\n- [自定义组件事件](components.html#Custom-Events)\n- [自定义输入组件](components.html#Form-Input-Components-using-Custom-Events) (使用组件事件)\n- [全局状态管理](state-management.html)\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，找出含有 <code>twoWay</code> 参数的实例。</p>\n</div>\n{% endraw %}\n\n### `v-bind` 的 `.once`和`.sync` 修饰符 <sup>移除</sup>\n\nProps 现在只能单向传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。详见：\n\n- [自定义组件事件](components.html#Custom-Events)\n- [自定义输入组件](components.html#Form-Input-Components-using-Custom-Events) (使用组件事件)\n- [全局状态管理](state-management.html)\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>.once</code> 和 <code>.sync</code> 修饰符的实例。</p>\n</div>\n{% endraw %}\n\n### 修改 Props <sup>弃用</sup>\n\n组件内修改 prop 是反模式（不推荐的）的。比如，先声明一个 prop ，然后在组件中通过 `this.myProp = 'someOtherValue'` 改变 prop 的值。根据渲染机制，当父组件重新渲染时，子组件的内部 prop 值也将被覆盖。\n\n大多数情况下，改变 prop 值可以用以下选项替代：\n\n- 通过 data 属性，用prop去设置一个data属性的默认值。\n- 通过 computed 属性。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，查看关于 prop 修改的<strong>控制台警告信息</strong>。</p>\n</div>\n{% endraw %}\n\n### 根实例的 Props <sup>替换</sup>\n\n对于一个根实例来说 (比如：用 `new Vue({ ... })` 创建的实例)，只能用 `propsData` 而不是 `props` 。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，将会弹出 <strong>failed tests</strong> 来通知你使用 <code>props</code> 的根实例已经失效。</p>\n</div>\n{% endraw %}\n\n## Built-In 指令\n\n### `v-bind` 真/假值 <sup>变更</sup>\n\n在2.0中使用 `v-bind` 时，只有 `null`, `undefined` , 和 `false` 被看作是假。这意味着，`0` 和空字符串将被作为真值渲染。比如 `v-bind:draggable=\"''\"` 将被渲染为 `draggable=\"true\"`。\n\n对于枚举属性，除了以上假值之外，字符串 `\"false\"` 也会被渲染为 `attr=\"false\"`。\n\n<p class=\"tip\">注意，对于其它钩子函数 (如 `v-if` 和 `v-show`)， 他们依然遵循 js 对真假值判断的一般规则。</p>\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端到端测试，如果你app的任何部分有可能被这个升级影响到，将会弹出<strong>failed tests</strong></p>\n</div>\n{% endraw %}\n\n### 用 `v-on` 监听原生事件 <sup>变更</sup>\n\n  现在在组件上使用 `v-on` 只会监听自定义事件（组件用 `$emit` 触发的事件）。如果要监听根元素的原生事件，可以使用 `.native` 修饰符，比如：\n\n``` html\n<my-component v-on:click.native=\"doSomething\"></my-component>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，如果你app的任何部分有可能被这个升级影响到，将会弹出<strong>failed tests</strong> </p>\n</div>\n{% endraw %}\n\n### 带有 `debounce` 的 `v-model`<sup>移除</sup>\n\nDebouncing 曾经被用来控制 Ajax 请求及其它高耗任务的频率。 Vue 中`v-model`的 `debounce` 属性参数使得在一些简单情况下非常容易实现这种控制。但实际上，这是控制了 __状态更新__ 的频率，而不是控制高耗时任务本身。这是个微小的差别，但是会随着应用增长而显现出局限性。\n\n例如在设计一个搜索提示时的局限性：\n\n{% raw %}\n<script src=\"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js\"></script>\n<div id=\"debounce-search-demo\" class=\"demo\">\n  <input v-model=\"searchQuery\" placeholder=\"Type something\">\n  <strong>{{ searchIndicator }}</strong>\n</div>\n<script>\nnew Vue({\n  el: '#debounce-search-demo',\n  data: {\n    searchQuery: '',\n    searchQueryIsDirty: false,\n    isCalculating: false\n  },\n  computed: {\n    searchIndicator: function () {\n      if (this.isCalculating) {\n        return '⟳ Fetching new results'\n      } else if (this.searchQueryIsDirty) {\n        return '... Typing'\n      } else {\n        return '✓ Done'\n      }\n    }\n  },\n  watch: {\n    searchQuery: function () {\n      this.searchQueryIsDirty = true\n      this.expensiveOperation()\n    }\n  },\n  methods: {\n    expensiveOperation: _.debounce(function () {\n      this.isCalculating = true\n      setTimeout(function () {\n        this.isCalculating = false\n        this.searchQueryIsDirty = false\n      }.bind(this), 1000)\n    }, 500)\n  }\n})\n</script>\n{% endraw %}\n\n使用 `debounce` 参数，便无法观察 \"Typing\" 的状态。因为无法对输入状态进行实时检测。然而，通过将 `debounce` 与 Vue 解耦，可以仅仅只延迟我们想要控制的操作，从而避开这些局限性：\n\n``` html\n<!--\n通过使用lodash或者其它库的debounce函数，\n我们相信 debounce 实现是一流的，\n并且可以随处使用它，不仅仅是在模板中。\n-->\n<script src=\"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js\"></script>\n<div id=\"debounce-search-demo\">\n  <input v-model=\"searchQuery\" placeholder=\"Type something\">\n  <strong>{{ searchIndicator }}</strong>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#debounce-search-demo',\n  data: {\n    searchQuery: '',\n    searchQueryIsDirty: false,\n    isCalculating: false\n  },\n  computed: {\n    searchIndicator: function () {\n      if (this.isCalculating) {\n        return '⟳ Fetching new results'\n      } else if (this.searchQueryIsDirty) {\n        return '... Typing'\n      } else {\n        return '✓ Done'\n      }\n    }\n  },\n  watch: {\n    searchQuery: function () {\n      this.searchQueryIsDirty = true\n      this.expensiveOperation()\n    }\n  },\n  methods: {\n    // 这是 debounce 实现的地方。\n    expensiveOperation: _.debounce(function () {\n      this.isCalculating = true\n      setTimeout(function () {\n        this.isCalculating = false\n        this.searchQueryIsDirty = false\n      }.bind(this), 1000)\n    }, 500)\n  }\n})\n```\n\n这种方式的另外一个优点是：当包裹函数执行时间与延时时间相当时，将会等待较长时间。比如，当给出搜索建议时，要等待用户输入停止一段时间后才给出建议，这个体验非常差。其实，这时候更适合用 __throttling__ 函数。因为现在你可以自由的使用类似 lodash 之类的库，所以很快就可以用 throttling 重构项目。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>Upgrade Path</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出使用 <code>debounce</code> 参数的 实例。</p>\n</div>\n{% endraw %}\n\n### 使用 `lazy` 或者 `number` 参数的 `v-model` 。 <sup>替换</sup>\n\n`lazy` 和 `number` 参数现在以修饰符的形式使用，这样看起来更加清晰，而不是这样：\n\n``` html\n<input v-model=\"name\" lazy>\n<input v-model=\"age\" type=\"number\" number>\n```\n\n现在写成这样：\n\n``` html\n<input v-model.lazy=\"name\">\n<input v-model.number=\"age\" type=\"number\">\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到这些弃用参数。</p>\n</div>\n{% endraw %}\n\n### 使用内联 `value`的`v-model`  <sup>移除</sup>\n\n`v-model` 不再以内联 `value` 方式初始化的初值了，显然他将以实例的 data 相应的属性作为真正的初值。\n\n这意味着以下元素：\n\n``` html\n<input v-model=\"text\" value=\"foo\">\n```\n\n在data选项中有下面写法的：\n\n``` js\ndata: {\n  text: 'bar'\n}\n```\n\n将渲染 model 为 'bar' 而不是 'foo' 。同样，对 `<textarea>` 已有的值来说：\n\n``` html\n<textarea v-model=\"text\">\n  hello world\n</textarea>\n```\n\n必须保证 `text` 初值为 \"hello world\"\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>升级后运行端对端测试，注意关于<code>v-model</code>内联参数的 <strong>console warnings</strong></p>\n</div>\n{% endraw %}\n\n### `v-model` with `v-for` Iterated Primitive Values <sup>移除</sup>\n\n像这样的写法将失效：\n\n``` html\n<input v-for=\"str in strings\" v-model=\"str\">\n```\n\n因为 `<input>` 将被编译成类似下面的 js 代码：\n\n``` js\nstrings.map(function (str) {\n  return createElement('input', ...)\n})\n```\n\n这样，`v-model` 的双向绑定在这里就失效了。把 `str` 赋值给迭代器里的另一个值也没有用，因为它仅仅是函数内部的一个变量。\n\n替代方案是，你可以使用对象数组，这样`v-model` 就可以同步更新对象里面的字段了，例如：\n\n``` html\n<input v-for=\"obj in objects\" v-model=\"obj.str\">\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行测试，如果你的 app 有地方被这个更新影响到的话将会弹出<strong>failed tests</strong>提示。</p>\n</div>\n{% endraw %}\n\n### 带有 `!important` 的`v-bind:style`  <sup>移除</sup>\n\n这样写将失效：\n\n``` html\n<p v-bind:style=\"{ color: myColor + ' !important' }\">hello</p>\n```\n\n如果确实需要覆盖其它的 `!important`，最好用字符串形式去写：\n\n``` html\n<p v-bind:style=\"'color: ' + myColor + ' !important'\">hello</p>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\"> 迁移帮助工具。</a>找到含有 <code>!important</code> 的style绑定对象。</p>\n</div>\n{% endraw %}\n\n### `v-el` 和`v-ref` <sup>替换</sup>\n\n简单起见， `v-el` 和 `v-ref` 合并为一个 `ref` 属性了，可以在组件实例中通过 `$refs` 来调用。这意味着 `v-el:my-element` 将写成这样： `ref=\"myElement\"`， `v-ref:my-component` 变成了这样： `ref=\"myComponent\"`。绑定在一般元素上时，`ref` 指DOM元素，绑定在组件上时，`ref` 为一组件实例。\n因为 `v-ref` 不再是一个指令了而是一个特殊的属性，它也可以被动态定义了。这样在和`v-for` 结合的时候是很有用的：\n\n``` html\n<p v-for=\"item in items\" v-bind:ref=\"'item' + item.id\"></p>\n```\n\n以前 `v-el`/`v-ref` 和 `v-for` 一起使用将产生一个DOM数组或者组件数组，因为没法给每个元素一个特定名字。现在你还仍然可以这样做，给每个元素一个同样的`ref`：\n\n``` html\n<p v-for=\"item in items\" ref=\"items\"></p>\n```\n\n和 1.x 中不同， `$refs` 不是响应的，因为它们在渲染过程中注册/更新。只有监听变化并重复渲染才能使它们响应。\n\n另一方面，设计`$refs`主要是提供给 js 程序访问的，并不建议在模板中过度依赖使用它。因为这意味着在实例之外去访问实例状态，违背了 Vue 数据驱动的思想。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出实例中的 <code>v-el</code> 和 <code>v-ref</code> 。</p>\n</div>\n{% endraw %}\n\n### `v-show`后面使用`v-else` <sup>移除</sup>\n\n`v-else` 不能再跟在 `v-show`后面使用。请在`v-if`的否定分支中使用`v-show`来替代。例如：\n\n``` html\n<p v-if=\"foo\">Foo</p>\n<p v-else v-show=\"bar\">Not foo, but bar</p>\n```\n\n现在应该写出这样：\n\n``` html\n<p v-if=\"foo\">Foo</p>\n<p v-if=\"!foo && bar\">Not foo, but bar</p>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出实例中存在的 <code>v-else</code> 以及 <code>v-show</code>。</p>\n</div>\n{% endraw %}\n\n## 自定义指令 <sup>简化</sup>\n\n在新版中，指令的使用范围已经大大减小了：现在指令仅仅被用于低级的 DOM 操作。大多数情况下，最好是把模板作为代码复用的抽象层。\n\n显要的改变有如下几点：\n\n- 指令不再拥有实例。意思是，在指令的钩子函数中不再拥有实例的 `this` 。替代的是，你可以在参数中接受你需要的任何数据。如果确实需要，可以通过 `el` 来访问实例。\n- 类似 `acceptStatement` ，`deep` ， `priority` 等都已被弃用。为了替换`双向`指令，见 [示例](#Two-Way-Filters-deprecated)。\n- 现在有些钩子的意义和以前不一样了，并且多了两个钩子函数。\n\n幸运的是，新钩子更加简单，更加容易掌握。详见 [自定义指令指南](custom-directive.html)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到定义指令的地方。在 helper 工具会把这些地方标记出来，因为很有可能这些地方需要重构。</p>\n</div>\n{% endraw %}\n\n### 指令 `.literal` 修饰符 <sup>移除</sup>\n\n`.literal` 修饰符已经被移除，为了获取一样的功能，可以简单地提供字符串修饰符作为值。\n\n示例，如下更改：\n\n``` js\n<p v-my-directive.literal=\"foo bar baz\"></p>\n```\n\n只是：\n\n``` html\n<p v-my-directive=\"'foo bar baz'\"></p>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到实例中使用 `.literal` 修饰符的地方。</p>\n</div>\n{% endraw %}\n\n## 过渡\n\n### `transition` 参数 <sup>替换</sup>\n\nVue 的过渡系统有了彻底的改变，现在通过使用 `<transition>` 和 `<transition-group>` 来包裹元素实现过渡效果，而不再使用 `transition` 属性。详见 [Transitions guide](transitions.html)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。</p>\n</div>\n{% endraw %}\n\n### 可复用的过渡 `Vue.transition` <sup>替换</sup>\n\n在新的过渡系统中，可以[通过模板复用过渡效果](transitions.html#Reusable-Transitions)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。</p>\n</div>\n{% endraw %}\n\n### 过渡的 `stagger` 参数 <sup>移除</sup>\n\n如果希望在列表渲染中使用渐近过渡，可以通过设置元素的 `data-index` （或类似属性）来控制时间。 请参考[这个例子](transitions.html#Staggering-List-Transitions)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。升级期间，你可以“过渡”到新的过渡策略。</p>\n</div>\n{% endraw %}\n\n## 事件\n\n### `events` 选项 <sup>移除</sup>\n\n`events` 选项被弃用。事件处理器现在在 `created` 钩子中被注册。参考详细示例 [`$dispatch` and `$broadcast` 迁移指南](#dispatch-and-broadcast-deprecated)\n\n### `Vue.directive('on').keyCodes` <sup>替换</sup>\n\n新的简明配置 `keyCodes` 的方式是通过 `Vue.config.keyCodes`例如：\n\n``` js\n// v-on:keyup.f1 不可用\nVue.config.keyCodes.f1 = 112\n```\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到过时的 <code>keyCode</code> 配置</p>\n</div>\n{% endraw %}\n\n### `$dispatch` 和 `$broadcast` <sup>替换</sup>\n\n`$dispatch` 和 `$broadcast` 已经被弃用。请使用更多简明清晰的组件间通信和更好的状态管理方案，如：[Vuex](https://github.com/vuejs/vuex).\n\n因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。这种事件方式确实不太好，我们也不希望在以后让开发者们太痛苦。并且`$dispatch` 和 `$broadcast` 也没有解决兄弟组件间的通信问题。\n\n对于`$dispatch` 和 `$broadcast`最简单的升级方式就是：通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层。由于 Vue 实例实现了一个事件分发接口，你可以通过实例化一个空的 Vue 实例来实现这个目的。\n\n这些方法的最常见用途之一是父子组件的相互通信。在这些情况下，你可以使用 [`v-on`监听子组件上 $emit 的变化](components.html#Form-Input-Components-using-Custom-Events)。这可以允许你很方便的添加事件显性。\n\n然而，如果是跨多层父子组件通信的话， `$emit` 并没有什么用。相反，用集中式的事件中间件可以做到简单的升级。这会让组件之间的通信非常顺利，即使是兄弟组件。因为 Vue 通过事件发射器接口执行实例，实际上你可以使用一个空的 Vue 实例。\n\n比如，假设我们有个 todo 的应用结构如下：\n\n```\nTodos\n|-- NewTodoInput\n|-- Todo\n    |-- DeleteTodoButton\n```\n\n可以通过单独的事件中心管理组件间的通信：\n\n``` js\n// 将在各处使用该事件中心\n// 组件通过它来通信\nvar eventHub = new Vue()\n```\n\n然后在组件中，可以使用 `$emit`, `$on`, `$off` 分别来分发、监听、取消监听事件：\n\n``` js\n// NewTodoInput\n// ...\nmethods: {\n  addTodo: function () {\n    eventHub.$emit('add-todo', { text: this.newTodoText })\n    this.newTodoText = ''\n  }\n}\n```\n\n``` js\n// DeleteTodoButton\n// ...\nmethods: {\n  deleteTodo: function (id) {\n    eventHub.$emit('delete-todo', id)\n  }\n}\n```\n\n``` js\n// Todos\n// ...\ncreated: function () {\n  eventHub.$on('add-todo', this.addTodo)\n  eventHub.$on('delete-todo', this.deleteTodo)\n},\n// 最好在组件销毁前\n// 清除事件监听\nbeforeDestroy: function () {\n  eventHub.$off('add-todo', this.addTodo)\n  eventHub.$off('delete-todo', this.deleteTodo)\n},\nmethods: {\n  addTodo: function (newTodo) {\n    this.todos.push(newTodo)\n  },\n  deleteTodo: function (todoId) {\n    this.todos = this.todos.filter(function (todo) {\n      return todo.id !== todoId\n    })\n  }\n}\n```\n\n在简单的情况下这样做可以替代 `$dispatch` 和 `$broadcast`，但是对于大多数复杂情况，更推荐使用一个专用的状态管理层如：[Vuex](https://github.com/vuejs/vuex) 。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出使用 <code>$dispatch</code> 和 <code>$broadcast</code>的实例。</p>\n</div>\n{% endraw %}\n\n## 过滤器\n\n### 插入文本之外的过滤器 <sup>移除</sup>\n\n现在过滤器只能用在插入文本中 (`{% raw %}{{ }}{% endraw %}` tags)。我们发现在指令（如：`v-model`， `v-on`等）中使用过滤器使事情变得更复杂。像`v-for` 这样的列表过滤器最好把处理逻辑作为一个计算属性放在js里面，这样就可以在整个模板中复用。\n\n总之，能在原生js中实现的东西，我们尽量避免引入一个新的符号去重复处理同样的问题。下面是如何替换 Vue 内置过滤器：\n\n#### 替换 `debounce` 过滤器\n\n不再这样写\n\n``` html\n<input v-on:keyup=\"doStuff | debounce 500\">\n```\n\n``` js\nmethods: {\n  doStuff: function () {\n    // ...\n  }\n}\n```\n\n请使用 [lodash's `debounce`](https://lodash.com/docs/4.15.0#debounce) (也有可能是 [`throttle`](https://lodash.com/docs/4.15.0#throttle)) 来直接控制高耗任务。可以这样来实现上面的功能：\n\n``` html\n<input v-on:keyup=\"doStuff\">\n```\n\n``` js\nmethods: {\n  doStuff: _.debounce(function () {\n    // ...\n  }, 500)\n}\n```\n\n这种写法的更多优点详见： [`v-model` 示例](#debounce-Param-Attribute-for-v-model-removed).\n\n#### 替换 `limitBy` 过滤器\n\n不再这样写：\n\n``` html\n<p v-for=\"item in items | limitBy 10\">{{ item }}</p>\n```\n\n在 computed 属性中使用js内置方法： [`.slice` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples)：\n\n``` html\n<p v-for=\"item in filteredItems\">{{ item }}</p>\n```\n\n``` js\ncomputed: {\n  filteredItems: function () {\n    return this.items.slice(0, 10)\n  }\n}\n```\n\n#### 替换 `filterBy` 过滤器\n\n不再这样写：\n\n``` html\n<p v-for=\"user in users | filterBy searchQuery in 'name'\">{{ user.name }}</p>\n```\n\n在 computed 属性中使用js内置方法 [`.filter` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples)：\n\n``` html\n<p v-for=\"user in filteredUsers\">{{ user.name }}</p>\n```\n\n``` js\ncomputed: {\n  filteredUsers: function () {\n    var self = this\n    return self.users.filter(function (user) {\n      return user.name.indexOf(self.searchQuery) !== -1\n    })\n  }\n}\n```\n\njs原生的 `.filter` 同样能实现很多复杂的过滤器操作，因为可以在计算 computed 属性中使用所有js方法。比如，想要通过匹配用户名字和电子邮箱地址（不区分大小写）找到用户：\n\n``` js\nvar self = this\nself.users.filter(function (user) {\n  var searchRegex = new RegExp(self.searchQuery, 'i')\n  return user.isActive && (\n    searchRegex.test(user.name) ||\n    searchRegex.test(user.email)\n  )\n})\n```\n\n#### 替换 `orderBy` 过滤器\n\n不这样写：\n\n``` html\n<p v-for=\"user in users | orderBy 'name'\">{{ user.name }}</p>\n```\n\n而是在 computed 属性中使用 [lodash's `orderBy`](https://lodash.com/docs/4.15.0#orderBy) (或者可能是 [`sortBy`](https://lodash.com/docs/4.15.0#sortBy))：\n\n``` html\n<p v-for=\"user in orderedUsers\">{{ user.name }}</p>\n```\n\n``` js\ncomputed: {\n  orderedUsers: function () {\n    return _.orderBy(this.users, 'name')\n  }\n}\n```\n\n甚至可以字段排序：\n\n``` js\n_.orderBy(this.users, ['name', 'last_login'], ['asc', 'desc'])\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到指令中使用的过滤器。如果有些没找到，看看<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### 过滤器参数符号 <sup>变更</sup>\n\n现在过滤器参数形式可以更好地与js函数调用方式一致，因此不用再用空格分隔参数：\n\n``` html\n<p>{{ date | formatDate 'YY-MM-DD' timeZone }}</p>\n```\n\n现在用圆括号括起来并用逗号分隔：\n\n``` html\n<p>{{ date | formatDate('YY-MM-DD', timeZone) }}</p>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到老式的调用符号，如果有遗漏，请看<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### 内置文本过滤器 <sup>移除</sup>\n\n尽管插入文本内部的过滤器依然有效，但是所有内置过滤器已经移除了。取代的是，推荐在每个区域使用更专业的库来解决。(比如用 [`date-fns`](https://date-fns.org/) 来格式化日期，用 [`accounting`](http://openexchangerates.github.io/accounting.js/) 来格式化货币)。\n\n对于每个内置过滤器，我们大概总结了下该怎么替换。代码示例可能写在自定义 helper 函数，方法或计算属性中。\n\n#### 替换 `json` 过滤器\n\n不用一个个改，因为Vue已经帮你自动格式化好了，无论是字符串，数字还是数组，对象。如果想用js的 `JSON.stringify` 功能去实现，你也可以把它写在方法或者计算属性里面。\n\n#### 替换 `capitalize` 过滤器\n\n``` js\ntext[0].toUpperCase() + text.slice(1)\n```\n\n#### 替换 `uppercase` 过滤器\n\n``` js\ntext.toUpperCase()\n```\n\n#### 替换 `lowercase` 过滤器\n\n``` js\ntext.toLowerCase()\n```\n\n#### 替换 `pluralize` 过滤器\n\nNPM 上的 [pluralize](https://www.npmjs.com/package/pluralize) 库可以很好的实现这个功能。如果仅仅想将特定的词格式化成复数形式或者想给特定的值（'0'）指定特定的输出，也可以很容易地自定义复数格式化过滤器：\n\n``` js\nfunction pluralizeKnife (count) {\n  if (count === 0) {\n    return 'no knives'\n  } else if (count === 1) {\n    return '1 knife'\n  } else {\n    return count + 'knives'\n  }\n}\n```\n\n#### Replacing the `currency` Filter\n\n对于简单的问题,可以这样做：\n\n``` js\n'$' + price.toFixed(2)\n```\n\n大多数情况下，仍然会有奇怪的现象(比如 `0.035.toFixed(2)` 向上取舍得到 `0.04`,但是 `0.045` 向下取舍却也得到 `0.04`)。解决这些问题可以使用 [`accounting`](http://openexchangerates.github.io/accounting.js/) 库来实现更多可靠的货币格式化。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到舍弃的过滤器。如果有些遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### Two-Way Filters <sup>replaced</sup>\n\nSome users have enjoyed using two-way filters with `v-model` to create interesting inputs with very little code. While _seemingly_ simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs.\n\nAs an example, we'll now walk the migration of a two-way currency filter:\n\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/6744xnjk/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nIt mostly works well, but the delayed state updates can cause strange behavior. For example, click on the `Result` tab and try entering `9.999` into one of those inputs. When the input loses focus, its value will update to `$10.00`. When looking at the calculated total however, you'll see that `9.999` is what's stored in our data. The version of reality that the user sees is out of sync!\n\nTo start transitioning towards a more robust solution using Vue 2.0, let's first wrap this filter in a new `<currency-input>` component:\n\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/943zfbsh/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nThis allows us add behavior that a filter alone couldn't encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external [`currencyValidator` object](https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e):\n\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/9c32kev2/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nThis increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:\n\n- unit tested in isolation from your Vue code\n- used by other parts of your application, such as to validate the payload to an API endpoint\n\nHaving this validator extracted out, we've also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it's actually impossible for users to enter anything wrong, similar to what the browser's native number input tries to do.\n\nWe're still limited however, by filters and by Vue 1.0 in general, so let's complete the upgrade to Vue 2.0:\n\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nYou may notice that:\n\n- Every aspect of our input is more explicit, using lifecycle hooks and DOM events in place of the hidden behavior of two-way filters.\n- We can now use `v-model` directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.\n- Since we're no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice.\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>Upgrade Path</h4>\n  <p>Run the<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>on your codebase to find examples of filters used in directives like <code>v-model</code>. If you miss any, you should also see <strong>console errors</strong>.</p>\n</div>\n{% endraw %}\n\n## Slots\n\n### 重名的 Slots <sup>移除</sup>\n\n同一模板中的重名 `<slot>` 已经弃用。当一个 slot 已经被渲染过了，那么就不能在同一模板其它地方被再次渲染了。如果要在不同位置渲染同一内容，可一用prop来传递。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>更新后运行测试，查看 <strong>控制台警告信息</strong> 关于重名slots的提示 <code>v-model</code>。</p>\n</div>\n{% endraw %}\n\n### `slot` 样式参数 <sup>移除</sup>\n\n通过具名 `<slot>` 插入的片段不再保持 `slot` 的参数。请用一个包裹元素来控制样式。或者用更高级方法：通过编程方式修改内容 ：[render functions](render-function.html) 。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到选择slots标签CSS选择器(例如： <code>[slot=\"my-slot-name\"]</code>) 。</p>\n</div>\n{% endraw %}\n\n## 特殊属性\n\n### `keep-alive` 属性 <sup>替换</sup>\n\n`keep-alive` 不再是一个特殊属性而是一个包裹组件，类似于  `<transition>`比如：\n\n``` html\n<keep-alive>\n  <component v-bind:is=\"view\"></component>\n</keep-alive>\n```\n\n这样可以在含多种状态子组件中使用 `<keep-alive>` ：\n\n``` html\n<keep-alive>\n  <todo-list v-if=\"todos.length > 0\"></todo-list>\n  <no-todos-gif v-else></no-todos-gif>\n</keep-alive>\n```\n\n<p class=\"tip\">当 `<keep-alive>` 含有不同子组件时，应该分别影响到每一个子组件。不仅是第一个而是所有的子组件都将被忽略。</p>\n\n和 `<transition>`一起使用时，确保把内容包裹在内：\n\n``` html\n<transition>\n  <keep-alive>\n    <component v-bind:is=\"view\"></component>\n  </keep-alive>\n</transition>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到<code>keep-alive</code> 属性。</p>\n</div>\n{% endraw %}\n\n## 计算插值todaymark\n\n### 属性内部的计算插值 <sup>移除</sup>\n\n属性内部的计算插值已经不能再使用了：\n\n``` html\n<button class=\"btn btn-{{ size }}\"></button>\n```\n\n应该写成行内表达式：\n\n``` html\n<button v-bind:class=\"'btn btn-' + size\"></button>\n```\n\n或者计算属性：\n\n``` html\n<button v-bind:class=\"buttonClasses\"></button>\n```\n\n``` js\ncomputed: {\n  buttonClasses: function () {\n    return 'btn btn-' + size\n  }\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到属性内部的计算插值</p>\n</div>\n{% endraw %}\n\n### HTML 计算插值 <sup>移除</sup>\n\nHTML 的计算插值 (`{% raw %}{{{ foo }}}{% endraw %}`) 已经移除，取代的是 [`v-html` 指令](../api/#v-html).\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 HTML 计算插值。</p>\n</div>\n{% endraw %}\n\n### 单次绑定<sup>替换</sup>\n\n单次绑定 (`{% raw %}{{* foo }}{% endraw %}`) 已经被新的 [`v-once` directive](../api/#v-once) 取代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到单次绑定使用位置。</p>\n</div>\n{% endraw %}\n\n## 响应\n\n### `vm.$watch` <sup>changed</sup>\n\n通过 `vm.$watch`创建的观察器现在将在组件渲染时被激活。这样可以让你在组件渲染前更新状态，不用做不必要的更新。比如可以通过观察组件的prop变化来更新组件本身的值。\n\n如果以前通过 `vm.$watch` 在组件更新后与 DOM 交互，现在就可以通过`updated`生命周期钩子来做这些。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行测试，如果有依赖于老方法的观察器将弹出 <strong>failed tests</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$set` <sup>变更</sup>\n\n `vm.$set` 只是 [`Vue.set`](../api/#Vue-set) 的别名。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到过时的用法</p>\n</div>\n{% endraw %}\n\n### `vm.$delete` <sup>变更</sup>\n\n`vm.$delete` 现在只是： [`Vue.delete`](../api/#Vue-delete) 别名。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到过时的用法</p>\n</div>\n{% endraw %}\n\n### `Array.prototype.$set`  <sup>弃用</sup>\n\n用 `Vue.set` 替代\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到数组上的<code>.$set</code>。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `Array.prototype.$remove` <sup>移除</sup>\n\n用 `Array.prototype.splice` 替代，例如：\n\n``` js\nmethods: {\n  removeTodo: function (todo) {\n    var index = this.todos.indexOf(todo)\n    this.todos.splice(index, 1)\n  }\n}\n```\n\n或者更好的方法，直接给除去的方法一个index参数：\n\n``` js\nmethods: {\n  removeTodo: function (index) {\n    this.todos.splice(index, 1)\n  }\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到数组上的<code>.$remove</code>。如有遗漏请参考<strong>控制台错误信息</strong></p>\n</div>\n{% endraw %}\n\n### Vue实例上的`Vue.set` 和 `Vue.delete`<sup>移除</sup>\n\n`Vue.set` 和 `Vue.delete` 在实例上将不再起作用。现在都强制在实例的data选项中声明所有顶级响应值。如果删除实例属性或实例`$data`上的某个值，直接将它设置为null即可。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到实例中的 <code>Vue.set</code> 或 <code>Vue.delete</code> 。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### 替换 `vm.$data` <sup>移除</sup>\n\n现在禁止替换实例的 $data。这样防止了响应系统的一些极端情况并且让组件状态更加可控可预测（特别是对于存在类型检查的系统）。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到覆盖 <code>vm.$data</code >的位置。如有遗漏请参考<strong>控制台警告信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$get` <sup>移除</sup>\n\n可以直接取回响应数据。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$get</code> 的位置。如有遗漏请参考 <strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n## 围绕 DOM 的实例方法\n\n### `vm.$appendTo` <sup>移除</sup>\n\n使用 DOM 原生方法:\n\n``` js\nmyElement.appendChild(vm.$el)\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$appendTo</code> 的位置。如果有遗漏可以参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$before` <sup>移除</sup>\n\n使用 DOM 原生方法：\n\n``` js\nmyElement.parentNode.insertBefore(vm.$el, myElement)\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$before</code>。如有遗漏，请参考 <strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$after` <sup>移除</sup>\n\n使用 DOM 原生方法：\n\n``` js\nmyElement.parentNode.insertBefore(vm.$el, myElement.nextSibling)\n```\n\n如果 `myElement` 是最后一个节点也可以这样写：\n\n``` js\nmyElement.parentNode.appendChild(vm.$el)\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$after</code> 的位置。如有遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$remove` <sup>移除</sup>\n\n使用 DOM 原生方法：\n\n``` js\nvm.$el.remove()\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到<code>vm.$remove</code>。如有遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n## 底层实例方法\n\n### `vm.$eval` <sup>移除</sup>\n\n尽量不要使用，如果必须使用该功能并且不肯定如何使用请参考 [the forum](http://forum.vuejs.org/)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>vm.$eval</code> 的位置。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$interpolate` <sup>移除</sup>\n\n尽量不要使用，如果必须使用该功能并且不肯定如何使用请参考 [the forum](http://forum.vuejs.org/)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到<code>vm.$interpolate</code>。如有遗漏请参考<strong>控制台错误信息</strong>.</p>\n</div>\n{% endraw %}\n\n### `vm.$log` <sup>移除</sup>\n\n请使用 [Vue Devtools](https://github.com/vuejs/vue-devtools) 感受最佳debug体验。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$log</code>。如有遗漏请参考<strong>控制台错误信息</strong>.</p>\n</div>\n{% endraw %}\n\n## 实例 DOM 选项\n\n### `replace: false` <sup>移除</sup>\n\n现在组件总是会替换掉他们被绑定的元素。为了模仿`replace: false`的行为，可以用一个和将要替换元素类似的元素将根组件包裹起来：\n\n``` js\nnew Vue({\n  el: '#app',\n  template: '<div id=\"app\"> ... </div>'\n})\n```\n\n或者使用渲染函数：\n\n``` js\nnew Vue({\n  el: '#app',\n  render: function (h) {\n    h('div', {\n      attrs: {\n        id: 'app',\n      }\n    }, /* ... */)\n  }\n})\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>replace: false</code>使用的位置。</p>\n</div>\n{% endraw %}\n\n## 全局配置\n\n### `Vue.config.debug` <sup>移除</sup>\n\n不再需要，因为警告信息将默认在堆栈信息里输出。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到包含<code>Vue.config.debug</code>的地方。</p>\n</div>\n{% endraw %}\n\n### `Vue.config.async` <sup>移除</sup>\n\n异步操作现在需要渲染性能的支持。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用<code>Vue.config.async</code>的实例。</p>\n</div>\n{% endraw %}\n\n### `Vue.config.delimiters` <sup>替换</sup>\n\n以 [模板选项](../api/#delimiters)的方式使用。这样可以在使用自定义分隔符时避免影响第三方模板。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用<code>Vue.config.delimiters</code>的实例。</p>\n</div>\n{% endraw %}\n\n### `Vue.config.unsafeDelimiters` <sup>移除</sup>\n\nHTML 插入 [替换为 `v-html`](#HTML-Interpolation-removed).\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>Vue.config.unsafeDelimiters</code>。然后 helper 工具也会找到HTML插入的实例，可以用`v-html`来替换。</p>\n</div>\n{% endraw %}\n\n## 全局 API\n\n### 带 `el` 的 `Vue.extend` <sup>移除</sup>\n\nel 选项不再在 `Vue.extend`中使用。仅在实例创建参数中可用。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>更新后运行测试在<strong>控制台警告信息</strong>中找到关于带有<code>Vue.extend</code>的<code>el</code>。</p>\n</div>\n{% endraw %}\n\n### `Vue.elementDirective` <sup>移除</sup>\n\n用组件来替代\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到包含<code>Vue.elementDirective</code>的实例。</p>\n</div>\n{% endraw %}\n\n### `Vue.partial` <sup>移除</sup>\n\nPartials 已被移除,取而代之的是更明确的组件之间的数据流--props。除非你正在使用一个部分性能关键型区域，否则建议只使用一个[normal component](components.html)来代替。如果你是动态绑定部分的`name`,您可以使用[dynamic component](components.html#Dynamic-Components)。\n\n\n如果你碰巧在你的应用程序的性能关键部分使用`partials`，那么你应该升级到[functional components](render-function.html#Functional-Components)。它们必须在纯JS / JSX文件中（而不是在`.vue`文件中），并且是无状态的和无实例的，就像`partials`。这使得渲染极快。\n\n`functional components`相对于`partials`一个好处是它们可以更具动态性，因为它们允许您访问JavaScript的全部功能。然而，这是有成本的。如果你从来没有使用过渲染式的组件框架，你可能需要花费更长的时间来学习它们。\n\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到包含 <code>Vue.partial</code>的实例</p>\n</div>\n{% endraw %}\n\n***\n\n> 原文： http:/   /vuejs.org/guide/migration.html\n\n***\n","source":"v2/guide/migration.md","raw":"---\ntitle: 从 Vue 1.x 迁移\ntype: guide\norder: 25\n---\n\n## FAQ\n\n> 哇，非常长的一页！是否意味着 Vue 2.0 已经完全不同了呢，是否需要从头学起呢，Vue 1.0 的项目是不是没法迁移了？\n\n非常开心地告诉你，并不是！几乎 90% 的 API 和核心概念都没有变。因为本节包含了很多详尽的阐述以及许多迁移的例子，所以显得有点长。不用担心，__你不必从头到尾把本节读一遍！__\n\n> 我该从哪里开始项目迁移呢？\n\n1. 首先，在当前项目下运行[迁移工具](https://github.com/vuejs/vue-migration-helper)。我们非常谨慎地把高级 Vue 升级过程简化为使用一个简单的命令行工具。当工具识别出旧有的特性后，就会告知你并给出建议，同时附上关于详细信息的链接。\n\n2. 然后，浏览本页面的侧边栏列出的内容。如果发现有的标题对你的项目有影响，但是迁移工具没有给出提示，请检查自己的项目。\n\n3. 如果你的项目有测试代码，运行并查看仍然失败的地方。如果没有测试代码，在浏览器中打开你的程序，通过导航环顾并留意那些报错或警告信息。\n\n4. 现在，你的应用程序应该已彻底完成迁移。如果你渴望了解更多，可以阅读本页面剩余部分 - 或者从[介绍](index.html)部分，从头开始深入新的文档和改进过的指南。由于你已经熟悉一些核心概念，所以许多部分已经被删除掉。\n\n> 将 Vue 1.x 版本的应用程序迁移到 2.0 要花多长时间？\n\n这取决于几个因素：\n\n- 取决于你应用程序的规模（中小型的基本上一天内就可以搞定）。\n\n- 取决于你分心和开始 2.0 最酷的新功能的次数。 😉 &nbsp;无法判断时间，我们构建 2.0 应用的时候也经常发生这种事！\n\n- 取决于你使用了哪些旧有的特性。大部分可以通过查找和替换(find-and-replace)来实现升级，但有一些可能还是要花点时间。如果你没有遵循最佳实践，Vue 2.0 会尽力强迫你去遵循。这有利于项目的长期运行，但也可能意味着重大重构（尽管有些需要重构的部分可能已经过时）。\n\n> 如果我升级到到 Vue 2 ，我还必须同时升级 Vuex 和 Vue-Router？\n\n只有 Vue-Router 2 与 Vue 2 保持兼容，所以 Vue-Router 是需要升级的，你必须遵循 [Vue-Router 迁移方式](migration-vue-router.html)来处理。幸运的是， 大多数应用没有很多 router 相关代码，所以迁移可能不会超过一个小时。\n\n对于 Vuex ，版本 0.8+ 与 Vue 2 保持兼容，所以部分不必强制升级。可以促使你立即升级的唯一理由，是你想要使用那些 Vuex 2 中新的高级特性，比如模块(modules)和减少的样板文件(reduced boilerplate)。\n\n## 模板\n\n### 片段实例 <sup>移除</sup>\n\n每个组件必须只有一个根元素。不再允许片段实例，如果你有这样的模板：\n\n``` html\n<p>foo</p>\n<p>bar</p>\n```\n\n最好把整个内容都简单包裹到一个新的元素里，如下所示：\n\n``` html\n<div>\n  <p>foo</p>\n  <p>bar</p>\n</div>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>升级后运行端到端测试套件(end-to-end test suite)或运行应用程序，并查看<strong>控制台警告(console warnings)</strong>来找出那些模板中有多个根元素的地方。\n</div>\n{% endraw %}\n\n## 生命周期钩子函数\n\n### `beforeCompile` <sup>移除</sup>\n\n使用 `created` 钩子函数替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n### `compiled` <sup>替换</sup>\n\n使用 `mounted` 钩子函数替代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n### `attached` <sup>移除</sup>\n\n使用其他钩子函数内置的 DOM 检测(DOM check)方法。例如，替换如下：\n\n``` js\nattached: function () {\n  doSomething()\n}\n```\n\n可以这样使用：\n\n``` js\nmounted: function () {\n  this.$nextTick(function () {\n    doSomething()\n  })\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n### `detached` <sup>移除</sup>\n\n使用其他钩子函数内的 DOM 检测(DOM check)方法。例如，替换如下：\n\n``` js\ndetached: function () {\n  doSomething()\n}\n```\n\n可以这样使用：\n\n``` js\ndestroyed: function () {\n  this.$nextTick(function () {\n    doSomething()\n  })\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n### `init` <sup>重新命名</sup>\n\n使用新的 `beforeCreate` 钩子函数替代，本质上 beforeCreate 和 init 完全相同。init 被重新命名是为了和其他的生命周期方法的命名方式保持一致。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n### `ready` <sup>替换</sup>\n\n使用新的 `mounted` 钩子函数替代。应该注意的是，使用 `mounted` 并不能保证钩子函数中的 this.$el 在 document 中。为此还应该引入 `Vue.nextTick`/`vm.$nextTick`。例如：\n\n``` js\nmounted: function () {\n  this.$nextTick(function () {\n    // 代码保证 this.$el 在 document 中\n  })\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n{% endraw %}\n\n## `v-for`\n\n### `v-for` 遍历数组时的参数顺序 <sup>变更</sup>\n\n当包含 `index` 时，之前遍历数组时的参数顺序是 `(index, value)`。现在是 `(value, index)` ，来和 JavaScript 的原生数组方法（例如 `forEach` 和 `map`）保持一致。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出那些使用旧有参数顺序的示例。注意，如果你将你的 index 参数命名为一些不通用的名字（例如 <code>position</code> 或 <code>num</code>），迁移工具将不会把它们标记出来。</p>\n</div>\n{% endraw %}\n\n### `v-for` 遍历对象时的参数顺序 <sup>变更</sup>\n\n当包含 `key` 时，之前遍历对象的参数顺序是 `(key, value)`。现在是 `(value, key)`，来和常见的对象迭代器（例如 lodash）保持一致。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出那些使用旧有参数顺序的示例。注意，如果你将你的 key 参数命名为一些不通用的名字（例如 <code>name</code> 或 <code>property</code>），迁移工具将不会把它们标记出来。</p>\n</div>\n{% endraw %}\n\n### `$index` and `$key` <sup>移除</sup>\n\n已经移除了 `$index` 和 `$key` 这两个隐式声明变量，以便在 `v-for` 中显式定义。这可以使没有太多 Vue 开发经验的开发者更好地阅读代码，并且在处理嵌套循环时也能产生更清晰的行为。\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出使用这些移除变量的示例。如果你没有找到，也可以在<strong>控制台错误</strong>中查找（例如 <code>Uncaught ReferenceError: $index is not defined</code>）。</p>\n</div>\n{% endraw %}\n\n### `track-by` <sup>替换</sup>\n\n`track-by` 已经替换为 `key`，它的工作方式与其他属性一样，没有 `v-bind` 或者 `:` 前缀，它会被作为一个字符串处理。多数情况下，你需要使用具有完整表达式的动态绑定(dynamic binding)来替换静态的 key。例如，替换：\n\n``` html\n<div v-for=\"item in items\" track-by=\"id\">\n```\n\n你现在应该写为：\n\n``` html\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出那些使用<code>track-by</code>的示例。</p>\n</div>\n{% endraw %}\n\n### `v-for` 范围值 <sup>变更</sup>\n\n之前，`v-for=\"number in 10\"` 的 `number` 从 0 开始到 9 结束，现在从 1 开始，到 10 结束。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中使用正则 <code>/\\w+ in \\d+/</code>搜索。当出现在 <code>v-for</code> 中，请检查是否受到影响。</p>\n</div>\n{% endraw %}\n\n## Props\n\n### `coerce` Prop的参数 <sup>移除</sup>\n\n如果需要检查 prop 的值，创建一个内部的 computed 值，而不再在 props 内部去定义，例如：\n\n``` js\nprops: {\n  username: {\n    type: String,\n    coerce: function (value) {\n      return value\n        .toLowerCase()\n        .replace(/\\s+/, '-')\n    }\n  }\n}\n```\n\n现在应该写为：\n\n``` js\nprops: {\n  username: String,\n},\ncomputed: {\n  normalizedUsername: function () {\n    return this.username\n      .toLowerCase()\n      .replace(/\\s+/, '-')\n  }\n}\n```\n\n这样有一些好处：\n\n- 你可以对保持原始 prop 值的操作权限。\n- 通过给予验证后的值一个不同的命名，强制开发者使用显式申明。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出包含 <code>coerce</code> 选项的实例。</p>\n</div>\n{% endraw %}\n\n### `twoWay` Prop 的参数 <sup>移除</sup>\n\nProps 现在只能单项传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。详见：\n\n- [自定义组件事件](components.html#Custom-Events)\n- [自定义输入组件](components.html#Form-Input-Components-using-Custom-Events) (使用组件事件)\n- [全局状态管理](state-management.html)\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，找出含有 <code>twoWay</code> 参数的实例。</p>\n</div>\n{% endraw %}\n\n### `v-bind` 的 `.once`和`.sync` 修饰符 <sup>移除</sup>\n\nProps 现在只能单向传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。详见：\n\n- [自定义组件事件](components.html#Custom-Events)\n- [自定义输入组件](components.html#Form-Input-Components-using-Custom-Events) (使用组件事件)\n- [全局状态管理](state-management.html)\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>.once</code> 和 <code>.sync</code> 修饰符的实例。</p>\n</div>\n{% endraw %}\n\n### 修改 Props <sup>弃用</sup>\n\n组件内修改 prop 是反模式（不推荐的）的。比如，先声明一个 prop ，然后在组件中通过 `this.myProp = 'someOtherValue'` 改变 prop 的值。根据渲染机制，当父组件重新渲染时，子组件的内部 prop 值也将被覆盖。\n\n大多数情况下，改变 prop 值可以用以下选项替代：\n\n- 通过 data 属性，用prop去设置一个data属性的默认值。\n- 通过 computed 属性。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，查看关于 prop 修改的<strong>控制台警告信息</strong>。</p>\n</div>\n{% endraw %}\n\n### 根实例的 Props <sup>替换</sup>\n\n对于一个根实例来说 (比如：用 `new Vue({ ... })` 创建的实例)，只能用 `propsData` 而不是 `props` 。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，将会弹出 <strong>failed tests</strong> 来通知你使用 <code>props</code> 的根实例已经失效。</p>\n</div>\n{% endraw %}\n\n## Built-In 指令\n\n### `v-bind` 真/假值 <sup>变更</sup>\n\n在2.0中使用 `v-bind` 时，只有 `null`, `undefined` , 和 `false` 被看作是假。这意味着，`0` 和空字符串将被作为真值渲染。比如 `v-bind:draggable=\"''\"` 将被渲染为 `draggable=\"true\"`。\n\n对于枚举属性，除了以上假值之外，字符串 `\"false\"` 也会被渲染为 `attr=\"false\"`。\n\n<p class=\"tip\">注意，对于其它钩子函数 (如 `v-if` 和 `v-show`)， 他们依然遵循 js 对真假值判断的一般规则。</p>\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端到端测试，如果你app的任何部分有可能被这个升级影响到，将会弹出<strong>failed tests</strong></p>\n</div>\n{% endraw %}\n\n### 用 `v-on` 监听原生事件 <sup>变更</sup>\n\n  现在在组件上使用 `v-on` 只会监听自定义事件（组件用 `$emit` 触发的事件）。如果要监听根元素的原生事件，可以使用 `.native` 修饰符，比如：\n\n``` html\n<my-component v-on:click.native=\"doSomething\"></my-component>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，如果你app的任何部分有可能被这个升级影响到，将会弹出<strong>failed tests</strong> </p>\n</div>\n{% endraw %}\n\n### 带有 `debounce` 的 `v-model`<sup>移除</sup>\n\nDebouncing 曾经被用来控制 Ajax 请求及其它高耗任务的频率。 Vue 中`v-model`的 `debounce` 属性参数使得在一些简单情况下非常容易实现这种控制。但实际上，这是控制了 __状态更新__ 的频率，而不是控制高耗时任务本身。这是个微小的差别，但是会随着应用增长而显现出局限性。\n\n例如在设计一个搜索提示时的局限性：\n\n{% raw %}\n<script src=\"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js\"></script>\n<div id=\"debounce-search-demo\" class=\"demo\">\n  <input v-model=\"searchQuery\" placeholder=\"Type something\">\n  <strong>{{ searchIndicator }}</strong>\n</div>\n<script>\nnew Vue({\n  el: '#debounce-search-demo',\n  data: {\n    searchQuery: '',\n    searchQueryIsDirty: false,\n    isCalculating: false\n  },\n  computed: {\n    searchIndicator: function () {\n      if (this.isCalculating) {\n        return '⟳ Fetching new results'\n      } else if (this.searchQueryIsDirty) {\n        return '... Typing'\n      } else {\n        return '✓ Done'\n      }\n    }\n  },\n  watch: {\n    searchQuery: function () {\n      this.searchQueryIsDirty = true\n      this.expensiveOperation()\n    }\n  },\n  methods: {\n    expensiveOperation: _.debounce(function () {\n      this.isCalculating = true\n      setTimeout(function () {\n        this.isCalculating = false\n        this.searchQueryIsDirty = false\n      }.bind(this), 1000)\n    }, 500)\n  }\n})\n</script>\n{% endraw %}\n\n使用 `debounce` 参数，便无法观察 \"Typing\" 的状态。因为无法对输入状态进行实时检测。然而，通过将 `debounce` 与 Vue 解耦，可以仅仅只延迟我们想要控制的操作，从而避开这些局限性：\n\n``` html\n<!--\n通过使用lodash或者其它库的debounce函数，\n我们相信 debounce 实现是一流的，\n并且可以随处使用它，不仅仅是在模板中。\n-->\n<script src=\"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js\"></script>\n<div id=\"debounce-search-demo\">\n  <input v-model=\"searchQuery\" placeholder=\"Type something\">\n  <strong>{{ searchIndicator }}</strong>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#debounce-search-demo',\n  data: {\n    searchQuery: '',\n    searchQueryIsDirty: false,\n    isCalculating: false\n  },\n  computed: {\n    searchIndicator: function () {\n      if (this.isCalculating) {\n        return '⟳ Fetching new results'\n      } else if (this.searchQueryIsDirty) {\n        return '... Typing'\n      } else {\n        return '✓ Done'\n      }\n    }\n  },\n  watch: {\n    searchQuery: function () {\n      this.searchQueryIsDirty = true\n      this.expensiveOperation()\n    }\n  },\n  methods: {\n    // 这是 debounce 实现的地方。\n    expensiveOperation: _.debounce(function () {\n      this.isCalculating = true\n      setTimeout(function () {\n        this.isCalculating = false\n        this.searchQueryIsDirty = false\n      }.bind(this), 1000)\n    }, 500)\n  }\n})\n```\n\n这种方式的另外一个优点是：当包裹函数执行时间与延时时间相当时，将会等待较长时间。比如，当给出搜索建议时，要等待用户输入停止一段时间后才给出建议，这个体验非常差。其实，这时候更适合用 __throttling__ 函数。因为现在你可以自由的使用类似 lodash 之类的库，所以很快就可以用 throttling 重构项目。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>Upgrade Path</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出使用 <code>debounce</code> 参数的 实例。</p>\n</div>\n{% endraw %}\n\n### 使用 `lazy` 或者 `number` 参数的 `v-model` 。 <sup>替换</sup>\n\n`lazy` 和 `number` 参数现在以修饰符的形式使用，这样看起来更加清晰，而不是这样：\n\n``` html\n<input v-model=\"name\" lazy>\n<input v-model=\"age\" type=\"number\" number>\n```\n\n现在写成这样：\n\n``` html\n<input v-model.lazy=\"name\">\n<input v-model.number=\"age\" type=\"number\">\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到这些弃用参数。</p>\n</div>\n{% endraw %}\n\n### 使用内联 `value`的`v-model`  <sup>移除</sup>\n\n`v-model` 不再以内联 `value` 方式初始化的初值了，显然他将以实例的 data 相应的属性作为真正的初值。\n\n这意味着以下元素：\n\n``` html\n<input v-model=\"text\" value=\"foo\">\n```\n\n在data选项中有下面写法的：\n\n``` js\ndata: {\n  text: 'bar'\n}\n```\n\n将渲染 model 为 'bar' 而不是 'foo' 。同样，对 `<textarea>` 已有的值来说：\n\n``` html\n<textarea v-model=\"text\">\n  hello world\n</textarea>\n```\n\n必须保证 `text` 初值为 \"hello world\"\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>升级后运行端对端测试，注意关于<code>v-model</code>内联参数的 <strong>console warnings</strong></p>\n</div>\n{% endraw %}\n\n### `v-model` with `v-for` Iterated Primitive Values <sup>移除</sup>\n\n像这样的写法将失效：\n\n``` html\n<input v-for=\"str in strings\" v-model=\"str\">\n```\n\n因为 `<input>` 将被编译成类似下面的 js 代码：\n\n``` js\nstrings.map(function (str) {\n  return createElement('input', ...)\n})\n```\n\n这样，`v-model` 的双向绑定在这里就失效了。把 `str` 赋值给迭代器里的另一个值也没有用，因为它仅仅是函数内部的一个变量。\n\n替代方案是，你可以使用对象数组，这样`v-model` 就可以同步更新对象里面的字段了，例如：\n\n``` html\n<input v-for=\"obj in objects\" v-model=\"obj.str\">\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行测试，如果你的 app 有地方被这个更新影响到的话将会弹出<strong>failed tests</strong>提示。</p>\n</div>\n{% endraw %}\n\n### 带有 `!important` 的`v-bind:style`  <sup>移除</sup>\n\n这样写将失效：\n\n``` html\n<p v-bind:style=\"{ color: myColor + ' !important' }\">hello</p>\n```\n\n如果确实需要覆盖其它的 `!important`，最好用字符串形式去写：\n\n``` html\n<p v-bind:style=\"'color: ' + myColor + ' !important'\">hello</p>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\"> 迁移帮助工具。</a>找到含有 <code>!important</code> 的style绑定对象。</p>\n</div>\n{% endraw %}\n\n### `v-el` 和`v-ref` <sup>替换</sup>\n\n简单起见， `v-el` 和 `v-ref` 合并为一个 `ref` 属性了，可以在组件实例中通过 `$refs` 来调用。这意味着 `v-el:my-element` 将写成这样： `ref=\"myElement\"`， `v-ref:my-component` 变成了这样： `ref=\"myComponent\"`。绑定在一般元素上时，`ref` 指DOM元素，绑定在组件上时，`ref` 为一组件实例。\n因为 `v-ref` 不再是一个指令了而是一个特殊的属性，它也可以被动态定义了。这样在和`v-for` 结合的时候是很有用的：\n\n``` html\n<p v-for=\"item in items\" v-bind:ref=\"'item' + item.id\"></p>\n```\n\n以前 `v-el`/`v-ref` 和 `v-for` 一起使用将产生一个DOM数组或者组件数组，因为没法给每个元素一个特定名字。现在你还仍然可以这样做，给每个元素一个同样的`ref`：\n\n``` html\n<p v-for=\"item in items\" ref=\"items\"></p>\n```\n\n和 1.x 中不同， `$refs` 不是响应的，因为它们在渲染过程中注册/更新。只有监听变化并重复渲染才能使它们响应。\n\n另一方面，设计`$refs`主要是提供给 js 程序访问的，并不建议在模板中过度依赖使用它。因为这意味着在实例之外去访问实例状态，违背了 Vue 数据驱动的思想。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出实例中的 <code>v-el</code> 和 <code>v-ref</code> 。</p>\n</div>\n{% endraw %}\n\n### `v-show`后面使用`v-else` <sup>移除</sup>\n\n`v-else` 不能再跟在 `v-show`后面使用。请在`v-if`的否定分支中使用`v-show`来替代。例如：\n\n``` html\n<p v-if=\"foo\">Foo</p>\n<p v-else v-show=\"bar\">Not foo, but bar</p>\n```\n\n现在应该写出这样：\n\n``` html\n<p v-if=\"foo\">Foo</p>\n<p v-if=\"!foo && bar\">Not foo, but bar</p>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出实例中存在的 <code>v-else</code> 以及 <code>v-show</code>。</p>\n</div>\n{% endraw %}\n\n## 自定义指令 <sup>简化</sup>\n\n在新版中，指令的使用范围已经大大减小了：现在指令仅仅被用于低级的 DOM 操作。大多数情况下，最好是把模板作为代码复用的抽象层。\n\n显要的改变有如下几点：\n\n- 指令不再拥有实例。意思是，在指令的钩子函数中不再拥有实例的 `this` 。替代的是，你可以在参数中接受你需要的任何数据。如果确实需要，可以通过 `el` 来访问实例。\n- 类似 `acceptStatement` ，`deep` ， `priority` 等都已被弃用。为了替换`双向`指令，见 [示例](#Two-Way-Filters-deprecated)。\n- 现在有些钩子的意义和以前不一样了，并且多了两个钩子函数。\n\n幸运的是，新钩子更加简单，更加容易掌握。详见 [自定义指令指南](custom-directive.html)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到定义指令的地方。在 helper 工具会把这些地方标记出来，因为很有可能这些地方需要重构。</p>\n</div>\n{% endraw %}\n\n### 指令 `.literal` 修饰符 <sup>移除</sup>\n\n`.literal` 修饰符已经被移除，为了获取一样的功能，可以简单地提供字符串修饰符作为值。\n\n示例，如下更改：\n\n``` js\n<p v-my-directive.literal=\"foo bar baz\"></p>\n```\n\n只是：\n\n``` html\n<p v-my-directive=\"'foo bar baz'\"></p>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到实例中使用 `.literal` 修饰符的地方。</p>\n</div>\n{% endraw %}\n\n## 过渡\n\n### `transition` 参数 <sup>替换</sup>\n\nVue 的过渡系统有了彻底的改变，现在通过使用 `<transition>` 和 `<transition-group>` 来包裹元素实现过渡效果，而不再使用 `transition` 属性。详见 [Transitions guide](transitions.html)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。</p>\n</div>\n{% endraw %}\n\n### 可复用的过渡 `Vue.transition` <sup>替换</sup>\n\n在新的过渡系统中，可以[通过模板复用过渡效果](transitions.html#Reusable-Transitions)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。</p>\n</div>\n{% endraw %}\n\n### 过渡的 `stagger` 参数 <sup>移除</sup>\n\n如果希望在列表渲染中使用渐近过渡，可以通过设置元素的 `data-index` （或类似属性）来控制时间。 请参考[这个例子](transitions.html#Staggering-List-Transitions)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。升级期间，你可以“过渡”到新的过渡策略。</p>\n</div>\n{% endraw %}\n\n## 事件\n\n### `events` 选项 <sup>移除</sup>\n\n`events` 选项被弃用。事件处理器现在在 `created` 钩子中被注册。参考详细示例 [`$dispatch` and `$broadcast` 迁移指南](#dispatch-and-broadcast-deprecated)\n\n### `Vue.directive('on').keyCodes` <sup>替换</sup>\n\n新的简明配置 `keyCodes` 的方式是通过 `Vue.config.keyCodes`例如：\n\n``` js\n// v-on:keyup.f1 不可用\nVue.config.keyCodes.f1 = 112\n```\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到过时的 <code>keyCode</code> 配置</p>\n</div>\n{% endraw %}\n\n### `$dispatch` 和 `$broadcast` <sup>替换</sup>\n\n`$dispatch` 和 `$broadcast` 已经被弃用。请使用更多简明清晰的组件间通信和更好的状态管理方案，如：[Vuex](https://github.com/vuejs/vuex).\n\n因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。这种事件方式确实不太好，我们也不希望在以后让开发者们太痛苦。并且`$dispatch` 和 `$broadcast` 也没有解决兄弟组件间的通信问题。\n\n对于`$dispatch` 和 `$broadcast`最简单的升级方式就是：通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层。由于 Vue 实例实现了一个事件分发接口，你可以通过实例化一个空的 Vue 实例来实现这个目的。\n\n这些方法的最常见用途之一是父子组件的相互通信。在这些情况下，你可以使用 [`v-on`监听子组件上 $emit 的变化](components.html#Form-Input-Components-using-Custom-Events)。这可以允许你很方便的添加事件显性。\n\n然而，如果是跨多层父子组件通信的话， `$emit` 并没有什么用。相反，用集中式的事件中间件可以做到简单的升级。这会让组件之间的通信非常顺利，即使是兄弟组件。因为 Vue 通过事件发射器接口执行实例，实际上你可以使用一个空的 Vue 实例。\n\n比如，假设我们有个 todo 的应用结构如下：\n\n```\nTodos\n|-- NewTodoInput\n|-- Todo\n    |-- DeleteTodoButton\n```\n\n可以通过单独的事件中心管理组件间的通信：\n\n``` js\n// 将在各处使用该事件中心\n// 组件通过它来通信\nvar eventHub = new Vue()\n```\n\n然后在组件中，可以使用 `$emit`, `$on`, `$off` 分别来分发、监听、取消监听事件：\n\n``` js\n// NewTodoInput\n// ...\nmethods: {\n  addTodo: function () {\n    eventHub.$emit('add-todo', { text: this.newTodoText })\n    this.newTodoText = ''\n  }\n}\n```\n\n``` js\n// DeleteTodoButton\n// ...\nmethods: {\n  deleteTodo: function (id) {\n    eventHub.$emit('delete-todo', id)\n  }\n}\n```\n\n``` js\n// Todos\n// ...\ncreated: function () {\n  eventHub.$on('add-todo', this.addTodo)\n  eventHub.$on('delete-todo', this.deleteTodo)\n},\n// 最好在组件销毁前\n// 清除事件监听\nbeforeDestroy: function () {\n  eventHub.$off('add-todo', this.addTodo)\n  eventHub.$off('delete-todo', this.deleteTodo)\n},\nmethods: {\n  addTodo: function (newTodo) {\n    this.todos.push(newTodo)\n  },\n  deleteTodo: function (todoId) {\n    this.todos = this.todos.filter(function (todo) {\n      return todo.id !== todoId\n    })\n  }\n}\n```\n\n在简单的情况下这样做可以替代 `$dispatch` 和 `$broadcast`，但是对于大多数复杂情况，更推荐使用一个专用的状态管理层如：[Vuex](https://github.com/vuejs/vuex) 。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出使用 <code>$dispatch</code> 和 <code>$broadcast</code>的实例。</p>\n</div>\n{% endraw %}\n\n## 过滤器\n\n### 插入文本之外的过滤器 <sup>移除</sup>\n\n现在过滤器只能用在插入文本中 (`{% raw %}{{ }}{% endraw %}` tags)。我们发现在指令（如：`v-model`， `v-on`等）中使用过滤器使事情变得更复杂。像`v-for` 这样的列表过滤器最好把处理逻辑作为一个计算属性放在js里面，这样就可以在整个模板中复用。\n\n总之，能在原生js中实现的东西，我们尽量避免引入一个新的符号去重复处理同样的问题。下面是如何替换 Vue 内置过滤器：\n\n#### 替换 `debounce` 过滤器\n\n不再这样写\n\n``` html\n<input v-on:keyup=\"doStuff | debounce 500\">\n```\n\n``` js\nmethods: {\n  doStuff: function () {\n    // ...\n  }\n}\n```\n\n请使用 [lodash's `debounce`](https://lodash.com/docs/4.15.0#debounce) (也有可能是 [`throttle`](https://lodash.com/docs/4.15.0#throttle)) 来直接控制高耗任务。可以这样来实现上面的功能：\n\n``` html\n<input v-on:keyup=\"doStuff\">\n```\n\n``` js\nmethods: {\n  doStuff: _.debounce(function () {\n    // ...\n  }, 500)\n}\n```\n\n这种写法的更多优点详见： [`v-model` 示例](#debounce-Param-Attribute-for-v-model-removed).\n\n#### 替换 `limitBy` 过滤器\n\n不再这样写：\n\n``` html\n<p v-for=\"item in items | limitBy 10\">{{ item }}</p>\n```\n\n在 computed 属性中使用js内置方法： [`.slice` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples)：\n\n``` html\n<p v-for=\"item in filteredItems\">{{ item }}</p>\n```\n\n``` js\ncomputed: {\n  filteredItems: function () {\n    return this.items.slice(0, 10)\n  }\n}\n```\n\n#### 替换 `filterBy` 过滤器\n\n不再这样写：\n\n``` html\n<p v-for=\"user in users | filterBy searchQuery in 'name'\">{{ user.name }}</p>\n```\n\n在 computed 属性中使用js内置方法 [`.filter` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples)：\n\n``` html\n<p v-for=\"user in filteredUsers\">{{ user.name }}</p>\n```\n\n``` js\ncomputed: {\n  filteredUsers: function () {\n    var self = this\n    return self.users.filter(function (user) {\n      return user.name.indexOf(self.searchQuery) !== -1\n    })\n  }\n}\n```\n\njs原生的 `.filter` 同样能实现很多复杂的过滤器操作，因为可以在计算 computed 属性中使用所有js方法。比如，想要通过匹配用户名字和电子邮箱地址（不区分大小写）找到用户：\n\n``` js\nvar self = this\nself.users.filter(function (user) {\n  var searchRegex = new RegExp(self.searchQuery, 'i')\n  return user.isActive && (\n    searchRegex.test(user.name) ||\n    searchRegex.test(user.email)\n  )\n})\n```\n\n#### 替换 `orderBy` 过滤器\n\n不这样写：\n\n``` html\n<p v-for=\"user in users | orderBy 'name'\">{{ user.name }}</p>\n```\n\n而是在 computed 属性中使用 [lodash's `orderBy`](https://lodash.com/docs/4.15.0#orderBy) (或者可能是 [`sortBy`](https://lodash.com/docs/4.15.0#sortBy))：\n\n``` html\n<p v-for=\"user in orderedUsers\">{{ user.name }}</p>\n```\n\n``` js\ncomputed: {\n  orderedUsers: function () {\n    return _.orderBy(this.users, 'name')\n  }\n}\n```\n\n甚至可以字段排序：\n\n``` js\n_.orderBy(this.users, ['name', 'last_login'], ['asc', 'desc'])\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到指令中使用的过滤器。如果有些没找到，看看<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### 过滤器参数符号 <sup>变更</sup>\n\n现在过滤器参数形式可以更好地与js函数调用方式一致，因此不用再用空格分隔参数：\n\n``` html\n<p>{{ date | formatDate 'YY-MM-DD' timeZone }}</p>\n```\n\n现在用圆括号括起来并用逗号分隔：\n\n``` html\n<p>{{ date | formatDate('YY-MM-DD', timeZone) }}</p>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到老式的调用符号，如果有遗漏，请看<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### 内置文本过滤器 <sup>移除</sup>\n\n尽管插入文本内部的过滤器依然有效，但是所有内置过滤器已经移除了。取代的是，推荐在每个区域使用更专业的库来解决。(比如用 [`date-fns`](https://date-fns.org/) 来格式化日期，用 [`accounting`](http://openexchangerates.github.io/accounting.js/) 来格式化货币)。\n\n对于每个内置过滤器，我们大概总结了下该怎么替换。代码示例可能写在自定义 helper 函数，方法或计算属性中。\n\n#### 替换 `json` 过滤器\n\n不用一个个改，因为Vue已经帮你自动格式化好了，无论是字符串，数字还是数组，对象。如果想用js的 `JSON.stringify` 功能去实现，你也可以把它写在方法或者计算属性里面。\n\n#### 替换 `capitalize` 过滤器\n\n``` js\ntext[0].toUpperCase() + text.slice(1)\n```\n\n#### 替换 `uppercase` 过滤器\n\n``` js\ntext.toUpperCase()\n```\n\n#### 替换 `lowercase` 过滤器\n\n``` js\ntext.toLowerCase()\n```\n\n#### 替换 `pluralize` 过滤器\n\nNPM 上的 [pluralize](https://www.npmjs.com/package/pluralize) 库可以很好的实现这个功能。如果仅仅想将特定的词格式化成复数形式或者想给特定的值（'0'）指定特定的输出，也可以很容易地自定义复数格式化过滤器：\n\n``` js\nfunction pluralizeKnife (count) {\n  if (count === 0) {\n    return 'no knives'\n  } else if (count === 1) {\n    return '1 knife'\n  } else {\n    return count + 'knives'\n  }\n}\n```\n\n#### Replacing the `currency` Filter\n\n对于简单的问题,可以这样做：\n\n``` js\n'$' + price.toFixed(2)\n```\n\n大多数情况下，仍然会有奇怪的现象(比如 `0.035.toFixed(2)` 向上取舍得到 `0.04`,但是 `0.045` 向下取舍却也得到 `0.04`)。解决这些问题可以使用 [`accounting`](http://openexchangerates.github.io/accounting.js/) 库来实现更多可靠的货币格式化。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到舍弃的过滤器。如果有些遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### Two-Way Filters <sup>replaced</sup>\n\nSome users have enjoyed using two-way filters with `v-model` to create interesting inputs with very little code. While _seemingly_ simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs.\n\nAs an example, we'll now walk the migration of a two-way currency filter:\n\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/6744xnjk/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nIt mostly works well, but the delayed state updates can cause strange behavior. For example, click on the `Result` tab and try entering `9.999` into one of those inputs. When the input loses focus, its value will update to `$10.00`. When looking at the calculated total however, you'll see that `9.999` is what's stored in our data. The version of reality that the user sees is out of sync!\n\nTo start transitioning towards a more robust solution using Vue 2.0, let's first wrap this filter in a new `<currency-input>` component:\n\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/943zfbsh/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nThis allows us add behavior that a filter alone couldn't encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external [`currencyValidator` object](https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e):\n\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/9c32kev2/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nThis increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:\n\n- unit tested in isolation from your Vue code\n- used by other parts of your application, such as to validate the payload to an API endpoint\n\nHaving this validator extracted out, we've also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it's actually impossible for users to enter anything wrong, similar to what the browser's native number input tries to do.\n\nWe're still limited however, by filters and by Vue 1.0 in general, so let's complete the upgrade to Vue 2.0:\n\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nYou may notice that:\n\n- Every aspect of our input is more explicit, using lifecycle hooks and DOM events in place of the hidden behavior of two-way filters.\n- We can now use `v-model` directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.\n- Since we're no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice.\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>Upgrade Path</h4>\n  <p>Run the<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>on your codebase to find examples of filters used in directives like <code>v-model</code>. If you miss any, you should also see <strong>console errors</strong>.</p>\n</div>\n{% endraw %}\n\n## Slots\n\n### 重名的 Slots <sup>移除</sup>\n\n同一模板中的重名 `<slot>` 已经弃用。当一个 slot 已经被渲染过了，那么就不能在同一模板其它地方被再次渲染了。如果要在不同位置渲染同一内容，可一用prop来传递。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>更新后运行测试，查看 <strong>控制台警告信息</strong> 关于重名slots的提示 <code>v-model</code>。</p>\n</div>\n{% endraw %}\n\n### `slot` 样式参数 <sup>移除</sup>\n\n通过具名 `<slot>` 插入的片段不再保持 `slot` 的参数。请用一个包裹元素来控制样式。或者用更高级方法：通过编程方式修改内容 ：[render functions](render-function.html) 。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到选择slots标签CSS选择器(例如： <code>[slot=\"my-slot-name\"]</code>) 。</p>\n</div>\n{% endraw %}\n\n## 特殊属性\n\n### `keep-alive` 属性 <sup>替换</sup>\n\n`keep-alive` 不再是一个特殊属性而是一个包裹组件，类似于  `<transition>`比如：\n\n``` html\n<keep-alive>\n  <component v-bind:is=\"view\"></component>\n</keep-alive>\n```\n\n这样可以在含多种状态子组件中使用 `<keep-alive>` ：\n\n``` html\n<keep-alive>\n  <todo-list v-if=\"todos.length > 0\"></todo-list>\n  <no-todos-gif v-else></no-todos-gif>\n</keep-alive>\n```\n\n<p class=\"tip\">当 `<keep-alive>` 含有不同子组件时，应该分别影响到每一个子组件。不仅是第一个而是所有的子组件都将被忽略。</p>\n\n和 `<transition>`一起使用时，确保把内容包裹在内：\n\n``` html\n<transition>\n  <keep-alive>\n    <component v-bind:is=\"view\"></component>\n  </keep-alive>\n</transition>\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到<code>keep-alive</code> 属性。</p>\n</div>\n{% endraw %}\n\n## 计算插值todaymark\n\n### 属性内部的计算插值 <sup>移除</sup>\n\n属性内部的计算插值已经不能再使用了：\n\n``` html\n<button class=\"btn btn-{{ size }}\"></button>\n```\n\n应该写成行内表达式：\n\n``` html\n<button v-bind:class=\"'btn btn-' + size\"></button>\n```\n\n或者计算属性：\n\n``` html\n<button v-bind:class=\"buttonClasses\"></button>\n```\n\n``` js\ncomputed: {\n  buttonClasses: function () {\n    return 'btn btn-' + size\n  }\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到属性内部的计算插值</p>\n</div>\n{% endraw %}\n\n### HTML 计算插值 <sup>移除</sup>\n\nHTML 的计算插值 (`{% raw %}{{{ foo }}}{% endraw %}`) 已经移除，取代的是 [`v-html` 指令](../api/#v-html).\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 HTML 计算插值。</p>\n</div>\n{% endraw %}\n\n### 单次绑定<sup>替换</sup>\n\n单次绑定 (`{% raw %}{{* foo }}{% endraw %}`) 已经被新的 [`v-once` directive](../api/#v-once) 取代。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到单次绑定使用位置。</p>\n</div>\n{% endraw %}\n\n## 响应\n\n### `vm.$watch` <sup>changed</sup>\n\n通过 `vm.$watch`创建的观察器现在将在组件渲染时被激活。这样可以让你在组件渲染前更新状态，不用做不必要的更新。比如可以通过观察组件的prop变化来更新组件本身的值。\n\n如果以前通过 `vm.$watch` 在组件更新后与 DOM 交互，现在就可以通过`updated`生命周期钩子来做这些。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行测试，如果有依赖于老方法的观察器将弹出 <strong>failed tests</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$set` <sup>变更</sup>\n\n `vm.$set` 只是 [`Vue.set`](../api/#Vue-set) 的别名。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到过时的用法</p>\n</div>\n{% endraw %}\n\n### `vm.$delete` <sup>变更</sup>\n\n`vm.$delete` 现在只是： [`Vue.delete`](../api/#Vue-delete) 别名。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到过时的用法</p>\n</div>\n{% endraw %}\n\n### `Array.prototype.$set`  <sup>弃用</sup>\n\n用 `Vue.set` 替代\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到数组上的<code>.$set</code>。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `Array.prototype.$remove` <sup>移除</sup>\n\n用 `Array.prototype.splice` 替代，例如：\n\n``` js\nmethods: {\n  removeTodo: function (todo) {\n    var index = this.todos.indexOf(todo)\n    this.todos.splice(index, 1)\n  }\n}\n```\n\n或者更好的方法，直接给除去的方法一个index参数：\n\n``` js\nmethods: {\n  removeTodo: function (index) {\n    this.todos.splice(index, 1)\n  }\n}\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到数组上的<code>.$remove</code>。如有遗漏请参考<strong>控制台错误信息</strong></p>\n</div>\n{% endraw %}\n\n### Vue实例上的`Vue.set` 和 `Vue.delete`<sup>移除</sup>\n\n`Vue.set` 和 `Vue.delete` 在实例上将不再起作用。现在都强制在实例的data选项中声明所有顶级响应值。如果删除实例属性或实例`$data`上的某个值，直接将它设置为null即可。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到实例中的 <code>Vue.set</code> 或 <code>Vue.delete</code> 。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### 替换 `vm.$data` <sup>移除</sup>\n\n现在禁止替换实例的 $data。这样防止了响应系统的一些极端情况并且让组件状态更加可控可预测（特别是对于存在类型检查的系统）。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到覆盖 <code>vm.$data</code >的位置。如有遗漏请参考<strong>控制台警告信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$get` <sup>移除</sup>\n\n可以直接取回响应数据。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$get</code> 的位置。如有遗漏请参考 <strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n## 围绕 DOM 的实例方法\n\n### `vm.$appendTo` <sup>移除</sup>\n\n使用 DOM 原生方法:\n\n``` js\nmyElement.appendChild(vm.$el)\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$appendTo</code> 的位置。如果有遗漏可以参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$before` <sup>移除</sup>\n\n使用 DOM 原生方法：\n\n``` js\nmyElement.parentNode.insertBefore(vm.$el, myElement)\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$before</code>。如有遗漏，请参考 <strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$after` <sup>移除</sup>\n\n使用 DOM 原生方法：\n\n``` js\nmyElement.parentNode.insertBefore(vm.$el, myElement.nextSibling)\n```\n\n如果 `myElement` 是最后一个节点也可以这样写：\n\n``` js\nmyElement.parentNode.appendChild(vm.$el)\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$after</code> 的位置。如有遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$remove` <sup>移除</sup>\n\n使用 DOM 原生方法：\n\n``` js\nvm.$el.remove()\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到<code>vm.$remove</code>。如有遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n## 底层实例方法\n\n### `vm.$eval` <sup>移除</sup>\n\n尽量不要使用，如果必须使用该功能并且不肯定如何使用请参考 [the forum](http://forum.vuejs.org/)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>vm.$eval</code> 的位置。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n{% endraw %}\n\n### `vm.$interpolate` <sup>移除</sup>\n\n尽量不要使用，如果必须使用该功能并且不肯定如何使用请参考 [the forum](http://forum.vuejs.org/)。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到<code>vm.$interpolate</code>。如有遗漏请参考<strong>控制台错误信息</strong>.</p>\n</div>\n{% endraw %}\n\n### `vm.$log` <sup>移除</sup>\n\n请使用 [Vue Devtools](https://github.com/vuejs/vue-devtools) 感受最佳debug体验。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$log</code>。如有遗漏请参考<strong>控制台错误信息</strong>.</p>\n</div>\n{% endraw %}\n\n## 实例 DOM 选项\n\n### `replace: false` <sup>移除</sup>\n\n现在组件总是会替换掉他们被绑定的元素。为了模仿`replace: false`的行为，可以用一个和将要替换元素类似的元素将根组件包裹起来：\n\n``` js\nnew Vue({\n  el: '#app',\n  template: '<div id=\"app\"> ... </div>'\n})\n```\n\n或者使用渲染函数：\n\n``` js\nnew Vue({\n  el: '#app',\n  render: function (h) {\n    h('div', {\n      attrs: {\n        id: 'app',\n      }\n    }, /* ... */)\n  }\n})\n```\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>replace: false</code>使用的位置。</p>\n</div>\n{% endraw %}\n\n## 全局配置\n\n### `Vue.config.debug` <sup>移除</sup>\n\n不再需要，因为警告信息将默认在堆栈信息里输出。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到包含<code>Vue.config.debug</code>的地方。</p>\n</div>\n{% endraw %}\n\n### `Vue.config.async` <sup>移除</sup>\n\n异步操作现在需要渲染性能的支持。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用<code>Vue.config.async</code>的实例。</p>\n</div>\n{% endraw %}\n\n### `Vue.config.delimiters` <sup>替换</sup>\n\n以 [模板选项](../api/#delimiters)的方式使用。这样可以在使用自定义分隔符时避免影响第三方模板。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用<code>Vue.config.delimiters</code>的实例。</p>\n</div>\n{% endraw %}\n\n### `Vue.config.unsafeDelimiters` <sup>移除</sup>\n\nHTML 插入 [替换为 `v-html`](#HTML-Interpolation-removed).\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>Vue.config.unsafeDelimiters</code>。然后 helper 工具也会找到HTML插入的实例，可以用`v-html`来替换。</p>\n</div>\n{% endraw %}\n\n## 全局 API\n\n### 带 `el` 的 `Vue.extend` <sup>移除</sup>\n\nel 选项不再在 `Vue.extend`中使用。仅在实例创建参数中可用。\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>更新后运行测试在<strong>控制台警告信息</strong>中找到关于带有<code>Vue.extend</code>的<code>el</code>。</p>\n</div>\n{% endraw %}\n\n### `Vue.elementDirective` <sup>移除</sup>\n\n用组件来替代\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到包含<code>Vue.elementDirective</code>的实例。</p>\n</div>\n{% endraw %}\n\n### `Vue.partial` <sup>移除</sup>\n\nPartials 已被移除,取而代之的是更明确的组件之间的数据流--props。除非你正在使用一个部分性能关键型区域，否则建议只使用一个[normal component](components.html)来代替。如果你是动态绑定部分的`name`,您可以使用[dynamic component](components.html#Dynamic-Components)。\n\n\n如果你碰巧在你的应用程序的性能关键部分使用`partials`，那么你应该升级到[functional components](render-function.html#Functional-Components)。它们必须在纯JS / JSX文件中（而不是在`.vue`文件中），并且是无状态的和无实例的，就像`partials`。这使得渲染极快。\n\n`functional components`相对于`partials`一个好处是它们可以更具动态性，因为它们允许您访问JavaScript的全部功能。然而，这是有成本的。如果你从来没有使用过渲染式的组件框架，你可能需要花费更长的时间来学习它们。\n\n\n{% raw %}\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到包含 <code>Vue.partial</code>的实例</p>\n</div>\n{% endraw %}\n\n***\n\n> 原文： http:/   /vuejs.org/guide/migration.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/migration.html","comments":1,"layout":"page","_id":"ciwnajuyu001mjl2dfrfil5vd","content":"<h2 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h2><blockquote>\n<p>哇，非常长的一页！是否意味着 Vue 2.0 已经完全不同了呢，是否需要从头学起呢，Vue 1.0 的项目是不是没法迁移了？</p>\n</blockquote>\n<p>非常开心地告诉你，并不是！几乎 90% 的 API 和核心概念都没有变。因为本节包含了很多详尽的阐述以及许多迁移的例子，所以显得有点长。不用担心，<strong>你不必从头到尾把本节读一遍！</strong></p>\n<blockquote>\n<p>我该从哪里开始项目迁移呢？</p>\n</blockquote>\n<ol>\n<li><p>首先，在当前项目下运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>。我们非常谨慎地把高级 Vue 升级过程简化为使用一个简单的命令行工具。当工具识别出旧有的特性后，就会告知你并给出建议，同时附上关于详细信息的链接。</p>\n</li>\n<li><p>然后，浏览本页面的侧边栏列出的内容。如果发现有的标题对你的项目有影响，但是迁移工具没有给出提示，请检查自己的项目。</p>\n</li>\n<li><p>如果你的项目有测试代码，运行并查看仍然失败的地方。如果没有测试代码，在浏览器中打开你的程序，通过导航环顾并留意那些报错或警告信息。</p>\n</li>\n<li><p>现在，你的应用程序应该已彻底完成迁移。如果你渴望了解更多，可以阅读本页面剩余部分 - 或者从<a href=\"index.html\">介绍</a>部分，从头开始深入新的文档和改进过的指南。由于你已经熟悉一些核心概念，所以许多部分已经被删除掉。</p>\n</li>\n</ol>\n<blockquote>\n<p>将 Vue 1.x 版本的应用程序迁移到 2.0 要花多长时间？</p>\n</blockquote>\n<p>这取决于几个因素：</p>\n<ul>\n<li><p>取决于你应用程序的规模（中小型的基本上一天内就可以搞定）。</p>\n</li>\n<li><p>取决于你分心和开始 2.0 最酷的新功能的次数。 😉 &nbsp;无法判断时间，我们构建 2.0 应用的时候也经常发生这种事！</p>\n</li>\n<li><p>取决于你使用了哪些旧有的特性。大部分可以通过查找和替换(find-and-replace)来实现升级，但有一些可能还是要花点时间。如果你没有遵循最佳实践，Vue 2.0 会尽力强迫你去遵循。这有利于项目的长期运行，但也可能意味着重大重构（尽管有些需要重构的部分可能已经过时）。</p>\n</li>\n</ul>\n<blockquote>\n<p>如果我升级到到 Vue 2 ，我还必须同时升级 Vuex 和 Vue-Router？</p>\n</blockquote>\n<p>只有 Vue-Router 2 与 Vue 2 保持兼容，所以 Vue-Router 是需要升级的，你必须遵循 <a href=\"migration-vue-router.html\">Vue-Router 迁移方式</a>来处理。幸运的是， 大多数应用没有很多 router 相关代码，所以迁移可能不会超过一个小时。</p>\n<p>对于 Vuex ，版本 0.8+ 与 Vue 2 保持兼容，所以部分不必强制升级。可以促使你立即升级的唯一理由，是你想要使用那些 Vuex 2 中新的高级特性，比如模块(modules)和减少的样板文件(reduced boilerplate)。</p>\n<h2 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h2><h3 id=\"片段实例-移除\"><a href=\"#片段实例-移除\" class=\"headerlink\" title=\"片段实例 移除\"></a>片段实例 <sup>移除</sup></h3><p>每个组件必须只有一个根元素。不再允许片段实例，如果你有这样的模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>foo<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>最好把整个内容都简单包裹到一个新的元素里，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>foo<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>升级后运行端到端测试套件(end-to-end test suite)或运行应用程序，并查看<strong>控制台警告(console warnings)</strong>来找出那些模板中有多个根元素的地方。\n</p></div>\n\n<h2 id=\"生命周期钩子函数\"><a href=\"#生命周期钩子函数\" class=\"headerlink\" title=\"生命周期钩子函数\"></a>生命周期钩子函数</h2><h3 id=\"beforeCompile-移除\"><a href=\"#beforeCompile-移除\" class=\"headerlink\" title=\"beforeCompile 移除\"></a><code>beforeCompile</code> <sup>移除</sup></h3><p>使用 <code>created</code> 钩子函数替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h3 id=\"compiled-替换\"><a href=\"#compiled-替换\" class=\"headerlink\" title=\"compiled 替换\"></a><code>compiled</code> <sup>替换</sup></h3><p>使用 <code>mounted</code> 钩子函数替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h3 id=\"attached-移除\"><a href=\"#attached-移除\" class=\"headerlink\" title=\"attached 移除\"></a><code>attached</code> <sup>移除</sup></h3><p>使用其他钩子函数内置的 DOM 检测(DOM check)方法。例如，替换如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">attached: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  doSomething()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以这样使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    doSomething()</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h3 id=\"detached-移除\"><a href=\"#detached-移除\" class=\"headerlink\" title=\"detached 移除\"></a><code>detached</code> <sup>移除</sup></h3><p>使用其他钩子函数内的 DOM 检测(DOM check)方法。例如，替换如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">detached: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  doSomething()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以这样使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">destroyed: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    doSomething()</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h3 id=\"init-重新命名\"><a href=\"#init-重新命名\" class=\"headerlink\" title=\"init 重新命名\"></a><code>init</code> <sup>重新命名</sup></h3><p>使用新的 <code>beforeCreate</code> 钩子函数替代，本质上 beforeCreate 和 init 完全相同。init 被重新命名是为了和其他的生命周期方法的命名方式保持一致。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h3 id=\"ready-替换\"><a href=\"#ready-替换\" class=\"headerlink\" title=\"ready 替换\"></a><code>ready</code> <sup>替换</sup></h3><p>使用新的 <code>mounted</code> 钩子函数替代。应该注意的是，使用 <code>mounted</code> 并不能保证钩子函数中的 this.$el 在 document 中。为此还应该引入 <code>Vue.nextTick</code>/<code>vm.$nextTick</code>。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 代码保证 this.$el 在 document 中</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h2 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a><code>v-for</code></h2><h3 id=\"v-for-遍历数组时的参数顺序-变更\"><a href=\"#v-for-遍历数组时的参数顺序-变更\" class=\"headerlink\" title=\"v-for 遍历数组时的参数顺序 变更\"></a><code>v-for</code> 遍历数组时的参数顺序 <sup>变更</sup></h3><p>当包含 <code>index</code> 时，之前遍历数组时的参数顺序是 <code>(index, value)</code>。现在是 <code>(value, index)</code> ，来和 JavaScript 的原生数组方法（例如 <code>forEach</code> 和 <code>map</code>）保持一致。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>来找出那些使用旧有参数顺序的示例。注意，如果你将你的 index 参数命名为一些不通用的名字（例如 <code>position</code> 或 <code>num</code>），迁移工具将不会把它们标记出来。</p>\n</div>\n\n<h3 id=\"v-for-遍历对象时的参数顺序-变更\"><a href=\"#v-for-遍历对象时的参数顺序-变更\" class=\"headerlink\" title=\"v-for 遍历对象时的参数顺序 变更\"></a><code>v-for</code> 遍历对象时的参数顺序 <sup>变更</sup></h3><p>当包含 <code>key</code> 时，之前遍历对象的参数顺序是 <code>(key, value)</code>。现在是 <code>(value, key)</code>，来和常见的对象迭代器（例如 lodash）保持一致。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>来找出那些使用旧有参数顺序的示例。注意，如果你将你的 key 参数命名为一些不通用的名字（例如 <code>name</code> 或 <code>property</code>），迁移工具将不会把它们标记出来。</p>\n</div>\n\n<h3 id=\"index-and-key-移除\"><a href=\"#index-and-key-移除\" class=\"headerlink\" title=\"$index and $key 移除\"></a><code>$index</code> and <code>$key</code> <sup>移除</sup></h3><p>已经移除了 <code>$index</code> 和 <code>$key</code> 这两个隐式声明变量，以便在 <code>v-for</code> 中显式定义。这可以使没有太多 Vue 开发经验的开发者更好地阅读代码，并且在处理嵌套循环时也能产生更清晰的行为。<br>\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>来找出使用这些移除变量的示例。如果你没有找到，也可以在<strong>控制台错误</strong>中查找（例如 <code>Uncaught ReferenceError: $index is not defined</code>）。</p>\n</div>\n</p>\n<h3 id=\"track-by-替换\"><a href=\"#track-by-替换\" class=\"headerlink\" title=\"track-by 替换\"></a><code>track-by</code> <sup>替换</sup></h3><p><code>track-by</code> 已经替换为 <code>key</code>，它的工作方式与其他属性一样，没有 <code>v-bind</code> 或者 <code>:</code> 前缀，它会被作为一个字符串处理。多数情况下，你需要使用具有完整表达式的动态绑定(dynamic binding)来替换静态的 key。例如，替换：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">track-by</span>=<span class=\"string\">\"id\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你现在应该写为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>来找出那些使用<code>track-by</code>的示例。</p>\n</div>\n\n<h3 id=\"v-for-范围值-变更\"><a href=\"#v-for-范围值-变更\" class=\"headerlink\" title=\"v-for 范围值 变更\"></a><code>v-for</code> 范围值 <sup>变更</sup></h3><p>之前，<code>v-for=&quot;number in 10&quot;</code> 的 <code>number</code> 从 0 开始到 9 结束，现在从 1 开始，到 10 结束。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中使用正则 <code>/\\w+ in \\d+/</code>搜索。当出现在 <code>v-for</code> 中，请检查是否受到影响。</p>\n</div>\n\n<h2 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h2><h3 id=\"coerce-Prop的参数-移除\"><a href=\"#coerce-Prop的参数-移除\" class=\"headerlink\" title=\"coerce Prop的参数 移除\"></a><code>coerce</code> Prop的参数 <sup>移除</sup></h3><p>如果需要检查 prop 的值，创建一个内部的 computed 值，而不再在 props 内部去定义，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">props: &#123;</div><div class=\"line\">  <span class=\"attr\">username</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">type</span>: <span class=\"built_in\">String</span>,</div><div class=\"line\">    <span class=\"attr\">coerce</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> value</div><div class=\"line\">        .toLowerCase()</div><div class=\"line\">        .replace(<span class=\"regexp\">/\\s+/</span>, <span class=\"string\">'-'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在应该写为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">props: &#123;</div><div class=\"line\">  <span class=\"attr\">username</span>: <span class=\"built_in\">String</span>,</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">normalizedUsername</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.username</div><div class=\"line\">      .toLowerCase()</div><div class=\"line\">      .replace(<span class=\"regexp\">/\\s+/</span>, <span class=\"string\">'-'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样有一些好处：</p>\n<ul>\n<li>你可以对保持原始 prop 值的操作权限。</li>\n<li>通过给予验证后的值一个不同的命名，强制开发者使用显式申明。</li>\n</ul>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找出包含 <code>coerce</code> 选项的实例。</p>\n</div>\n\n<h3 id=\"twoWay-Prop-的参数-移除\"><a href=\"#twoWay-Prop-的参数-移除\" class=\"headerlink\" title=\"twoWay Prop 的参数 移除\"></a><code>twoWay</code> Prop 的参数 <sup>移除</sup></h3><p>Props 现在只能单项传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。详见：</p>\n<ul>\n<li><a href=\"components.html#Custom-Events\">自定义组件事件</a></li>\n<li><a href=\"components.html#Form-Input-Components-using-Custom-Events\">自定义输入组件</a> (使用组件事件)</li>\n<li><a href=\"state-management.html\">全局状态管理</a></li>\n</ul>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>，找出含有 <code>twoWay</code> 参数的实例。</p>\n</div>\n\n<h3 id=\"v-bind-的-once和-sync-修饰符-移除\"><a href=\"#v-bind-的-once和-sync-修饰符-移除\" class=\"headerlink\" title=\"v-bind 的 .once和.sync 修饰符 移除\"></a><code>v-bind</code> 的 <code>.once</code>和<code>.sync</code> 修饰符 <sup>移除</sup></h3><p>Props 现在只能单向传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。详见：</p>\n<ul>\n<li><a href=\"components.html#Custom-Events\">自定义组件事件</a></li>\n<li><a href=\"components.html#Form-Input-Components-using-Custom-Events\">自定义输入组件</a> (使用组件事件)</li>\n<li><a href=\"state-management.html\">全局状态管理</a></li>\n</ul>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到使用 <code>.once</code> 和 <code>.sync</code> 修饰符的实例。</p>\n</div>\n\n<h3 id=\"修改-Props-弃用\"><a href=\"#修改-Props-弃用\" class=\"headerlink\" title=\"修改 Props 弃用\"></a>修改 Props <sup>弃用</sup></h3><p>组件内修改 prop 是反模式（不推荐的）的。比如，先声明一个 prop ，然后在组件中通过 <code>this.myProp = &#39;someOtherValue&#39;</code> 改变 prop 的值。根据渲染机制，当父组件重新渲染时，子组件的内部 prop 值也将被覆盖。</p>\n<p>大多数情况下，改变 prop 值可以用以下选项替代：</p>\n<ul>\n<li>通过 data 属性，用prop去设置一个data属性的默认值。</li>\n<li>通过 computed 属性。</li>\n</ul>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，查看关于 prop 修改的<strong>控制台警告信息</strong>。</p>\n</div>\n\n<h3 id=\"根实例的-Props-替换\"><a href=\"#根实例的-Props-替换\" class=\"headerlink\" title=\"根实例的 Props 替换\"></a>根实例的 Props <sup>替换</sup></h3><p>对于一个根实例来说 (比如：用 <code>new Vue({ ... })</code> 创建的实例)，只能用 <code>propsData</code> 而不是 <code>props</code> 。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，将会弹出 <strong>failed tests</strong> 来通知你使用 <code>props</code> 的根实例已经失效。</p>\n</div>\n\n<h2 id=\"Built-In-指令\"><a href=\"#Built-In-指令\" class=\"headerlink\" title=\"Built-In 指令\"></a>Built-In 指令</h2><h3 id=\"v-bind-真-假值-变更\"><a href=\"#v-bind-真-假值-变更\" class=\"headerlink\" title=\"v-bind 真/假值 变更\"></a><code>v-bind</code> 真/假值 <sup>变更</sup></h3><p>在2.0中使用 <code>v-bind</code> 时，只有 <code>null</code>, <code>undefined</code> , 和 <code>false</code> 被看作是假。这意味着，<code>0</code> 和空字符串将被作为真值渲染。比如 <code>v-bind:draggable=&quot;&#39;&#39;&quot;</code> 将被渲染为 <code>draggable=&quot;true&quot;</code>。</p>\n<p>对于枚举属性，除了以上假值之外，字符串 <code>&quot;false&quot;</code> 也会被渲染为 <code>attr=&quot;false&quot;</code>。</p>\n<p class=\"tip\">注意，对于其它钩子函数 (如 <code>v-if</code> 和 <code>v-show</code>)， 他们依然遵循 js 对真假值判断的一般规则。</p>\n\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端到端测试，如果你app的任何部分有可能被这个升级影响到，将会弹出<strong>failed tests</strong></p>\n</div>\n\n<h3 id=\"用-v-on-监听原生事件-变更\"><a href=\"#用-v-on-监听原生事件-变更\" class=\"headerlink\" title=\"用 v-on 监听原生事件 变更\"></a>用 <code>v-on</code> 监听原生事件 <sup>变更</sup></h3><p>  现在在组件上使用 <code>v-on</code> 只会监听自定义事件（组件用 <code>$emit</code> 触发的事件）。如果要监听根元素的原生事件，可以使用 <code>.native</code> 修饰符，比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-on:click.native</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，如果你app的任何部分有可能被这个升级影响到，将会弹出<strong>failed tests</strong> </p>\n</div>\n\n<h3 id=\"带有-debounce-的-v-model移除\"><a href=\"#带有-debounce-的-v-model移除\" class=\"headerlink\" title=\"带有 debounce 的 v-model移除\"></a>带有 <code>debounce</code> 的 <code>v-model</code><sup>移除</sup></h3><p>Debouncing 曾经被用来控制 Ajax 请求及其它高耗任务的频率。 Vue 中<code>v-model</code>的 <code>debounce</code> 属性参数使得在一些简单情况下非常容易实现这种控制。但实际上，这是控制了 <strong>状态更新</strong> 的频率，而不是控制高耗时任务本身。这是个微小的差别，但是会随着应用增长而显现出局限性。</p>\n<p>例如在设计一个搜索提示时的局限性：</p>\n\n<script src=\"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js\"></script>\n<div id=\"debounce-search-demo\" class=\"demo\">\n  <input v-model=\"searchQuery\" placeholder=\"Type something\">\n  <strong>{{ searchIndicator }}</strong>\n</div>\n<script>\nnew Vue({\n  el: '#debounce-search-demo',\n  data: {\n    searchQuery: '',\n    searchQueryIsDirty: false,\n    isCalculating: false\n  },\n  computed: {\n    searchIndicator: function () {\n      if (this.isCalculating) {\n        return '⟳ Fetching new results'\n      } else if (this.searchQueryIsDirty) {\n        return '... Typing'\n      } else {\n        return '✓ Done'\n      }\n    }\n  },\n  watch: {\n    searchQuery: function () {\n      this.searchQueryIsDirty = true\n      this.expensiveOperation()\n    }\n  },\n  methods: {\n    expensiveOperation: _.debounce(function () {\n      this.isCalculating = true\n      setTimeout(function () {\n        this.isCalculating = false\n        this.searchQueryIsDirty = false\n      }.bind(this), 1000)\n    }, 500)\n  }\n})\n</script>\n\n<p>使用 <code>debounce</code> 参数，便无法观察 “Typing” 的状态。因为无法对输入状态进行实时检测。然而，通过将 <code>debounce</code> 与 Vue 解耦，可以仅仅只延迟我们想要控制的操作，从而避开这些局限性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!--</span></div><div class=\"line\">通过使用lodash或者其它库的debounce函数，</div><div class=\"line\">我们相信 debounce 实现是一流的，</div><div class=\"line\">并且可以随处使用它，不仅仅是在模板中。</div><div class=\"line\">--&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"debounce-search-demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"searchQuery\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Type something\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span>&#123;&#123; searchIndicator &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#debounce-search-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">searchQuery</span>: <span class=\"string\">''</span>,</div><div class=\"line\">    <span class=\"attr\">searchQueryIsDirty</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">isCalculating</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">searchIndicator</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isCalculating) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'⟳ Fetching new results'</span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.searchQueryIsDirty) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'... Typing'</span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'✓ Done'</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">searchQuery</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.searchQueryIsDirty = <span class=\"literal\">true</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.expensiveOperation()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 这是 debounce 实现的地方。</span></div><div class=\"line\">    expensiveOperation: _.debounce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.isCalculating = <span class=\"literal\">true</span></div><div class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.isCalculating = <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.searchQueryIsDirty = <span class=\"literal\">false</span></div><div class=\"line\">      &#125;.bind(<span class=\"keyword\">this</span>), <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;, <span class=\"number\">500</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这种方式的另外一个优点是：当包裹函数执行时间与延时时间相当时，将会等待较长时间。比如，当给出搜索建议时，要等待用户输入停止一段时间后才给出建议，这个体验非常差。其实，这时候更适合用 <strong>throttling</strong> 函数。因为现在你可以自由的使用类似 lodash 之类的库，所以很快就可以用 throttling 重构项目。</p>\n\n<div class=\"upgrade-path\">\n  <h4>Upgrade Path</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找出使用 <code>debounce</code> 参数的 实例。</p>\n</div>\n\n<h3 id=\"使用-lazy-或者-number-参数的-v-model-。-替换\"><a href=\"#使用-lazy-或者-number-参数的-v-model-。-替换\" class=\"headerlink\" title=\"使用 lazy 或者 number 参数的 v-model 。 替换\"></a>使用 <code>lazy</code> 或者 <code>number</code> 参数的 <code>v-model</code> 。 <sup>替换</sup></h3><p><code>lazy</code> 和 <code>number</code> 参数现在以修饰符的形式使用，这样看起来更加清晰，而不是这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">lazy</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">number</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>现在写成这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.lazy</span>=<span class=\"string\">\"name\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到这些弃用参数。</p>\n</div>\n\n<h3 id=\"使用内联-value的v-model-移除\"><a href=\"#使用内联-value的v-model-移除\" class=\"headerlink\" title=\"使用内联 value的v-model  移除\"></a>使用内联 <code>value</code>的<code>v-model</code>  <sup>移除</sup></h3><p><code>v-model</code> 不再以内联 <code>value</code> 方式初始化的初值了，显然他将以实例的 data 相应的属性作为真正的初值。</p>\n<p>这意味着以下元素：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"foo\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在data选项中有下面写法的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">text</span>: <span class=\"string\">'bar'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>将渲染 model 为 ‘bar’ 而不是 ‘foo’ 。同样，对 <code>&lt;textarea&gt;</code> 已有的值来说：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"text\"</span>&gt;</span></div><div class=\"line\">  hello world</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>必须保证 <code>text</code> 初值为 “hello world”</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>升级后运行端对端测试，注意关于<code>v-model</code>内联参数的 <strong>console warnings</strong></p>\n</div>\n\n<h3 id=\"v-model-with-v-for-Iterated-Primitive-Values-移除\"><a href=\"#v-model-with-v-for-Iterated-Primitive-Values-移除\" class=\"headerlink\" title=\"v-model with v-for Iterated Primitive Values 移除\"></a><code>v-model</code> with <code>v-for</code> Iterated Primitive Values <sup>移除</sup></h3><p>像这样的写法将失效：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"str in strings\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"str\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>因为 <code>&lt;input&gt;</code> 将被编译成类似下面的 js 代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">strings.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'input'</span>, ...)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样，<code>v-model</code> 的双向绑定在这里就失效了。把 <code>str</code> 赋值给迭代器里的另一个值也没有用，因为它仅仅是函数内部的一个变量。</p>\n<p>替代方案是，你可以使用对象数组，这样<code>v-model</code> 就可以同步更新对象里面的字段了，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"obj in objects\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"obj.str\"</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行测试，如果你的 app 有地方被这个更新影响到的话将会弹出<strong>failed tests</strong>提示。</p>\n</div>\n\n<h3 id=\"带有-important-的v-bind-style-移除\"><a href=\"#带有-important-的v-bind-style-移除\" class=\"headerlink\" title=\"带有 !important 的v-bind:style  移除\"></a>带有 <code>!important</code> 的<code>v-bind:style</code>  <sup>移除</sup></h3><p>这样写将失效：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"&#123; color: myColor + ' !important' &#125;\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果确实需要覆盖其它的 <code>!important</code>，最好用字符串形式去写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"'color: ' + myColor + ' !important'\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\"> 迁移帮助工具。</a>找到含有 <code>!important</code> 的style绑定对象。</p>\n</div>\n\n<h3 id=\"v-el-和v-ref-替换\"><a href=\"#v-el-和v-ref-替换\" class=\"headerlink\" title=\"v-el 和v-ref 替换\"></a><code>v-el</code> 和<code>v-ref</code> <sup>替换</sup></h3><p>简单起见， <code>v-el</code> 和 <code>v-ref</code> 合并为一个 <code>ref</code> 属性了，可以在组件实例中通过 <code>$refs</code> 来调用。这意味着 <code>v-el:my-element</code> 将写成这样： <code>ref=&quot;myElement&quot;</code>， <code>v-ref:my-component</code> 变成了这样： <code>ref=&quot;myComponent&quot;</code>。绑定在一般元素上时，<code>ref</code> 指DOM元素，绑定在组件上时，<code>ref</code> 为一组件实例。<br>因为 <code>v-ref</code> 不再是一个指令了而是一个特殊的属性，它也可以被动态定义了。这样在和<code>v-for</code> 结合的时候是很有用的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">v-bind:ref</span>=<span class=\"string\">\"'item' + item.id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>以前 <code>v-el</code>/<code>v-ref</code> 和 <code>v-for</code> 一起使用将产生一个DOM数组或者组件数组，因为没法给每个元素一个特定名字。现在你还仍然可以这样做，给每个元素一个同样的<code>ref</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>和 1.x 中不同， <code>$refs</code> 不是响应的，因为它们在渲染过程中注册/更新。只有监听变化并重复渲染才能使它们响应。</p>\n<p>另一方面，设计<code>$refs</code>主要是提供给 js 程序访问的，并不建议在模板中过度依赖使用它。因为这意味着在实例之外去访问实例状态，违背了 Vue 数据驱动的思想。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找出实例中的 <code>v-el</code> 和 <code>v-ref</code> 。</p>\n</div>\n\n<h3 id=\"v-show后面使用v-else-移除\"><a href=\"#v-show后面使用v-else-移除\" class=\"headerlink\" title=\"v-show后面使用v-else 移除\"></a><code>v-show</code>后面使用<code>v-else</code> <sup>移除</sup></h3><p><code>v-else</code> 不能再跟在 <code>v-show</code>后面使用。请在<code>v-if</code>的否定分支中使用<code>v-show</code>来替代。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"foo\"</span>&gt;</span>Foo<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"bar\"</span>&gt;</span>Not foo, but bar<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>现在应该写出这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"foo\"</span>&gt;</span>Foo<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"!foo &amp;&amp; bar\"</span>&gt;</span>Not foo, but bar<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找出实例中存在的 <code>v-else</code> 以及 <code>v-show</code>。</p>\n</div>\n\n<h2 id=\"自定义指令-简化\"><a href=\"#自定义指令-简化\" class=\"headerlink\" title=\"自定义指令 简化\"></a>自定义指令 <sup>简化</sup></h2><p>在新版中，指令的使用范围已经大大减小了：现在指令仅仅被用于低级的 DOM 操作。大多数情况下，最好是把模板作为代码复用的抽象层。</p>\n<p>显要的改变有如下几点：</p>\n<ul>\n<li>指令不再拥有实例。意思是，在指令的钩子函数中不再拥有实例的 <code>this</code> 。替代的是，你可以在参数中接受你需要的任何数据。如果确实需要，可以通过 <code>el</code> 来访问实例。</li>\n<li>类似 <code>acceptStatement</code> ，<code>deep</code> ， <code>priority</code> 等都已被弃用。为了替换<code>双向</code>指令，见 <a href=\"#Two-Way-Filters-deprecated\">示例</a>。</li>\n<li>现在有些钩子的意义和以前不一样了，并且多了两个钩子函数。</li>\n</ul>\n<p>幸运的是，新钩子更加简单，更加容易掌握。详见 <a href=\"custom-directive.html\">自定义指令指南</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到定义指令的地方。在 helper 工具会把这些地方标记出来，因为很有可能这些地方需要重构。</p>\n</div>\n\n<h3 id=\"指令-literal-修饰符-移除\"><a href=\"#指令-literal-修饰符-移除\" class=\"headerlink\" title=\"指令 .literal 修饰符 移除\"></a>指令 <code>.literal</code> 修饰符 <sup>移除</sup></h3><p><code>.literal</code> 修饰符已经被移除，为了获取一样的功能，可以简单地提供字符串修饰符作为值。</p>\n<p>示例，如下更改：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;p v-my-directive.literal=<span class=\"string\">\"foo bar baz\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<p>只是：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-my-directive</span>=<span class=\"string\">\"'foo bar baz'\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到实例中使用 `.literal` 修饰符的地方。</p>\n</div>\n\n<h2 id=\"过渡\"><a href=\"#过渡\" class=\"headerlink\" title=\"过渡\"></a>过渡</h2><h3 id=\"transition-参数-替换\"><a href=\"#transition-参数-替换\" class=\"headerlink\" title=\"transition 参数 替换\"></a><code>transition</code> 参数 <sup>替换</sup></h3><p>Vue 的过渡系统有了彻底的改变，现在通过使用 <code>&lt;transition&gt;</code> 和 <code>&lt;transition-group&gt;</code> 来包裹元素实现过渡效果，而不再使用 <code>transition</code> 属性。详见 <a href=\"transitions.html\">Transitions guide</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。</p>\n</div>\n\n<h3 id=\"可复用的过渡-Vue-transition-替换\"><a href=\"#可复用的过渡-Vue-transition-替换\" class=\"headerlink\" title=\"可复用的过渡 Vue.transition 替换\"></a>可复用的过渡 <code>Vue.transition</code> <sup>替换</sup></h3><p>在新的过渡系统中，可以<a href=\"transitions.html#Reusable-Transitions\">通过模板复用过渡效果</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。</p>\n</div>\n\n<h3 id=\"过渡的-stagger-参数-移除\"><a href=\"#过渡的-stagger-参数-移除\" class=\"headerlink\" title=\"过渡的 stagger 参数 移除\"></a>过渡的 <code>stagger</code> 参数 <sup>移除</sup></h3><p>如果希望在列表渲染中使用渐近过渡，可以通过设置元素的 <code>data-index</code> （或类似属性）来控制时间。 请参考<a href=\"transitions.html#Staggering-List-Transitions\">这个例子</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。升级期间，你可以“过渡”到新的过渡策略。</p>\n</div>\n\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><h3 id=\"events-选项-移除\"><a href=\"#events-选项-移除\" class=\"headerlink\" title=\"events 选项 移除\"></a><code>events</code> 选项 <sup>移除</sup></h3><p><code>events</code> 选项被弃用。事件处理器现在在 <code>created</code> 钩子中被注册。参考详细示例 <a href=\"#dispatch-and-broadcast-deprecated\"><code>$dispatch</code> and <code>$broadcast</code> 迁移指南</a></p>\n<h3 id=\"Vue-directive-39-on-39-keyCodes-替换\"><a href=\"#Vue-directive-39-on-39-keyCodes-替换\" class=\"headerlink\" title=\"Vue.directive(&#39;on&#39;).keyCodes 替换\"></a><code>Vue.directive(&#39;on&#39;).keyCodes</code> <sup>替换</sup></h3><p>新的简明配置 <code>keyCodes</code> 的方式是通过 <code>Vue.config.keyCodes</code>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// v-on:keyup.f1 不可用</span></div><div class=\"line\">Vue.config.keyCodes.f1 = <span class=\"number\">112</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到过时的 <code>keyCode</code> 配置</p>\n</div>\n\n<h3 id=\"dispatch-和-broadcast-替换\"><a href=\"#dispatch-和-broadcast-替换\" class=\"headerlink\" title=\"$dispatch 和 $broadcast 替换\"></a><code>$dispatch</code> 和 <code>$broadcast</code> <sup>替换</sup></h3><p><code>$dispatch</code> 和 <code>$broadcast</code> 已经被弃用。请使用更多简明清晰的组件间通信和更好的状态管理方案，如：<a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">Vuex</a>.</p>\n<p>因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。这种事件方式确实不太好，我们也不希望在以后让开发者们太痛苦。并且<code>$dispatch</code> 和 <code>$broadcast</code> 也没有解决兄弟组件间的通信问题。</p>\n<p>对于<code>$dispatch</code> 和 <code>$broadcast</code>最简单的升级方式就是：通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层。由于 Vue 实例实现了一个事件分发接口，你可以通过实例化一个空的 Vue 实例来实现这个目的。</p>\n<p>这些方法的最常见用途之一是父子组件的相互通信。在这些情况下，你可以使用 <a href=\"components.html#Form-Input-Components-using-Custom-Events\"><code>v-on</code>监听子组件上 $emit 的变化</a>。这可以允许你很方便的添加事件显性。</p>\n<p>然而，如果是跨多层父子组件通信的话， <code>$emit</code> 并没有什么用。相反，用集中式的事件中间件可以做到简单的升级。这会让组件之间的通信非常顺利，即使是兄弟组件。因为 Vue 通过事件发射器接口执行实例，实际上你可以使用一个空的 Vue 实例。</p>\n<p>比如，假设我们有个 todo 的应用结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Todos</div><div class=\"line\">|-- NewTodoInput</div><div class=\"line\">|-- Todo</div><div class=\"line\">    |-- DeleteTodoButton</div></pre></td></tr></table></figure>\n<p>可以通过单独的事件中心管理组件间的通信：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将在各处使用该事件中心</span></div><div class=\"line\"><span class=\"comment\">// 组件通过它来通信</span></div><div class=\"line\"><span class=\"keyword\">var</span> eventHub = <span class=\"keyword\">new</span> Vue()</div></pre></td></tr></table></figure>\n<p>然后在组件中，可以使用 <code>$emit</code>, <code>$on</code>, <code>$off</code> 分别来分发、监听、取消监听事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NewTodoInput</span></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">addTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    eventHub.$emit(<span class=\"string\">'add-todo'</span>, &#123; <span class=\"attr\">text</span>: <span class=\"keyword\">this</span>.newTodoText &#125;)</div><div class=\"line\">    <span class=\"keyword\">this</span>.newTodoText = <span class=\"string\">''</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// DeleteTodoButton</span></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">deleteTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">    eventHub.$emit(<span class=\"string\">'delete-todo'</span>, id)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Todos</span></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">created: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  eventHub.$on(<span class=\"string\">'add-todo'</span>, <span class=\"keyword\">this</span>.addTodo)</div><div class=\"line\">  eventHub.$on(<span class=\"string\">'delete-todo'</span>, <span class=\"keyword\">this</span>.deleteTodo)</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"comment\">// 最好在组件销毁前</span></div><div class=\"line\"><span class=\"comment\">// 清除事件监听</span></div><div class=\"line\">beforeDestroy: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  eventHub.$off(<span class=\"string\">'add-todo'</span>, <span class=\"keyword\">this</span>.addTodo)</div><div class=\"line\">  eventHub.$off(<span class=\"string\">'delete-todo'</span>, <span class=\"keyword\">this</span>.deleteTodo)</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">addTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newTodo</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.todos.push(newTodo)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">deleteTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">todoId</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.todos = <span class=\"keyword\">this</span>.todos.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">todo</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> todo.id !== todoId</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在简单的情况下这样做可以替代 <code>$dispatch</code> 和 <code>$broadcast</code>，但是对于大多数复杂情况，更推荐使用一个专用的状态管理层如：<a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">Vuex</a> 。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找出使用 <code>$dispatch</code> 和 <code>$broadcast</code>的实例。</p>\n</div>\n\n<h2 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h2><h3 id=\"插入文本之外的过滤器-移除\"><a href=\"#插入文本之外的过滤器-移除\" class=\"headerlink\" title=\"插入文本之外的过滤器 移除\"></a>插入文本之外的过滤器 <sup>移除</sup></h3><p>现在过滤器只能用在插入文本中 (<code>{{ }}</code> tags)。我们发现在指令（如：<code>v-model</code>， <code>v-on</code>等）中使用过滤器使事情变得更复杂。像<code>v-for</code> 这样的列表过滤器最好把处理逻辑作为一个计算属性放在js里面，这样就可以在整个模板中复用。</p>\n<p>总之，能在原生js中实现的东西，我们尽量避免引入一个新的符号去重复处理同样的问题。下面是如何替换 Vue 内置过滤器：</p>\n<h4 id=\"替换-debounce-过滤器\"><a href=\"#替换-debounce-过滤器\" class=\"headerlink\" title=\"替换 debounce 过滤器\"></a>替换 <code>debounce</code> 过滤器</h4><p>不再这样写</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup</span>=<span class=\"string\">\"doStuff | debounce 500\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">doStuff</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>请使用 <a href=\"https://lodash.com/docs/4.15.0#debounce\" target=\"_blank\" rel=\"external\">lodash’s <code>debounce</code></a> (也有可能是 <a href=\"https://lodash.com/docs/4.15.0#throttle\" target=\"_blank\" rel=\"external\"><code>throttle</code></a>) 来直接控制高耗任务。可以这样来实现上面的功能：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup</span>=<span class=\"string\">\"doStuff\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">doStuff</span>: _.debounce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;, <span class=\"number\">500</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种写法的更多优点详见： <a href=\"#debounce-Param-Attribute-for-v-model-removed\"><code>v-model</code> 示例</a>.</p>\n<h4 id=\"替换-limitBy-过滤器\"><a href=\"#替换-limitBy-过滤器\" class=\"headerlink\" title=\"替换 limitBy 过滤器\"></a>替换 <code>limitBy</code> 过滤器</h4><p>不再这样写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items | limitBy 10\"</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在 computed 属性中使用js内置方法： <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples\" target=\"_blank\" rel=\"external\"><code>.slice</code> method</a>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in filteredItems\"</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">filteredItems</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items.slice(<span class=\"number\">0</span>, <span class=\"number\">10</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"替换-filterBy-过滤器\"><a href=\"#替换-filterBy-过滤器\" class=\"headerlink\" title=\"替换 filterBy 过滤器\"></a>替换 <code>filterBy</code> 过滤器</h4><p>不再这样写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"user in users | filterBy searchQuery in 'name'\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在 computed 属性中使用js内置方法 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples\" target=\"_blank\" rel=\"external\"><code>.filter</code> method</a>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"user in filteredUsers\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">filteredUsers</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">    <span class=\"keyword\">return</span> self.users.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> user.name.indexOf(self.searchQuery) !== <span class=\"number\">-1</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>js原生的 <code>.filter</code> 同样能实现很多复杂的过滤器操作，因为可以在计算 computed 属性中使用所有js方法。比如，想要通过匹配用户名字和电子邮箱地址（不区分大小写）找到用户：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">self.users.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> searchRegex = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(self.searchQuery, <span class=\"string\">'i'</span>)</div><div class=\"line\">  <span class=\"keyword\">return</span> user.isActive &amp;&amp; (</div><div class=\"line\">    searchRegex.test(user.name) ||</div><div class=\"line\">    searchRegex.test(user.email)</div><div class=\"line\">  )</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"替换-orderBy-过滤器\"><a href=\"#替换-orderBy-过滤器\" class=\"headerlink\" title=\"替换 orderBy 过滤器\"></a>替换 <code>orderBy</code> 过滤器</h4><p>不这样写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"user in users | orderBy 'name'\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>而是在 computed 属性中使用 <a href=\"https://lodash.com/docs/4.15.0#orderBy\" target=\"_blank\" rel=\"external\">lodash’s <code>orderBy</code></a> (或者可能是 <a href=\"https://lodash.com/docs/4.15.0#sortBy\" target=\"_blank\" rel=\"external\"><code>sortBy</code></a>)：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"user in orderedUsers\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">orderedUsers</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> _.orderBy(<span class=\"keyword\">this</span>.users, <span class=\"string\">'name'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>甚至可以字段排序：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">_.orderBy(<span class=\"keyword\">this</span>.users, [<span class=\"string\">'name'</span>, <span class=\"string\">'last_login'</span>], [<span class=\"string\">'asc'</span>, <span class=\"string\">'desc'</span>])</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到指令中使用的过滤器。如果有些没找到，看看<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"过滤器参数符号-变更\"><a href=\"#过滤器参数符号-变更\" class=\"headerlink\" title=\"过滤器参数符号 变更\"></a>过滤器参数符号 <sup>变更</sup></h3><p>现在过滤器参数形式可以更好地与js函数调用方式一致，因此不用再用空格分隔参数：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; date | formatDate 'YY-MM-DD' timeZone &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>现在用圆括号括起来并用逗号分隔：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; date | formatDate('YY-MM-DD', timeZone) &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到老式的调用符号，如果有遗漏，请看<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"内置文本过滤器-移除\"><a href=\"#内置文本过滤器-移除\" class=\"headerlink\" title=\"内置文本过滤器 移除\"></a>内置文本过滤器 <sup>移除</sup></h3><p>尽管插入文本内部的过滤器依然有效，但是所有内置过滤器已经移除了。取代的是，推荐在每个区域使用更专业的库来解决。(比如用 <a href=\"https://date-fns.org/\" target=\"_blank\" rel=\"external\"><code>date-fns</code></a> 来格式化日期，用 <a href=\"http://openexchangerates.github.io/accounting.js/\" target=\"_blank\" rel=\"external\"><code>accounting</code></a> 来格式化货币)。</p>\n<p>对于每个内置过滤器，我们大概总结了下该怎么替换。代码示例可能写在自定义 helper 函数，方法或计算属性中。</p>\n<h4 id=\"替换-json-过滤器\"><a href=\"#替换-json-过滤器\" class=\"headerlink\" title=\"替换 json 过滤器\"></a>替换 <code>json</code> 过滤器</h4><p>不用一个个改，因为Vue已经帮你自动格式化好了，无论是字符串，数字还是数组，对象。如果想用js的 <code>JSON.stringify</code> 功能去实现，你也可以把它写在方法或者计算属性里面。</p>\n<h4 id=\"替换-capitalize-过滤器\"><a href=\"#替换-capitalize-过滤器\" class=\"headerlink\" title=\"替换 capitalize 过滤器\"></a>替换 <code>capitalize</code> 过滤器</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">text[<span class=\"number\">0</span>].toUpperCase() + text.slice(<span class=\"number\">1</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"替换-uppercase-过滤器\"><a href=\"#替换-uppercase-过滤器\" class=\"headerlink\" title=\"替换 uppercase 过滤器\"></a>替换 <code>uppercase</code> 过滤器</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">text.toUpperCase()</div></pre></td></tr></table></figure>\n<h4 id=\"替换-lowercase-过滤器\"><a href=\"#替换-lowercase-过滤器\" class=\"headerlink\" title=\"替换 lowercase 过滤器\"></a>替换 <code>lowercase</code> 过滤器</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">text.toLowerCase()</div></pre></td></tr></table></figure>\n<h4 id=\"替换-pluralize-过滤器\"><a href=\"#替换-pluralize-过滤器\" class=\"headerlink\" title=\"替换 pluralize 过滤器\"></a>替换 <code>pluralize</code> 过滤器</h4><p>NPM 上的 <a href=\"https://www.npmjs.com/package/pluralize\" target=\"_blank\" rel=\"external\">pluralize</a> 库可以很好的实现这个功能。如果仅仅想将特定的词格式化成复数形式或者想给特定的值（’0’）指定特定的输出，也可以很容易地自定义复数格式化过滤器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pluralizeKnife</span> (<span class=\"params\">count</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (count === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'no knives'</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count === <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'1 knife'</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> count + <span class=\"string\">'knives'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Replacing-the-currency-Filter\"><a href=\"#Replacing-the-currency-Filter\" class=\"headerlink\" title=\"Replacing the currency Filter\"></a>Replacing the <code>currency</code> Filter</h4><p>对于简单的问题,可以这样做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'$'</span> + price.toFixed(<span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>大多数情况下，仍然会有奇怪的现象(比如 <code>0.035.toFixed(2)</code> 向上取舍得到 <code>0.04</code>,但是 <code>0.045</code> 向下取舍却也得到 <code>0.04</code>)。解决这些问题可以使用 <a href=\"http://openexchangerates.github.io/accounting.js/\" target=\"_blank\" rel=\"external\"><code>accounting</code></a> 库来实现更多可靠的货币格式化。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到舍弃的过滤器。如果有些遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"Two-Way-Filters-replaced\"><a href=\"#Two-Way-Filters-replaced\" class=\"headerlink\" title=\"Two-Way Filters replaced\"></a>Two-Way Filters <sup>replaced</sup></h3><p>Some users have enjoyed using two-way filters with <code>v-model</code> to create interesting inputs with very little code. While <em>seemingly</em> simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs.</p>\n<p>As an example, we’ll now walk the migration of a two-way currency filter:</p>\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/6744xnjk/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the <code>Result</code> tab and try entering <code>9.999</code> into one of those inputs. When the input loses focus, its value will update to <code>$10.00</code>. When looking at the calculated total however, you’ll see that <code>9.999</code> is what’s stored in our data. The version of reality that the user sees is out of sync!</p>\n<p>To start transitioning towards a more robust solution using Vue 2.0, let’s first wrap this filter in a new <code>&lt;currency-input&gt;</code> component:</p>\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/943zfbsh/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>This allows us add behavior that a filter alone couldn’t encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external <a href=\"https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e\" target=\"_blank\" rel=\"external\"><code>currencyValidator</code> object</a>:</p>\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/9c32kev2/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</p>\n<ul>\n<li>unit tested in isolation from your Vue code</li>\n<li>used by other parts of your application, such as to validate the payload to an API endpoint</li>\n</ul>\n<p>Having this validator extracted out, we’ve also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it’s actually impossible for users to enter anything wrong, similar to what the browser’s native number input tries to do.</p>\n<p>We’re still limited however, by filters and by Vue 1.0 in general, so let’s complete the upgrade to Vue 2.0:</p>\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>You may notice that:</p>\n<ul>\n<li>Every aspect of our input is more explicit, using lifecycle hooks and DOM events in place of the hidden behavior of two-way filters.</li>\n<li>We can now use <code>v-model</code> directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</li>\n<li>Since we’re no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice.</li>\n</ul>\n\n<div class=\"upgrade-path\">\n  <h4>Upgrade Path</h4>\n  <p>Run the<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>on your codebase to find examples of filters used in directives like <code>v-model</code>. If you miss any, you should also see <strong>console errors</strong>.</p>\n</div>\n\n<h2 id=\"Slots\"><a href=\"#Slots\" class=\"headerlink\" title=\"Slots\"></a>Slots</h2><h3 id=\"重名的-Slots-移除\"><a href=\"#重名的-Slots-移除\" class=\"headerlink\" title=\"重名的 Slots 移除\"></a>重名的 Slots <sup>移除</sup></h3><p>同一模板中的重名 <code>&lt;slot&gt;</code> 已经弃用。当一个 slot 已经被渲染过了，那么就不能在同一模板其它地方被再次渲染了。如果要在不同位置渲染同一内容，可一用prop来传递。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>更新后运行测试，查看 <strong>控制台警告信息</strong> 关于重名slots的提示 <code>v-model</code>。</p>\n</div>\n\n<h3 id=\"slot-样式参数-移除\"><a href=\"#slot-样式参数-移除\" class=\"headerlink\" title=\"slot 样式参数 移除\"></a><code>slot</code> 样式参数 <sup>移除</sup></h3><p>通过具名 <code>&lt;slot&gt;</code> 插入的片段不再保持 <code>slot</code> 的参数。请用一个包裹元素来控制样式。或者用更高级方法：通过编程方式修改内容 ：<a href=\"render-function.html\">render functions</a> 。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到选择slots标签CSS选择器(例如： <code>[slot=\"my-slot-name\"]</code>) 。</p>\n</div>\n\n<h2 id=\"特殊属性\"><a href=\"#特殊属性\" class=\"headerlink\" title=\"特殊属性\"></a>特殊属性</h2><h3 id=\"keep-alive-属性-替换\"><a href=\"#keep-alive-属性-替换\" class=\"headerlink\" title=\"keep-alive 属性 替换\"></a><code>keep-alive</code> 属性 <sup>替换</sup></h3><p><code>keep-alive</code> 不再是一个特殊属性而是一个包裹组件，类似于  <code>&lt;transition&gt;</code>比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这样可以在含多种状态子组件中使用 <code>&lt;keep-alive&gt;</code> ：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">todo-list</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"todos.length &gt; 0\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">todo-list</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">no-todos-gif</span> <span class=\"attr\">v-else</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">no-todos-gif</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">当 <code>&lt;keep-alive&gt;</code> 含有不同子组件时，应该分别影响到每一个子组件。不仅是第一个而是所有的子组件都将被忽略。</p>\n\n<p>和 <code>&lt;transition&gt;</code>一起使用时，确保把内容包裹在内：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到<code>keep-alive</code> 属性。</p>\n</div>\n\n<h2 id=\"计算插值todaymark\"><a href=\"#计算插值todaymark\" class=\"headerlink\" title=\"计算插值todaymark\"></a>计算插值todaymark</h2><h3 id=\"属性内部的计算插值-移除\"><a href=\"#属性内部的计算插值-移除\" class=\"headerlink\" title=\"属性内部的计算插值 移除\"></a>属性内部的计算插值 <sup>移除</sup></h3><p>属性内部的计算插值已经不能再使用了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-&#123;&#123; size &#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>应该写成行内表达式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"'btn btn-' + size\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>或者计算属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"buttonClasses\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">buttonClasses</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'btn btn-'</span> + size</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到属性内部的计算插值</p>\n</div>\n\n<h3 id=\"HTML-计算插值-移除\"><a href=\"#HTML-计算插值-移除\" class=\"headerlink\" title=\"HTML 计算插值 移除\"></a>HTML 计算插值 <sup>移除</sup></h3><p>HTML 的计算插值 (<code>{{{ foo }}}</code>) 已经移除，取代的是 <a href=\"../api/#v-html\"><code>v-html</code> 指令</a>.</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到 HTML 计算插值。</p>\n</div>\n\n<h3 id=\"单次绑定替换\"><a href=\"#单次绑定替换\" class=\"headerlink\" title=\"单次绑定替换\"></a>单次绑定<sup>替换</sup></h3><p>单次绑定 (<code>{{* foo }}</code>) 已经被新的 <a href=\"../api/#v-once\"><code>v-once</code> directive</a> 取代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到单次绑定使用位置。</p>\n</div>\n\n<h2 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h2><h3 id=\"vm-watch-changed\"><a href=\"#vm-watch-changed\" class=\"headerlink\" title=\"vm.$watch changed\"></a><code>vm.$watch</code> <sup>changed</sup></h3><p>通过 <code>vm.$watch</code>创建的观察器现在将在组件渲染时被激活。这样可以让你在组件渲染前更新状态，不用做不必要的更新。比如可以通过观察组件的prop变化来更新组件本身的值。</p>\n<p>如果以前通过 <code>vm.$watch</code> 在组件更新后与 DOM 交互，现在就可以通过<code>updated</code>生命周期钩子来做这些。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行测试，如果有依赖于老方法的观察器将弹出 <strong>failed tests</strong>。</p>\n</div>\n\n<h3 id=\"vm-set-变更\"><a href=\"#vm-set-变更\" class=\"headerlink\" title=\"vm.$set 变更\"></a><code>vm.$set</code> <sup>变更</sup></h3><p> <code>vm.$set</code> 只是 <a href=\"../api/#Vue-set\"><code>Vue.set</code></a> 的别名。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到过时的用法</p>\n</div>\n\n<h3 id=\"vm-delete-变更\"><a href=\"#vm-delete-变更\" class=\"headerlink\" title=\"vm.$delete 变更\"></a><code>vm.$delete</code> <sup>变更</sup></h3><p><code>vm.$delete</code> 现在只是： <a href=\"../api/#Vue-delete\"><code>Vue.delete</code></a> 别名。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到过时的用法</p>\n</div>\n\n<h3 id=\"Array-prototype-set-弃用\"><a href=\"#Array-prototype-set-弃用\" class=\"headerlink\" title=\"Array.prototype.$set  弃用\"></a><code>Array.prototype.$set</code>  <sup>弃用</sup></h3><p>用 <code>Vue.set</code> 替代</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到数组上的<code>.$set</code>。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"Array-prototype-remove-移除\"><a href=\"#Array-prototype-remove-移除\" class=\"headerlink\" title=\"Array.prototype.$remove 移除\"></a><code>Array.prototype.$remove</code> <sup>移除</sup></h3><p>用 <code>Array.prototype.splice</code> 替代，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">removeTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">todo</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> index = <span class=\"keyword\">this</span>.todos.indexOf(todo)</div><div class=\"line\">    <span class=\"keyword\">this</span>.todos.splice(index, <span class=\"number\">1</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或者更好的方法，直接给除去的方法一个index参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">removeTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">index</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.todos.splice(index, <span class=\"number\">1</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到数组上的<code>.$remove</code>。如有遗漏请参考<strong>控制台错误信息</strong></p>\n</div>\n\n<h3 id=\"Vue实例上的Vue-set-和-Vue-delete移除\"><a href=\"#Vue实例上的Vue-set-和-Vue-delete移除\" class=\"headerlink\" title=\"Vue实例上的Vue.set 和 Vue.delete移除\"></a>Vue实例上的<code>Vue.set</code> 和 <code>Vue.delete</code><sup>移除</sup></h3><p><code>Vue.set</code> 和 <code>Vue.delete</code> 在实例上将不再起作用。现在都强制在实例的data选项中声明所有顶级响应值。如果删除实例属性或实例<code>$data</code>上的某个值，直接将它设置为null即可。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到实例中的 <code>Vue.set</code> 或 <code>Vue.delete</code> 。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"替换-vm-data-移除\"><a href=\"#替换-vm-data-移除\" class=\"headerlink\" title=\"替换 vm.$data 移除\"></a>替换 <code>vm.$data</code> <sup>移除</sup></h3><p>现在禁止替换实例的 $data。这样防止了响应系统的一些极端情况并且让组件状态更加可控可预测（特别是对于存在类型检查的系统）。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到覆盖 <code>vm.$data</code>的位置。如有遗漏请参考<strong>控制台警告信息</strong>。</p>\n</div>\n\n<h3 id=\"vm-get-移除\"><a href=\"#vm-get-移除\" class=\"headerlink\" title=\"vm.$get 移除\"></a><code>vm.$get</code> <sup>移除</sup></h3><p>可以直接取回响应数据。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到 <code>vm.$get</code> 的位置。如有遗漏请参考 <strong>控制台错误信息</strong>。</p>\n</div>\n\n<h2 id=\"围绕-DOM-的实例方法\"><a href=\"#围绕-DOM-的实例方法\" class=\"headerlink\" title=\"围绕 DOM 的实例方法\"></a>围绕 DOM 的实例方法</h2><h3 id=\"vm-appendTo-移除\"><a href=\"#vm-appendTo-移除\" class=\"headerlink\" title=\"vm.$appendTo 移除\"></a><code>vm.$appendTo</code> <sup>移除</sup></h3><p>使用 DOM 原生方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">myElement.appendChild(vm.$el)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到 <code>vm.$appendTo</code> 的位置。如果有遗漏可以参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"vm-before-移除\"><a href=\"#vm-before-移除\" class=\"headerlink\" title=\"vm.$before 移除\"></a><code>vm.$before</code> <sup>移除</sup></h3><p>使用 DOM 原生方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">myElement.parentNode.insertBefore(vm.$el, myElement)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到 <code>vm.$before</code>。如有遗漏，请参考 <strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"vm-after-移除\"><a href=\"#vm-after-移除\" class=\"headerlink\" title=\"vm.$after 移除\"></a><code>vm.$after</code> <sup>移除</sup></h3><p>使用 DOM 原生方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">myElement.parentNode.insertBefore(vm.$el, myElement.nextSibling)</div></pre></td></tr></table></figure>\n<p>如果 <code>myElement</code> 是最后一个节点也可以这样写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">myElement.parentNode.appendChild(vm.$el)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到 <code>vm.$after</code> 的位置。如有遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"vm-remove-移除\"><a href=\"#vm-remove-移除\" class=\"headerlink\" title=\"vm.$remove 移除\"></a><code>vm.$remove</code> <sup>移除</sup></h3><p>使用 DOM 原生方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$el.remove()</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到<code>vm.$remove</code>。如有遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h2 id=\"底层实例方法\"><a href=\"#底层实例方法\" class=\"headerlink\" title=\"底层实例方法\"></a>底层实例方法</h2><h3 id=\"vm-eval-移除\"><a href=\"#vm-eval-移除\" class=\"headerlink\" title=\"vm.$eval 移除\"></a><code>vm.$eval</code> <sup>移除</sup></h3><p>尽量不要使用，如果必须使用该功能并且不肯定如何使用请参考 <a href=\"http://forum.vuejs.org/\" target=\"_blank\" rel=\"external\">the forum</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到使用 <code>vm.$eval</code> 的位置。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"vm-interpolate-移除\"><a href=\"#vm-interpolate-移除\" class=\"headerlink\" title=\"vm.$interpolate 移除\"></a><code>vm.$interpolate</code> <sup>移除</sup></h3><p>尽量不要使用，如果必须使用该功能并且不肯定如何使用请参考 <a href=\"http://forum.vuejs.org/\" target=\"_blank\" rel=\"external\">the forum</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到<code>vm.$interpolate</code>。如有遗漏请参考<strong>控制台错误信息</strong>.</p>\n</div>\n\n<h3 id=\"vm-log-移除\"><a href=\"#vm-log-移除\" class=\"headerlink\" title=\"vm.$log 移除\"></a><code>vm.$log</code> <sup>移除</sup></h3><p>请使用 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"external\">Vue Devtools</a> 感受最佳debug体验。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到 <code>vm.$log</code>。如有遗漏请参考<strong>控制台错误信息</strong>.</p>\n</div>\n\n<h2 id=\"实例-DOM-选项\"><a href=\"#实例-DOM-选项\" class=\"headerlink\" title=\"实例 DOM 选项\"></a>实例 DOM 选项</h2><h3 id=\"replace-false-移除\"><a href=\"#replace-false-移除\" class=\"headerlink\" title=\"replace: false 移除\"></a><code>replace: false</code> <sup>移除</sup></h3><p>现在组件总是会替换掉他们被绑定的元素。为了模仿<code>replace: false</code>的行为，可以用一个和将要替换元素类似的元素将根组件包裹起来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div id=\"app\"&gt; ... &lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>或者使用渲染函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">h</span>) </span>&#123;</div><div class=\"line\">    h(<span class=\"string\">'div'</span>, &#123;</div><div class=\"line\">      <span class=\"attr\">attrs</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">id</span>: <span class=\"string\">'app'</span>,</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;, <span class=\"comment\">/* ... */</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到 <code>replace: false</code>使用的位置。</p>\n</div>\n\n<h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><h3 id=\"Vue-config-debug-移除\"><a href=\"#Vue-config-debug-移除\" class=\"headerlink\" title=\"Vue.config.debug 移除\"></a><code>Vue.config.debug</code> <sup>移除</sup></h3><p>不再需要，因为警告信息将默认在堆栈信息里输出。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到包含<code>Vue.config.debug</code>的地方。</p>\n</div>\n\n<h3 id=\"Vue-config-async-移除\"><a href=\"#Vue-config-async-移除\" class=\"headerlink\" title=\"Vue.config.async 移除\"></a><code>Vue.config.async</code> <sup>移除</sup></h3><p>异步操作现在需要渲染性能的支持。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到使用<code>Vue.config.async</code>的实例。</p>\n</div>\n\n<h3 id=\"Vue-config-delimiters-替换\"><a href=\"#Vue-config-delimiters-替换\" class=\"headerlink\" title=\"Vue.config.delimiters 替换\"></a><code>Vue.config.delimiters</code> <sup>替换</sup></h3><p>以 <a href=\"../api/#delimiters\">模板选项</a>的方式使用。这样可以在使用自定义分隔符时避免影响第三方模板。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到使用<code>Vue.config.delimiters</code>的实例。</p>\n</div>\n\n<h3 id=\"Vue-config-unsafeDelimiters-移除\"><a href=\"#Vue-config-unsafeDelimiters-移除\" class=\"headerlink\" title=\"Vue.config.unsafeDelimiters 移除\"></a><code>Vue.config.unsafeDelimiters</code> <sup>移除</sup></h3><p>HTML 插入 <a href=\"#HTML-Interpolation-removed\">替换为 <code>v-html</code></a>.</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到 <code>Vue.config.unsafeDelimiters</code>。然后 helper 工具也会找到HTML插入的实例，可以用`v-html`来替换。</p>\n</div>\n\n<h2 id=\"全局-API\"><a href=\"#全局-API\" class=\"headerlink\" title=\"全局 API\"></a>全局 API</h2><h3 id=\"带-el-的-Vue-extend-移除\"><a href=\"#带-el-的-Vue-extend-移除\" class=\"headerlink\" title=\"带 el 的 Vue.extend 移除\"></a>带 <code>el</code> 的 <code>Vue.extend</code> <sup>移除</sup></h3><p>el 选项不再在 <code>Vue.extend</code>中使用。仅在实例创建参数中可用。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>更新后运行测试在<strong>控制台警告信息</strong>中找到关于带有<code>Vue.extend</code>的<code>el</code>。</p>\n</div>\n\n<h3 id=\"Vue-elementDirective-移除\"><a href=\"#Vue-elementDirective-移除\" class=\"headerlink\" title=\"Vue.elementDirective 移除\"></a><code>Vue.elementDirective</code> <sup>移除</sup></h3><p>用组件来替代</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到包含<code>Vue.elementDirective</code>的实例。</p>\n</div>\n\n<h3 id=\"Vue-partial-移除\"><a href=\"#Vue-partial-移除\" class=\"headerlink\" title=\"Vue.partial 移除\"></a><code>Vue.partial</code> <sup>移除</sup></h3><p>Partials 已被移除,取而代之的是更明确的组件之间的数据流–props。除非你正在使用一个部分性能关键型区域，否则建议只使用一个<a href=\"components.html\">normal component</a>来代替。如果你是动态绑定部分的<code>name</code>,您可以使用<a href=\"components.html#Dynamic-Components\">dynamic component</a>。</p>\n<p>如果你碰巧在你的应用程序的性能关键部分使用<code>partials</code>，那么你应该升级到<a href=\"render-function.html#Functional-Components\">functional components</a>。它们必须在纯JS / JSX文件中（而不是在<code>.vue</code>文件中），并且是无状态的和无实例的，就像<code>partials</code>。这使得渲染极快。</p>\n<p><code>functional components</code>相对于<code>partials</code>一个好处是它们可以更具动态性，因为它们允许您访问JavaScript的全部功能。然而，这是有成本的。如果你从来没有使用过渲染式的组件框架，你可能需要花费更长的时间来学习它们。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\" target=\"_blank\" rel=\"external\">迁移工具</a>找到包含 <code>Vue.partial</code>的实例</p>\n</div>\n\n<hr>\n<blockquote>\n<p>原文： http:/   /vuejs.org/guide/migration.html</p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h2><blockquote>\n<p>哇，非常长的一页！是否意味着 Vue 2.0 已经完全不同了呢，是否需要从头学起呢，Vue 1.0 的项目是不是没法迁移了？</p>\n</blockquote>\n<p>非常开心地告诉你，并不是！几乎 90% 的 API 和核心概念都没有变。因为本节包含了很多详尽的阐述以及许多迁移的例子，所以显得有点长。不用担心，<strong>你不必从头到尾把本节读一遍！</strong></p>\n<blockquote>\n<p>我该从哪里开始项目迁移呢？</p>\n</blockquote>\n<ol>\n<li><p>首先，在当前项目下运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>。我们非常谨慎地把高级 Vue 升级过程简化为使用一个简单的命令行工具。当工具识别出旧有的特性后，就会告知你并给出建议，同时附上关于详细信息的链接。</p>\n</li>\n<li><p>然后，浏览本页面的侧边栏列出的内容。如果发现有的标题对你的项目有影响，但是迁移工具没有给出提示，请检查自己的项目。</p>\n</li>\n<li><p>如果你的项目有测试代码，运行并查看仍然失败的地方。如果没有测试代码，在浏览器中打开你的程序，通过导航环顾并留意那些报错或警告信息。</p>\n</li>\n<li><p>现在，你的应用程序应该已彻底完成迁移。如果你渴望了解更多，可以阅读本页面剩余部分 - 或者从<a href=\"index.html\">介绍</a>部分，从头开始深入新的文档和改进过的指南。由于你已经熟悉一些核心概念，所以许多部分已经被删除掉。</p>\n</li>\n</ol>\n<blockquote>\n<p>将 Vue 1.x 版本的应用程序迁移到 2.0 要花多长时间？</p>\n</blockquote>\n<p>这取决于几个因素：</p>\n<ul>\n<li><p>取决于你应用程序的规模（中小型的基本上一天内就可以搞定）。</p>\n</li>\n<li><p>取决于你分心和开始 2.0 最酷的新功能的次数。 😉 &nbsp;无法判断时间，我们构建 2.0 应用的时候也经常发生这种事！</p>\n</li>\n<li><p>取决于你使用了哪些旧有的特性。大部分可以通过查找和替换(find-and-replace)来实现升级，但有一些可能还是要花点时间。如果你没有遵循最佳实践，Vue 2.0 会尽力强迫你去遵循。这有利于项目的长期运行，但也可能意味着重大重构（尽管有些需要重构的部分可能已经过时）。</p>\n</li>\n</ul>\n<blockquote>\n<p>如果我升级到到 Vue 2 ，我还必须同时升级 Vuex 和 Vue-Router？</p>\n</blockquote>\n<p>只有 Vue-Router 2 与 Vue 2 保持兼容，所以 Vue-Router 是需要升级的，你必须遵循 <a href=\"migration-vue-router.html\">Vue-Router 迁移方式</a>来处理。幸运的是， 大多数应用没有很多 router 相关代码，所以迁移可能不会超过一个小时。</p>\n<p>对于 Vuex ，版本 0.8+ 与 Vue 2 保持兼容，所以部分不必强制升级。可以促使你立即升级的唯一理由，是你想要使用那些 Vuex 2 中新的高级特性，比如模块(modules)和减少的样板文件(reduced boilerplate)。</p>\n<h2 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h2><h3 id=\"片段实例-移除\"><a href=\"#片段实例-移除\" class=\"headerlink\" title=\"片段实例 移除\"></a>片段实例 <sup>移除</sup></h3><p>每个组件必须只有一个根元素。不再允许片段实例，如果你有这样的模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>foo<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>最好把整个内容都简单包裹到一个新的元素里，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>foo<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>升级后运行端到端测试套件(end-to-end test suite)或运行应用程序，并查看<strong>控制台警告(console warnings)</strong>来找出那些模板中有多个根元素的地方。\n</div>\n\n<h2 id=\"生命周期钩子函数\"><a href=\"#生命周期钩子函数\" class=\"headerlink\" title=\"生命周期钩子函数\"></a>生命周期钩子函数</h2><h3 id=\"beforeCompile-移除\"><a href=\"#beforeCompile-移除\" class=\"headerlink\" title=\"beforeCompile 移除\"></a><code>beforeCompile</code> <sup>移除</sup></h3><p>使用 <code>created</code> 钩子函数替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h3 id=\"compiled-替换\"><a href=\"#compiled-替换\" class=\"headerlink\" title=\"compiled 替换\"></a><code>compiled</code> <sup>替换</sup></h3><p>使用 <code>mounted</code> 钩子函数替代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h3 id=\"attached-移除\"><a href=\"#attached-移除\" class=\"headerlink\" title=\"attached 移除\"></a><code>attached</code> <sup>移除</sup></h3><p>使用其他钩子函数内置的 DOM 检测(DOM check)方法。例如，替换如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">attached: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  doSomething()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以这样使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    doSomething()</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h3 id=\"detached-移除\"><a href=\"#detached-移除\" class=\"headerlink\" title=\"detached 移除\"></a><code>detached</code> <sup>移除</sup></h3><p>使用其他钩子函数内的 DOM 检测(DOM check)方法。例如，替换如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">detached: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  doSomething()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以这样使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">destroyed: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    doSomething()</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h3 id=\"init-重新命名\"><a href=\"#init-重新命名\" class=\"headerlink\" title=\"init 重新命名\"></a><code>init</code> <sup>重新命名</sup></h3><p>使用新的 <code>beforeCreate</code> 钩子函数替代，本质上 beforeCreate 和 init 完全相同。init 被重新命名是为了和其他的生命周期方法的命名方式保持一致。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h3 id=\"ready-替换\"><a href=\"#ready-替换\" class=\"headerlink\" title=\"ready 替换\"></a><code>ready</code> <sup>替换</sup></h3><p>使用新的 <code>mounted</code> 钩子函数替代。应该注意的是，使用 <code>mounted</code> 并不能保证钩子函数中的 this.$el 在 document 中。为此还应该引入 <code>Vue.nextTick</code>/<code>vm.$nextTick</code>。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 代码保证 this.$el 在 document 中</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出所有使用此钩子函数的示例。</p>\n</div>\n\n<h2 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a><code>v-for</code></h2><h3 id=\"v-for-遍历数组时的参数顺序-变更\"><a href=\"#v-for-遍历数组时的参数顺序-变更\" class=\"headerlink\" title=\"v-for 遍历数组时的参数顺序 变更\"></a><code>v-for</code> 遍历数组时的参数顺序 <sup>变更</sup></h3><p>当包含 <code>index</code> 时，之前遍历数组时的参数顺序是 <code>(index, value)</code>。现在是 <code>(value, index)</code> ，来和 JavaScript 的原生数组方法（例如 <code>forEach</code> 和 <code>map</code>）保持一致。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出那些使用旧有参数顺序的示例。注意，如果你将你的 index 参数命名为一些不通用的名字（例如 <code>position</code> 或 <code>num</code>），迁移工具将不会把它们标记出来。</p>\n</div>\n\n<h3 id=\"v-for-遍历对象时的参数顺序-变更\"><a href=\"#v-for-遍历对象时的参数顺序-变更\" class=\"headerlink\" title=\"v-for 遍历对象时的参数顺序 变更\"></a><code>v-for</code> 遍历对象时的参数顺序 <sup>变更</sup></h3><p>当包含 <code>key</code> 时，之前遍历对象的参数顺序是 <code>(key, value)</code>。现在是 <code>(value, key)</code>，来和常见的对象迭代器（例如 lodash）保持一致。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出那些使用旧有参数顺序的示例。注意，如果你将你的 key 参数命名为一些不通用的名字（例如 <code>name</code> 或 <code>property</code>），迁移工具将不会把它们标记出来。</p>\n</div>\n\n<h3 id=\"index-and-key-移除\"><a href=\"#index-and-key-移除\" class=\"headerlink\" title=\"$index and $key 移除\"></a><code>$index</code> and <code>$key</code> <sup>移除</sup></h3><p>已经移除了 <code>$index</code> 和 <code>$key</code> 这两个隐式声明变量，以便在 <code>v-for</code> 中显式定义。这可以使没有太多 Vue 开发经验的开发者更好地阅读代码，并且在处理嵌套循环时也能产生更清晰的行为。<br>\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出使用这些移除变量的示例。如果你没有找到，也可以在<strong>控制台错误</strong>中查找（例如 <code>Uncaught ReferenceError: $index is not defined</code>）。</p>\n</div>\n</p>\n<h3 id=\"track-by-替换\"><a href=\"#track-by-替换\" class=\"headerlink\" title=\"track-by 替换\"></a><code>track-by</code> <sup>替换</sup></h3><p><code>track-by</code> 已经替换为 <code>key</code>，它的工作方式与其他属性一样，没有 <code>v-bind</code> 或者 <code>:</code> 前缀，它会被作为一个字符串处理。多数情况下，你需要使用具有完整表达式的动态绑定(dynamic binding)来替换静态的 key。例如，替换：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">track-by</span>=<span class=\"string\">\"id\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你现在应该写为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>来找出那些使用<code>track-by</code>的示例。</p>\n</div>\n\n<h3 id=\"v-for-范围值-变更\"><a href=\"#v-for-范围值-变更\" class=\"headerlink\" title=\"v-for 范围值 变更\"></a><code>v-for</code> 范围值 <sup>变更</sup></h3><p>之前，<code>v-for=&quot;number in 10&quot;</code> 的 <code>number</code> 从 0 开始到 9 结束，现在从 1 开始，到 10 结束。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>在代码库中使用正则 <code>/\\w+ in \\d+/</code>搜索。当出现在 <code>v-for</code> 中，请检查是否受到影响。</p>\n</div>\n\n<h2 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h2><h3 id=\"coerce-Prop的参数-移除\"><a href=\"#coerce-Prop的参数-移除\" class=\"headerlink\" title=\"coerce Prop的参数 移除\"></a><code>coerce</code> Prop的参数 <sup>移除</sup></h3><p>如果需要检查 prop 的值，创建一个内部的 computed 值，而不再在 props 内部去定义，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">props: &#123;</div><div class=\"line\">  <span class=\"attr\">username</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">type</span>: <span class=\"built_in\">String</span>,</div><div class=\"line\">    <span class=\"attr\">coerce</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> value</div><div class=\"line\">        .toLowerCase()</div><div class=\"line\">        .replace(<span class=\"regexp\">/\\s+/</span>, <span class=\"string\">'-'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在应该写为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">props: &#123;</div><div class=\"line\">  <span class=\"attr\">username</span>: <span class=\"built_in\">String</span>,</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">normalizedUsername</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.username</div><div class=\"line\">      .toLowerCase()</div><div class=\"line\">      .replace(<span class=\"regexp\">/\\s+/</span>, <span class=\"string\">'-'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样有一些好处：</p>\n<ul>\n<li>你可以对保持原始 prop 值的操作权限。</li>\n<li>通过给予验证后的值一个不同的命名，强制开发者使用显式申明。</li>\n</ul>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出包含 <code>coerce</code> 选项的实例。</p>\n</div>\n\n<h3 id=\"twoWay-Prop-的参数-移除\"><a href=\"#twoWay-Prop-的参数-移除\" class=\"headerlink\" title=\"twoWay Prop 的参数 移除\"></a><code>twoWay</code> Prop 的参数 <sup>移除</sup></h3><p>Props 现在只能单项传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。详见：</p>\n<ul>\n<li><a href=\"components.html#Custom-Events\">自定义组件事件</a></li>\n<li><a href=\"components.html#Form-Input-Components-using-Custom-Events\">自定义输入组件</a> (使用组件事件)</li>\n<li><a href=\"state-management.html\">全局状态管理</a></li>\n</ul>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>，找出含有 <code>twoWay</code> 参数的实例。</p>\n</div>\n\n<h3 id=\"v-bind-的-once和-sync-修饰符-移除\"><a href=\"#v-bind-的-once和-sync-修饰符-移除\" class=\"headerlink\" title=\"v-bind 的 .once和.sync 修饰符 移除\"></a><code>v-bind</code> 的 <code>.once</code>和<code>.sync</code> 修饰符 <sup>移除</sup></h3><p>Props 现在只能单向传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。详见：</p>\n<ul>\n<li><a href=\"components.html#Custom-Events\">自定义组件事件</a></li>\n<li><a href=\"components.html#Form-Input-Components-using-Custom-Events\">自定义输入组件</a> (使用组件事件)</li>\n<li><a href=\"state-management.html\">全局状态管理</a></li>\n</ul>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>.once</code> 和 <code>.sync</code> 修饰符的实例。</p>\n</div>\n\n<h3 id=\"修改-Props-弃用\"><a href=\"#修改-Props-弃用\" class=\"headerlink\" title=\"修改 Props 弃用\"></a>修改 Props <sup>弃用</sup></h3><p>组件内修改 prop 是反模式（不推荐的）的。比如，先声明一个 prop ，然后在组件中通过 <code>this.myProp = &#39;someOtherValue&#39;</code> 改变 prop 的值。根据渲染机制，当父组件重新渲染时，子组件的内部 prop 值也将被覆盖。</p>\n<p>大多数情况下，改变 prop 值可以用以下选项替代：</p>\n<ul>\n<li>通过 data 属性，用prop去设置一个data属性的默认值。</li>\n<li>通过 computed 属性。</li>\n</ul>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，查看关于 prop 修改的<strong>控制台警告信息</strong>。</p>\n</div>\n\n<h3 id=\"根实例的-Props-替换\"><a href=\"#根实例的-Props-替换\" class=\"headerlink\" title=\"根实例的 Props 替换\"></a>根实例的 Props <sup>替换</sup></h3><p>对于一个根实例来说 (比如：用 <code>new Vue({ ... })</code> 创建的实例)，只能用 <code>propsData</code> 而不是 <code>props</code> 。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，将会弹出 <strong>failed tests</strong> 来通知你使用 <code>props</code> 的根实例已经失效。</p>\n</div>\n\n<h2 id=\"Built-In-指令\"><a href=\"#Built-In-指令\" class=\"headerlink\" title=\"Built-In 指令\"></a>Built-In 指令</h2><h3 id=\"v-bind-真-假值-变更\"><a href=\"#v-bind-真-假值-变更\" class=\"headerlink\" title=\"v-bind 真/假值 变更\"></a><code>v-bind</code> 真/假值 <sup>变更</sup></h3><p>在2.0中使用 <code>v-bind</code> 时，只有 <code>null</code>, <code>undefined</code> , 和 <code>false</code> 被看作是假。这意味着，<code>0</code> 和空字符串将被作为真值渲染。比如 <code>v-bind:draggable=&quot;&#39;&#39;&quot;</code> 将被渲染为 <code>draggable=&quot;true&quot;</code>。</p>\n<p>对于枚举属性，除了以上假值之外，字符串 <code>&quot;false&quot;</code> 也会被渲染为 <code>attr=&quot;false&quot;</code>。</p>\n<p class=\"tip\">注意，对于其它钩子函数 (如 <code>v-if</code> 和 <code>v-show</code>)， 他们依然遵循 js 对真假值判断的一般规则。</p>\n\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端到端测试，如果你app的任何部分有可能被这个升级影响到，将会弹出<strong>failed tests</strong></p>\n</div>\n\n<h3 id=\"用-v-on-监听原生事件-变更\"><a href=\"#用-v-on-监听原生事件-变更\" class=\"headerlink\" title=\"用 v-on 监听原生事件 变更\"></a>用 <code>v-on</code> 监听原生事件 <sup>变更</sup></h3><p>  现在在组件上使用 <code>v-on</code> 只会监听自定义事件（组件用 <code>$emit</code> 触发的事件）。如果要监听根元素的原生事件，可以使用 <code>.native</code> 修饰符，比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-on:click.native</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行端对端测试，如果你app的任何部分有可能被这个升级影响到，将会弹出<strong>failed tests</strong> </p>\n</div>\n\n<h3 id=\"带有-debounce-的-v-model移除\"><a href=\"#带有-debounce-的-v-model移除\" class=\"headerlink\" title=\"带有 debounce 的 v-model移除\"></a>带有 <code>debounce</code> 的 <code>v-model</code><sup>移除</sup></h3><p>Debouncing 曾经被用来控制 Ajax 请求及其它高耗任务的频率。 Vue 中<code>v-model</code>的 <code>debounce</code> 属性参数使得在一些简单情况下非常容易实现这种控制。但实际上，这是控制了 <strong>状态更新</strong> 的频率，而不是控制高耗时任务本身。这是个微小的差别，但是会随着应用增长而显现出局限性。</p>\n<p>例如在设计一个搜索提示时的局限性：</p>\n\n<script src=\"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js\"></script>\n<div id=\"debounce-search-demo\" class=\"demo\">\n  <input v-model=\"searchQuery\" placeholder=\"Type something\">\n  <strong>{{ searchIndicator }}</strong>\n</div>\n<script>\nnew Vue({\n  el: '#debounce-search-demo',\n  data: {\n    searchQuery: '',\n    searchQueryIsDirty: false,\n    isCalculating: false\n  },\n  computed: {\n    searchIndicator: function () {\n      if (this.isCalculating) {\n        return '⟳ Fetching new results'\n      } else if (this.searchQueryIsDirty) {\n        return '... Typing'\n      } else {\n        return '✓ Done'\n      }\n    }\n  },\n  watch: {\n    searchQuery: function () {\n      this.searchQueryIsDirty = true\n      this.expensiveOperation()\n    }\n  },\n  methods: {\n    expensiveOperation: _.debounce(function () {\n      this.isCalculating = true\n      setTimeout(function () {\n        this.isCalculating = false\n        this.searchQueryIsDirty = false\n      }.bind(this), 1000)\n    }, 500)\n  }\n})\n</script>\n\n<p>使用 <code>debounce</code> 参数，便无法观察 “Typing” 的状态。因为无法对输入状态进行实时检测。然而，通过将 <code>debounce</code> 与 Vue 解耦，可以仅仅只延迟我们想要控制的操作，从而避开这些局限性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!--</div><div class=\"line\">通过使用lodash或者其它库的debounce函数，</div><div class=\"line\">我们相信 debounce 实现是一流的，</div><div class=\"line\">并且可以随处使用它，不仅仅是在模板中。</div><div class=\"line\">--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"debounce-search-demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"searchQuery\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Type something\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span>&#123;&#123; searchIndicator &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#debounce-search-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">searchQuery</span>: <span class=\"string\">''</span>,</div><div class=\"line\">    <span class=\"attr\">searchQueryIsDirty</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">isCalculating</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">searchIndicator</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isCalculating) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'⟳ Fetching new results'</span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.searchQueryIsDirty) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'... Typing'</span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'✓ Done'</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">searchQuery</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.searchQueryIsDirty = <span class=\"literal\">true</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.expensiveOperation()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 这是 debounce 实现的地方。</span></div><div class=\"line\">    expensiveOperation: _.debounce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.isCalculating = <span class=\"literal\">true</span></div><div class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.isCalculating = <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.searchQueryIsDirty = <span class=\"literal\">false</span></div><div class=\"line\">      &#125;.bind(<span class=\"keyword\">this</span>), <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;, <span class=\"number\">500</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这种方式的另外一个优点是：当包裹函数执行时间与延时时间相当时，将会等待较长时间。比如，当给出搜索建议时，要等待用户输入停止一段时间后才给出建议，这个体验非常差。其实，这时候更适合用 <strong>throttling</strong> 函数。因为现在你可以自由的使用类似 lodash 之类的库，所以很快就可以用 throttling 重构项目。</p>\n\n<div class=\"upgrade-path\">\n  <h4>Upgrade Path</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出使用 <code>debounce</code> 参数的 实例。</p>\n</div>\n\n<h3 id=\"使用-lazy-或者-number-参数的-v-model-。-替换\"><a href=\"#使用-lazy-或者-number-参数的-v-model-。-替换\" class=\"headerlink\" title=\"使用 lazy 或者 number 参数的 v-model 。 替换\"></a>使用 <code>lazy</code> 或者 <code>number</code> 参数的 <code>v-model</code> 。 <sup>替换</sup></h3><p><code>lazy</code> 和 <code>number</code> 参数现在以修饰符的形式使用，这样看起来更加清晰，而不是这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">lazy</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">number</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>现在写成这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.lazy</span>=<span class=\"string\">\"name\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到这些弃用参数。</p>\n</div>\n\n<h3 id=\"使用内联-value的v-model-移除\"><a href=\"#使用内联-value的v-model-移除\" class=\"headerlink\" title=\"使用内联 value的v-model  移除\"></a>使用内联 <code>value</code>的<code>v-model</code>  <sup>移除</sup></h3><p><code>v-model</code> 不再以内联 <code>value</code> 方式初始化的初值了，显然他将以实例的 data 相应的属性作为真正的初值。</p>\n<p>这意味着以下元素：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"foo\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在data选项中有下面写法的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">data: &#123;</div><div class=\"line\">  <span class=\"attr\">text</span>: <span class=\"string\">'bar'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>将渲染 model 为 ‘bar’ 而不是 ‘foo’ 。同样，对 <code>&lt;textarea&gt;</code> 已有的值来说：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"text\"</span>&gt;</span></div><div class=\"line\">  hello world</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>必须保证 <code>text</code> 初值为 “hello world”</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>升级后运行端对端测试，注意关于<code>v-model</code>内联参数的 <strong>console warnings</strong></p>\n</div>\n\n<h3 id=\"v-model-with-v-for-Iterated-Primitive-Values-移除\"><a href=\"#v-model-with-v-for-Iterated-Primitive-Values-移除\" class=\"headerlink\" title=\"v-model with v-for Iterated Primitive Values 移除\"></a><code>v-model</code> with <code>v-for</code> Iterated Primitive Values <sup>移除</sup></h3><p>像这样的写法将失效：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"str in strings\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"str\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>因为 <code>&lt;input&gt;</code> 将被编译成类似下面的 js 代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">strings.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'input'</span>, ...)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样，<code>v-model</code> 的双向绑定在这里就失效了。把 <code>str</code> 赋值给迭代器里的另一个值也没有用，因为它仅仅是函数内部的一个变量。</p>\n<p>替代方案是，你可以使用对象数组，这样<code>v-model</code> 就可以同步更新对象里面的字段了，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"obj in objects\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"obj.str\"</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行测试，如果你的 app 有地方被这个更新影响到的话将会弹出<strong>failed tests</strong>提示。</p>\n</div>\n\n<h3 id=\"带有-important-的v-bind-style-移除\"><a href=\"#带有-important-的v-bind-style-移除\" class=\"headerlink\" title=\"带有 !important 的v-bind:style  移除\"></a>带有 <code>!important</code> 的<code>v-bind:style</code>  <sup>移除</sup></h3><p>这样写将失效：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"&#123; color: myColor + ' !important' &#125;\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果确实需要覆盖其它的 <code>!important</code>，最好用字符串形式去写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"'color: ' + myColor + ' !important'\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\"> 迁移帮助工具。</a>找到含有 <code>!important</code> 的style绑定对象。</p>\n</div>\n\n<h3 id=\"v-el-和v-ref-替换\"><a href=\"#v-el-和v-ref-替换\" class=\"headerlink\" title=\"v-el 和v-ref 替换\"></a><code>v-el</code> 和<code>v-ref</code> <sup>替换</sup></h3><p>简单起见， <code>v-el</code> 和 <code>v-ref</code> 合并为一个 <code>ref</code> 属性了，可以在组件实例中通过 <code>$refs</code> 来调用。这意味着 <code>v-el:my-element</code> 将写成这样： <code>ref=&quot;myElement&quot;</code>， <code>v-ref:my-component</code> 变成了这样： <code>ref=&quot;myComponent&quot;</code>。绑定在一般元素上时，<code>ref</code> 指DOM元素，绑定在组件上时，<code>ref</code> 为一组件实例。<br>因为 <code>v-ref</code> 不再是一个指令了而是一个特殊的属性，它也可以被动态定义了。这样在和<code>v-for</code> 结合的时候是很有用的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">v-bind:ref</span>=<span class=\"string\">\"'item' + item.id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>以前 <code>v-el</code>/<code>v-ref</code> 和 <code>v-for</code> 一起使用将产生一个DOM数组或者组件数组，因为没法给每个元素一个特定名字。现在你还仍然可以这样做，给每个元素一个同样的<code>ref</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>和 1.x 中不同， <code>$refs</code> 不是响应的，因为它们在渲染过程中注册/更新。只有监听变化并重复渲染才能使它们响应。</p>\n<p>另一方面，设计<code>$refs</code>主要是提供给 js 程序访问的，并不建议在模板中过度依赖使用它。因为这意味着在实例之外去访问实例状态，违背了 Vue 数据驱动的思想。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出实例中的 <code>v-el</code> 和 <code>v-ref</code> 。</p>\n</div>\n\n<h3 id=\"v-show后面使用v-else-移除\"><a href=\"#v-show后面使用v-else-移除\" class=\"headerlink\" title=\"v-show后面使用v-else 移除\"></a><code>v-show</code>后面使用<code>v-else</code> <sup>移除</sup></h3><p><code>v-else</code> 不能再跟在 <code>v-show</code>后面使用。请在<code>v-if</code>的否定分支中使用<code>v-show</code>来替代。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"foo\"</span>&gt;</span>Foo<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"bar\"</span>&gt;</span>Not foo, but bar<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>现在应该写出这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"foo\"</span>&gt;</span>Foo<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"!foo &amp;&amp; bar\"</span>&gt;</span>Not foo, but bar<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出实例中存在的 <code>v-else</code> 以及 <code>v-show</code>。</p>\n</div>\n\n<h2 id=\"自定义指令-简化\"><a href=\"#自定义指令-简化\" class=\"headerlink\" title=\"自定义指令 简化\"></a>自定义指令 <sup>简化</sup></h2><p>在新版中，指令的使用范围已经大大减小了：现在指令仅仅被用于低级的 DOM 操作。大多数情况下，最好是把模板作为代码复用的抽象层。</p>\n<p>显要的改变有如下几点：</p>\n<ul>\n<li>指令不再拥有实例。意思是，在指令的钩子函数中不再拥有实例的 <code>this</code> 。替代的是，你可以在参数中接受你需要的任何数据。如果确实需要，可以通过 <code>el</code> 来访问实例。</li>\n<li>类似 <code>acceptStatement</code> ，<code>deep</code> ， <code>priority</code> 等都已被弃用。为了替换<code>双向</code>指令，见 <a href=\"#Two-Way-Filters-deprecated\">示例</a>。</li>\n<li>现在有些钩子的意义和以前不一样了，并且多了两个钩子函数。</li>\n</ul>\n<p>幸运的是，新钩子更加简单，更加容易掌握。详见 <a href=\"custom-directive.html\">自定义指令指南</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到定义指令的地方。在 helper 工具会把这些地方标记出来，因为很有可能这些地方需要重构。</p>\n</div>\n\n<h3 id=\"指令-literal-修饰符-移除\"><a href=\"#指令-literal-修饰符-移除\" class=\"headerlink\" title=\"指令 .literal 修饰符 移除\"></a>指令 <code>.literal</code> 修饰符 <sup>移除</sup></h3><p><code>.literal</code> 修饰符已经被移除，为了获取一样的功能，可以简单地提供字符串修饰符作为值。</p>\n<p>示例，如下更改：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;p v-my-directive.literal=<span class=\"string\">\"foo bar baz\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<p>只是：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-my-directive</span>=<span class=\"string\">\"'foo bar baz'\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到实例中使用 `.literal` 修饰符的地方。</p>\n</div>\n\n<h2 id=\"过渡\"><a href=\"#过渡\" class=\"headerlink\" title=\"过渡\"></a>过渡</h2><h3 id=\"transition-参数-替换\"><a href=\"#transition-参数-替换\" class=\"headerlink\" title=\"transition 参数 替换\"></a><code>transition</code> 参数 <sup>替换</sup></h3><p>Vue 的过渡系统有了彻底的改变，现在通过使用 <code>&lt;transition&gt;</code> 和 <code>&lt;transition-group&gt;</code> 来包裹元素实现过渡效果，而不再使用 <code>transition</code> 属性。详见 <a href=\"transitions.html\">Transitions guide</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。</p>\n</div>\n\n<h3 id=\"可复用的过渡-Vue-transition-替换\"><a href=\"#可复用的过渡-Vue-transition-替换\" class=\"headerlink\" title=\"可复用的过渡 Vue.transition 替换\"></a>可复用的过渡 <code>Vue.transition</code> <sup>替换</sup></h3><p>在新的过渡系统中，可以<a href=\"transitions.html#Reusable-Transitions\">通过模板复用过渡效果</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。</p>\n</div>\n\n<h3 id=\"过渡的-stagger-参数-移除\"><a href=\"#过渡的-stagger-参数-移除\" class=\"headerlink\" title=\"过渡的 stagger 参数 移除\"></a>过渡的 <code>stagger</code> 参数 <sup>移除</sup></h3><p>如果希望在列表渲染中使用渐近过渡，可以通过设置元素的 <code>data-index</code> （或类似属性）来控制时间。 请参考<a href=\"transitions.html#Staggering-List-Transitions\">这个例子</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>transition</code> 属性的地方。升级期间，你可以“过渡”到新的过渡策略。</p>\n</div>\n\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><h3 id=\"events-选项-移除\"><a href=\"#events-选项-移除\" class=\"headerlink\" title=\"events 选项 移除\"></a><code>events</code> 选项 <sup>移除</sup></h3><p><code>events</code> 选项被弃用。事件处理器现在在 <code>created</code> 钩子中被注册。参考详细示例 <a href=\"#dispatch-and-broadcast-deprecated\"><code>$dispatch</code> and <code>$broadcast</code> 迁移指南</a></p>\n<h3 id=\"Vue-directive-39-on-39-keyCodes-替换\"><a href=\"#Vue-directive-39-on-39-keyCodes-替换\" class=\"headerlink\" title=\"Vue.directive(&#39;on&#39;).keyCodes 替换\"></a><code>Vue.directive(&#39;on&#39;).keyCodes</code> <sup>替换</sup></h3><p>新的简明配置 <code>keyCodes</code> 的方式是通过 <code>Vue.config.keyCodes</code>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// v-on:keyup.f1 不可用</span></div><div class=\"line\">Vue.config.keyCodes.f1 = <span class=\"number\">112</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到过时的 <code>keyCode</code> 配置</p>\n</div>\n\n<h3 id=\"dispatch-和-broadcast-替换\"><a href=\"#dispatch-和-broadcast-替换\" class=\"headerlink\" title=\"$dispatch 和 $broadcast 替换\"></a><code>$dispatch</code> 和 <code>$broadcast</code> <sup>替换</sup></h3><p><code>$dispatch</code> 和 <code>$broadcast</code> 已经被弃用。请使用更多简明清晰的组件间通信和更好的状态管理方案，如：<a href=\"https://github.com/vuejs/vuex\">Vuex</a>.</p>\n<p>因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。这种事件方式确实不太好，我们也不希望在以后让开发者们太痛苦。并且<code>$dispatch</code> 和 <code>$broadcast</code> 也没有解决兄弟组件间的通信问题。</p>\n<p>对于<code>$dispatch</code> 和 <code>$broadcast</code>最简单的升级方式就是：通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层。由于 Vue 实例实现了一个事件分发接口，你可以通过实例化一个空的 Vue 实例来实现这个目的。</p>\n<p>这些方法的最常见用途之一是父子组件的相互通信。在这些情况下，你可以使用 <a href=\"components.html#Form-Input-Components-using-Custom-Events\"><code>v-on</code>监听子组件上 $emit 的变化</a>。这可以允许你很方便的添加事件显性。</p>\n<p>然而，如果是跨多层父子组件通信的话， <code>$emit</code> 并没有什么用。相反，用集中式的事件中间件可以做到简单的升级。这会让组件之间的通信非常顺利，即使是兄弟组件。因为 Vue 通过事件发射器接口执行实例，实际上你可以使用一个空的 Vue 实例。</p>\n<p>比如，假设我们有个 todo 的应用结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Todos</div><div class=\"line\">|-- NewTodoInput</div><div class=\"line\">|-- Todo</div><div class=\"line\">    |-- DeleteTodoButton</div></pre></td></tr></table></figure>\n<p>可以通过单独的事件中心管理组件间的通信：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将在各处使用该事件中心</span></div><div class=\"line\"><span class=\"comment\">// 组件通过它来通信</span></div><div class=\"line\"><span class=\"keyword\">var</span> eventHub = <span class=\"keyword\">new</span> Vue()</div></pre></td></tr></table></figure>\n<p>然后在组件中，可以使用 <code>$emit</code>, <code>$on</code>, <code>$off</code> 分别来分发、监听、取消监听事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NewTodoInput</span></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">addTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    eventHub.$emit(<span class=\"string\">'add-todo'</span>, &#123; <span class=\"attr\">text</span>: <span class=\"keyword\">this</span>.newTodoText &#125;)</div><div class=\"line\">    <span class=\"keyword\">this</span>.newTodoText = <span class=\"string\">''</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// DeleteTodoButton</span></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">deleteTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">    eventHub.$emit(<span class=\"string\">'delete-todo'</span>, id)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Todos</span></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">created: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  eventHub.$on(<span class=\"string\">'add-todo'</span>, <span class=\"keyword\">this</span>.addTodo)</div><div class=\"line\">  eventHub.$on(<span class=\"string\">'delete-todo'</span>, <span class=\"keyword\">this</span>.deleteTodo)</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"comment\">// 最好在组件销毁前</span></div><div class=\"line\"><span class=\"comment\">// 清除事件监听</span></div><div class=\"line\">beforeDestroy: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  eventHub.$off(<span class=\"string\">'add-todo'</span>, <span class=\"keyword\">this</span>.addTodo)</div><div class=\"line\">  eventHub.$off(<span class=\"string\">'delete-todo'</span>, <span class=\"keyword\">this</span>.deleteTodo)</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">addTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newTodo</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.todos.push(newTodo)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">deleteTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">todoId</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.todos = <span class=\"keyword\">this</span>.todos.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">todo</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> todo.id !== todoId</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在简单的情况下这样做可以替代 <code>$dispatch</code> 和 <code>$broadcast</code>，但是对于大多数复杂情况，更推荐使用一个专用的状态管理层如：<a href=\"https://github.com/vuejs/vuex\">Vuex</a> 。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找出使用 <code>$dispatch</code> 和 <code>$broadcast</code>的实例。</p>\n</div>\n\n<h2 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h2><h3 id=\"插入文本之外的过滤器-移除\"><a href=\"#插入文本之外的过滤器-移除\" class=\"headerlink\" title=\"插入文本之外的过滤器 移除\"></a>插入文本之外的过滤器 <sup>移除</sup></h3><p>现在过滤器只能用在插入文本中 (<code>{{ }}</code> tags)。我们发现在指令（如：<code>v-model</code>， <code>v-on</code>等）中使用过滤器使事情变得更复杂。像<code>v-for</code> 这样的列表过滤器最好把处理逻辑作为一个计算属性放在js里面，这样就可以在整个模板中复用。</p>\n<p>总之，能在原生js中实现的东西，我们尽量避免引入一个新的符号去重复处理同样的问题。下面是如何替换 Vue 内置过滤器：</p>\n<h4 id=\"替换-debounce-过滤器\"><a href=\"#替换-debounce-过滤器\" class=\"headerlink\" title=\"替换 debounce 过滤器\"></a>替换 <code>debounce</code> 过滤器</h4><p>不再这样写</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup</span>=<span class=\"string\">\"doStuff | debounce 500\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">doStuff</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>请使用 <a href=\"https://lodash.com/docs/4.15.0#debounce\">lodash’s <code>debounce</code></a> (也有可能是 <a href=\"https://lodash.com/docs/4.15.0#throttle\"><code>throttle</code></a>) 来直接控制高耗任务。可以这样来实现上面的功能：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup</span>=<span class=\"string\">\"doStuff\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">doStuff</span>: _.debounce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;, <span class=\"number\">500</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种写法的更多优点详见： <a href=\"#debounce-Param-Attribute-for-v-model-removed\"><code>v-model</code> 示例</a>.</p>\n<h4 id=\"替换-limitBy-过滤器\"><a href=\"#替换-limitBy-过滤器\" class=\"headerlink\" title=\"替换 limitBy 过滤器\"></a>替换 <code>limitBy</code> 过滤器</h4><p>不再这样写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items | limitBy 10\"</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在 computed 属性中使用js内置方法： <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples\"><code>.slice</code> method</a>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in filteredItems\"</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">filteredItems</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items.slice(<span class=\"number\">0</span>, <span class=\"number\">10</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"替换-filterBy-过滤器\"><a href=\"#替换-filterBy-过滤器\" class=\"headerlink\" title=\"替换 filterBy 过滤器\"></a>替换 <code>filterBy</code> 过滤器</h4><p>不再这样写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"user in users | filterBy searchQuery in 'name'\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在 computed 属性中使用js内置方法 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples\"><code>.filter</code> method</a>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"user in filteredUsers\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">filteredUsers</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">    <span class=\"keyword\">return</span> self.users.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> user.name.indexOf(self.searchQuery) !== <span class=\"number\">-1</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>js原生的 <code>.filter</code> 同样能实现很多复杂的过滤器操作，因为可以在计算 computed 属性中使用所有js方法。比如，想要通过匹配用户名字和电子邮箱地址（不区分大小写）找到用户：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">self.users.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> searchRegex = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(self.searchQuery, <span class=\"string\">'i'</span>)</div><div class=\"line\">  <span class=\"keyword\">return</span> user.isActive &amp;&amp; (</div><div class=\"line\">    searchRegex.test(user.name) ||</div><div class=\"line\">    searchRegex.test(user.email)</div><div class=\"line\">  )</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"替换-orderBy-过滤器\"><a href=\"#替换-orderBy-过滤器\" class=\"headerlink\" title=\"替换 orderBy 过滤器\"></a>替换 <code>orderBy</code> 过滤器</h4><p>不这样写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"user in users | orderBy 'name'\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>而是在 computed 属性中使用 <a href=\"https://lodash.com/docs/4.15.0#orderBy\">lodash’s <code>orderBy</code></a> (或者可能是 <a href=\"https://lodash.com/docs/4.15.0#sortBy\"><code>sortBy</code></a>)：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"user in orderedUsers\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">orderedUsers</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> _.orderBy(<span class=\"keyword\">this</span>.users, <span class=\"string\">'name'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>甚至可以字段排序：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">_.orderBy(<span class=\"keyword\">this</span>.users, [<span class=\"string\">'name'</span>, <span class=\"string\">'last_login'</span>], [<span class=\"string\">'asc'</span>, <span class=\"string\">'desc'</span>])</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到指令中使用的过滤器。如果有些没找到，看看<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"过滤器参数符号-变更\"><a href=\"#过滤器参数符号-变更\" class=\"headerlink\" title=\"过滤器参数符号 变更\"></a>过滤器参数符号 <sup>变更</sup></h3><p>现在过滤器参数形式可以更好地与js函数调用方式一致，因此不用再用空格分隔参数：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; date | formatDate 'YY-MM-DD' timeZone &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>现在用圆括号括起来并用逗号分隔：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; date | formatDate('YY-MM-DD', timeZone) &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到老式的调用符号，如果有遗漏，请看<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"内置文本过滤器-移除\"><a href=\"#内置文本过滤器-移除\" class=\"headerlink\" title=\"内置文本过滤器 移除\"></a>内置文本过滤器 <sup>移除</sup></h3><p>尽管插入文本内部的过滤器依然有效，但是所有内置过滤器已经移除了。取代的是，推荐在每个区域使用更专业的库来解决。(比如用 <a href=\"https://date-fns.org/\"><code>date-fns</code></a> 来格式化日期，用 <a href=\"http://openexchangerates.github.io/accounting.js/\"><code>accounting</code></a> 来格式化货币)。</p>\n<p>对于每个内置过滤器，我们大概总结了下该怎么替换。代码示例可能写在自定义 helper 函数，方法或计算属性中。</p>\n<h4 id=\"替换-json-过滤器\"><a href=\"#替换-json-过滤器\" class=\"headerlink\" title=\"替换 json 过滤器\"></a>替换 <code>json</code> 过滤器</h4><p>不用一个个改，因为Vue已经帮你自动格式化好了，无论是字符串，数字还是数组，对象。如果想用js的 <code>JSON.stringify</code> 功能去实现，你也可以把它写在方法或者计算属性里面。</p>\n<h4 id=\"替换-capitalize-过滤器\"><a href=\"#替换-capitalize-过滤器\" class=\"headerlink\" title=\"替换 capitalize 过滤器\"></a>替换 <code>capitalize</code> 过滤器</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">text[<span class=\"number\">0</span>].toUpperCase() + text.slice(<span class=\"number\">1</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"替换-uppercase-过滤器\"><a href=\"#替换-uppercase-过滤器\" class=\"headerlink\" title=\"替换 uppercase 过滤器\"></a>替换 <code>uppercase</code> 过滤器</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">text.toUpperCase()</div></pre></td></tr></table></figure>\n<h4 id=\"替换-lowercase-过滤器\"><a href=\"#替换-lowercase-过滤器\" class=\"headerlink\" title=\"替换 lowercase 过滤器\"></a>替换 <code>lowercase</code> 过滤器</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">text.toLowerCase()</div></pre></td></tr></table></figure>\n<h4 id=\"替换-pluralize-过滤器\"><a href=\"#替换-pluralize-过滤器\" class=\"headerlink\" title=\"替换 pluralize 过滤器\"></a>替换 <code>pluralize</code> 过滤器</h4><p>NPM 上的 <a href=\"https://www.npmjs.com/package/pluralize\">pluralize</a> 库可以很好的实现这个功能。如果仅仅想将特定的词格式化成复数形式或者想给特定的值（’0’）指定特定的输出，也可以很容易地自定义复数格式化过滤器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pluralizeKnife</span> (<span class=\"params\">count</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (count === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'no knives'</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count === <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'1 knife'</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> count + <span class=\"string\">'knives'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Replacing-the-currency-Filter\"><a href=\"#Replacing-the-currency-Filter\" class=\"headerlink\" title=\"Replacing the currency Filter\"></a>Replacing the <code>currency</code> Filter</h4><p>对于简单的问题,可以这样做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'$'</span> + price.toFixed(<span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>大多数情况下，仍然会有奇怪的现象(比如 <code>0.035.toFixed(2)</code> 向上取舍得到 <code>0.04</code>,但是 <code>0.045</code> 向下取舍却也得到 <code>0.04</code>)。解决这些问题可以使用 <a href=\"http://openexchangerates.github.io/accounting.js/\"><code>accounting</code></a> 库来实现更多可靠的货币格式化。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到舍弃的过滤器。如果有些遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"Two-Way-Filters-replaced\"><a href=\"#Two-Way-Filters-replaced\" class=\"headerlink\" title=\"Two-Way Filters replaced\"></a>Two-Way Filters <sup>replaced</sup></h3><p>Some users have enjoyed using two-way filters with <code>v-model</code> to create interesting inputs with very little code. While <em>seemingly</em> simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs.</p>\n<p>As an example, we’ll now walk the migration of a two-way currency filter:</p>\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/6744xnjk/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the <code>Result</code> tab and try entering <code>9.999</code> into one of those inputs. When the input loses focus, its value will update to <code>$10.00</code>. When looking at the calculated total however, you’ll see that <code>9.999</code> is what’s stored in our data. The version of reality that the user sees is out of sync!</p>\n<p>To start transitioning towards a more robust solution using Vue 2.0, let’s first wrap this filter in a new <code>&lt;currency-input&gt;</code> component:</p>\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/943zfbsh/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>This allows us add behavior that a filter alone couldn’t encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external <a href=\"https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e\"><code>currencyValidator</code> object</a>:</p>\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/9c32kev2/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</p>\n<ul>\n<li>unit tested in isolation from your Vue code</li>\n<li>used by other parts of your application, such as to validate the payload to an API endpoint</li>\n</ul>\n<p>Having this validator extracted out, we’ve also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it’s actually impossible for users to enter anything wrong, similar to what the browser’s native number input tries to do.</p>\n<p>We’re still limited however, by filters and by Vue 1.0 in general, so let’s complete the upgrade to Vue 2.0:</p>\n<iframe width=\"100%\" height=\"300\" src=\"https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/js,html,result\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>You may notice that:</p>\n<ul>\n<li>Every aspect of our input is more explicit, using lifecycle hooks and DOM events in place of the hidden behavior of two-way filters.</li>\n<li>We can now use <code>v-model</code> directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</li>\n<li>Since we’re no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice.</li>\n</ul>\n\n<div class=\"upgrade-path\">\n  <h4>Upgrade Path</h4>\n  <p>Run the<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>on your codebase to find examples of filters used in directives like <code>v-model</code>. If you miss any, you should also see <strong>console errors</strong>.</p>\n</div>\n\n<h2 id=\"Slots\"><a href=\"#Slots\" class=\"headerlink\" title=\"Slots\"></a>Slots</h2><h3 id=\"重名的-Slots-移除\"><a href=\"#重名的-Slots-移除\" class=\"headerlink\" title=\"重名的 Slots 移除\"></a>重名的 Slots <sup>移除</sup></h3><p>同一模板中的重名 <code>&lt;slot&gt;</code> 已经弃用。当一个 slot 已经被渲染过了，那么就不能在同一模板其它地方被再次渲染了。如果要在不同位置渲染同一内容，可一用prop来传递。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>更新后运行测试，查看 <strong>控制台警告信息</strong> 关于重名slots的提示 <code>v-model</code>。</p>\n</div>\n\n<h3 id=\"slot-样式参数-移除\"><a href=\"#slot-样式参数-移除\" class=\"headerlink\" title=\"slot 样式参数 移除\"></a><code>slot</code> 样式参数 <sup>移除</sup></h3><p>通过具名 <code>&lt;slot&gt;</code> 插入的片段不再保持 <code>slot</code> 的参数。请用一个包裹元素来控制样式。或者用更高级方法：通过编程方式修改内容 ：<a href=\"render-function.html\">render functions</a> 。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到选择slots标签CSS选择器(例如： <code>[slot=\"my-slot-name\"]</code>) 。</p>\n</div>\n\n<h2 id=\"特殊属性\"><a href=\"#特殊属性\" class=\"headerlink\" title=\"特殊属性\"></a>特殊属性</h2><h3 id=\"keep-alive-属性-替换\"><a href=\"#keep-alive-属性-替换\" class=\"headerlink\" title=\"keep-alive 属性 替换\"></a><code>keep-alive</code> 属性 <sup>替换</sup></h3><p><code>keep-alive</code> 不再是一个特殊属性而是一个包裹组件，类似于  <code>&lt;transition&gt;</code>比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这样可以在含多种状态子组件中使用 <code>&lt;keep-alive&gt;</code> ：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">todo-list</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"todos.length &gt; 0\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">todo-list</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">no-todos-gif</span> <span class=\"attr\">v-else</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">no-todos-gif</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">当 <code>&lt;keep-alive&gt;</code> 含有不同子组件时，应该分别影响到每一个子组件。不仅是第一个而是所有的子组件都将被忽略。</p>\n\n<p>和 <code>&lt;transition&gt;</code>一起使用时，确保把内容包裹在内：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到<code>keep-alive</code> 属性。</p>\n</div>\n\n<h2 id=\"计算插值todaymark\"><a href=\"#计算插值todaymark\" class=\"headerlink\" title=\"计算插值todaymark\"></a>计算插值todaymark</h2><h3 id=\"属性内部的计算插值-移除\"><a href=\"#属性内部的计算插值-移除\" class=\"headerlink\" title=\"属性内部的计算插值 移除\"></a>属性内部的计算插值 <sup>移除</sup></h3><p>属性内部的计算插值已经不能再使用了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-&#123;&#123; size &#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>应该写成行内表达式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"'btn btn-' + size\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>或者计算属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"buttonClasses\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">buttonClasses</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'btn btn-'</span> + size</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到属性内部的计算插值</p>\n</div>\n\n<h3 id=\"HTML-计算插值-移除\"><a href=\"#HTML-计算插值-移除\" class=\"headerlink\" title=\"HTML 计算插值 移除\"></a>HTML 计算插值 <sup>移除</sup></h3><p>HTML 的计算插值 (<code>{{{ foo }}}</code>) 已经移除，取代的是 <a href=\"../api/#v-html\"><code>v-html</code> 指令</a>.</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 HTML 计算插值。</p>\n</div>\n\n<h3 id=\"单次绑定替换\"><a href=\"#单次绑定替换\" class=\"headerlink\" title=\"单次绑定替换\"></a>单次绑定<sup>替换</sup></h3><p>单次绑定 (<code>{{* foo }}</code>) 已经被新的 <a href=\"../api/#v-once\"><code>v-once</code> directive</a> 取代。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到单次绑定使用位置。</p>\n</div>\n\n<h2 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h2><h3 id=\"vm-watch-changed\"><a href=\"#vm-watch-changed\" class=\"headerlink\" title=\"vm.$watch changed\"></a><code>vm.$watch</code> <sup>changed</sup></h3><p>通过 <code>vm.$watch</code>创建的观察器现在将在组件渲染时被激活。这样可以让你在组件渲染前更新状态，不用做不必要的更新。比如可以通过观察组件的prop变化来更新组件本身的值。</p>\n<p>如果以前通过 <code>vm.$watch</code> 在组件更新后与 DOM 交互，现在就可以通过<code>updated</code>生命周期钩子来做这些。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行测试，如果有依赖于老方法的观察器将弹出 <strong>failed tests</strong>。</p>\n</div>\n\n<h3 id=\"vm-set-变更\"><a href=\"#vm-set-变更\" class=\"headerlink\" title=\"vm.$set 变更\"></a><code>vm.$set</code> <sup>变更</sup></h3><p> <code>vm.$set</code> 只是 <a href=\"../api/#Vue-set\"><code>Vue.set</code></a> 的别名。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到过时的用法</p>\n</div>\n\n<h3 id=\"vm-delete-变更\"><a href=\"#vm-delete-变更\" class=\"headerlink\" title=\"vm.$delete 变更\"></a><code>vm.$delete</code> <sup>变更</sup></h3><p><code>vm.$delete</code> 现在只是： <a href=\"../api/#Vue-delete\"><code>Vue.delete</code></a> 别名。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到过时的用法</p>\n</div>\n\n<h3 id=\"Array-prototype-set-弃用\"><a href=\"#Array-prototype-set-弃用\" class=\"headerlink\" title=\"Array.prototype.$set  弃用\"></a><code>Array.prototype.$set</code>  <sup>弃用</sup></h3><p>用 <code>Vue.set</code> 替代</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到数组上的<code>.$set</code>。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"Array-prototype-remove-移除\"><a href=\"#Array-prototype-remove-移除\" class=\"headerlink\" title=\"Array.prototype.$remove 移除\"></a><code>Array.prototype.$remove</code> <sup>移除</sup></h3><p>用 <code>Array.prototype.splice</code> 替代，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">removeTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">todo</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> index = <span class=\"keyword\">this</span>.todos.indexOf(todo)</div><div class=\"line\">    <span class=\"keyword\">this</span>.todos.splice(index, <span class=\"number\">1</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或者更好的方法，直接给除去的方法一个index参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"attr\">removeTodo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">index</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.todos.splice(index, <span class=\"number\">1</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到数组上的<code>.$remove</code>。如有遗漏请参考<strong>控制台错误信息</strong></p>\n</div>\n\n<h3 id=\"Vue实例上的Vue-set-和-Vue-delete移除\"><a href=\"#Vue实例上的Vue-set-和-Vue-delete移除\" class=\"headerlink\" title=\"Vue实例上的Vue.set 和 Vue.delete移除\"></a>Vue实例上的<code>Vue.set</code> 和 <code>Vue.delete</code><sup>移除</sup></h3><p><code>Vue.set</code> 和 <code>Vue.delete</code> 在实例上将不再起作用。现在都强制在实例的data选项中声明所有顶级响应值。如果删除实例属性或实例<code>$data</code>上的某个值，直接将它设置为null即可。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到实例中的 <code>Vue.set</code> 或 <code>Vue.delete</code> 。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"替换-vm-data-移除\"><a href=\"#替换-vm-data-移除\" class=\"headerlink\" title=\"替换 vm.$data 移除\"></a>替换 <code>vm.$data</code> <sup>移除</sup></h3><p>现在禁止替换实例的 $data。这样防止了响应系统的一些极端情况并且让组件状态更加可控可预测（特别是对于存在类型检查的系统）。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到覆盖 <code>vm.$data</code >的位置。如有遗漏请参考<strong>控制台警告信息</strong>。</p>\n</div>\n\n<h3 id=\"vm-get-移除\"><a href=\"#vm-get-移除\" class=\"headerlink\" title=\"vm.$get 移除\"></a><code>vm.$get</code> <sup>移除</sup></h3><p>可以直接取回响应数据。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$get</code> 的位置。如有遗漏请参考 <strong>控制台错误信息</strong>。</p>\n</div>\n\n<h2 id=\"围绕-DOM-的实例方法\"><a href=\"#围绕-DOM-的实例方法\" class=\"headerlink\" title=\"围绕 DOM 的实例方法\"></a>围绕 DOM 的实例方法</h2><h3 id=\"vm-appendTo-移除\"><a href=\"#vm-appendTo-移除\" class=\"headerlink\" title=\"vm.$appendTo 移除\"></a><code>vm.$appendTo</code> <sup>移除</sup></h3><p>使用 DOM 原生方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">myElement.appendChild(vm.$el)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$appendTo</code> 的位置。如果有遗漏可以参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"vm-before-移除\"><a href=\"#vm-before-移除\" class=\"headerlink\" title=\"vm.$before 移除\"></a><code>vm.$before</code> <sup>移除</sup></h3><p>使用 DOM 原生方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">myElement.parentNode.insertBefore(vm.$el, myElement)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$before</code>。如有遗漏，请参考 <strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"vm-after-移除\"><a href=\"#vm-after-移除\" class=\"headerlink\" title=\"vm.$after 移除\"></a><code>vm.$after</code> <sup>移除</sup></h3><p>使用 DOM 原生方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">myElement.parentNode.insertBefore(vm.$el, myElement.nextSibling)</div></pre></td></tr></table></figure>\n<p>如果 <code>myElement</code> 是最后一个节点也可以这样写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">myElement.parentNode.appendChild(vm.$el)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$after</code> 的位置。如有遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"vm-remove-移除\"><a href=\"#vm-remove-移除\" class=\"headerlink\" title=\"vm.$remove 移除\"></a><code>vm.$remove</code> <sup>移除</sup></h3><p>使用 DOM 原生方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$el.remove()</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到<code>vm.$remove</code>。如有遗漏，请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h2 id=\"底层实例方法\"><a href=\"#底层实例方法\" class=\"headerlink\" title=\"底层实例方法\"></a>底层实例方法</h2><h3 id=\"vm-eval-移除\"><a href=\"#vm-eval-移除\" class=\"headerlink\" title=\"vm.$eval 移除\"></a><code>vm.$eval</code> <sup>移除</sup></h3><p>尽量不要使用，如果必须使用该功能并且不肯定如何使用请参考 <a href=\"http://forum.vuejs.org/\">the forum</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用 <code>vm.$eval</code> 的位置。如有遗漏请参考<strong>控制台错误信息</strong>。</p>\n</div>\n\n<h3 id=\"vm-interpolate-移除\"><a href=\"#vm-interpolate-移除\" class=\"headerlink\" title=\"vm.$interpolate 移除\"></a><code>vm.$interpolate</code> <sup>移除</sup></h3><p>尽量不要使用，如果必须使用该功能并且不肯定如何使用请参考 <a href=\"http://forum.vuejs.org/\">the forum</a>。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到<code>vm.$interpolate</code>。如有遗漏请参考<strong>控制台错误信息</strong>.</p>\n</div>\n\n<h3 id=\"vm-log-移除\"><a href=\"#vm-log-移除\" class=\"headerlink\" title=\"vm.$log 移除\"></a><code>vm.$log</code> <sup>移除</sup></h3><p>请使用 <a href=\"https://github.com/vuejs/vue-devtools\">Vue Devtools</a> 感受最佳debug体验。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>vm.$log</code>。如有遗漏请参考<strong>控制台错误信息</strong>.</p>\n</div>\n\n<h2 id=\"实例-DOM-选项\"><a href=\"#实例-DOM-选项\" class=\"headerlink\" title=\"实例 DOM 选项\"></a>实例 DOM 选项</h2><h3 id=\"replace-false-移除\"><a href=\"#replace-false-移除\" class=\"headerlink\" title=\"replace: false 移除\"></a><code>replace: false</code> <sup>移除</sup></h3><p>现在组件总是会替换掉他们被绑定的元素。为了模仿<code>replace: false</code>的行为，可以用一个和将要替换元素类似的元素将根组件包裹起来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div id=\"app\"&gt; ... &lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>或者使用渲染函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">h</span>) </span>&#123;</div><div class=\"line\">    h(<span class=\"string\">'div'</span>, &#123;</div><div class=\"line\">      <span class=\"attr\">attrs</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">id</span>: <span class=\"string\">'app'</span>,</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;, <span class=\"comment\">/* ... */</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>replace: false</code>使用的位置。</p>\n</div>\n\n<h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><h3 id=\"Vue-config-debug-移除\"><a href=\"#Vue-config-debug-移除\" class=\"headerlink\" title=\"Vue.config.debug 移除\"></a><code>Vue.config.debug</code> <sup>移除</sup></h3><p>不再需要，因为警告信息将默认在堆栈信息里输出。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到包含<code>Vue.config.debug</code>的地方。</p>\n</div>\n\n<h3 id=\"Vue-config-async-移除\"><a href=\"#Vue-config-async-移除\" class=\"headerlink\" title=\"Vue.config.async 移除\"></a><code>Vue.config.async</code> <sup>移除</sup></h3><p>异步操作现在需要渲染性能的支持。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行 <a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用<code>Vue.config.async</code>的实例。</p>\n</div>\n\n<h3 id=\"Vue-config-delimiters-替换\"><a href=\"#Vue-config-delimiters-替换\" class=\"headerlink\" title=\"Vue.config.delimiters 替换\"></a><code>Vue.config.delimiters</code> <sup>替换</sup></h3><p>以 <a href=\"../api/#delimiters\">模板选项</a>的方式使用。这样可以在使用自定义分隔符时避免影响第三方模板。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到使用<code>Vue.config.delimiters</code>的实例。</p>\n</div>\n\n<h3 id=\"Vue-config-unsafeDelimiters-移除\"><a href=\"#Vue-config-unsafeDelimiters-移除\" class=\"headerlink\" title=\"Vue.config.unsafeDelimiters 移除\"></a><code>Vue.config.unsafeDelimiters</code> <sup>移除</sup></h3><p>HTML 插入 <a href=\"#HTML-Interpolation-removed\">替换为 <code>v-html</code></a>.</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到 <code>Vue.config.unsafeDelimiters</code>。然后 helper 工具也会找到HTML插入的实例，可以用`v-html`来替换。</p>\n</div>\n\n<h2 id=\"全局-API\"><a href=\"#全局-API\" class=\"headerlink\" title=\"全局 API\"></a>全局 API</h2><h3 id=\"带-el-的-Vue-extend-移除\"><a href=\"#带-el-的-Vue-extend-移除\" class=\"headerlink\" title=\"带 el 的 Vue.extend 移除\"></a>带 <code>el</code> 的 <code>Vue.extend</code> <sup>移除</sup></h3><p>el 选项不再在 <code>Vue.extend</code>中使用。仅在实例创建参数中可用。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>更新后运行测试在<strong>控制台警告信息</strong>中找到关于带有<code>Vue.extend</code>的<code>el</code>。</p>\n</div>\n\n<h3 id=\"Vue-elementDirective-移除\"><a href=\"#Vue-elementDirective-移除\" class=\"headerlink\" title=\"Vue.elementDirective 移除\"></a><code>Vue.elementDirective</code> <sup>移除</sup></h3><p>用组件来替代</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到包含<code>Vue.elementDirective</code>的实例。</p>\n</div>\n\n<h3 id=\"Vue-partial-移除\"><a href=\"#Vue-partial-移除\" class=\"headerlink\" title=\"Vue.partial 移除\"></a><code>Vue.partial</code> <sup>移除</sup></h3><p>Partials 已被移除,取而代之的是更明确的组件之间的数据流–props。除非你正在使用一个部分性能关键型区域，否则建议只使用一个<a href=\"components.html\">normal component</a>来代替。如果你是动态绑定部分的<code>name</code>,您可以使用<a href=\"components.html#Dynamic-Components\">dynamic component</a>。</p>\n<p>如果你碰巧在你的应用程序的性能关键部分使用<code>partials</code>，那么你应该升级到<a href=\"render-function.html#Functional-Components\">functional components</a>。它们必须在纯JS / JSX文件中（而不是在<code>.vue</code>文件中），并且是无状态的和无实例的，就像<code>partials</code>。这使得渲染极快。</p>\n<p><code>functional components</code>相对于<code>partials</code>一个好处是它们可以更具动态性，因为它们允许您访问JavaScript的全部功能。然而，这是有成本的。如果你从来没有使用过渲染式的组件框架，你可能需要花费更长的时间来学习它们。</p>\n\n<div class=\"upgrade-path\">\n  <h4>升级方式</h4>\n  <p>运行<a href=\"https://github.com/vuejs/vue-migration-helper\">迁移工具</a>找到包含 <code>Vue.partial</code>的实例</p>\n</div>\n\n<hr>\n<blockquote>\n<p>原文： http:/   /vuejs.org/guide/migration.html</p>\n</blockquote>\n<hr>\n"},{"title":"深入响应式原理","type":"guide","order":12,"_content":"\n我们已经涵盖了大部分的基础知识 - 现在是时候深入底层原理了！Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，修改它则更新视图(view)。这会让状态管理变得非常简单且直观，不过理解它的工作原理以避免一些常见的问题也是很重要的。在本节中，我们将开始深入挖掘 Vue 响应式系统的底层细节。\n\n## 如何追踪变化\n\n把一个普通 Javascript 对象传给 Vue 实例的 `data` 选项，Vue 将遍历此对象所有的属性，并使用 [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。\n\n用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 [vue-devtools](https://github.com/vuejs/vue-devtools) 来获取更加友好的检查接口。\n    \n每个组件实例都有相应的 **watcher** 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 `setter` 被调用时，会通知 `watcher` 重新计算，从而致使它关联的组件得以更新。\n\n![data](/images/data.png)\n\n## 变化检测问题\n\n受现代 Javascript 的限制（以及废弃 `Object.observe`），Vue **不能检测到对象属性的添加或删除**。由于 Vue 会在初始化实例时对属性执行 `getter/setter` 转化过程，所以属性必须在 `data` 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：\n\n``` js\nvar vm = new Vue({\n  data:{\n  a:1\n  }\n})\n\n// `vm.a` 是响应的\n\nvm.b = 2\n// `vm.b` 是非响应的\n```\n\nVue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 `Vue.set(object, key, value)` 方法将响应属性添加到嵌套的对象上：\n\n``` js\nVue.set(vm.someObject, 'b', 2)\n\n```\n您还可以使用 `vm.$set` 实例方法，这也是全局 `Vue.set` 方法的别名：\n\n``` js\nthis.$set(this.someObject,'b',2)\n```\n\n有时你想向已有对象上添加一些属性，例如使用 `Object.assign()` 或 `_.extend()` 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：\n\n``` js\n// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\n```\n\n也有一些数组相关的问题，之前已经在[列表渲染](list.html#注意事项)中讲过。\n\n## 声明响应式属性\n\n由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值:\n\n``` js\nvar vm = new Vue({\n  data: {\n    // 声明 message 为一个空值字符串\n    message: ''\n  },\n  template: '<div>{{ message }}</div>'\n})\n// 之后设置 `message` \nvm.message = 'Hello!'\n```\n  \n如果你在 data 选项中未声明 `message`，Vue 将警告你渲染函数在试图访问的属性不存在。\n\n这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例在类型检查系统的帮助下运行的更高效。而且在代码可维护性方面也有一点重要的考虑：`data` 对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。\n\n## 异步更新队列\n\n可能你还没有注意到，Vue **异步**执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 `Promise.then` 和 `MutationObserver`，如果执行环境不支持，会采用 `setTimeout(fn, 0)` 代替。\n\n例如，当你设置 `vm.someData = 'new value'` ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 `Vue.nextTick(callback)` 。这样回调函数在 DOM 更新完成后就会调用。例如：\n\n```html\n<div id=\"example\">{{message}}</div>\n```\n``` js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: '123'\n  }\n})\nvm.message = 'new message' // 更改数据\nvm.$el.textContent === 'new message' // false\nVue.nextTick(function () {\n  vm.$el.textContent === 'new message' // true\n})\n```\n在组件内使用 `vm.$nextTick()` 实例方法特别方便，因为它不需要全局 `Vue` ，并且回调函数中的 `this` 将自动绑定到当前的 Vue 实例上：\n``` js\nVue.component('example', {\n  template: '<span>{{ message }}</span>',\n  data: function () {\n    return {\n      message: 'not updated'\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.message = 'updated'\n      console.log(this.$el.textContent) // => '没有更新'\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) // => '更新完成'\n      })\n    }\n  }\n})\n```\n\n***\n\n> 原文： http://vuejs.org/guide/reactivity.html\n\n***\n","source":"v2/guide/reactivity.md","raw":"---\ntitle: 深入响应式原理\ntype: guide\norder: 12\n---\n\n我们已经涵盖了大部分的基础知识 - 现在是时候深入底层原理了！Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，修改它则更新视图(view)。这会让状态管理变得非常简单且直观，不过理解它的工作原理以避免一些常见的问题也是很重要的。在本节中，我们将开始深入挖掘 Vue 响应式系统的底层细节。\n\n## 如何追踪变化\n\n把一个普通 Javascript 对象传给 Vue 实例的 `data` 选项，Vue 将遍历此对象所有的属性，并使用 [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。\n\n用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 [vue-devtools](https://github.com/vuejs/vue-devtools) 来获取更加友好的检查接口。\n    \n每个组件实例都有相应的 **watcher** 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 `setter` 被调用时，会通知 `watcher` 重新计算，从而致使它关联的组件得以更新。\n\n![data](/images/data.png)\n\n## 变化检测问题\n\n受现代 Javascript 的限制（以及废弃 `Object.observe`），Vue **不能检测到对象属性的添加或删除**。由于 Vue 会在初始化实例时对属性执行 `getter/setter` 转化过程，所以属性必须在 `data` 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：\n\n``` js\nvar vm = new Vue({\n  data:{\n  a:1\n  }\n})\n\n// `vm.a` 是响应的\n\nvm.b = 2\n// `vm.b` 是非响应的\n```\n\nVue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 `Vue.set(object, key, value)` 方法将响应属性添加到嵌套的对象上：\n\n``` js\nVue.set(vm.someObject, 'b', 2)\n\n```\n您还可以使用 `vm.$set` 实例方法，这也是全局 `Vue.set` 方法的别名：\n\n``` js\nthis.$set(this.someObject,'b',2)\n```\n\n有时你想向已有对象上添加一些属性，例如使用 `Object.assign()` 或 `_.extend()` 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：\n\n``` js\n// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\n```\n\n也有一些数组相关的问题，之前已经在[列表渲染](list.html#注意事项)中讲过。\n\n## 声明响应式属性\n\n由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值:\n\n``` js\nvar vm = new Vue({\n  data: {\n    // 声明 message 为一个空值字符串\n    message: ''\n  },\n  template: '<div>{{ message }}</div>'\n})\n// 之后设置 `message` \nvm.message = 'Hello!'\n```\n  \n如果你在 data 选项中未声明 `message`，Vue 将警告你渲染函数在试图访问的属性不存在。\n\n这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例在类型检查系统的帮助下运行的更高效。而且在代码可维护性方面也有一点重要的考虑：`data` 对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。\n\n## 异步更新队列\n\n可能你还没有注意到，Vue **异步**执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 `Promise.then` 和 `MutationObserver`，如果执行环境不支持，会采用 `setTimeout(fn, 0)` 代替。\n\n例如，当你设置 `vm.someData = 'new value'` ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 `Vue.nextTick(callback)` 。这样回调函数在 DOM 更新完成后就会调用。例如：\n\n```html\n<div id=\"example\">{{message}}</div>\n```\n``` js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: '123'\n  }\n})\nvm.message = 'new message' // 更改数据\nvm.$el.textContent === 'new message' // false\nVue.nextTick(function () {\n  vm.$el.textContent === 'new message' // true\n})\n```\n在组件内使用 `vm.$nextTick()` 实例方法特别方便，因为它不需要全局 `Vue` ，并且回调函数中的 `this` 将自动绑定到当前的 Vue 实例上：\n``` js\nVue.component('example', {\n  template: '<span>{{ message }}</span>',\n  data: function () {\n    return {\n      message: 'not updated'\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.message = 'updated'\n      console.log(this.$el.textContent) // => '没有更新'\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) // => '更新完成'\n      })\n    }\n  }\n})\n```\n\n***\n\n> 原文： http://vuejs.org/guide/reactivity.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/reactivity.html","comments":1,"layout":"page","_id":"ciwnajuyv001njl2dybni9mgj","content":"<p>我们已经涵盖了大部分的基础知识 - 现在是时候深入底层原理了！Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，修改它则更新视图(view)。这会让状态管理变得非常简单且直观，不过理解它的工作原理以避免一些常见的问题也是很重要的。在本节中，我们将开始深入挖掘 Vue 响应式系统的底层细节。</p>\n<h2 id=\"如何追踪变化\"><a href=\"#如何追踪变化\" class=\"headerlink\" title=\"如何追踪变化\"></a>如何追踪变化</h2><p>把一个普通 Javascript 对象传给 Vue 实例的 <code>data</code> 选项，Vue 将遍历此对象所有的属性，并使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"external\">Object.defineProperty</a> 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>\n<p>用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"external\">vue-devtools</a> 来获取更加友好的检查接口。</p>\n<p>每个组件实例都有相应的 <strong>watcher</strong> 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 <code>setter</code> 被调用时，会通知 <code>watcher</code> 重新计算，从而致使它关联的组件得以更新。</p>\n<p><img src=\"/images/data.png\" alt=\"data\"></p>\n<h2 id=\"变化检测问题\"><a href=\"#变化检测问题\" class=\"headerlink\" title=\"变化检测问题\"></a>变化检测问题</h2><p>受现代 Javascript 的限制（以及废弃 <code>Object.observe</code>），Vue <strong>不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>:&#123;</div><div class=\"line\">  <span class=\"attr\">a</span>:<span class=\"number\">1</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// `vm.a` 是响应的</span></div><div class=\"line\"></div><div class=\"line\">vm.b = <span class=\"number\">2</span></div><div class=\"line\"><span class=\"comment\">// `vm.b` 是非响应的</span></div></pre></td></tr></table></figure>\n<p>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 <code>Vue.set(object, key, value)</code> 方法将响应属性添加到嵌套的对象上：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.set(vm.someObject, <span class=\"string\">'b'</span>, <span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>您还可以使用 <code>vm.$set</code> 实例方法，这也是全局 <code>Vue.set</code> 方法的别名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.$set(<span class=\"keyword\">this</span>.someObject,<span class=\"string\">'b'</span>,<span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>有时你想向已有对象上添加一些属性，例如使用 <code>Object.assign()</code> 或 <code>_.extend()</code> 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span></div><div class=\"line\"><span class=\"keyword\">this</span>.someObject = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, <span class=\"keyword\">this</span>.someObject, &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;)</div></pre></td></tr></table></figure>\n<p>也有一些数组相关的问题，之前已经在<a href=\"list.html#注意事项\">列表渲染</a>中讲过。</p>\n<h2 id=\"声明响应式属性\"><a href=\"#声明响应式属性\" class=\"headerlink\" title=\"声明响应式属性\"></a>声明响应式属性</h2><p>由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 声明 message 为一个空值字符串</span></div><div class=\"line\">    message: <span class=\"string\">''</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// 之后设置 `message` </span></div><div class=\"line\">vm.message = <span class=\"string\">'Hello!'</span></div></pre></td></tr></table></figure>\n<p>如果你在 data 选项中未声明 <code>message</code>，Vue 将警告你渲染函数在试图访问的属性不存在。</p>\n<p>这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例在类型检查系统的帮助下运行的更高效。而且在代码可维护性方面也有一点重要的考虑：<code>data</code> 对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。</p>\n<h2 id=\"异步更新队列\"><a href=\"#异步更新队列\" class=\"headerlink\" title=\"异步更新队列\"></a>异步更新队列</h2><p>可能你还没有注意到，Vue <strong>异步</strong>执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和 <code>MutationObserver</code>，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code> 代替。</p>\n<p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code> ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code> 。这样回调函数在 DOM 更新完成后就会调用。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'123'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.message = <span class=\"string\">'new message'</span> <span class=\"comment\">// 更改数据</span></div><div class=\"line\">vm.$el.textContent === <span class=\"string\">'new message'</span> <span class=\"comment\">// false</span></div><div class=\"line\">Vue.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  vm.$el.textContent === <span class=\"string\">'new message'</span> <span class=\"comment\">// true</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局 <code>Vue</code> ，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'example'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">message</span>: <span class=\"string\">'not updated'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">updateMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.message = <span class=\"string\">'updated'</span></div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$el.textContent) <span class=\"comment\">// =&gt; '没有更新'</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$el.textContent) <span class=\"comment\">// =&gt; '更新完成'</span></div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/reactivity.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/reactivity.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<p>我们已经涵盖了大部分的基础知识 - 现在是时候深入底层原理了！Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，修改它则更新视图(view)。这会让状态管理变得非常简单且直观，不过理解它的工作原理以避免一些常见的问题也是很重要的。在本节中，我们将开始深入挖掘 Vue 响应式系统的底层细节。</p>\n<h2 id=\"如何追踪变化\"><a href=\"#如何追踪变化\" class=\"headerlink\" title=\"如何追踪变化\"></a>如何追踪变化</h2><p>把一个普通 Javascript 对象传给 Vue 实例的 <code>data</code> 选项，Vue 将遍历此对象所有的属性，并使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty</a> 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>\n<p>用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 <a href=\"https://github.com/vuejs/vue-devtools\">vue-devtools</a> 来获取更加友好的检查接口。</p>\n<p>每个组件实例都有相应的 <strong>watcher</strong> 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 <code>setter</code> 被调用时，会通知 <code>watcher</code> 重新计算，从而致使它关联的组件得以更新。</p>\n<p><img src=\"/images/data.png\" alt=\"data\"></p>\n<h2 id=\"变化检测问题\"><a href=\"#变化检测问题\" class=\"headerlink\" title=\"变化检测问题\"></a>变化检测问题</h2><p>受现代 Javascript 的限制（以及废弃 <code>Object.observe</code>），Vue <strong>不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>:&#123;</div><div class=\"line\">  <span class=\"attr\">a</span>:<span class=\"number\">1</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// `vm.a` 是响应的</span></div><div class=\"line\"></div><div class=\"line\">vm.b = <span class=\"number\">2</span></div><div class=\"line\"><span class=\"comment\">// `vm.b` 是非响应的</span></div></pre></td></tr></table></figure>\n<p>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 <code>Vue.set(object, key, value)</code> 方法将响应属性添加到嵌套的对象上：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.set(vm.someObject, <span class=\"string\">'b'</span>, <span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>您还可以使用 <code>vm.$set</code> 实例方法，这也是全局 <code>Vue.set</code> 方法的别名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.$set(<span class=\"keyword\">this</span>.someObject,<span class=\"string\">'b'</span>,<span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>有时你想向已有对象上添加一些属性，例如使用 <code>Object.assign()</code> 或 <code>_.extend()</code> 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span></div><div class=\"line\"><span class=\"keyword\">this</span>.someObject = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, <span class=\"keyword\">this</span>.someObject, &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;)</div></pre></td></tr></table></figure>\n<p>也有一些数组相关的问题，之前已经在<a href=\"list.html#注意事项\">列表渲染</a>中讲过。</p>\n<h2 id=\"声明响应式属性\"><a href=\"#声明响应式属性\" class=\"headerlink\" title=\"声明响应式属性\"></a>声明响应式属性</h2><p>由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 声明 message 为一个空值字符串</span></div><div class=\"line\">    message: <span class=\"string\">''</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// 之后设置 `message` </span></div><div class=\"line\">vm.message = <span class=\"string\">'Hello!'</span></div></pre></td></tr></table></figure>\n<p>如果你在 data 选项中未声明 <code>message</code>，Vue 将警告你渲染函数在试图访问的属性不存在。</p>\n<p>这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例在类型检查系统的帮助下运行的更高效。而且在代码可维护性方面也有一点重要的考虑：<code>data</code> 对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。</p>\n<h2 id=\"异步更新队列\"><a href=\"#异步更新队列\" class=\"headerlink\" title=\"异步更新队列\"></a>异步更新队列</h2><p>可能你还没有注意到，Vue <strong>异步</strong>执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和 <code>MutationObserver</code>，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code> 代替。</p>\n<p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code> ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code> 。这样回调函数在 DOM 更新完成后就会调用。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'123'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.message = <span class=\"string\">'new message'</span> <span class=\"comment\">// 更改数据</span></div><div class=\"line\">vm.$el.textContent === <span class=\"string\">'new message'</span> <span class=\"comment\">// false</span></div><div class=\"line\">Vue.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  vm.$el.textContent === <span class=\"string\">'new message'</span> <span class=\"comment\">// true</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局 <code>Vue</code> ，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'example'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">message</span>: <span class=\"string\">'not updated'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">updateMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.message = <span class=\"string\">'updated'</span></div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$el.textContent) <span class=\"comment\">// =&gt; '没有更新'</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$el.textContent) <span class=\"comment\">// =&gt; '更新完成'</span></div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/reactivity.html\">http://vuejs.org/guide/reactivity.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"Render 函数","type":"guide","order":15,"_content":"\n## 基础\n\nVue 推荐使用在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 **render 函数**，它比 template 更接近编译器。\n\n\n``` html\n<h1>\n  <a name=\"hello-world\" href=\"#hello-world\">\n    Hello world!\n  </a>\n</h1>\n```\n\n在 HTML 层， 我们决定这样定义组件接口：\n\n``` html\n<anchored-heading :level=\"1\">Hello world!</anchored-heading>\n```\n\n当我们开始写一个通过 `level` prop 动态生成heading 标签的组件，你可很快能想到这样实现：\n\n``` html\n<script type=\"text/x-template\" id=\"anchored-heading-template\">\n  <div>\n    <h1 v-if=\"level === 1\">\n      <slot></slot>\n    </h1>\n    <h2 v-if=\"level === 2\">\n      <slot></slot>\n    </h2>\n    <h3 v-if=\"level === 3\">\n      <slot></slot>\n    </h3>\n    <h4 v-if=\"level === 4\">\n      <slot></slot>\n    </h4>\n    <h5 v-if=\"level === 5\">\n      <slot></slot>\n    </h5>\n    <h6 v-if=\"level === 6\">\n      <slot></slot>\n    </h6>\n  </div>\n</script>\n```\n\n``` js\nVue.component('anchored-heading', {\n  template: '#anchored-heading-template',\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\ntemplate 在这种场景中就表现的有些冗余了。虽然我们重复使用 `<slot></slot>` 来接收每一个级别的标题标签，在标题标签中添加相同的锚点元素。但是些都会被包裹在一个无用的 `div` 中，因为组件必须有根节点。\n\n虽然模板在大多数组件中都非常好用，但是在这里它就不是很简洁的了。那么，我们来尝试使用 `render` 函数重写上面的例子：\n\n``` js\nVue.component('anchored-heading', {\n  render: function (createElement) {\n    return createElement(\n      'h' + this.level,   // tag name 标签名称\n      this.$slots.default // 子组件中的阵列\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\n简单清晰很多！简单来说，这样代码精简很多，但是需要非常熟悉 Vue 的实例属性。在这个例子中，你需要知道当你不使用 `slot`  属性向组件中传递内容时，比如 `anchored-heading` 中的 `Hello world!`, 这些子元素被存储在组件实例中的 `$slots.default`中。如果你还不了解，** 在深入 render 函数之前推荐阅读 [instance properties API](../api/#vm-slots)。**\n\n## `createElement` 参数\n\n第二件你需要熟悉的是如何在 `createElement` 函数中生成模板。这里是 `createElement` 接受的参数：\n\n``` js\n// @returns {VNode}\ncreateElement(\n  // {String | Object | Function}\n  // 一个 HTML 标签，组件选项，或一个函数\n  // 必须 Return 上述其中一个\n  'div',\n\n  // {Object}\n  // 一个对应属性的数据对象\n  // 您可以在 template 中使用.可选项.\n  {\n    // (下一章，将详细说明相关细节)\n  },\n\n  // {String | Array}\n  // 子节点(VNodes). 可选项.\n  [\n    createElement('h1', 'hello world'),\n    createElement(MyComponent, {\n      props: {\n        someProp: 'foo'\n      }\n    }),\n    'bar'\n  ]\n)\n```\n\n### 完整数据对象\n\n有一件事要注意：在 templates 中，`v-bind:class` 和  `v-bind:style` ，会有特别的处理，他们在 VNode 数据对象中，为最高级配置。\n\n\n``` js\n{\n  // 和`v-bind:class`一样的 API\n  'class': {\n    foo: true,\n    bar: false\n  },\n  // 和`v-bind:style`一样的 API\n  style: {\n    color: 'red',\n    fontSize: '14px'\n  },\n  // 正常的 HTML 特性\n  attrs: {\n    id: 'foo'\n  },\n  // 组件 props\n  props: {\n    myProp: 'bar'\n  },\n  // DOM 属性\n  domProps: {\n    innerHTML: 'baz'\n  },\n  // 事件监听器基于 \"on\"\n  // 所以不再支持如 v-on:keyup.enter 修饰器\n  // 需要手动匹配 keyCode。\n  on: {\n    click: this.clickHandler\n  },\n  // 仅对于组件，用于监听原生事件，而不是组件使用 vm.$emit 触发的事件。\n  nativeOn: {\n    click: this.nativeClickHandler\n  },\n  // 自定义指令. 注意事项：不能对绑定的旧值设值\n  // Vue 会为您持续追踨\n  directives: [\n    {\n      name: 'my-custom-directive',\n      value: '2'\n      expression: '1 + 1',\n      arg: 'foo',\n      modifiers: {\n        bar: true\n      }\n    }\n  ],\n  // Scoped slots in the form of\n  // { name: props => VNode | Array<VNode> }\n  scopedSlots: {\n    default: props => h('span', props.text)\n  },\n  // 如果子组件有定义 slot 的名称\n  slot: 'name-of-slot'\n  // 其他特殊顶层属性\n  key: 'myKey',\n  ref: 'myRef'\n}\n```\n\n### 完整示例\n\n有了这方面的知识，我们现在可以完成我们最开始想实现的组件：\n\n``` js\nvar getChildrenTextContent = function (children) {\n  return children.map(function (node) {\n    return node.children\n      ? getChildrenTextContent(node.children)\n      : node.text\n  }).join('')\n}\n\nVue.component('anchored-heading', {\n  render: function (createElement) {\n    // create kebabCase id\n    var headingId = getChildrenTextContent(this.$slots.default)\n      .toLowerCase()\n      .replace(/\\W+/g, '-')\n      .replace(/(^\\-|\\-$)/g, '')\n\n    return createElement(\n      'h' + this.level,\n      [\n        createElement('a', {\n          attrs: {\n            name: headingId,\n            href: '#' + headingId\n          }\n        }, this.$slots.default)\n      ]\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\n### 约束\n\n#### VNodes 必须唯一\n\n所有组件树中的 VNodes 必须唯一。这意味着，下面的 render function 是无效的：\n\n``` js\nrender: function (createElement) {\n  var myParagraphVNode = createElement('p', 'hi')\n  return createElement('div', [\n    // Yikes - duplicate VNodes!\n    myParagraphVNode, myParagraphVNode\n  ])\n}\n```\n\n如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这个例子 render 函数完美有效地渲染了 20 个重复的段落：\n\n``` js\nrender: function (createElement) {\n  return createElement('div',\n    Array.apply(null, { length: 20 }).map(function () {\n      return createElement('p', 'hi')\n    })\n  )\n}\n```\n\n## 使用 JavaScript 代替模板功能\n\n### `v-if` and `v-for`\n\n无论什么都可以使用原生的 JavaScript 来实现，Vue 的 render 函数不会提供专用的 API。比如， template 中的 `v-if` 和 `v-for`:\n\n``` html\n<ul v-if=\"items.length\">\n  <li v-for=\"item in items\">{{ item.name }}</li>\n</ul>\n<p v-else>No items found.</p>\n```\n这些都会在 render 函数中被 JavaScript 的 `if`/`else` 和 `map` 重写：\n\n``` js\nrender: function (createElement) {\n  if (this.items.length) {\n    return createElement('ul', this.items.map(function (item) {\n      return createElement('li', item.name)\n    }))\n  } else {\n    return createElement('p', 'No items found.')\n  }\n}\n```\n\n### `v-model`\n\nThere is no direct `v-model` counterpart in render functions - you will have to implement the logic yourself:\n\n``` js\nrender: function (createElement) {\n  var self = this\n  return createElement('input', {\n    domProps: {\n      value: self.value\n    },\n    on: {\n      input: function (event) {\n        self.value = event.target.value\n      }\n    }\n  })\n}\n```\n\nThis is the cost of going lower-level, but it also gives you much more control over the interaction details compared to `v-model`.\n\n### Event & Key Modifiers\n\nFor the `.capture` and `.once` event modifiers, Vue offers prefixes that can be used with `on`:\n\n| Modifier(s) | Prefix |\n| ------ | ------ |\n| `.capture` | `!` |\n| `.once` | `~` |\n| `.capture.once` or<br>`.once.capture` | `~!` |\n\nFor example:\n\n```javascript\non: {\n  '!click': this.doThisInCapturingMode,\n  '~keyup': this.doThisOnce,\n  `~!mouseover`: this.doThisOnceInCapturingMode\n}\n```\n\nFor all other event and key modifiers, no proprietary prefix is necessary, because you can simply use event methods in the handler:\n\n| Modifier(s) | Equivalent in Handler |\n| ------ | ------ |\n| `.stop` | `event.stopPropagation()` |\n| `.prevent` | `event.preventDefault()` |\n| `.self` | `if (event.target !== event.currentTarget) return` |\n| Keys:<br>`.enter`, `.13` | `if (event.keyCode !== 13) return` (change `13` to [another key code](http://keycode.info/) for other key modifiers) |\n| Modifiers Keys:<br>`.ctrl`, `.alt`, `.shift`, `.meta` | `if (!event.ctrlKey) return` (change `ctrlKey` to `altKey`, `shiftKey`, or `metaKey`, respectively) |\n\nHere's an example with all of these modifiers used together:\n\n```javascript\non: {\n  keyup: function (event) {\n    // Abort if the element emitting the event is not\n    // the element the event is bound to\n    if (event.target !== event.currentTarget) return\n    // Abort if the key that went up is not the enter\n    // key (13) and the shift key was not held down\n    // at the same time\n    if (!event.shiftKey || event.keyCode !== 13) return\n    // Stop event propagation\n    event.stopPropagation()\n    // Prevent the default keyup handler for this element\n    event.preventDefault()\n    // ...\n  }\n}\n```\n\n### Slots\n\nYou can access static slot contents as Arrays of VNodes from [`this.$slots`](http://vuejs.org/v2/api/#vm-slots):\n\n``` js\nrender: function (createElement) {\n  // <div><slot></slot></div>\n  return createElement('div', this.$slots.default)\n}\n```\n\nAnd access scoped slots as functions that return VNodes from [`this.$scopedSlots`](http://vuejs.org/v2/api/#vm-scopedSlots):\n\n``` js\nrender: function (createElement) {\n  // <div><slot :text=\"msg\"></slot></div>\n  return createElement('div', [\n    this.$scopedSlots.default({\n      text: this.msg\n    })\n  ])\n}\n```\n\nTo pass scoped slots to a child component using render functions, use the `scopedSlots` field in VNode data:\n\n``` js\nrender (createElement) {\n  return createElement('div', [\n    createElement('child', {\n      // pass scopedSlots in the data object\n      // in the form of { name: props => VNode | Array<VNode> }\n      scopedSlots: {\n        default: function (props) {\n          return createElement('span', props.text)\n        }\n      }\n    })\n  ])\n}\n```\n\n## JSX\n\n如果你写了很多 `render`  函数，可能会觉得痛苦：\n\n``` js\ncreateElement(\n  'anchored-heading', {\n    props: {\n      level: 1\n    }\n  }, [\n    createElement('span', 'Hello'),\n    ' world!'\n  ]\n)\n```\n\n特别是模板如此简单的情况下：\n\n``` html\n<anchored-heading :level=\"1\">\n  <span>Hello</span> world!\n</anchored-heading>\n```\n\n这就是会有一个 [Babel plugin](https://github.com/vuejs/babel-plugin-transform-vue-jsx) 插件，用于在 Vue 中使用 JSX 语法的原因，它可以让我们回到于更接近模板的语法上。\n\n\n``` js\nimport AnchoredHeading from './AnchoredHeading.vue'\n\nnew Vue({\n  el: '#demo',\n  render (h) {\n    return (\n      <AnchoredHeading level={1}>\n        <span>Hello</span> world!\n      </AnchoredHeading>\n    )\n  }\n})\n```\n<p class=\"tip\">将 `h` 作为 `createElement` 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的，如果在作用域中 `h` 失去作用， 在应用中会触发报错。</p>\n\n更多关于 JSX 映射到 JavaScript，阅读 [使用文档](https://github.com/vuejs/babel-plugin-transform-vue-jsx#usage)。\n\n\n## 函数化组件\n\n之前创建的锚点标题组件是比较简单，没有管理或者监听任何传递给他的状态，也没有生命周期方法。它只是一个接收参数的函数。\n在这个例子中，我们标记组件为 `functional`， 这意味它是无状态（没有 `data`），无实例（没有 `this` 上下文）。\n一个 **函数化组件** 就像这样：\n\n\n``` js\nVue.component('my-component', {\n  functional: true,\n  // 为了弥补缺少的实例\n  // 提供第二个参数作为上下文\n  render: function (createElement, context) {\n    // ...\n  },\n  // Props 可选\n  props: {\n    // ...\n  }\n})\n```\n\n组件需要的一切都是通过上下文传递，包括：\n\n- `props`: 提供props 的对象\n- `children`: VNode 子节点的数组\n- `slots`: slots 对象\n- `data`: 传递给组件的 data 对象\n- `parent`: 对父组件的引用\n\n\n在添加 `functional: true` 之后，锚点标题组件的 render 函数之间简单更新增加 `context` 参数，`this.$slots.default` 更新为 `context.children`，之后`this.level` 更新为 `context.props.level`。\n\n函数化组件只是一个函数，所以渲染开销也低很多。但同样它也有完整的组件封装，你需要知道这些， 比如：\n\n\n- 程序化地在多个组件中选择一个\n- 在将 children, props, data 传递给子组件之前操作它们。 \n\n\n\n下面是一个依赖传入 props 的值的 `smart-list` 组件例子，它能代表更多具体的组件：\n\n\n``` js\nvar EmptyList = { /* ... */ }\nvar TableList = { /* ... */ }\nvar OrderedList = { /* ... */ }\nvar UnorderedList = { /* ... */ }\n\nVue.component('smart-list', {\n  functional: true,\n  render: function (createElement, context) {\n    function appropriateListComponent () {\n      var items = context.props.items\n\n      if (items.length === 0)           return EmptyList\n      if (typeof items[0] === 'object') return TableList\n      if (context.props.isOrdered)      return OrderedList\n\n      return UnorderedList\n    }\n\n    return createElement(\n      appropriateListComponent(),\n      context.data,\n      context.children\n    )\n  },\n  props: {\n    items: {\n      type: Array,\n      required: true\n    },\n    isOrdered: Boolean\n  }\n})\n```\n\n### `slots()` 和 `children` 对比\n\n你可能想知道为什么同时需要 `slots()` 和 `children`。`slots().default` 不是和 `children` 类似的吗？在一些场景中，是这样，但是如果是函数式组件和下面这样的 children 呢？\n\n``` html\n<my-functional-component>\n  <p slot=\"foo\">\n    first\n  </p>\n  <p>second</p>\n</my-functional-component>\n```\n\n对于这个组件，`children` 会给你两个段落标签，而 `slots().default` 只会传递第二个匿名段落标签，`slots().foo` 会传递第一个具名段落标签。同时拥有 `children` 和 `slots()` ，因此你可以选择让组件通过 `slot()` 系统分发或者简单的通过 `children` 接收，让其他组件去处理。\n\n## 模板编译\n\n你可能有兴趣知道，Vue 的模板实际是编译成了 render 函数。这是一个实现细节，通常不需要关心，但如果你想看看模板的功能是怎样被编译的，你会发现会非常有趣。下面是一个使用 `Vue.compile`  来实时编译模板字符串的简单 demo：\n\n{% raw %}\n<div id=\"vue-compile-demo\" class=\"demo\">\n  <textarea v-model=\"templateText\" rows=\"10\"></textarea>\n  <div v-if=\"typeof result === 'object'\">\n    <label>render:</label>\n    <pre><code>{{ result.render }}</code></pre>\n    <label>staticRenderFns:</label>\n    <pre v-for=\"(fn, index) in result.staticRenderFns\"><code>_m({{ index }}): {{ fn }}</code></pre>\n  </div>\n  <div v-else>\n    <label>Compilation Error:</label>\n    <pre><code>{{ result }}</code></pre>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#vue-compile-demo',\n  data: {\n    templateText: '\\\n<div>\\n\\\n  <h1>I\\'m a template!</h1>\\n\\\n  <p v-if=\"message\">\\n\\\n    {{ message }}\\n\\\n  </p>\\n\\\n  <p v-else>\\n\\\n    No message.\\n\\\n  </p>\\n\\\n</div>\\\n    ',\n  },\n  computed: {\n    result: function () {\n      if (!this.templateText) {\n        return 'Enter a valid template above'\n      }\n      try {\n        var result = Vue.compile(this.templateText.replace(/\\s{2,}/g, ''))\n        return {\n          render: this.formatFunction(result.render),\n          staticRenderFns: result.staticRenderFns.map(this.formatFunction)\n        }\n      } catch (error) {\n        return error.message\n      }\n    }\n  },\n  methods: {\n    formatFunction: function (fn) {\n      return fn.toString().replace(/(\\{\\n)(\\S)/, '$1  $2')\n    }\n  }\n})\nconsole.error = function (error) {\n  throw new Error(error)\n}\n</script>\n<style>\n#vue-compile-demo pre {\n  padding: 10px;\n  overflow-x: auto;\n}\n#vue-compile-demo code {\n  white-space: pre;\n  padding: 0\n}\n#vue-compile-demo textarea {\n  width: 100%;\n\n}\n</style>\n{% endraw %}\n\n***\n\n> 原文： http://vuejs.org/guide/render-function.html\n\n***\n","source":"v2/guide/render-function.md","raw":"---\ntitle: Render 函数\ntype: guide\norder: 15\n---\n\n## 基础\n\nVue 推荐使用在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 **render 函数**，它比 template 更接近编译器。\n\n\n``` html\n<h1>\n  <a name=\"hello-world\" href=\"#hello-world\">\n    Hello world!\n  </a>\n</h1>\n```\n\n在 HTML 层， 我们决定这样定义组件接口：\n\n``` html\n<anchored-heading :level=\"1\">Hello world!</anchored-heading>\n```\n\n当我们开始写一个通过 `level` prop 动态生成heading 标签的组件，你可很快能想到这样实现：\n\n``` html\n<script type=\"text/x-template\" id=\"anchored-heading-template\">\n  <div>\n    <h1 v-if=\"level === 1\">\n      <slot></slot>\n    </h1>\n    <h2 v-if=\"level === 2\">\n      <slot></slot>\n    </h2>\n    <h3 v-if=\"level === 3\">\n      <slot></slot>\n    </h3>\n    <h4 v-if=\"level === 4\">\n      <slot></slot>\n    </h4>\n    <h5 v-if=\"level === 5\">\n      <slot></slot>\n    </h5>\n    <h6 v-if=\"level === 6\">\n      <slot></slot>\n    </h6>\n  </div>\n</script>\n```\n\n``` js\nVue.component('anchored-heading', {\n  template: '#anchored-heading-template',\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\ntemplate 在这种场景中就表现的有些冗余了。虽然我们重复使用 `<slot></slot>` 来接收每一个级别的标题标签，在标题标签中添加相同的锚点元素。但是些都会被包裹在一个无用的 `div` 中，因为组件必须有根节点。\n\n虽然模板在大多数组件中都非常好用，但是在这里它就不是很简洁的了。那么，我们来尝试使用 `render` 函数重写上面的例子：\n\n``` js\nVue.component('anchored-heading', {\n  render: function (createElement) {\n    return createElement(\n      'h' + this.level,   // tag name 标签名称\n      this.$slots.default // 子组件中的阵列\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\n简单清晰很多！简单来说，这样代码精简很多，但是需要非常熟悉 Vue 的实例属性。在这个例子中，你需要知道当你不使用 `slot`  属性向组件中传递内容时，比如 `anchored-heading` 中的 `Hello world!`, 这些子元素被存储在组件实例中的 `$slots.default`中。如果你还不了解，** 在深入 render 函数之前推荐阅读 [instance properties API](../api/#vm-slots)。**\n\n## `createElement` 参数\n\n第二件你需要熟悉的是如何在 `createElement` 函数中生成模板。这里是 `createElement` 接受的参数：\n\n``` js\n// @returns {VNode}\ncreateElement(\n  // {String | Object | Function}\n  // 一个 HTML 标签，组件选项，或一个函数\n  // 必须 Return 上述其中一个\n  'div',\n\n  // {Object}\n  // 一个对应属性的数据对象\n  // 您可以在 template 中使用.可选项.\n  {\n    // (下一章，将详细说明相关细节)\n  },\n\n  // {String | Array}\n  // 子节点(VNodes). 可选项.\n  [\n    createElement('h1', 'hello world'),\n    createElement(MyComponent, {\n      props: {\n        someProp: 'foo'\n      }\n    }),\n    'bar'\n  ]\n)\n```\n\n### 完整数据对象\n\n有一件事要注意：在 templates 中，`v-bind:class` 和  `v-bind:style` ，会有特别的处理，他们在 VNode 数据对象中，为最高级配置。\n\n\n``` js\n{\n  // 和`v-bind:class`一样的 API\n  'class': {\n    foo: true,\n    bar: false\n  },\n  // 和`v-bind:style`一样的 API\n  style: {\n    color: 'red',\n    fontSize: '14px'\n  },\n  // 正常的 HTML 特性\n  attrs: {\n    id: 'foo'\n  },\n  // 组件 props\n  props: {\n    myProp: 'bar'\n  },\n  // DOM 属性\n  domProps: {\n    innerHTML: 'baz'\n  },\n  // 事件监听器基于 \"on\"\n  // 所以不再支持如 v-on:keyup.enter 修饰器\n  // 需要手动匹配 keyCode。\n  on: {\n    click: this.clickHandler\n  },\n  // 仅对于组件，用于监听原生事件，而不是组件使用 vm.$emit 触发的事件。\n  nativeOn: {\n    click: this.nativeClickHandler\n  },\n  // 自定义指令. 注意事项：不能对绑定的旧值设值\n  // Vue 会为您持续追踨\n  directives: [\n    {\n      name: 'my-custom-directive',\n      value: '2'\n      expression: '1 + 1',\n      arg: 'foo',\n      modifiers: {\n        bar: true\n      }\n    }\n  ],\n  // Scoped slots in the form of\n  // { name: props => VNode | Array<VNode> }\n  scopedSlots: {\n    default: props => h('span', props.text)\n  },\n  // 如果子组件有定义 slot 的名称\n  slot: 'name-of-slot'\n  // 其他特殊顶层属性\n  key: 'myKey',\n  ref: 'myRef'\n}\n```\n\n### 完整示例\n\n有了这方面的知识，我们现在可以完成我们最开始想实现的组件：\n\n``` js\nvar getChildrenTextContent = function (children) {\n  return children.map(function (node) {\n    return node.children\n      ? getChildrenTextContent(node.children)\n      : node.text\n  }).join('')\n}\n\nVue.component('anchored-heading', {\n  render: function (createElement) {\n    // create kebabCase id\n    var headingId = getChildrenTextContent(this.$slots.default)\n      .toLowerCase()\n      .replace(/\\W+/g, '-')\n      .replace(/(^\\-|\\-$)/g, '')\n\n    return createElement(\n      'h' + this.level,\n      [\n        createElement('a', {\n          attrs: {\n            name: headingId,\n            href: '#' + headingId\n          }\n        }, this.$slots.default)\n      ]\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\n### 约束\n\n#### VNodes 必须唯一\n\n所有组件树中的 VNodes 必须唯一。这意味着，下面的 render function 是无效的：\n\n``` js\nrender: function (createElement) {\n  var myParagraphVNode = createElement('p', 'hi')\n  return createElement('div', [\n    // Yikes - duplicate VNodes!\n    myParagraphVNode, myParagraphVNode\n  ])\n}\n```\n\n如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这个例子 render 函数完美有效地渲染了 20 个重复的段落：\n\n``` js\nrender: function (createElement) {\n  return createElement('div',\n    Array.apply(null, { length: 20 }).map(function () {\n      return createElement('p', 'hi')\n    })\n  )\n}\n```\n\n## 使用 JavaScript 代替模板功能\n\n### `v-if` and `v-for`\n\n无论什么都可以使用原生的 JavaScript 来实现，Vue 的 render 函数不会提供专用的 API。比如， template 中的 `v-if` 和 `v-for`:\n\n``` html\n<ul v-if=\"items.length\">\n  <li v-for=\"item in items\">{{ item.name }}</li>\n</ul>\n<p v-else>No items found.</p>\n```\n这些都会在 render 函数中被 JavaScript 的 `if`/`else` 和 `map` 重写：\n\n``` js\nrender: function (createElement) {\n  if (this.items.length) {\n    return createElement('ul', this.items.map(function (item) {\n      return createElement('li', item.name)\n    }))\n  } else {\n    return createElement('p', 'No items found.')\n  }\n}\n```\n\n### `v-model`\n\nThere is no direct `v-model` counterpart in render functions - you will have to implement the logic yourself:\n\n``` js\nrender: function (createElement) {\n  var self = this\n  return createElement('input', {\n    domProps: {\n      value: self.value\n    },\n    on: {\n      input: function (event) {\n        self.value = event.target.value\n      }\n    }\n  })\n}\n```\n\nThis is the cost of going lower-level, but it also gives you much more control over the interaction details compared to `v-model`.\n\n### Event & Key Modifiers\n\nFor the `.capture` and `.once` event modifiers, Vue offers prefixes that can be used with `on`:\n\n| Modifier(s) | Prefix |\n| ------ | ------ |\n| `.capture` | `!` |\n| `.once` | `~` |\n| `.capture.once` or<br>`.once.capture` | `~!` |\n\nFor example:\n\n```javascript\non: {\n  '!click': this.doThisInCapturingMode,\n  '~keyup': this.doThisOnce,\n  `~!mouseover`: this.doThisOnceInCapturingMode\n}\n```\n\nFor all other event and key modifiers, no proprietary prefix is necessary, because you can simply use event methods in the handler:\n\n| Modifier(s) | Equivalent in Handler |\n| ------ | ------ |\n| `.stop` | `event.stopPropagation()` |\n| `.prevent` | `event.preventDefault()` |\n| `.self` | `if (event.target !== event.currentTarget) return` |\n| Keys:<br>`.enter`, `.13` | `if (event.keyCode !== 13) return` (change `13` to [another key code](http://keycode.info/) for other key modifiers) |\n| Modifiers Keys:<br>`.ctrl`, `.alt`, `.shift`, `.meta` | `if (!event.ctrlKey) return` (change `ctrlKey` to `altKey`, `shiftKey`, or `metaKey`, respectively) |\n\nHere's an example with all of these modifiers used together:\n\n```javascript\non: {\n  keyup: function (event) {\n    // Abort if the element emitting the event is not\n    // the element the event is bound to\n    if (event.target !== event.currentTarget) return\n    // Abort if the key that went up is not the enter\n    // key (13) and the shift key was not held down\n    // at the same time\n    if (!event.shiftKey || event.keyCode !== 13) return\n    // Stop event propagation\n    event.stopPropagation()\n    // Prevent the default keyup handler for this element\n    event.preventDefault()\n    // ...\n  }\n}\n```\n\n### Slots\n\nYou can access static slot contents as Arrays of VNodes from [`this.$slots`](http://vuejs.org/v2/api/#vm-slots):\n\n``` js\nrender: function (createElement) {\n  // <div><slot></slot></div>\n  return createElement('div', this.$slots.default)\n}\n```\n\nAnd access scoped slots as functions that return VNodes from [`this.$scopedSlots`](http://vuejs.org/v2/api/#vm-scopedSlots):\n\n``` js\nrender: function (createElement) {\n  // <div><slot :text=\"msg\"></slot></div>\n  return createElement('div', [\n    this.$scopedSlots.default({\n      text: this.msg\n    })\n  ])\n}\n```\n\nTo pass scoped slots to a child component using render functions, use the `scopedSlots` field in VNode data:\n\n``` js\nrender (createElement) {\n  return createElement('div', [\n    createElement('child', {\n      // pass scopedSlots in the data object\n      // in the form of { name: props => VNode | Array<VNode> }\n      scopedSlots: {\n        default: function (props) {\n          return createElement('span', props.text)\n        }\n      }\n    })\n  ])\n}\n```\n\n## JSX\n\n如果你写了很多 `render`  函数，可能会觉得痛苦：\n\n``` js\ncreateElement(\n  'anchored-heading', {\n    props: {\n      level: 1\n    }\n  }, [\n    createElement('span', 'Hello'),\n    ' world!'\n  ]\n)\n```\n\n特别是模板如此简单的情况下：\n\n``` html\n<anchored-heading :level=\"1\">\n  <span>Hello</span> world!\n</anchored-heading>\n```\n\n这就是会有一个 [Babel plugin](https://github.com/vuejs/babel-plugin-transform-vue-jsx) 插件，用于在 Vue 中使用 JSX 语法的原因，它可以让我们回到于更接近模板的语法上。\n\n\n``` js\nimport AnchoredHeading from './AnchoredHeading.vue'\n\nnew Vue({\n  el: '#demo',\n  render (h) {\n    return (\n      <AnchoredHeading level={1}>\n        <span>Hello</span> world!\n      </AnchoredHeading>\n    )\n  }\n})\n```\n<p class=\"tip\">将 `h` 作为 `createElement` 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的，如果在作用域中 `h` 失去作用， 在应用中会触发报错。</p>\n\n更多关于 JSX 映射到 JavaScript，阅读 [使用文档](https://github.com/vuejs/babel-plugin-transform-vue-jsx#usage)。\n\n\n## 函数化组件\n\n之前创建的锚点标题组件是比较简单，没有管理或者监听任何传递给他的状态，也没有生命周期方法。它只是一个接收参数的函数。\n在这个例子中，我们标记组件为 `functional`， 这意味它是无状态（没有 `data`），无实例（没有 `this` 上下文）。\n一个 **函数化组件** 就像这样：\n\n\n``` js\nVue.component('my-component', {\n  functional: true,\n  // 为了弥补缺少的实例\n  // 提供第二个参数作为上下文\n  render: function (createElement, context) {\n    // ...\n  },\n  // Props 可选\n  props: {\n    // ...\n  }\n})\n```\n\n组件需要的一切都是通过上下文传递，包括：\n\n- `props`: 提供props 的对象\n- `children`: VNode 子节点的数组\n- `slots`: slots 对象\n- `data`: 传递给组件的 data 对象\n- `parent`: 对父组件的引用\n\n\n在添加 `functional: true` 之后，锚点标题组件的 render 函数之间简单更新增加 `context` 参数，`this.$slots.default` 更新为 `context.children`，之后`this.level` 更新为 `context.props.level`。\n\n函数化组件只是一个函数，所以渲染开销也低很多。但同样它也有完整的组件封装，你需要知道这些， 比如：\n\n\n- 程序化地在多个组件中选择一个\n- 在将 children, props, data 传递给子组件之前操作它们。 \n\n\n\n下面是一个依赖传入 props 的值的 `smart-list` 组件例子，它能代表更多具体的组件：\n\n\n``` js\nvar EmptyList = { /* ... */ }\nvar TableList = { /* ... */ }\nvar OrderedList = { /* ... */ }\nvar UnorderedList = { /* ... */ }\n\nVue.component('smart-list', {\n  functional: true,\n  render: function (createElement, context) {\n    function appropriateListComponent () {\n      var items = context.props.items\n\n      if (items.length === 0)           return EmptyList\n      if (typeof items[0] === 'object') return TableList\n      if (context.props.isOrdered)      return OrderedList\n\n      return UnorderedList\n    }\n\n    return createElement(\n      appropriateListComponent(),\n      context.data,\n      context.children\n    )\n  },\n  props: {\n    items: {\n      type: Array,\n      required: true\n    },\n    isOrdered: Boolean\n  }\n})\n```\n\n### `slots()` 和 `children` 对比\n\n你可能想知道为什么同时需要 `slots()` 和 `children`。`slots().default` 不是和 `children` 类似的吗？在一些场景中，是这样，但是如果是函数式组件和下面这样的 children 呢？\n\n``` html\n<my-functional-component>\n  <p slot=\"foo\">\n    first\n  </p>\n  <p>second</p>\n</my-functional-component>\n```\n\n对于这个组件，`children` 会给你两个段落标签，而 `slots().default` 只会传递第二个匿名段落标签，`slots().foo` 会传递第一个具名段落标签。同时拥有 `children` 和 `slots()` ，因此你可以选择让组件通过 `slot()` 系统分发或者简单的通过 `children` 接收，让其他组件去处理。\n\n## 模板编译\n\n你可能有兴趣知道，Vue 的模板实际是编译成了 render 函数。这是一个实现细节，通常不需要关心，但如果你想看看模板的功能是怎样被编译的，你会发现会非常有趣。下面是一个使用 `Vue.compile`  来实时编译模板字符串的简单 demo：\n\n{% raw %}\n<div id=\"vue-compile-demo\" class=\"demo\">\n  <textarea v-model=\"templateText\" rows=\"10\"></textarea>\n  <div v-if=\"typeof result === 'object'\">\n    <label>render:</label>\n    <pre><code>{{ result.render }}</code></pre>\n    <label>staticRenderFns:</label>\n    <pre v-for=\"(fn, index) in result.staticRenderFns\"><code>_m({{ index }}): {{ fn }}</code></pre>\n  </div>\n  <div v-else>\n    <label>Compilation Error:</label>\n    <pre><code>{{ result }}</code></pre>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#vue-compile-demo',\n  data: {\n    templateText: '\\\n<div>\\n\\\n  <h1>I\\'m a template!</h1>\\n\\\n  <p v-if=\"message\">\\n\\\n    {{ message }}\\n\\\n  </p>\\n\\\n  <p v-else>\\n\\\n    No message.\\n\\\n  </p>\\n\\\n</div>\\\n    ',\n  },\n  computed: {\n    result: function () {\n      if (!this.templateText) {\n        return 'Enter a valid template above'\n      }\n      try {\n        var result = Vue.compile(this.templateText.replace(/\\s{2,}/g, ''))\n        return {\n          render: this.formatFunction(result.render),\n          staticRenderFns: result.staticRenderFns.map(this.formatFunction)\n        }\n      } catch (error) {\n        return error.message\n      }\n    }\n  },\n  methods: {\n    formatFunction: function (fn) {\n      return fn.toString().replace(/(\\{\\n)(\\S)/, '$1  $2')\n    }\n  }\n})\nconsole.error = function (error) {\n  throw new Error(error)\n}\n</script>\n<style>\n#vue-compile-demo pre {\n  padding: 10px;\n  overflow-x: auto;\n}\n#vue-compile-demo code {\n  white-space: pre;\n  padding: 0\n}\n#vue-compile-demo textarea {\n  width: 100%;\n\n}\n</style>\n{% endraw %}\n\n***\n\n> 原文： http://vuejs.org/guide/render-function.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/render-function.html","comments":1,"layout":"page","_id":"ciwnajuyw001ojl2d84m83eo4","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>Vue 推荐使用在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 <strong>render 函数</strong>，它比 template 更接近编译器。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hello-world\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#hello-world\"</span>&gt;</span></div><div class=\"line\">    Hello world!</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在 HTML 层， 我们决定这样定义组件接口：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">anchored-heading</span> <span class=\"attr\">:level</span>=<span class=\"string\">\"1\"</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">anchored-heading</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当我们开始写一个通过 <code>level</code> prop 动态生成heading 标签的组件，你可很快能想到这样实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/x-template\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"anchored-heading-template\"</span>&gt;</span><span class=\"xml\"></span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 1\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 2\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 3\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h4</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 4\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h4</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h5</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 5\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 6\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'anchored-heading'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'#anchored-heading-template'</span>,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">level</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>template 在这种场景中就表现的有些冗余了。虽然我们重复使用 <code>&lt;slot&gt;&lt;/slot&gt;</code> 来接收每一个级别的标题标签，在标题标签中添加相同的锚点元素。但是些都会被包裹在一个无用的 <code>div</code> 中，因为组件必须有根节点。</p>\n<p>虽然模板在大多数组件中都非常好用，但是在这里它就不是很简洁的了。那么，我们来尝试使用 <code>render</code> 函数重写上面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'anchored-heading'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(</div><div class=\"line\">      <span class=\"string\">'h'</span> + <span class=\"keyword\">this</span>.level,   <span class=\"comment\">// tag name 标签名称</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$slots.default <span class=\"comment\">// 子组件中的阵列</span></div><div class=\"line\">    )</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">level</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>简单清晰很多！简单来说，这样代码精简很多，但是需要非常熟悉 Vue 的实例属性。在这个例子中，你需要知道当你不使用 <code>slot</code>  属性向组件中传递内容时，比如 <code>anchored-heading</code> 中的 <code>Hello world!</code>, 这些子元素被存储在组件实例中的 <code>$slots.default</code>中。如果你还不了解，<strong> 在深入 render 函数之前推荐阅读 <a href=\"../api/#vm-slots\">instance properties API</a>。</strong></p>\n<h2 id=\"createElement-参数\"><a href=\"#createElement-参数\" class=\"headerlink\" title=\"createElement 参数\"></a><code>createElement</code> 参数</h2><p>第二件你需要熟悉的是如何在 <code>createElement</code> 函数中生成模板。这里是 <code>createElement</code> 接受的参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// @returns &#123;VNode&#125;</span></div><div class=\"line\">createElement(</div><div class=\"line\">  <span class=\"comment\">// &#123;String | Object | Function&#125;</span></div><div class=\"line\">  <span class=\"comment\">// 一个 HTML 标签，组件选项，或一个函数</span></div><div class=\"line\">  <span class=\"comment\">// 必须 Return 上述其中一个</span></div><div class=\"line\">  <span class=\"string\">'div'</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// &#123;Object&#125;</span></div><div class=\"line\">  <span class=\"comment\">// 一个对应属性的数据对象</span></div><div class=\"line\">  <span class=\"comment\">// 您可以在 template 中使用.可选项.</span></div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"comment\">// (下一章，将详细说明相关细节)</span></div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// &#123;String | Array&#125;</span></div><div class=\"line\">  <span class=\"comment\">// 子节点(VNodes). 可选项.</span></div><div class=\"line\">  [</div><div class=\"line\">    createElement(<span class=\"string\">'h1'</span>, <span class=\"string\">'hello world'</span>),</div><div class=\"line\">    createElement(MyComponent, &#123;</div><div class=\"line\">      <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">someProp</span>: <span class=\"string\">'foo'</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"string\">'bar'</span></div><div class=\"line\">  ]</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<h3 id=\"完整数据对象\"><a href=\"#完整数据对象\" class=\"headerlink\" title=\"完整数据对象\"></a>完整数据对象</h3><p>有一件事要注意：在 templates 中，<code>v-bind:class</code> 和  <code>v-bind:style</code> ，会有特别的处理，他们在 VNode 数据对象中，为最高级配置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"comment\">// 和`v-bind:class`一样的 API</span></div><div class=\"line\">  <span class=\"string\">'class'</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">bar</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 和`v-bind:style`一样的 API</span></div><div class=\"line\">  style: &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>: <span class=\"string\">'red'</span>,</div><div class=\"line\">    <span class=\"attr\">fontSize</span>: <span class=\"string\">'14px'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 正常的 HTML 特性</span></div><div class=\"line\">  attrs: &#123;</div><div class=\"line\">    <span class=\"attr\">id</span>: <span class=\"string\">'foo'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 组件 props</span></div><div class=\"line\">  props: &#123;</div><div class=\"line\">    <span class=\"attr\">myProp</span>: <span class=\"string\">'bar'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// DOM 属性</span></div><div class=\"line\">  domProps: &#123;</div><div class=\"line\">    <span class=\"attr\">innerHTML</span>: <span class=\"string\">'baz'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 事件监听器基于 \"on\"</span></div><div class=\"line\">  <span class=\"comment\">// 所以不再支持如 v-on:keyup.enter 修饰器</span></div><div class=\"line\">  <span class=\"comment\">// 需要手动匹配 keyCode。</span></div><div class=\"line\">  on: &#123;</div><div class=\"line\">    <span class=\"attr\">click</span>: <span class=\"keyword\">this</span>.clickHandler</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 仅对于组件，用于监听原生事件，而不是组件使用 vm.$emit 触发的事件。</span></div><div class=\"line\">  nativeOn: &#123;</div><div class=\"line\">    <span class=\"attr\">click</span>: <span class=\"keyword\">this</span>.nativeClickHandler</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 自定义指令. 注意事项：不能对绑定的旧值设值</span></div><div class=\"line\">  <span class=\"comment\">// Vue 会为您持续追踨</span></div><div class=\"line\">  directives: [</div><div class=\"line\">    &#123;</div><div class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">'my-custom-directive'</span>,</div><div class=\"line\">      <span class=\"attr\">value</span>: <span class=\"string\">'2'</span></div><div class=\"line\">      expression: <span class=\"string\">'1 + 1'</span>,</div><div class=\"line\">      <span class=\"attr\">arg</span>: <span class=\"string\">'foo'</span>,</div><div class=\"line\">      <span class=\"attr\">modifiers</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">bar</span>: <span class=\"literal\">true</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  ],</div><div class=\"line\">  <span class=\"comment\">// Scoped slots in the form of</span></div><div class=\"line\">  <span class=\"comment\">// &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></div><div class=\"line\">  scopedSlots: &#123;</div><div class=\"line\">    <span class=\"attr\">default</span>: <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> h(<span class=\"string\">'span'</span>, props.text)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 如果子组件有定义 slot 的名称</span></div><div class=\"line\">  slot: <span class=\"string\">'name-of-slot'</span></div><div class=\"line\">  <span class=\"comment\">// 其他特殊顶层属性</span></div><div class=\"line\">  key: <span class=\"string\">'myKey'</span>,</div><div class=\"line\">  <span class=\"attr\">ref</span>: <span class=\"string\">'myRef'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"完整示例\"><a href=\"#完整示例\" class=\"headerlink\" title=\"完整示例\"></a>完整示例</h3><p>有了这方面的知识，我们现在可以完成我们最开始想实现的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getChildrenTextContent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">children</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> children.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> node.children</div><div class=\"line\">      ? getChildrenTextContent(node.children)</div><div class=\"line\">      : node.text</div><div class=\"line\">  &#125;).join(<span class=\"string\">''</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Vue.component(<span class=\"string\">'anchored-heading'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// create kebabCase id</span></div><div class=\"line\">    <span class=\"keyword\">var</span> headingId = getChildrenTextContent(<span class=\"keyword\">this</span>.$slots.default)</div><div class=\"line\">      .toLowerCase()</div><div class=\"line\">      .replace(<span class=\"regexp\">/\\W+/g</span>, <span class=\"string\">'-'</span>)</div><div class=\"line\">      .replace(<span class=\"regexp\">/(^\\-|\\-$)/g</span>, <span class=\"string\">''</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(</div><div class=\"line\">      <span class=\"string\">'h'</span> + <span class=\"keyword\">this</span>.level,</div><div class=\"line\">      [</div><div class=\"line\">        createElement(<span class=\"string\">'a'</span>, &#123;</div><div class=\"line\">          <span class=\"attr\">attrs</span>: &#123;</div><div class=\"line\">            <span class=\"attr\">name</span>: headingId,</div><div class=\"line\">            <span class=\"attr\">href</span>: <span class=\"string\">'#'</span> + headingId</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;, <span class=\"keyword\">this</span>.$slots.default)</div><div class=\"line\">      ]</div><div class=\"line\">    )</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">level</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h3><h4 id=\"VNodes-必须唯一\"><a href=\"#VNodes-必须唯一\" class=\"headerlink\" title=\"VNodes 必须唯一\"></a>VNodes 必须唯一</h4><p>所有组件树中的 VNodes 必须唯一。这意味着，下面的 render function 是无效的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> myParagraphVNode = createElement(<span class=\"string\">'p'</span>, <span class=\"string\">'hi'</span>)</div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, [</div><div class=\"line\">    <span class=\"comment\">// Yikes - duplicate VNodes!</span></div><div class=\"line\">    myParagraphVNode, myParagraphVNode</div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这个例子 render 函数完美有效地渲染了 20 个重复的段落：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>,</div><div class=\"line\">    <span class=\"built_in\">Array</span>.apply(<span class=\"literal\">null</span>, &#123; <span class=\"attr\">length</span>: <span class=\"number\">20</span> &#125;).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> createElement(<span class=\"string\">'p'</span>, <span class=\"string\">'hi'</span>)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  )</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"使用-JavaScript-代替模板功能\"><a href=\"#使用-JavaScript-代替模板功能\" class=\"headerlink\" title=\"使用 JavaScript 代替模板功能\"></a>使用 JavaScript 代替模板功能</h2><h3 id=\"v-if-and-v-for\"><a href=\"#v-if-and-v-for\" class=\"headerlink\" title=\"v-if and v-for\"></a><code>v-if</code> and <code>v-for</code></h3><p>无论什么都可以使用原生的 JavaScript 来实现，Vue 的 render 函数不会提供专用的 API。比如， template 中的 <code>v-if</code> 和 <code>v-for</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"items.length\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>No items found.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这些都会在 render 函数中被 JavaScript 的 <code>if</code>/<code>else</code> 和 <code>map</code> 重写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.items.length) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">'ul'</span>, <span class=\"keyword\">this</span>.items.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> createElement(<span class=\"string\">'li'</span>, item.name)</div><div class=\"line\">    &#125;))</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">'p'</span>, <span class=\"string\">'No items found.'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a><code>v-model</code></h3><p>There is no direct <code>v-model</code> counterpart in render functions - you will have to implement the logic yourself:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'input'</span>, &#123;</div><div class=\"line\">    <span class=\"attr\">domProps</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">value</span>: self.value</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">on</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">input</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">        self.value = event.target.value</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to <code>v-model</code>.</p>\n<h3 id=\"Event-amp-Key-Modifiers\"><a href=\"#Event-amp-Key-Modifiers\" class=\"headerlink\" title=\"Event &amp; Key Modifiers\"></a>Event &amp; Key Modifiers</h3><p>For the <code>.capture</code> and <code>.once</code> event modifiers, Vue offers prefixes that can be used with <code>on</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Modifier(s)</th>\n<th>Prefix</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.capture</code></td>\n<td><code>!</code></td>\n</tr>\n<tr>\n<td><code>.once</code></td>\n<td><code>~</code></td>\n</tr>\n<tr>\n<td><code>.capture.once</code> or<br><code>.once.capture</code></td>\n<td><code>~!</code></td>\n</tr>\n</tbody>\n</table>\n<p>For example:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">on: &#123;</div><div class=\"line\">  <span class=\"string\">'!click'</span>: <span class=\"keyword\">this</span>.doThisInCapturingMode,</div><div class=\"line\">  <span class=\"string\">'~keyup'</span>: <span class=\"keyword\">this</span>.doThisOnce,</div><div class=\"line\">  <span class=\"string\">`~!mouseover`</span>: <span class=\"keyword\">this</span>.doThisOnceInCapturingMode</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>For all other event and key modifiers, no proprietary prefix is necessary, because you can simply use event methods in the handler:</p>\n<table>\n<thead>\n<tr>\n<th>Modifier(s)</th>\n<th>Equivalent in Handler</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.stop</code></td>\n<td><code>event.stopPropagation()</code></td>\n</tr>\n<tr>\n<td><code>.prevent</code></td>\n<td><code>event.preventDefault()</code></td>\n</tr>\n<tr>\n<td><code>.self</code></td>\n<td><code>if (event.target !== event.currentTarget) return</code></td>\n</tr>\n<tr>\n<td>Keys:<br><code>.enter</code>, <code>.13</code></td>\n<td><code>if (event.keyCode !== 13) return</code> (change <code>13</code> to <a href=\"http://keycode.info/\" target=\"_blank\" rel=\"external\">another key code</a> for other key modifiers)</td>\n</tr>\n<tr>\n<td>Modifiers Keys:<br><code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></td>\n<td><code>if (!event.ctrlKey) return</code> (change <code>ctrlKey</code> to <code>altKey</code>, <code>shiftKey</code>, or <code>metaKey</code>, respectively)</td>\n</tr>\n</tbody>\n</table>\n<p>Here’s an example with all of these modifiers used together:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">on: &#123;</div><div class=\"line\">  <span class=\"attr\">keyup</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Abort if the element emitting the event is not</span></div><div class=\"line\">    <span class=\"comment\">// the element the event is bound to</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (event.target !== event.currentTarget) <span class=\"keyword\">return</span></div><div class=\"line\">    <span class=\"comment\">// Abort if the key that went up is not the enter</span></div><div class=\"line\">    <span class=\"comment\">// key (13) and the shift key was not held down</span></div><div class=\"line\">    <span class=\"comment\">// at the same time</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!event.shiftKey || event.keyCode !== <span class=\"number\">13</span>) <span class=\"keyword\">return</span></div><div class=\"line\">    <span class=\"comment\">// Stop event propagation</span></div><div class=\"line\">    event.stopPropagation()</div><div class=\"line\">    <span class=\"comment\">// Prevent the default keyup handler for this element</span></div><div class=\"line\">    event.preventDefault()</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Slots\"><a href=\"#Slots\" class=\"headerlink\" title=\"Slots\"></a>Slots</h3><p>You can access static slot contents as Arrays of VNodes from <a href=\"http://vuejs.org/v2/api/#vm-slots\" target=\"_blank\" rel=\"external\"><code>this.$slots</code></a>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// &lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;</span></div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, <span class=\"keyword\">this</span>.$slots.default)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And access scoped slots as functions that return VNodes from <a href=\"http://vuejs.org/v2/api/#vm-scopedSlots\" target=\"_blank\" rel=\"external\"><code>this.$scopedSlots</code></a>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// &lt;div&gt;&lt;slot :text=\"msg\"&gt;&lt;/slot&gt;&lt;/div&gt;</span></div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, [</div><div class=\"line\">    <span class=\"keyword\">this</span>.$scopedSlots.default(&#123;</div><div class=\"line\">      <span class=\"attr\">text</span>: <span class=\"keyword\">this</span>.msg</div><div class=\"line\">    &#125;)</div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>To pass scoped slots to a child component using render functions, use the <code>scopedSlots</code> field in VNode data:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render (createElement) &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, [</div><div class=\"line\">    createElement(<span class=\"string\">'child'</span>, &#123;</div><div class=\"line\">      <span class=\"comment\">// pass scopedSlots in the data object</span></div><div class=\"line\">      <span class=\"comment\">// in the form of &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></div><div class=\"line\">      scopedSlots: &#123;</div><div class=\"line\">        <span class=\"attr\">default</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> createElement(<span class=\"string\">'span'</span>, props.text)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>如果你写了很多 <code>render</code>  函数，可能会觉得痛苦：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">createElement(</div><div class=\"line\">  <span class=\"string\">'anchored-heading'</span>, &#123;</div><div class=\"line\">    <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">level</span>: <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, [</div><div class=\"line\">    createElement(<span class=\"string\">'span'</span>, <span class=\"string\">'Hello'</span>),</div><div class=\"line\">    <span class=\"string\">' world!'</span></div><div class=\"line\">  ]</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>特别是模板如此简单的情况下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">anchored-heading</span> <span class=\"attr\">:level</span>=<span class=\"string\">\"1\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> world!</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">anchored-heading</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这就是会有一个 <a href=\"https://github.com/vuejs/babel-plugin-transform-vue-jsx\" target=\"_blank\" rel=\"external\">Babel plugin</a> 插件，用于在 Vue 中使用 JSX 语法的原因，它可以让我们回到于更接近模板的语法上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> AnchoredHeading <span class=\"keyword\">from</span> <span class=\"string\">'./AnchoredHeading.vue'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#demo'</span>,</div><div class=\"line\">  render (h) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AnchoredHeading</span> <span class=\"attr\">level</span>=<span class=\"string\">&#123;1&#125;</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> world!</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">AnchoredHeading</span>&gt;</span></div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">将 <code>h</code> 作为 <code>createElement</code> 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的，如果在作用域中 <code>h</code> 失去作用， 在应用中会触发报错。</p>\n\n<p>更多关于 JSX 映射到 JavaScript，阅读 <a href=\"https://github.com/vuejs/babel-plugin-transform-vue-jsx#usage\" target=\"_blank\" rel=\"external\">使用文档</a>。</p>\n<h2 id=\"函数化组件\"><a href=\"#函数化组件\" class=\"headerlink\" title=\"函数化组件\"></a>函数化组件</h2><p>之前创建的锚点标题组件是比较简单，没有管理或者监听任何传递给他的状态，也没有生命周期方法。它只是一个接收参数的函数。<br>在这个例子中，我们标记组件为 <code>functional</code>， 这意味它是无状态（没有 <code>data</code>），无实例（没有 <code>this</code> 上下文）。<br>一个 <strong>函数化组件</strong> 就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">functional</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"comment\">// 为了弥补缺少的实例</span></div><div class=\"line\">  <span class=\"comment\">// 提供第二个参数作为上下文</span></div><div class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// Props 可选</span></div><div class=\"line\">  props: &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>组件需要的一切都是通过上下文传递，包括：</p>\n<ul>\n<li><code>props</code>: 提供props 的对象</li>\n<li><code>children</code>: VNode 子节点的数组</li>\n<li><code>slots</code>: slots 对象</li>\n<li><code>data</code>: 传递给组件的 data 对象</li>\n<li><code>parent</code>: 对父组件的引用</li>\n</ul>\n<p>在添加 <code>functional: true</code> 之后，锚点标题组件的 render 函数之间简单更新增加 <code>context</code> 参数，<code>this.$slots.default</code> 更新为 <code>context.children</code>，之后<code>this.level</code> 更新为 <code>context.props.level</code>。</p>\n<p>函数化组件只是一个函数，所以渲染开销也低很多。但同样它也有完整的组件封装，你需要知道这些， 比如：</p>\n<ul>\n<li>程序化地在多个组件中选择一个</li>\n<li>在将 children, props, data 传递给子组件之前操作它们。 </li>\n</ul>\n<p>下面是一个依赖传入 props 的值的 <code>smart-list</code> 组件例子，它能代表更多具体的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> EmptyList = &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> TableList = &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> OrderedList = &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> UnorderedList = &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"></div><div class=\"line\">Vue.component(<span class=\"string\">'smart-list'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">functional</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appropriateListComponent</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> items = context.props.items</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (items.length === <span class=\"number\">0</span>)           <span class=\"keyword\">return</span> EmptyList</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> items[<span class=\"number\">0</span>] === <span class=\"string\">'object'</span>) <span class=\"keyword\">return</span> TableList</div><div class=\"line\">      <span class=\"keyword\">if</span> (context.props.isOrdered)      <span class=\"keyword\">return</span> OrderedList</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> UnorderedList</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(</div><div class=\"line\">      appropriateListComponent(),</div><div class=\"line\">      context.data,</div><div class=\"line\">      context.children</div><div class=\"line\">    )</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">items</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Array</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">isOrdered</span>: <span class=\"built_in\">Boolean</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"slots-和-children-对比\"><a href=\"#slots-和-children-对比\" class=\"headerlink\" title=\"slots() 和 children 对比\"></a><code>slots()</code> 和 <code>children</code> 对比</h3><p>你可能想知道为什么同时需要 <code>slots()</code> 和 <code>children</code>。<code>slots().default</code> 不是和 <code>children</code> 类似的吗？在一些场景中，是这样，但是如果是函数式组件和下面这样的 children 呢？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-functional-component</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"foo\"</span>&gt;</span></div><div class=\"line\">    first</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>second<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-functional-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>对于这个组件，<code>children</code> 会给你两个段落标签，而 <code>slots().default</code> 只会传递第二个匿名段落标签，<code>slots().foo</code> 会传递第一个具名段落标签。同时拥有 <code>children</code> 和 <code>slots()</code> ，因此你可以选择让组件通过 <code>slot()</code> 系统分发或者简单的通过 <code>children</code> 接收，让其他组件去处理。</p>\n<h2 id=\"模板编译\"><a href=\"#模板编译\" class=\"headerlink\" title=\"模板编译\"></a>模板编译</h2><p>你可能有兴趣知道，Vue 的模板实际是编译成了 render 函数。这是一个实现细节，通常不需要关心，但如果你想看看模板的功能是怎样被编译的，你会发现会非常有趣。下面是一个使用 <code>Vue.compile</code>  来实时编译模板字符串的简单 demo：</p>\n\n<div id=\"vue-compile-demo\" class=\"demo\">\n  <textarea v-model=\"templateText\" rows=\"10\"></textarea>\n  <div v-if=\"typeof result === 'object'\">\n    <label>render:</label>\n    <pre><code>{{ result.render }}</code></pre>\n    <label>staticRenderFns:</label>\n    <pre v-for=\"(fn, index) in result.staticRenderFns\"><code>_m({{ index }}): {{ fn }}</code></pre>\n  </div>\n  <div v-else=\"\">\n    <label>Compilation Error:</label>\n    <pre><code>{{ result }}</code></pre>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#vue-compile-demo',\n  data: {\n    templateText: '\\\n<div>\\n\\\n  <h1>I\\'m a template!</h1>\\n\\\n  <p v-if=\"message\">\\n\\\n    {{ message }}\\n\\\n  </p>\\n\\\n  <p v-else>\\n\\\n    No message.\\n\\\n  </p>\\n\\\n</div>\\\n    ',\n  },\n  computed: {\n    result: function () {\n      if (!this.templateText) {\n        return 'Enter a valid template above'\n      }\n      try {\n        var result = Vue.compile(this.templateText.replace(/\\s{2,}/g, ''))\n        return {\n          render: this.formatFunction(result.render),\n          staticRenderFns: result.staticRenderFns.map(this.formatFunction)\n        }\n      } catch (error) {\n        return error.message\n      }\n    }\n  },\n  methods: {\n    formatFunction: function (fn) {\n      return fn.toString().replace(/(\\{\\n)(\\S)/, '$1  $2')\n    }\n  }\n})\nconsole.error = function (error) {\n  throw new Error(error)\n}\n</script>\n<style>\n#vue-compile-demo pre {\n  padding: 10px;\n  overflow-x: auto;\n}\n#vue-compile-demo code {\n  white-space: pre;\n  padding: 0\n}\n#vue-compile-demo textarea {\n  width: 100%;\n\n}\n</style>\n\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/render-function.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/render-function.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>Vue 推荐使用在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 <strong>render 函数</strong>，它比 template 更接近编译器。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hello-world\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#hello-world\"</span>&gt;</span></div><div class=\"line\">    Hello world!</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在 HTML 层， 我们决定这样定义组件接口：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">anchored-heading</span> <span class=\"attr\">:level</span>=<span class=\"string\">\"1\"</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">anchored-heading</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当我们开始写一个通过 <code>level</code> prop 动态生成heading 标签的组件，你可很快能想到这样实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/x-template\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"anchored-heading-template\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 1\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 2\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 3\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h4</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 4\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h4</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h5</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 5\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"level === 6\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'anchored-heading'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'#anchored-heading-template'</span>,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">level</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>template 在这种场景中就表现的有些冗余了。虽然我们重复使用 <code>&lt;slot&gt;&lt;/slot&gt;</code> 来接收每一个级别的标题标签，在标题标签中添加相同的锚点元素。但是些都会被包裹在一个无用的 <code>div</code> 中，因为组件必须有根节点。</p>\n<p>虽然模板在大多数组件中都非常好用，但是在这里它就不是很简洁的了。那么，我们来尝试使用 <code>render</code> 函数重写上面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'anchored-heading'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(</div><div class=\"line\">      <span class=\"string\">'h'</span> + <span class=\"keyword\">this</span>.level,   <span class=\"comment\">// tag name 标签名称</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$slots.default <span class=\"comment\">// 子组件中的阵列</span></div><div class=\"line\">    )</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">level</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>简单清晰很多！简单来说，这样代码精简很多，但是需要非常熟悉 Vue 的实例属性。在这个例子中，你需要知道当你不使用 <code>slot</code>  属性向组件中传递内容时，比如 <code>anchored-heading</code> 中的 <code>Hello world!</code>, 这些子元素被存储在组件实例中的 <code>$slots.default</code>中。如果你还不了解，<strong> 在深入 render 函数之前推荐阅读 <a href=\"../api/#vm-slots\">instance properties API</a>。</strong></p>\n<h2 id=\"createElement-参数\"><a href=\"#createElement-参数\" class=\"headerlink\" title=\"createElement 参数\"></a><code>createElement</code> 参数</h2><p>第二件你需要熟悉的是如何在 <code>createElement</code> 函数中生成模板。这里是 <code>createElement</code> 接受的参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// @returns &#123;VNode&#125;</span></div><div class=\"line\">createElement(</div><div class=\"line\">  <span class=\"comment\">// &#123;String | Object | Function&#125;</span></div><div class=\"line\">  <span class=\"comment\">// 一个 HTML 标签，组件选项，或一个函数</span></div><div class=\"line\">  <span class=\"comment\">// 必须 Return 上述其中一个</span></div><div class=\"line\">  <span class=\"string\">'div'</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// &#123;Object&#125;</span></div><div class=\"line\">  <span class=\"comment\">// 一个对应属性的数据对象</span></div><div class=\"line\">  <span class=\"comment\">// 您可以在 template 中使用.可选项.</span></div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"comment\">// (下一章，将详细说明相关细节)</span></div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// &#123;String | Array&#125;</span></div><div class=\"line\">  <span class=\"comment\">// 子节点(VNodes). 可选项.</span></div><div class=\"line\">  [</div><div class=\"line\">    createElement(<span class=\"string\">'h1'</span>, <span class=\"string\">'hello world'</span>),</div><div class=\"line\">    createElement(MyComponent, &#123;</div><div class=\"line\">      <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">someProp</span>: <span class=\"string\">'foo'</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"string\">'bar'</span></div><div class=\"line\">  ]</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<h3 id=\"完整数据对象\"><a href=\"#完整数据对象\" class=\"headerlink\" title=\"完整数据对象\"></a>完整数据对象</h3><p>有一件事要注意：在 templates 中，<code>v-bind:class</code> 和  <code>v-bind:style</code> ，会有特别的处理，他们在 VNode 数据对象中，为最高级配置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"comment\">// 和`v-bind:class`一样的 API</span></div><div class=\"line\">  <span class=\"string\">'class'</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">bar</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 和`v-bind:style`一样的 API</span></div><div class=\"line\">  style: &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>: <span class=\"string\">'red'</span>,</div><div class=\"line\">    <span class=\"attr\">fontSize</span>: <span class=\"string\">'14px'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 正常的 HTML 特性</span></div><div class=\"line\">  attrs: &#123;</div><div class=\"line\">    <span class=\"attr\">id</span>: <span class=\"string\">'foo'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 组件 props</span></div><div class=\"line\">  props: &#123;</div><div class=\"line\">    <span class=\"attr\">myProp</span>: <span class=\"string\">'bar'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// DOM 属性</span></div><div class=\"line\">  domProps: &#123;</div><div class=\"line\">    <span class=\"attr\">innerHTML</span>: <span class=\"string\">'baz'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 事件监听器基于 \"on\"</span></div><div class=\"line\">  <span class=\"comment\">// 所以不再支持如 v-on:keyup.enter 修饰器</span></div><div class=\"line\">  <span class=\"comment\">// 需要手动匹配 keyCode。</span></div><div class=\"line\">  on: &#123;</div><div class=\"line\">    <span class=\"attr\">click</span>: <span class=\"keyword\">this</span>.clickHandler</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 仅对于组件，用于监听原生事件，而不是组件使用 vm.$emit 触发的事件。</span></div><div class=\"line\">  nativeOn: &#123;</div><div class=\"line\">    <span class=\"attr\">click</span>: <span class=\"keyword\">this</span>.nativeClickHandler</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 自定义指令. 注意事项：不能对绑定的旧值设值</span></div><div class=\"line\">  <span class=\"comment\">// Vue 会为您持续追踨</span></div><div class=\"line\">  directives: [</div><div class=\"line\">    &#123;</div><div class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">'my-custom-directive'</span>,</div><div class=\"line\">      <span class=\"attr\">value</span>: <span class=\"string\">'2'</span></div><div class=\"line\">      expression: <span class=\"string\">'1 + 1'</span>,</div><div class=\"line\">      <span class=\"attr\">arg</span>: <span class=\"string\">'foo'</span>,</div><div class=\"line\">      <span class=\"attr\">modifiers</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">bar</span>: <span class=\"literal\">true</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  ],</div><div class=\"line\">  <span class=\"comment\">// Scoped slots in the form of</span></div><div class=\"line\">  <span class=\"comment\">// &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></div><div class=\"line\">  scopedSlots: &#123;</div><div class=\"line\">    <span class=\"attr\">default</span>: <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> h(<span class=\"string\">'span'</span>, props.text)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 如果子组件有定义 slot 的名称</span></div><div class=\"line\">  slot: <span class=\"string\">'name-of-slot'</span></div><div class=\"line\">  <span class=\"comment\">// 其他特殊顶层属性</span></div><div class=\"line\">  key: <span class=\"string\">'myKey'</span>,</div><div class=\"line\">  <span class=\"attr\">ref</span>: <span class=\"string\">'myRef'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"完整示例\"><a href=\"#完整示例\" class=\"headerlink\" title=\"完整示例\"></a>完整示例</h3><p>有了这方面的知识，我们现在可以完成我们最开始想实现的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getChildrenTextContent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">children</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> children.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> node.children</div><div class=\"line\">      ? getChildrenTextContent(node.children)</div><div class=\"line\">      : node.text</div><div class=\"line\">  &#125;).join(<span class=\"string\">''</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Vue.component(<span class=\"string\">'anchored-heading'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// create kebabCase id</span></div><div class=\"line\">    <span class=\"keyword\">var</span> headingId = getChildrenTextContent(<span class=\"keyword\">this</span>.$slots.default)</div><div class=\"line\">      .toLowerCase()</div><div class=\"line\">      .replace(<span class=\"regexp\">/\\W+/g</span>, <span class=\"string\">'-'</span>)</div><div class=\"line\">      .replace(<span class=\"regexp\">/(^\\-|\\-$)/g</span>, <span class=\"string\">''</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(</div><div class=\"line\">      <span class=\"string\">'h'</span> + <span class=\"keyword\">this</span>.level,</div><div class=\"line\">      [</div><div class=\"line\">        createElement(<span class=\"string\">'a'</span>, &#123;</div><div class=\"line\">          <span class=\"attr\">attrs</span>: &#123;</div><div class=\"line\">            <span class=\"attr\">name</span>: headingId,</div><div class=\"line\">            <span class=\"attr\">href</span>: <span class=\"string\">'#'</span> + headingId</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;, <span class=\"keyword\">this</span>.$slots.default)</div><div class=\"line\">      ]</div><div class=\"line\">    )</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">level</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h3><h4 id=\"VNodes-必须唯一\"><a href=\"#VNodes-必须唯一\" class=\"headerlink\" title=\"VNodes 必须唯一\"></a>VNodes 必须唯一</h4><p>所有组件树中的 VNodes 必须唯一。这意味着，下面的 render function 是无效的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> myParagraphVNode = createElement(<span class=\"string\">'p'</span>, <span class=\"string\">'hi'</span>)</div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, [</div><div class=\"line\">    <span class=\"comment\">// Yikes - duplicate VNodes!</span></div><div class=\"line\">    myParagraphVNode, myParagraphVNode</div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这个例子 render 函数完美有效地渲染了 20 个重复的段落：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>,</div><div class=\"line\">    <span class=\"built_in\">Array</span>.apply(<span class=\"literal\">null</span>, &#123; <span class=\"attr\">length</span>: <span class=\"number\">20</span> &#125;).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> createElement(<span class=\"string\">'p'</span>, <span class=\"string\">'hi'</span>)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  )</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"使用-JavaScript-代替模板功能\"><a href=\"#使用-JavaScript-代替模板功能\" class=\"headerlink\" title=\"使用 JavaScript 代替模板功能\"></a>使用 JavaScript 代替模板功能</h2><h3 id=\"v-if-and-v-for\"><a href=\"#v-if-and-v-for\" class=\"headerlink\" title=\"v-if and v-for\"></a><code>v-if</code> and <code>v-for</code></h3><p>无论什么都可以使用原生的 JavaScript 来实现，Vue 的 render 函数不会提供专用的 API。比如， template 中的 <code>v-if</code> 和 <code>v-for</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"items.length\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>No items found.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这些都会在 render 函数中被 JavaScript 的 <code>if</code>/<code>else</code> 和 <code>map</code> 重写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.items.length) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">'ul'</span>, <span class=\"keyword\">this</span>.items.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> createElement(<span class=\"string\">'li'</span>, item.name)</div><div class=\"line\">    &#125;))</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">'p'</span>, <span class=\"string\">'No items found.'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a><code>v-model</code></h3><p>There is no direct <code>v-model</code> counterpart in render functions - you will have to implement the logic yourself:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'input'</span>, &#123;</div><div class=\"line\">    <span class=\"attr\">domProps</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">value</span>: self.value</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">on</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">input</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">        self.value = event.target.value</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to <code>v-model</code>.</p>\n<h3 id=\"Event-amp-Key-Modifiers\"><a href=\"#Event-amp-Key-Modifiers\" class=\"headerlink\" title=\"Event &amp; Key Modifiers\"></a>Event &amp; Key Modifiers</h3><p>For the <code>.capture</code> and <code>.once</code> event modifiers, Vue offers prefixes that can be used with <code>on</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Modifier(s)</th>\n<th>Prefix</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.capture</code></td>\n<td><code>!</code></td>\n</tr>\n<tr>\n<td><code>.once</code></td>\n<td><code>~</code></td>\n</tr>\n<tr>\n<td><code>.capture.once</code> or<br><code>.once.capture</code></td>\n<td><code>~!</code></td>\n</tr>\n</tbody>\n</table>\n<p>For example:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">on: &#123;</div><div class=\"line\">  <span class=\"string\">'!click'</span>: <span class=\"keyword\">this</span>.doThisInCapturingMode,</div><div class=\"line\">  <span class=\"string\">'~keyup'</span>: <span class=\"keyword\">this</span>.doThisOnce,</div><div class=\"line\">  <span class=\"string\">`~!mouseover`</span>: <span class=\"keyword\">this</span>.doThisOnceInCapturingMode</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>For all other event and key modifiers, no proprietary prefix is necessary, because you can simply use event methods in the handler:</p>\n<table>\n<thead>\n<tr>\n<th>Modifier(s)</th>\n<th>Equivalent in Handler</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.stop</code></td>\n<td><code>event.stopPropagation()</code></td>\n</tr>\n<tr>\n<td><code>.prevent</code></td>\n<td><code>event.preventDefault()</code></td>\n</tr>\n<tr>\n<td><code>.self</code></td>\n<td><code>if (event.target !== event.currentTarget) return</code></td>\n</tr>\n<tr>\n<td>Keys:<br><code>.enter</code>, <code>.13</code></td>\n<td><code>if (event.keyCode !== 13) return</code> (change <code>13</code> to <a href=\"http://keycode.info/\">another key code</a> for other key modifiers)</td>\n</tr>\n<tr>\n<td>Modifiers Keys:<br><code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></td>\n<td><code>if (!event.ctrlKey) return</code> (change <code>ctrlKey</code> to <code>altKey</code>, <code>shiftKey</code>, or <code>metaKey</code>, respectively)</td>\n</tr>\n</tbody>\n</table>\n<p>Here’s an example with all of these modifiers used together:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">on: &#123;</div><div class=\"line\">  <span class=\"attr\">keyup</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Abort if the element emitting the event is not</span></div><div class=\"line\">    <span class=\"comment\">// the element the event is bound to</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (event.target !== event.currentTarget) <span class=\"keyword\">return</span></div><div class=\"line\">    <span class=\"comment\">// Abort if the key that went up is not the enter</span></div><div class=\"line\">    <span class=\"comment\">// key (13) and the shift key was not held down</span></div><div class=\"line\">    <span class=\"comment\">// at the same time</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!event.shiftKey || event.keyCode !== <span class=\"number\">13</span>) <span class=\"keyword\">return</span></div><div class=\"line\">    <span class=\"comment\">// Stop event propagation</span></div><div class=\"line\">    event.stopPropagation()</div><div class=\"line\">    <span class=\"comment\">// Prevent the default keyup handler for this element</span></div><div class=\"line\">    event.preventDefault()</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Slots\"><a href=\"#Slots\" class=\"headerlink\" title=\"Slots\"></a>Slots</h3><p>You can access static slot contents as Arrays of VNodes from <a href=\"http://vuejs.org/v2/api/#vm-slots\"><code>this.$slots</code></a>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// &lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;</span></div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, <span class=\"keyword\">this</span>.$slots.default)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And access scoped slots as functions that return VNodes from <a href=\"http://vuejs.org/v2/api/#vm-scopedSlots\"><code>this.$scopedSlots</code></a>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// &lt;div&gt;&lt;slot :text=\"msg\"&gt;&lt;/slot&gt;&lt;/div&gt;</span></div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, [</div><div class=\"line\">    <span class=\"keyword\">this</span>.$scopedSlots.default(&#123;</div><div class=\"line\">      <span class=\"attr\">text</span>: <span class=\"keyword\">this</span>.msg</div><div class=\"line\">    &#125;)</div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>To pass scoped slots to a child component using render functions, use the <code>scopedSlots</code> field in VNode data:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">render (createElement) &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, [</div><div class=\"line\">    createElement(<span class=\"string\">'child'</span>, &#123;</div><div class=\"line\">      <span class=\"comment\">// pass scopedSlots in the data object</span></div><div class=\"line\">      <span class=\"comment\">// in the form of &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></div><div class=\"line\">      scopedSlots: &#123;</div><div class=\"line\">        <span class=\"attr\">default</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> createElement(<span class=\"string\">'span'</span>, props.text)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>如果你写了很多 <code>render</code>  函数，可能会觉得痛苦：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">createElement(</div><div class=\"line\">  <span class=\"string\">'anchored-heading'</span>, &#123;</div><div class=\"line\">    <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">level</span>: <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, [</div><div class=\"line\">    createElement(<span class=\"string\">'span'</span>, <span class=\"string\">'Hello'</span>),</div><div class=\"line\">    <span class=\"string\">' world!'</span></div><div class=\"line\">  ]</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>特别是模板如此简单的情况下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">anchored-heading</span> <span class=\"attr\">:level</span>=<span class=\"string\">\"1\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> world!</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">anchored-heading</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这就是会有一个 <a href=\"https://github.com/vuejs/babel-plugin-transform-vue-jsx\">Babel plugin</a> 插件，用于在 Vue 中使用 JSX 语法的原因，它可以让我们回到于更接近模板的语法上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> AnchoredHeading <span class=\"keyword\">from</span> <span class=\"string\">'./AnchoredHeading.vue'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#demo'</span>,</div><div class=\"line\">  render (h) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AnchoredHeading</span> <span class=\"attr\">level</span>=<span class=\"string\">&#123;1&#125;</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> world!</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">AnchoredHeading</span>&gt;</span></span></div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">将 <code>h</code> 作为 <code>createElement</code> 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的，如果在作用域中 <code>h</code> 失去作用， 在应用中会触发报错。</p>\n\n<p>更多关于 JSX 映射到 JavaScript，阅读 <a href=\"https://github.com/vuejs/babel-plugin-transform-vue-jsx#usage\">使用文档</a>。</p>\n<h2 id=\"函数化组件\"><a href=\"#函数化组件\" class=\"headerlink\" title=\"函数化组件\"></a>函数化组件</h2><p>之前创建的锚点标题组件是比较简单，没有管理或者监听任何传递给他的状态，也没有生命周期方法。它只是一个接收参数的函数。<br>在这个例子中，我们标记组件为 <code>functional</code>， 这意味它是无状态（没有 <code>data</code>），无实例（没有 <code>this</code> 上下文）。<br>一个 <strong>函数化组件</strong> 就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">functional</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"comment\">// 为了弥补缺少的实例</span></div><div class=\"line\">  <span class=\"comment\">// 提供第二个参数作为上下文</span></div><div class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// Props 可选</span></div><div class=\"line\">  props: &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>组件需要的一切都是通过上下文传递，包括：</p>\n<ul>\n<li><code>props</code>: 提供props 的对象</li>\n<li><code>children</code>: VNode 子节点的数组</li>\n<li><code>slots</code>: slots 对象</li>\n<li><code>data</code>: 传递给组件的 data 对象</li>\n<li><code>parent</code>: 对父组件的引用</li>\n</ul>\n<p>在添加 <code>functional: true</code> 之后，锚点标题组件的 render 函数之间简单更新增加 <code>context</code> 参数，<code>this.$slots.default</code> 更新为 <code>context.children</code>，之后<code>this.level</code> 更新为 <code>context.props.level</code>。</p>\n<p>函数化组件只是一个函数，所以渲染开销也低很多。但同样它也有完整的组件封装，你需要知道这些， 比如：</p>\n<ul>\n<li>程序化地在多个组件中选择一个</li>\n<li>在将 children, props, data 传递给子组件之前操作它们。 </li>\n</ul>\n<p>下面是一个依赖传入 props 的值的 <code>smart-list</code> 组件例子，它能代表更多具体的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> EmptyList = &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> TableList = &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> OrderedList = &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> UnorderedList = &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"></div><div class=\"line\">Vue.component(<span class=\"string\">'smart-list'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">functional</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appropriateListComponent</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> items = context.props.items</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (items.length === <span class=\"number\">0</span>)           <span class=\"keyword\">return</span> EmptyList</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> items[<span class=\"number\">0</span>] === <span class=\"string\">'object'</span>) <span class=\"keyword\">return</span> TableList</div><div class=\"line\">      <span class=\"keyword\">if</span> (context.props.isOrdered)      <span class=\"keyword\">return</span> OrderedList</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> UnorderedList</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(</div><div class=\"line\">      appropriateListComponent(),</div><div class=\"line\">      context.data,</div><div class=\"line\">      context.children</div><div class=\"line\">    )</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">items</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Array</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">isOrdered</span>: <span class=\"built_in\">Boolean</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"slots-和-children-对比\"><a href=\"#slots-和-children-对比\" class=\"headerlink\" title=\"slots() 和 children 对比\"></a><code>slots()</code> 和 <code>children</code> 对比</h3><p>你可能想知道为什么同时需要 <code>slots()</code> 和 <code>children</code>。<code>slots().default</code> 不是和 <code>children</code> 类似的吗？在一些场景中，是这样，但是如果是函数式组件和下面这样的 children 呢？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-functional-component</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"foo\"</span>&gt;</span></div><div class=\"line\">    first</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>second<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-functional-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>对于这个组件，<code>children</code> 会给你两个段落标签，而 <code>slots().default</code> 只会传递第二个匿名段落标签，<code>slots().foo</code> 会传递第一个具名段落标签。同时拥有 <code>children</code> 和 <code>slots()</code> ，因此你可以选择让组件通过 <code>slot()</code> 系统分发或者简单的通过 <code>children</code> 接收，让其他组件去处理。</p>\n<h2 id=\"模板编译\"><a href=\"#模板编译\" class=\"headerlink\" title=\"模板编译\"></a>模板编译</h2><p>你可能有兴趣知道，Vue 的模板实际是编译成了 render 函数。这是一个实现细节，通常不需要关心，但如果你想看看模板的功能是怎样被编译的，你会发现会非常有趣。下面是一个使用 <code>Vue.compile</code>  来实时编译模板字符串的简单 demo：</p>\n\n<div id=\"vue-compile-demo\" class=\"demo\">\n  <textarea v-model=\"templateText\" rows=\"10\"></textarea>\n  <div v-if=\"typeof result === 'object'\">\n    <label>render:</label>\n    <pre><code>{{ result.render }}</code></pre>\n    <label>staticRenderFns:</label>\n    <pre v-for=\"(fn, index) in result.staticRenderFns\"><code>_m({{ index }}): {{ fn }}</code></pre>\n  </div>\n  <div v-else>\n    <label>Compilation Error:</label>\n    <pre><code>{{ result }}</code></pre>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#vue-compile-demo',\n  data: {\n    templateText: '\\\n<div>\\n\\\n  <h1>I\\'m a template!</h1>\\n\\\n  <p v-if=\"message\">\\n\\\n    {{ message }}\\n\\\n  </p>\\n\\\n  <p v-else>\\n\\\n    No message.\\n\\\n  </p>\\n\\\n</div>\\\n    ',\n  },\n  computed: {\n    result: function () {\n      if (!this.templateText) {\n        return 'Enter a valid template above'\n      }\n      try {\n        var result = Vue.compile(this.templateText.replace(/\\s{2,}/g, ''))\n        return {\n          render: this.formatFunction(result.render),\n          staticRenderFns: result.staticRenderFns.map(this.formatFunction)\n        }\n      } catch (error) {\n        return error.message\n      }\n    }\n  },\n  methods: {\n    formatFunction: function (fn) {\n      return fn.toString().replace(/(\\{\\n)(\\S)/, '$1  $2')\n    }\n  }\n})\nconsole.error = function (error) {\n  throw new Error(error)\n}\n</script>\n<style>\n#vue-compile-demo pre {\n  padding: 10px;\n  overflow-x: auto;\n}\n#vue-compile-demo code {\n  white-space: pre;\n  padding: 0\n}\n#vue-compile-demo textarea {\n  width: 100%;\n\n}\n</style>\n\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/render-function.html\">http://vuejs.org/guide/render-function.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"路由","type":"guide","order":21,"_content":"\n## 官方路由\n\n对于大多数单页面应用，都推荐使用官方支持的[vue-router库](https://github.com/vuejs/vue-router)。更多细节可以看[vue-router文档](http://vuejs.github.io/vue-router/)。\n\n## 从零开始简单的路由\n\n如果只需要非常简单的路由而不需要引入整个路由库，可以动态渲染一个页面级的组件像这样：\n\n``` js\nconst NotFound = { template: '<p>Page not found</p>' }\nconst Home = { template: '<p>home page</p>' }\nconst About = { template: '<p>about page</p>' }\n\nconst routes = {\n  '/': Home,\n  '/about': About\n}\n\nnew Vue({\n  el: '#app',\n  data: {\n    currentRoute: window.location.pathname\n  },\n  computed: {\n    ViewComponent () {\n      return routes[this.currentRoute] || NotFound\n    }\n  },\n  render (h) { return h(this.ViewComponent) }\n})\n```\n结合HTML5 History API，你可以建立一个非常基本但功能齐全的客户端路由器。可以直接看[实例应用](https://github.com/chrisvfritz/vue-2.0-simple-routing-example)\n\n## 整合第三方路由\n\n如果有非常喜欢的第三方路由，如[Page.js](https://github.com/visionmedia/page.js)或者 [Director](https://github.com/flatiron/director), 整合[很简单](https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs)。 这有个用了Page.js的[复杂示例](https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs) 。\n\n***\n\n> 原文： http://vuejs.org/guide/routing.html\n\n***\n","source":"v2/guide/routing.md","raw":"---\ntitle: 路由\ntype: guide\norder: 21\n---\n\n## 官方路由\n\n对于大多数单页面应用，都推荐使用官方支持的[vue-router库](https://github.com/vuejs/vue-router)。更多细节可以看[vue-router文档](http://vuejs.github.io/vue-router/)。\n\n## 从零开始简单的路由\n\n如果只需要非常简单的路由而不需要引入整个路由库，可以动态渲染一个页面级的组件像这样：\n\n``` js\nconst NotFound = { template: '<p>Page not found</p>' }\nconst Home = { template: '<p>home page</p>' }\nconst About = { template: '<p>about page</p>' }\n\nconst routes = {\n  '/': Home,\n  '/about': About\n}\n\nnew Vue({\n  el: '#app',\n  data: {\n    currentRoute: window.location.pathname\n  },\n  computed: {\n    ViewComponent () {\n      return routes[this.currentRoute] || NotFound\n    }\n  },\n  render (h) { return h(this.ViewComponent) }\n})\n```\n结合HTML5 History API，你可以建立一个非常基本但功能齐全的客户端路由器。可以直接看[实例应用](https://github.com/chrisvfritz/vue-2.0-simple-routing-example)\n\n## 整合第三方路由\n\n如果有非常喜欢的第三方路由，如[Page.js](https://github.com/visionmedia/page.js)或者 [Director](https://github.com/flatiron/director), 整合[很简单](https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs)。 这有个用了Page.js的[复杂示例](https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs) 。\n\n***\n\n> 原文： http://vuejs.org/guide/routing.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/routing.html","comments":1,"layout":"page","_id":"ciwnajuyx001pjl2di3tptf39","content":"<h2 id=\"官方路由\"><a href=\"#官方路由\" class=\"headerlink\" title=\"官方路由\"></a>官方路由</h2><p>对于大多数单页面应用，都推荐使用官方支持的<a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"external\">vue-router库</a>。更多细节可以看<a href=\"http://vuejs.github.io/vue-router/\" target=\"_blank\" rel=\"external\">vue-router文档</a>。</p>\n<h2 id=\"从零开始简单的路由\"><a href=\"#从零开始简单的路由\" class=\"headerlink\" title=\"从零开始简单的路由\"></a>从零开始简单的路由</h2><p>如果只需要非常简单的路由而不需要引入整个路由库，可以动态渲染一个页面级的组件像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> NotFound = &#123; <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;Page not found&lt;/p&gt;'</span> &#125;</div><div class=\"line\"><span class=\"keyword\">const</span> Home = &#123; <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;home page&lt;/p&gt;'</span> &#125;</div><div class=\"line\"><span class=\"keyword\">const</span> About = &#123; <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;about page&lt;/p&gt;'</span> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> routes = &#123;</div><div class=\"line\">  <span class=\"string\">'/'</span>: Home,</div><div class=\"line\">  <span class=\"string\">'/about'</span>: About</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">currentRoute</span>: <span class=\"built_in\">window</span>.location.pathname</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    ViewComponent () &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> routes[<span class=\"keyword\">this</span>.currentRoute] || NotFound</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  render (h) &#123; <span class=\"keyword\">return</span> h(<span class=\"keyword\">this</span>.ViewComponent) &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结合HTML5 History API，你可以建立一个非常基本但功能齐全的客户端路由器。可以直接看<a href=\"https://github.com/chrisvfritz/vue-2.0-simple-routing-example\" target=\"_blank\" rel=\"external\">实例应用</a></p>\n<h2 id=\"整合第三方路由\"><a href=\"#整合第三方路由\" class=\"headerlink\" title=\"整合第三方路由\"></a>整合第三方路由</h2><p>如果有非常喜欢的第三方路由，如<a href=\"https://github.com/visionmedia/page.js\" target=\"_blank\" rel=\"external\">Page.js</a>或者 <a href=\"https://github.com/flatiron/director\" target=\"_blank\" rel=\"external\">Director</a>, 整合<a href=\"https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs\" target=\"_blank\" rel=\"external\">很简单</a>。 这有个用了Page.js的<a href=\"https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs\" target=\"_blank\" rel=\"external\">复杂示例</a> 。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/routing.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/routing.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"官方路由\"><a href=\"#官方路由\" class=\"headerlink\" title=\"官方路由\"></a>官方路由</h2><p>对于大多数单页面应用，都推荐使用官方支持的<a href=\"https://github.com/vuejs/vue-router\">vue-router库</a>。更多细节可以看<a href=\"http://vuejs.github.io/vue-router/\">vue-router文档</a>。</p>\n<h2 id=\"从零开始简单的路由\"><a href=\"#从零开始简单的路由\" class=\"headerlink\" title=\"从零开始简单的路由\"></a>从零开始简单的路由</h2><p>如果只需要非常简单的路由而不需要引入整个路由库，可以动态渲染一个页面级的组件像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> NotFound = &#123; <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;Page not found&lt;/p&gt;'</span> &#125;</div><div class=\"line\"><span class=\"keyword\">const</span> Home = &#123; <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;home page&lt;/p&gt;'</span> &#125;</div><div class=\"line\"><span class=\"keyword\">const</span> About = &#123; <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;about page&lt;/p&gt;'</span> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> routes = &#123;</div><div class=\"line\">  <span class=\"string\">'/'</span>: Home,</div><div class=\"line\">  <span class=\"string\">'/about'</span>: About</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">currentRoute</span>: <span class=\"built_in\">window</span>.location.pathname</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    ViewComponent () &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> routes[<span class=\"keyword\">this</span>.currentRoute] || NotFound</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  render (h) &#123; <span class=\"keyword\">return</span> h(<span class=\"keyword\">this</span>.ViewComponent) &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>结合HTML5 History API，你可以建立一个非常基本但功能齐全的客户端路由器。可以直接看<a href=\"https://github.com/chrisvfritz/vue-2.0-simple-routing-example\">实例应用</a></p>\n<h2 id=\"整合第三方路由\"><a href=\"#整合第三方路由\" class=\"headerlink\" title=\"整合第三方路由\"></a>整合第三方路由</h2><p>如果有非常喜欢的第三方路由，如<a href=\"https://github.com/visionmedia/page.js\">Page.js</a>或者 <a href=\"https://github.com/flatiron/director\">Director</a>, 整合<a href=\"https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs\">很简单</a>。 这有个用了Page.js的<a href=\"https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs\">复杂示例</a> 。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/routing.html\">http://vuejs.org/guide/routing.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"单文件组件","type":"guide","order":19,"_content":"\n## 介绍\n\n \n在很多Vue项目中，我们使用 `Vue.component` 来定义全局组件，紧接着用 `new Vue({ el: '#container '})` 在每个页面内指定一个容器元素。\n\n- **全局定义(Global definitions)**  强制要求每个 component 中的命名不得重复\n- **字符串模板(String templates)**  缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 `\\`\n- **不支持CSS(No CSS support)**  意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏\n- **没有构建步骤(No build step)**  限制只能使用 HTML 和 ES5 JavaScript,  而不能使用预处理器，如 Pug (formerly Jade) 和 Babel\n\n文件扩展名为 `.vue` 的 **single-file components(单文件组件)** 为以上所有问题提供了解决方法，并且还可以使用 Webpack 或 Browserify 等构建工具。\n\n这是一个文件名为 `Hello.vue` 的简单实例：\n\n<img src=\"/images/vue-component.png\" style=\"display: block; margin: 30px auto\">\n\n现在我们获得：\n\n- [完整语法高亮](https://github.com/vuejs/awesome-vue#syntax-highlighting)\n- [CommonJS 模块](https://webpack.github.io/docs/commonjs.html)\n- [组件化的 CSS](https://github.com/vuejs/vue-loader/blob/master/docs/en/features/scoped-css.md)\n\n正如我们说过的，我们可以使用预处理器来构建简洁和功能更丰富的组件，比如 Jade，Babel (with ES2015 modules)，和 Stylus。\n\n<img src=\"/images/vue-component-with-preprocessors.png\" style=\"display: block; margin: 30px auto\">\n\n这些特定的语言只是例子，你可以只是简单地使用 Buble，TypeScript，SCSS，PostCSS - 或者其他任何能够帮助你提高生产力的预处理器。\n\n<!-- TODO: include CSS modules once it's supported in vue-loader 9.x -->\n\n## 起步\n\n### 针对刚接触 JavaScript 模块开发系统的用户\n\n有了 `.vue` 组件，我们就进入了高级 JavaScirpt 应用领域。如果你没有准备好的话，意味着还需要学会使用一些附加的工具：\n\n- **Node Package Manager (NPM)**: 阅读 [Getting Started guide](https://docs.npmjs.com/getting-started/what-is-npm) 直到 _10: Uninstalling global packages_章节.\n\n- **Modern JavaScript with ES2015/16**: 阅读 Babel 的 [Learn ES2015 guide](https://babeljs.io/docs/learn-es2015/). 你不需要立刻记住每一个方法，但是你可以保留这个页面以便后期参考。\n\n在你花一些时日了解这些资源之后，我们建议你参考 [webpack-simple](https://github.com/vuejs-templates/webpack-simple) 。只要遵循指示，你就能很快的运行一个用到 `.vue` 组件，ES2015 和  热重载( hot-reloading ) 的Vue项目!\n\n这个模板使用 [Webpack](https://webpack.github.io/)，一个能将多个模块打包成最终应用的模块打包工具。 [这个视频](https://www.youtube.com/watch?v=WQue1AN93YU) 介绍了Webpack的更多相关信息。 学习了这些基础知识后， 你可能想看看 [这个在 Egghead.io上的 高级 Webpack 课程](https://egghead.io/courses/using-webpack-for-production-javascript-applications).\n\n在 Webpack中，每个模块被打包到 bundle 之前都由一个相应的 \"loader\" 来转换，Vue 也提供 [vue-loader](https://github.com/vuejs/vue-loader) 插件来执行 `.vue` 单文件组件 的转换. 这个 [webpack-simple](https://github.com/vuejs-templates/webpack-simple) 模板已经为你准备好了所有的东西，但是如果你想了解更多关于 `.vue` 组件和 Webpack 如何一起运转的信息，你可以阅读 [vue-loader 的文档](https://vue-loader.vuejs.org)。\n\n### 针对高级用户\n\n无论你更钟情 Webpack 或是 Browserify，我们为简单的和更复杂的项目都提供了一些文档模板。我们建议浏览 [github.com/vuejs-templates](https://github.com/vuejs-templates)，找到你需要的部分，然后参考 README 中的说明，使用 [vue-cli](https://github.com/vuejs/vue-cli) 工具生成新的项目。\n\n模板中使用 [Webpack](https://webpack.github.io/) ，一个模块加载器加载多个模块然后构建成最终应用。为了进一步了解 Webpack, 可以看 [官方介绍视频](https://www.youtube.com/watch?v=WQue1AN93YU)。如果你有基础，可以看 [在 Egghead.io 上的 Webpack 进阶教程](https://egghead.io/courses/using-webpack-for-production-javascript-applications)。\n\n***\n\n> 原文： http://vuejs.org/guide/single-file-components.html\n\n***\n","source":"v2/guide/single-file-components.md","raw":"---\ntitle: 单文件组件\ntype: guide\norder: 19\n---\n\n## 介绍\n\n \n在很多Vue项目中，我们使用 `Vue.component` 来定义全局组件，紧接着用 `new Vue({ el: '#container '})` 在每个页面内指定一个容器元素。\n\n- **全局定义(Global definitions)**  强制要求每个 component 中的命名不得重复\n- **字符串模板(String templates)**  缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 `\\`\n- **不支持CSS(No CSS support)**  意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏\n- **没有构建步骤(No build step)**  限制只能使用 HTML 和 ES5 JavaScript,  而不能使用预处理器，如 Pug (formerly Jade) 和 Babel\n\n文件扩展名为 `.vue` 的 **single-file components(单文件组件)** 为以上所有问题提供了解决方法，并且还可以使用 Webpack 或 Browserify 等构建工具。\n\n这是一个文件名为 `Hello.vue` 的简单实例：\n\n<img src=\"/images/vue-component.png\" style=\"display: block; margin: 30px auto\">\n\n现在我们获得：\n\n- [完整语法高亮](https://github.com/vuejs/awesome-vue#syntax-highlighting)\n- [CommonJS 模块](https://webpack.github.io/docs/commonjs.html)\n- [组件化的 CSS](https://github.com/vuejs/vue-loader/blob/master/docs/en/features/scoped-css.md)\n\n正如我们说过的，我们可以使用预处理器来构建简洁和功能更丰富的组件，比如 Jade，Babel (with ES2015 modules)，和 Stylus。\n\n<img src=\"/images/vue-component-with-preprocessors.png\" style=\"display: block; margin: 30px auto\">\n\n这些特定的语言只是例子，你可以只是简单地使用 Buble，TypeScript，SCSS，PostCSS - 或者其他任何能够帮助你提高生产力的预处理器。\n\n<!-- TODO: include CSS modules once it's supported in vue-loader 9.x -->\n\n## 起步\n\n### 针对刚接触 JavaScript 模块开发系统的用户\n\n有了 `.vue` 组件，我们就进入了高级 JavaScirpt 应用领域。如果你没有准备好的话，意味着还需要学会使用一些附加的工具：\n\n- **Node Package Manager (NPM)**: 阅读 [Getting Started guide](https://docs.npmjs.com/getting-started/what-is-npm) 直到 _10: Uninstalling global packages_章节.\n\n- **Modern JavaScript with ES2015/16**: 阅读 Babel 的 [Learn ES2015 guide](https://babeljs.io/docs/learn-es2015/). 你不需要立刻记住每一个方法，但是你可以保留这个页面以便后期参考。\n\n在你花一些时日了解这些资源之后，我们建议你参考 [webpack-simple](https://github.com/vuejs-templates/webpack-simple) 。只要遵循指示，你就能很快的运行一个用到 `.vue` 组件，ES2015 和  热重载( hot-reloading ) 的Vue项目!\n\n这个模板使用 [Webpack](https://webpack.github.io/)，一个能将多个模块打包成最终应用的模块打包工具。 [这个视频](https://www.youtube.com/watch?v=WQue1AN93YU) 介绍了Webpack的更多相关信息。 学习了这些基础知识后， 你可能想看看 [这个在 Egghead.io上的 高级 Webpack 课程](https://egghead.io/courses/using-webpack-for-production-javascript-applications).\n\n在 Webpack中，每个模块被打包到 bundle 之前都由一个相应的 \"loader\" 来转换，Vue 也提供 [vue-loader](https://github.com/vuejs/vue-loader) 插件来执行 `.vue` 单文件组件 的转换. 这个 [webpack-simple](https://github.com/vuejs-templates/webpack-simple) 模板已经为你准备好了所有的东西，但是如果你想了解更多关于 `.vue` 组件和 Webpack 如何一起运转的信息，你可以阅读 [vue-loader 的文档](https://vue-loader.vuejs.org)。\n\n### 针对高级用户\n\n无论你更钟情 Webpack 或是 Browserify，我们为简单的和更复杂的项目都提供了一些文档模板。我们建议浏览 [github.com/vuejs-templates](https://github.com/vuejs-templates)，找到你需要的部分，然后参考 README 中的说明，使用 [vue-cli](https://github.com/vuejs/vue-cli) 工具生成新的项目。\n\n模板中使用 [Webpack](https://webpack.github.io/) ，一个模块加载器加载多个模块然后构建成最终应用。为了进一步了解 Webpack, 可以看 [官方介绍视频](https://www.youtube.com/watch?v=WQue1AN93YU)。如果你有基础，可以看 [在 Egghead.io 上的 Webpack 进阶教程](https://egghead.io/courses/using-webpack-for-production-javascript-applications)。\n\n***\n\n> 原文： http://vuejs.org/guide/single-file-components.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/single-file-components.html","comments":1,"layout":"page","_id":"ciwnajuyx001qjl2depj5sp3y","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>在很多Vue项目中，我们使用 <code>Vue.component</code> 来定义全局组件，紧接着用 <code>new Vue({ el: &#39;#container &#39;})</code> 在每个页面内指定一个容器元素。</p>\n<ul>\n<li><strong>全局定义(Global definitions)</strong>  强制要求每个 component 中的命名不得重复</li>\n<li><strong>字符串模板(String templates)</strong>  缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 <code>\\</code></li>\n<li><strong>不支持CSS(No CSS support)</strong>  意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li>\n<li><strong>没有构建步骤(No build step)</strong>  限制只能使用 HTML 和 ES5 JavaScript,  而不能使用预处理器，如 Pug (formerly Jade) 和 Babel</li>\n</ul>\n<p>文件扩展名为 <code>.vue</code> 的 <strong>single-file components(单文件组件)</strong> 为以上所有问题提供了解决方法，并且还可以使用 Webpack 或 Browserify 等构建工具。</p>\n<p>这是一个文件名为 <code>Hello.vue</code> 的简单实例：</p>\n<p><img src=\"/images/vue-component.png\" style=\"display: block; margin: 30px auto\"></p>\n<p>现在我们获得：</p>\n<ul>\n<li><a href=\"https://github.com/vuejs/awesome-vue#syntax-highlighting\" target=\"_blank\" rel=\"external\">完整语法高亮</a></li>\n<li><a href=\"https://webpack.github.io/docs/commonjs.html\" target=\"_blank\" rel=\"external\">CommonJS 模块</a></li>\n<li><a href=\"https://github.com/vuejs/vue-loader/blob/master/docs/en/features/scoped-css.md\" target=\"_blank\" rel=\"external\">组件化的 CSS</a></li>\n</ul>\n<p>正如我们说过的，我们可以使用预处理器来构建简洁和功能更丰富的组件，比如 Jade，Babel (with ES2015 modules)，和 Stylus。</p>\n<p><img src=\"/images/vue-component-with-preprocessors.png\" style=\"display: block; margin: 30px auto\"></p>\n<p>这些特定的语言只是例子，你可以只是简单地使用 Buble，TypeScript，SCSS，PostCSS - 或者其他任何能够帮助你提高生产力的预处理器。</p>\n<!-- TODO: include CSS modules once it's supported in vue-loader 9.x -->\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><h3 id=\"针对刚接触-JavaScript-模块开发系统的用户\"><a href=\"#针对刚接触-JavaScript-模块开发系统的用户\" class=\"headerlink\" title=\"针对刚接触 JavaScript 模块开发系统的用户\"></a>针对刚接触 JavaScript 模块开发系统的用户</h3><p>有了 <code>.vue</code> 组件，我们就进入了高级 JavaScirpt 应用领域。如果你没有准备好的话，意味着还需要学会使用一些附加的工具：</p>\n<ul>\n<li><p><strong>Node Package Manager (NPM)</strong>: 阅读 <a href=\"https://docs.npmjs.com/getting-started/what-is-npm\" target=\"_blank\" rel=\"external\">Getting Started guide</a> 直到 <em>10: Uninstalling global packages</em>章节.</p>\n</li>\n<li><p><strong>Modern JavaScript with ES2015/16</strong>: 阅读 Babel 的 <a href=\"https://babeljs.io/docs/learn-es2015/\" target=\"_blank\" rel=\"external\">Learn ES2015 guide</a>. 你不需要立刻记住每一个方法，但是你可以保留这个页面以便后期参考。</p>\n</li>\n</ul>\n<p>在你花一些时日了解这些资源之后，我们建议你参考 <a href=\"https://github.com/vuejs-templates/webpack-simple\" target=\"_blank\" rel=\"external\">webpack-simple</a> 。只要遵循指示，你就能很快的运行一个用到 <code>.vue</code> 组件，ES2015 和  热重载( hot-reloading ) 的Vue项目!</p>\n<p>这个模板使用 <a href=\"https://webpack.github.io/\" target=\"_blank\" rel=\"external\">Webpack</a>，一个能将多个模块打包成最终应用的模块打包工具。 <a href=\"https://www.youtube.com/watch?v=WQue1AN93YU\" target=\"_blank\" rel=\"external\">这个视频</a> 介绍了Webpack的更多相关信息。 学习了这些基础知识后， 你可能想看看 <a href=\"https://egghead.io/courses/using-webpack-for-production-javascript-applications\" target=\"_blank\" rel=\"external\">这个在 Egghead.io上的 高级 Webpack 课程</a>.</p>\n<p>在 Webpack中，每个模块被打包到 bundle 之前都由一个相应的 “loader” 来转换，Vue 也提供 <a href=\"https://github.com/vuejs/vue-loader\" target=\"_blank\" rel=\"external\">vue-loader</a> 插件来执行 <code>.vue</code> 单文件组件 的转换. 这个 <a href=\"https://github.com/vuejs-templates/webpack-simple\" target=\"_blank\" rel=\"external\">webpack-simple</a> 模板已经为你准备好了所有的东西，但是如果你想了解更多关于 <code>.vue</code> 组件和 Webpack 如何一起运转的信息，你可以阅读 <a href=\"https://vue-loader.vuejs.org\" target=\"_blank\" rel=\"external\">vue-loader 的文档</a>。</p>\n<h3 id=\"针对高级用户\"><a href=\"#针对高级用户\" class=\"headerlink\" title=\"针对高级用户\"></a>针对高级用户</h3><p>无论你更钟情 Webpack 或是 Browserify，我们为简单的和更复杂的项目都提供了一些文档模板。我们建议浏览 <a href=\"https://github.com/vuejs-templates\" target=\"_blank\" rel=\"external\">github.com/vuejs-templates</a>，找到你需要的部分，然后参考 README 中的说明，使用 <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"external\">vue-cli</a> 工具生成新的项目。</p>\n<p>模板中使用 <a href=\"https://webpack.github.io/\" target=\"_blank\" rel=\"external\">Webpack</a> ，一个模块加载器加载多个模块然后构建成最终应用。为了进一步了解 Webpack, 可以看 <a href=\"https://www.youtube.com/watch?v=WQue1AN93YU\" target=\"_blank\" rel=\"external\">官方介绍视频</a>。如果你有基础，可以看 <a href=\"https://egghead.io/courses/using-webpack-for-production-javascript-applications\" target=\"_blank\" rel=\"external\">在 Egghead.io 上的 Webpack 进阶教程</a>。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/single-file-components.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/single-file-components.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>在很多Vue项目中，我们使用 <code>Vue.component</code> 来定义全局组件，紧接着用 <code>new Vue({ el: &#39;#container &#39;})</code> 在每个页面内指定一个容器元素。</p>\n<ul>\n<li><strong>全局定义(Global definitions)</strong>  强制要求每个 component 中的命名不得重复</li>\n<li><strong>字符串模板(String templates)</strong>  缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 <code>\\</code></li>\n<li><strong>不支持CSS(No CSS support)</strong>  意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li>\n<li><strong>没有构建步骤(No build step)</strong>  限制只能使用 HTML 和 ES5 JavaScript,  而不能使用预处理器，如 Pug (formerly Jade) 和 Babel</li>\n</ul>\n<p>文件扩展名为 <code>.vue</code> 的 <strong>single-file components(单文件组件)</strong> 为以上所有问题提供了解决方法，并且还可以使用 Webpack 或 Browserify 等构建工具。</p>\n<p>这是一个文件名为 <code>Hello.vue</code> 的简单实例：</p>\n<p><img src=\"/images/vue-component.png\" style=\"display: block; margin: 30px auto\"></p>\n<p>现在我们获得：</p>\n<ul>\n<li><a href=\"https://github.com/vuejs/awesome-vue#syntax-highlighting\">完整语法高亮</a></li>\n<li><a href=\"https://webpack.github.io/docs/commonjs.html\">CommonJS 模块</a></li>\n<li><a href=\"https://github.com/vuejs/vue-loader/blob/master/docs/en/features/scoped-css.md\">组件化的 CSS</a></li>\n</ul>\n<p>正如我们说过的，我们可以使用预处理器来构建简洁和功能更丰富的组件，比如 Jade，Babel (with ES2015 modules)，和 Stylus。</p>\n<p><img src=\"/images/vue-component-with-preprocessors.png\" style=\"display: block; margin: 30px auto\"></p>\n<p>这些特定的语言只是例子，你可以只是简单地使用 Buble，TypeScript，SCSS，PostCSS - 或者其他任何能够帮助你提高生产力的预处理器。</p>\n<!-- TODO: include CSS modules once it's supported in vue-loader 9.x -->\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><h3 id=\"针对刚接触-JavaScript-模块开发系统的用户\"><a href=\"#针对刚接触-JavaScript-模块开发系统的用户\" class=\"headerlink\" title=\"针对刚接触 JavaScript 模块开发系统的用户\"></a>针对刚接触 JavaScript 模块开发系统的用户</h3><p>有了 <code>.vue</code> 组件，我们就进入了高级 JavaScirpt 应用领域。如果你没有准备好的话，意味着还需要学会使用一些附加的工具：</p>\n<ul>\n<li><p><strong>Node Package Manager (NPM)</strong>: 阅读 <a href=\"https://docs.npmjs.com/getting-started/what-is-npm\">Getting Started guide</a> 直到 <em>10: Uninstalling global packages</em>章节.</p>\n</li>\n<li><p><strong>Modern JavaScript with ES2015/16</strong>: 阅读 Babel 的 <a href=\"https://babeljs.io/docs/learn-es2015/\">Learn ES2015 guide</a>. 你不需要立刻记住每一个方法，但是你可以保留这个页面以便后期参考。</p>\n</li>\n</ul>\n<p>在你花一些时日了解这些资源之后，我们建议你参考 <a href=\"https://github.com/vuejs-templates/webpack-simple\">webpack-simple</a> 。只要遵循指示，你就能很快的运行一个用到 <code>.vue</code> 组件，ES2015 和  热重载( hot-reloading ) 的Vue项目!</p>\n<p>这个模板使用 <a href=\"https://webpack.github.io/\">Webpack</a>，一个能将多个模块打包成最终应用的模块打包工具。 <a href=\"https://www.youtube.com/watch?v=WQue1AN93YU\">这个视频</a> 介绍了Webpack的更多相关信息。 学习了这些基础知识后， 你可能想看看 <a href=\"https://egghead.io/courses/using-webpack-for-production-javascript-applications\">这个在 Egghead.io上的 高级 Webpack 课程</a>.</p>\n<p>在 Webpack中，每个模块被打包到 bundle 之前都由一个相应的 “loader” 来转换，Vue 也提供 <a href=\"https://github.com/vuejs/vue-loader\">vue-loader</a> 插件来执行 <code>.vue</code> 单文件组件 的转换. 这个 <a href=\"https://github.com/vuejs-templates/webpack-simple\">webpack-simple</a> 模板已经为你准备好了所有的东西，但是如果你想了解更多关于 <code>.vue</code> 组件和 Webpack 如何一起运转的信息，你可以阅读 <a href=\"https://vue-loader.vuejs.org\">vue-loader 的文档</a>。</p>\n<h3 id=\"针对高级用户\"><a href=\"#针对高级用户\" class=\"headerlink\" title=\"针对高级用户\"></a>针对高级用户</h3><p>无论你更钟情 Webpack 或是 Browserify，我们为简单的和更复杂的项目都提供了一些文档模板。我们建议浏览 <a href=\"https://github.com/vuejs-templates\">github.com/vuejs-templates</a>，找到你需要的部分，然后参考 README 中的说明，使用 <a href=\"https://github.com/vuejs/vue-cli\">vue-cli</a> 工具生成新的项目。</p>\n<p>模板中使用 <a href=\"https://webpack.github.io/\">Webpack</a> ，一个模块加载器加载多个模块然后构建成最终应用。为了进一步了解 Webpack, 可以看 <a href=\"https://www.youtube.com/watch?v=WQue1AN93YU\">官方介绍视频</a>。如果你有基础，可以看 <a href=\"https://egghead.io/courses/using-webpack-for-production-javascript-applications\">在 Egghead.io 上的 Webpack 进阶教程</a>。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/single-file-components.html\">http://vuejs.org/guide/single-file-components.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"状态管理","type":"guide","order":22,"_content":"\n## 类 Flux 状态管理的官方实现\n\n由于多个状态分散的跨越在许多组件和交互间各个角落，大型应用复杂度也经常逐渐增长。为了解决这个问题，Vue 提供 [vuex](https://github.com/vuejs/vuex)： 我们有受到 Elm 启发的状态管理库。vuex 甚至集成到 [vue-devtools](https://github.com/vuejs/vue-devtools)，无需配置即可访问时光旅行。\n\n### React 的开发者请参考以下信息\n\n如果你是来自 React 的开发者，你可能会对 vuex 和 [redux](https://github.com/reactjs/redux) 间的差异表示关注，redux 是 React 生态环境中最流行的 Flux 实现。Redux 事实上无法感知视图层，所以它能够轻松的通过一些[简单绑定](https://github.com/egoist/revue)和Vue一起使用。vuex区别在于它是一个专门为 vue 应用所设计。这使得它能够更好地和vue进行整合，同时提供简洁的API和改善过的开发体验。\n\n## 简单状态管理起步使用\n\n经常被忽略的是，Vue 应用中原始 `数据` 对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享：\n\n``` js\nconst sourceOfTruth = {}\n\nconst vmA = new Vue({\n  data: sourceOfTruth\n})\n\nconst vmB = new Vue({\n  data: sourceOfTruth\n})\n```\n\n现在当 `sourceOfTruth` 发生变化，`vmA` 和 `vmB` 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 `this.$root.$data` 去访问。现在我们有了唯一的实际来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录。\n\n为了解决这个问题，我们采用一个简单的 **store 模式**：\n\n``` js\nvar store = {\n  debug: true,\n  state: {\n    message: 'Hello!'\n  },\n  setMessageAction (newValue) {\n    this.debug && console.log('setMessageAction triggered with', newValue)\n    this.state.message = newValue\n  },\n  clearMessageAction () {\n    this.debug && console.log('clearMessageAction triggered')\n    this.state.message = 'clearMessageAction triggered'\n  }\n}\n```\n\n需要注意，所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。\n\n此外，每个实例/组件仍然可以拥有和管理自己的私有状态：\n\n``` js\nvar vmA = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n\nvar vmB = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n```\n\n![状态管理](/images/state.png)\n\n<p class=\"tip\">重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，mutation 才能够被观察</p>\n\n接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 [Flux](https://facebook.github.io/flux/) 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation) 、保存状态快照、历史回滚/时光旅行的先进的调试工具。\n\n说了一圈其实又回到了[vuex](https://github.com/vuejs/vuex) ，如果你已经读到这儿，或许可以去尝试一下！\n\n***\n\n> 原文： http://vuejs.org/guide/state-management.html\n\n***\n","source":"v2/guide/state-management.md","raw":"---\ntitle: 状态管理\ntype: guide\norder: 22\n---\n\n## 类 Flux 状态管理的官方实现\n\n由于多个状态分散的跨越在许多组件和交互间各个角落，大型应用复杂度也经常逐渐增长。为了解决这个问题，Vue 提供 [vuex](https://github.com/vuejs/vuex)： 我们有受到 Elm 启发的状态管理库。vuex 甚至集成到 [vue-devtools](https://github.com/vuejs/vue-devtools)，无需配置即可访问时光旅行。\n\n### React 的开发者请参考以下信息\n\n如果你是来自 React 的开发者，你可能会对 vuex 和 [redux](https://github.com/reactjs/redux) 间的差异表示关注，redux 是 React 生态环境中最流行的 Flux 实现。Redux 事实上无法感知视图层，所以它能够轻松的通过一些[简单绑定](https://github.com/egoist/revue)和Vue一起使用。vuex区别在于它是一个专门为 vue 应用所设计。这使得它能够更好地和vue进行整合，同时提供简洁的API和改善过的开发体验。\n\n## 简单状态管理起步使用\n\n经常被忽略的是，Vue 应用中原始 `数据` 对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享：\n\n``` js\nconst sourceOfTruth = {}\n\nconst vmA = new Vue({\n  data: sourceOfTruth\n})\n\nconst vmB = new Vue({\n  data: sourceOfTruth\n})\n```\n\n现在当 `sourceOfTruth` 发生变化，`vmA` 和 `vmB` 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 `this.$root.$data` 去访问。现在我们有了唯一的实际来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录。\n\n为了解决这个问题，我们采用一个简单的 **store 模式**：\n\n``` js\nvar store = {\n  debug: true,\n  state: {\n    message: 'Hello!'\n  },\n  setMessageAction (newValue) {\n    this.debug && console.log('setMessageAction triggered with', newValue)\n    this.state.message = newValue\n  },\n  clearMessageAction () {\n    this.debug && console.log('clearMessageAction triggered')\n    this.state.message = 'clearMessageAction triggered'\n  }\n}\n```\n\n需要注意，所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。\n\n此外，每个实例/组件仍然可以拥有和管理自己的私有状态：\n\n``` js\nvar vmA = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n\nvar vmB = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n```\n\n![状态管理](/images/state.png)\n\n<p class=\"tip\">重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，mutation 才能够被观察</p>\n\n接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 [Flux](https://facebook.github.io/flux/) 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation) 、保存状态快照、历史回滚/时光旅行的先进的调试工具。\n\n说了一圈其实又回到了[vuex](https://github.com/vuejs/vuex) ，如果你已经读到这儿，或许可以去尝试一下！\n\n***\n\n> 原文： http://vuejs.org/guide/state-management.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/state-management.html","comments":1,"layout":"page","_id":"ciwnajuyy001rjl2dp2vw24zf","content":"<h2 id=\"类-Flux-状态管理的官方实现\"><a href=\"#类-Flux-状态管理的官方实现\" class=\"headerlink\" title=\"类 Flux 状态管理的官方实现\"></a>类 Flux 状态管理的官方实现</h2><p>由于多个状态分散的跨越在许多组件和交互间各个角落，大型应用复杂度也经常逐渐增长。为了解决这个问题，Vue 提供 <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">vuex</a>： 我们有受到 Elm 启发的状态管理库。vuex 甚至集成到 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"external\">vue-devtools</a>，无需配置即可访问时光旅行。</p>\n<h3 id=\"React-的开发者请参考以下信息\"><a href=\"#React-的开发者请参考以下信息\" class=\"headerlink\" title=\"React 的开发者请参考以下信息\"></a>React 的开发者请参考以下信息</h3><p>如果你是来自 React 的开发者，你可能会对 vuex 和 <a href=\"https://github.com/reactjs/redux\" target=\"_blank\" rel=\"external\">redux</a> 间的差异表示关注，redux 是 React 生态环境中最流行的 Flux 实现。Redux 事实上无法感知视图层，所以它能够轻松的通过一些<a href=\"https://github.com/egoist/revue\" target=\"_blank\" rel=\"external\">简单绑定</a>和Vue一起使用。vuex区别在于它是一个专门为 vue 应用所设计。这使得它能够更好地和vue进行整合，同时提供简洁的API和改善过的开发体验。</p>\n<h2 id=\"简单状态管理起步使用\"><a href=\"#简单状态管理起步使用\" class=\"headerlink\" title=\"简单状态管理起步使用\"></a>简单状态管理起步使用</h2><p>经常被忽略的是，Vue 应用中原始 <code>数据</code> 对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> sourceOfTruth = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> vmA = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: sourceOfTruth</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> vmB = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: sourceOfTruth</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>现在当 <code>sourceOfTruth</code> 发生变化，<code>vmA</code> 和 <code>vmB</code> 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 <code>this.$root.$data</code> 去访问。现在我们有了唯一的实际来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录。</p>\n<p>为了解决这个问题，我们采用一个简单的 <strong>store 模式</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> store = &#123;</div><div class=\"line\">  <span class=\"attr\">debug</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"attr\">state</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello!'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  setMessageAction (newValue) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.debug &amp;&amp; <span class=\"built_in\">console</span>.log(<span class=\"string\">'setMessageAction triggered with'</span>, newValue)</div><div class=\"line\">    <span class=\"keyword\">this</span>.state.message = newValue</div><div class=\"line\">  &#125;,</div><div class=\"line\">  clearMessageAction () &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.debug &amp;&amp; <span class=\"built_in\">console</span>.log(<span class=\"string\">'clearMessageAction triggered'</span>)</div><div class=\"line\">    <span class=\"keyword\">this</span>.state.message = <span class=\"string\">'clearMessageAction triggered'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意，所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。</p>\n<p>此外，每个实例/组件仍然可以拥有和管理自己的私有状态：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vmA = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">privateState</span>: &#123;&#125;,</div><div class=\"line\">    <span class=\"attr\">sharedState</span>: store.state</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vmB = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">privateState</span>: &#123;&#125;,</div><div class=\"line\">    <span class=\"attr\">sharedState</span>: store.state</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><img src=\"/images/state.png\" alt=\"状态管理\"></p>\n<p class=\"tip\">重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，mutation 才能够被观察</p>\n\n<p>接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 <a href=\"https://facebook.github.io/flux/\" target=\"_blank\" rel=\"external\">Flux</a> 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation) 、保存状态快照、历史回滚/时光旅行的先进的调试工具。</p>\n<p>说了一圈其实又回到了<a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">vuex</a> ，如果你已经读到这儿，或许可以去尝试一下！</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/state-management.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/state-management.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"类-Flux-状态管理的官方实现\"><a href=\"#类-Flux-状态管理的官方实现\" class=\"headerlink\" title=\"类 Flux 状态管理的官方实现\"></a>类 Flux 状态管理的官方实现</h2><p>由于多个状态分散的跨越在许多组件和交互间各个角落，大型应用复杂度也经常逐渐增长。为了解决这个问题，Vue 提供 <a href=\"https://github.com/vuejs/vuex\">vuex</a>： 我们有受到 Elm 启发的状态管理库。vuex 甚至集成到 <a href=\"https://github.com/vuejs/vue-devtools\">vue-devtools</a>，无需配置即可访问时光旅行。</p>\n<h3 id=\"React-的开发者请参考以下信息\"><a href=\"#React-的开发者请参考以下信息\" class=\"headerlink\" title=\"React 的开发者请参考以下信息\"></a>React 的开发者请参考以下信息</h3><p>如果你是来自 React 的开发者，你可能会对 vuex 和 <a href=\"https://github.com/reactjs/redux\">redux</a> 间的差异表示关注，redux 是 React 生态环境中最流行的 Flux 实现。Redux 事实上无法感知视图层，所以它能够轻松的通过一些<a href=\"https://github.com/egoist/revue\">简单绑定</a>和Vue一起使用。vuex区别在于它是一个专门为 vue 应用所设计。这使得它能够更好地和vue进行整合，同时提供简洁的API和改善过的开发体验。</p>\n<h2 id=\"简单状态管理起步使用\"><a href=\"#简单状态管理起步使用\" class=\"headerlink\" title=\"简单状态管理起步使用\"></a>简单状态管理起步使用</h2><p>经常被忽略的是，Vue 应用中原始 <code>数据</code> 对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> sourceOfTruth = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> vmA = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: sourceOfTruth</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> vmB = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: sourceOfTruth</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>现在当 <code>sourceOfTruth</code> 发生变化，<code>vmA</code> 和 <code>vmB</code> 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 <code>this.$root.$data</code> 去访问。现在我们有了唯一的实际来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录。</p>\n<p>为了解决这个问题，我们采用一个简单的 <strong>store 模式</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> store = &#123;</div><div class=\"line\">  <span class=\"attr\">debug</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"attr\">state</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">'Hello!'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  setMessageAction (newValue) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.debug &amp;&amp; <span class=\"built_in\">console</span>.log(<span class=\"string\">'setMessageAction triggered with'</span>, newValue)</div><div class=\"line\">    <span class=\"keyword\">this</span>.state.message = newValue</div><div class=\"line\">  &#125;,</div><div class=\"line\">  clearMessageAction () &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.debug &amp;&amp; <span class=\"built_in\">console</span>.log(<span class=\"string\">'clearMessageAction triggered'</span>)</div><div class=\"line\">    <span class=\"keyword\">this</span>.state.message = <span class=\"string\">'clearMessageAction triggered'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意，所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。</p>\n<p>此外，每个实例/组件仍然可以拥有和管理自己的私有状态：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vmA = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">privateState</span>: &#123;&#125;,</div><div class=\"line\">    <span class=\"attr\">sharedState</span>: store.state</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vmB = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">privateState</span>: &#123;&#125;,</div><div class=\"line\">    <span class=\"attr\">sharedState</span>: store.state</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><img src=\"/images/state.png\" alt=\"状态管理\"></p>\n<p class=\"tip\">重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，mutation 才能够被观察</p>\n\n<p>接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 <a href=\"https://facebook.github.io/flux/\">Flux</a> 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation) 、保存状态快照、历史回滚/时光旅行的先进的调试工具。</p>\n<p>说了一圈其实又回到了<a href=\"https://github.com/vuejs/vuex\">vuex</a> ，如果你已经读到这儿，或许可以去尝试一下！</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/state-management.html\">http://vuejs.org/guide/state-management.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"服务端渲染","type":"guide","order":24,"_content":"\n## 需要服务端渲染（SSR）吗？\n\n在开始服务端渲染前，我们先看看它能给我们带来什么，以及什么时候需要用它。\n\n### SEO（搜索引擎优化）\n\n谷歌和Bing可以很好地索引同步的JavaScript应用。_同步_在这里是个关键词。如果应用启动时有一个加载动画，然后内容通过ajax获取，那爬虫不会等待他们加载完成。\n\n这意味着在异步获取内容的页面上很需要进行搜索引擎优化的时候，服务端渲染就很重要。\n\n### 客户端的网络比较慢\n\n用户可能在网络比较慢的情况下从远处访问网站 - 或者通过比较差的带宽。 这些情况下，尽量减少页面请求数量，来保证用户尽快看到基本的内容。\n\n可以用 [Webpack的代码拆分](https://webpack.github.io/docs/code-splitting.html) 避免强制用户下载整个单页面应用，但是，这样也远没有下载个单独的预先渲染过的HTML文件性能高。\n\n### 客户端运行在老的(或者直接没有)JavaScript引擎上\n\n对于世界上的一些地区人，可能只能用1998年产的电脑访问互联网的方式使用计算机。而Vue只能运行在IE9以上的浏览器，你可以也想为那些老式浏览器提供基础内容 - 或者是在命令行中使用 [Lynx](http://lynx.browser.org/)的时髦的黑客。\n\n### 服务端渲染 对比 预渲染(Prerendering)\n\n如果你只是用服务端渲染来改善一个少数的营销页面（如 首页，关于，联系 等等）的SEO，那你可以用__预渲染__替换。预渲染不像服务器渲染那样即时编译HTML,预渲染只是在构建时为了特定的路由生成特定的几个静态页面。其优势是预渲染的设置更加简单，可以保持前端是一个完整的静态站。\n\n你用webpack可以很简单地通过[prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin)来添加预渲染，它被广泛地用在Vue应用上 - 事实上，创建者也是Vue核心团队成员之一。\n\n## Hello World\n\n准备在行动中体验服务端渲染吧。服务端渲染(即SSR)听起来很复杂，不过一个简单的Node脚本只需要3步就可以实现这个功能:\n\n``` js\n// 步骤 1:创建一个Vue实例\nvar Vue = require('vue')\nvar app = new Vue({\n  render: function (h) {\n    return h('p', 'hello world')\n  }\n})\n\n// 步骤 2: 创建一个渲染器\nvar renderer = require('vue-server-renderer').createRenderer()\n\n// 步骤 3: 将 Vue实例 渲染成 HTML\n\nrenderer.renderToString(app, function (error, html) {\n  if (error) throw error\n  console.log(html)\n  // => <p server-rendered=\"true\">hello world</p>\n})\n```\n\n这并不困难。当然这个示例比大部分应用都简单。我们不必担心：\n\n- 一个Web服务器\n- 流式响应\n- 组件缓存\n- 构建过程\n- 路由\n- Vuex状态管理\n\n这个指南的其余部分，我们将探讨这些功能怎样运作。一旦你理解了基础，我们会提供更多细节和进一步的示例来帮助你解决意外情况。\n\n## 通过Express Web服务器实现简单的服务端渲染\n\n如果没有一个Web服务器，很难说是服务端渲染，所以我们来补充它。我们将构建一个非常简单的服务端渲染应用，只用ES5，也不带其他构建步骤或Vue插件。\n\n启动一个应用告诉用户他们在一个页面上花了多少时间。\n\n\n``` js\nnew Vue({\n  template: '<div>你已经在这花了 {{ counter }} 秒。</div>',\n  data: {\n    counter: 0\n  },\n  created: function () {\n    var vm = this\n    setInterval(function () {\n      vm.counter += 1\n    }, 1000)\n  }\n})\n```\n\n为了适应服务端渲染，我们需要进行一些修改，让它可以在浏览器和Node中渲染：\n\n- 在浏览器中，将我们的应用实例添加到全局上下文（ `window`）上,我们可以安装它。\n- 在Node中，导出一个工厂函数让我们可以为每个请求创建应用实例。\n\n实现这个需要一点模板：\n\n``` js\n// assets/app.js\n(function () { 'use strict'\n  var createApp = function () {\n    // ---------------------\n    // 开始常用的应用代码\n    // ---------------------\n\n    // 主要的Vue实例必须返回，并且有一个根节点在id \"app\"上，这样客户端可以加载它。\n\n    return new Vue({\n      template: '<div id=\"app\">你已经在这花了 {{ counter }} 秒。</div>',\n      data: {\n        counter: 0\n      },\n      created: function () {\n        var vm = this\n        setInterval(function () {\n          vm.counter += 1\n        }, 1000)\n      }\n    })\n\n    // -------------------\n    // 结束常用的应用代码\n    // -------------------\n  }\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = createApp\n  } else {\n    this.app = createApp()\n  }\n}).call(this)\n```\n\n现在有了应用代码，接着加一个 html文件。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Vue App</title>\n  <script src=\"/assets/vue.js\"></script>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script src=\"/assets/app.js\"></script>\n  <script>app.$mount('#app')</script>\n</body>\n</html>\n```\n\n主要引用`assets`文件夹中我们先前创建的`app.js`，以及`vue.js`文件，我们就有了一个可以运行的单页面应用\n\n然后为了实现服务端渲染，在服务端需要加一个步骤。\n\n``` js\n// server.js\n'use strict'\n\nvar fs = require('fs')\nvar path = require('path')\n\n// 定义全局的Vue为了服务端的app.js\nglobal.Vue = require('vue')\n\n// 获取HTML布局\nvar layout = fs.readFileSync('./index.html', 'utf8')\n\n// 创建一个渲染器\nvar renderer = require('vue-server-renderer').createRenderer()\n\n// 创建一个Express服务器\nvar express = require('express')\nvar server = express()\n\n// 部署静态文件夹为 \"assets\"文件夹\nserver.use('/assets', express.static(\n  path.resolve(__dirname, 'assets')\n))\n\n// 处理所有的Get请求\nserver.get('*', function (request, response) {\n  // 渲染我们的Vue应用为一个字符串\n  renderer.renderToString(\n    // 创建一个应用实例\n    require('./assets/app')(),\n    // 处理渲染结果\n    function (error, html) {\n      // 如果渲染时发生了错误\n      if (error) {\n        // 打印错误到控制台\n        console.error(error)\n        // 告诉客户端错误\n        return response\n          .status(500)\n          .send('Server Error')\n      }\n      // 发送布局和HTML文件\n      response.send(layout.replace('<div id=\"app\"></div>', html))\n    }\n  )\n})\n\n// 监听5000端口\nserver.listen(5000, function (error) {\n  if (error) throw error\n  console.log('Server is running at localhost:5000')\n})\n```\n\n这样就完成了。[整个示例](https://github.com/chrisvfritz/vue-ssr-demo-simple)，克隆下来深度实验。一旦它在本地运行时，你可以通过在页面右击选择`页面资源`（或类似操作）确认服务选渲染真的运行了。可以在body中看到：\n\n``` html\n<div id=\"app\" server-rendered=\"true\">You have been here for 0 seconds&period;</div>\n```\n\n代替:\n\n``` html\n<div id=\"app\"></div>\n```\n\n## 流式响应\n\nVue还支持__流式__渲染，优先选择适用于支持流的Web服务器。允许HTML一边生成一边写入相应流，而不是在最后一次全部写入。其结果是请求服务速度更快，没有缺点！\n\n为了使上一节应用代码适用流式渲染，可以简单的替换 `server.get('*',...)`为下面的代码：\n\n``` js\n// 拆分布局成两段HTML\nvar layoutSections = layout.split('<div id=\"app\"></div>')\nvar preAppHTML = layoutSections[0]\nvar postAppHTML = layoutSections[1]\n\n// 处理所有的Get请求\nserver.get('*', function (request, response) {\n  // 渲染我们的Vue实例作为流\n  var stream = renderer.renderToStream(require('./assets/app')())\n\n  // 将预先的HTML写入响应\n  response.write(preAppHTML)\n\n  // 每当新的块被渲染\n  stream.on('data', function (chunk) {\n    // 将块写入响应\n    response.write(chunk)\n  })\n\n  // 当所有的块被渲染完成\n  stream.on('end', function () {\n    // 将post-app HTML写入响应\n    response.end(postAppHTML)\n  })\n\n  // 当渲染时发生错误\n  stream.on('error', function (error) {\n    // 打印错误到控制台\n    console.error(error)\n    // 告诉客服端发生了错误\n    return response\n      .status(500)\n      .send('Server Error')\n  })\n})\n```\n\n这不比之前的版本复杂，甚至这对你来说都不是个新概念。我们做了：\n1. 建立流\n2. 在应用响应前写入HTML\n3. 在可获得时将应用HTML写入响应\n4. 在响应最后写入HTML\n5. 处理任何错误\n\n## 组件缓存\n\nVue的服务端渲染默认非常快，但是你可以通过缓存渲染好的组件进一步提高性能。这被认为是一种先进的功能，但是，如果缓存了错误的组件（或者正确的组件带有错误的内容）将导致应用渲染出错。特别注意：\n\n<p class=\"tip\">不应该缓存组件包含子组件依赖全局状态（例如来自vuex的状态）。如果这么做，子组件（事实上是整个子树）也会被缓存。所以要特别注意带有slots片段或者子组件的情况。</p>\n\n### 设置\n\n在警告情况之外的，我们可以用下面的方法缓存组件。\n\n首先，你需要提供给渲染器一个 [缓存对象](https://www.npmjs.com/package/vue-server-renderer#cache)。这有个简单的示例使用 [lru-cache](https://github.com/isaacs/node-lru-cache)\n\n``` js\nvar createRenderer = require('vue-server-renderer').createRenderer\nvar lru = require('lru-cache')\n\nvar renderer = createRenderer({\n  cache: lru(1000)\n})\n```\n\n这将缓存高达1000个独立的渲染。对于更进一步缓存到内容中的配置，看[lru-cache设置](https://github.com/isaacs/node-lru-cache#options)\n\n然后对于你想缓存的组件，你可以为他们提供：\n\n- 一个唯一的`名字`\n- 一个 `serverCacheKey`函数，返回一个唯一的组件作用域\n\n例如:\n\n``` js\nVue.component({\n  name: 'list-item',\n  template: '<li>{{ item.name }}</li>',\n  props: ['item'],\n  serverCacheKey: function (props) {\n    return props.item.type + '::' + props.item.id\n  }\n})\n```\n\n### 缓存的理想组件\n\n任何纯组件可以被安全缓存 -  这是保证给任何组件传递一样的数据产生相同的HTML。这些场景的例子包括：\n\n- 静态的组件 (例如 总是尝试一样的HTML,所以 `serverCacheKey` 函数可以被返回 `true`)\n- 列表组件（当有大量列表，缓存他们可以改善性能）\n- 通用UI组件 (例如 buttons, alerts, 等等 - 至少他们通过props获取数据而不是 slots或者子组件)\n\n## 构建过程，路由，和Vuex状态管理\n\n现在，应该理解服务端渲染背后的基本概念了。但是，构建过程、路由、Vuex每一个都有自己的注意事项。\n\n要真正掌握复杂应用下的服务端渲染，我们推荐深度熟悉以下资源：\n\n- [vue-server-renderer 文档](https://www.npmjs.com/package/vue-server-renderer#api):更多细节在这里，和更多先进的主题一起的文档。 例如 [preventing cross-request contamination](https://www.npmjs.com/package/vue-server-renderer#why-use-bundlerenderer) 和 [添加独立的服务构建](https://www.npmjs.com/package/vue-server-renderer#creating-the-server-bundle)\n- [vue-hackernews-2.0](https://github.com/vuejs/vue-hackernews-2.0): 明确整合了  所有主要的Vue库和概念在单个应用中\n\n***\n\n> 原文: http://vuejs.org/guide/ssr.html\n\n***\n","source":"v2/guide/ssr.md","raw":"---\ntitle: 服务端渲染\ntype: guide\norder: 24\n---\n\n## 需要服务端渲染（SSR）吗？\n\n在开始服务端渲染前，我们先看看它能给我们带来什么，以及什么时候需要用它。\n\n### SEO（搜索引擎优化）\n\n谷歌和Bing可以很好地索引同步的JavaScript应用。_同步_在这里是个关键词。如果应用启动时有一个加载动画，然后内容通过ajax获取，那爬虫不会等待他们加载完成。\n\n这意味着在异步获取内容的页面上很需要进行搜索引擎优化的时候，服务端渲染就很重要。\n\n### 客户端的网络比较慢\n\n用户可能在网络比较慢的情况下从远处访问网站 - 或者通过比较差的带宽。 这些情况下，尽量减少页面请求数量，来保证用户尽快看到基本的内容。\n\n可以用 [Webpack的代码拆分](https://webpack.github.io/docs/code-splitting.html) 避免强制用户下载整个单页面应用，但是，这样也远没有下载个单独的预先渲染过的HTML文件性能高。\n\n### 客户端运行在老的(或者直接没有)JavaScript引擎上\n\n对于世界上的一些地区人，可能只能用1998年产的电脑访问互联网的方式使用计算机。而Vue只能运行在IE9以上的浏览器，你可以也想为那些老式浏览器提供基础内容 - 或者是在命令行中使用 [Lynx](http://lynx.browser.org/)的时髦的黑客。\n\n### 服务端渲染 对比 预渲染(Prerendering)\n\n如果你只是用服务端渲染来改善一个少数的营销页面（如 首页，关于，联系 等等）的SEO，那你可以用__预渲染__替换。预渲染不像服务器渲染那样即时编译HTML,预渲染只是在构建时为了特定的路由生成特定的几个静态页面。其优势是预渲染的设置更加简单，可以保持前端是一个完整的静态站。\n\n你用webpack可以很简单地通过[prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin)来添加预渲染，它被广泛地用在Vue应用上 - 事实上，创建者也是Vue核心团队成员之一。\n\n## Hello World\n\n准备在行动中体验服务端渲染吧。服务端渲染(即SSR)听起来很复杂，不过一个简单的Node脚本只需要3步就可以实现这个功能:\n\n``` js\n// 步骤 1:创建一个Vue实例\nvar Vue = require('vue')\nvar app = new Vue({\n  render: function (h) {\n    return h('p', 'hello world')\n  }\n})\n\n// 步骤 2: 创建一个渲染器\nvar renderer = require('vue-server-renderer').createRenderer()\n\n// 步骤 3: 将 Vue实例 渲染成 HTML\n\nrenderer.renderToString(app, function (error, html) {\n  if (error) throw error\n  console.log(html)\n  // => <p server-rendered=\"true\">hello world</p>\n})\n```\n\n这并不困难。当然这个示例比大部分应用都简单。我们不必担心：\n\n- 一个Web服务器\n- 流式响应\n- 组件缓存\n- 构建过程\n- 路由\n- Vuex状态管理\n\n这个指南的其余部分，我们将探讨这些功能怎样运作。一旦你理解了基础，我们会提供更多细节和进一步的示例来帮助你解决意外情况。\n\n## 通过Express Web服务器实现简单的服务端渲染\n\n如果没有一个Web服务器，很难说是服务端渲染，所以我们来补充它。我们将构建一个非常简单的服务端渲染应用，只用ES5，也不带其他构建步骤或Vue插件。\n\n启动一个应用告诉用户他们在一个页面上花了多少时间。\n\n\n``` js\nnew Vue({\n  template: '<div>你已经在这花了 {{ counter }} 秒。</div>',\n  data: {\n    counter: 0\n  },\n  created: function () {\n    var vm = this\n    setInterval(function () {\n      vm.counter += 1\n    }, 1000)\n  }\n})\n```\n\n为了适应服务端渲染，我们需要进行一些修改，让它可以在浏览器和Node中渲染：\n\n- 在浏览器中，将我们的应用实例添加到全局上下文（ `window`）上,我们可以安装它。\n- 在Node中，导出一个工厂函数让我们可以为每个请求创建应用实例。\n\n实现这个需要一点模板：\n\n``` js\n// assets/app.js\n(function () { 'use strict'\n  var createApp = function () {\n    // ---------------------\n    // 开始常用的应用代码\n    // ---------------------\n\n    // 主要的Vue实例必须返回，并且有一个根节点在id \"app\"上，这样客户端可以加载它。\n\n    return new Vue({\n      template: '<div id=\"app\">你已经在这花了 {{ counter }} 秒。</div>',\n      data: {\n        counter: 0\n      },\n      created: function () {\n        var vm = this\n        setInterval(function () {\n          vm.counter += 1\n        }, 1000)\n      }\n    })\n\n    // -------------------\n    // 结束常用的应用代码\n    // -------------------\n  }\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = createApp\n  } else {\n    this.app = createApp()\n  }\n}).call(this)\n```\n\n现在有了应用代码，接着加一个 html文件。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Vue App</title>\n  <script src=\"/assets/vue.js\"></script>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script src=\"/assets/app.js\"></script>\n  <script>app.$mount('#app')</script>\n</body>\n</html>\n```\n\n主要引用`assets`文件夹中我们先前创建的`app.js`，以及`vue.js`文件，我们就有了一个可以运行的单页面应用\n\n然后为了实现服务端渲染，在服务端需要加一个步骤。\n\n``` js\n// server.js\n'use strict'\n\nvar fs = require('fs')\nvar path = require('path')\n\n// 定义全局的Vue为了服务端的app.js\nglobal.Vue = require('vue')\n\n// 获取HTML布局\nvar layout = fs.readFileSync('./index.html', 'utf8')\n\n// 创建一个渲染器\nvar renderer = require('vue-server-renderer').createRenderer()\n\n// 创建一个Express服务器\nvar express = require('express')\nvar server = express()\n\n// 部署静态文件夹为 \"assets\"文件夹\nserver.use('/assets', express.static(\n  path.resolve(__dirname, 'assets')\n))\n\n// 处理所有的Get请求\nserver.get('*', function (request, response) {\n  // 渲染我们的Vue应用为一个字符串\n  renderer.renderToString(\n    // 创建一个应用实例\n    require('./assets/app')(),\n    // 处理渲染结果\n    function (error, html) {\n      // 如果渲染时发生了错误\n      if (error) {\n        // 打印错误到控制台\n        console.error(error)\n        // 告诉客户端错误\n        return response\n          .status(500)\n          .send('Server Error')\n      }\n      // 发送布局和HTML文件\n      response.send(layout.replace('<div id=\"app\"></div>', html))\n    }\n  )\n})\n\n// 监听5000端口\nserver.listen(5000, function (error) {\n  if (error) throw error\n  console.log('Server is running at localhost:5000')\n})\n```\n\n这样就完成了。[整个示例](https://github.com/chrisvfritz/vue-ssr-demo-simple)，克隆下来深度实验。一旦它在本地运行时，你可以通过在页面右击选择`页面资源`（或类似操作）确认服务选渲染真的运行了。可以在body中看到：\n\n``` html\n<div id=\"app\" server-rendered=\"true\">You have been here for 0 seconds&period;</div>\n```\n\n代替:\n\n``` html\n<div id=\"app\"></div>\n```\n\n## 流式响应\n\nVue还支持__流式__渲染，优先选择适用于支持流的Web服务器。允许HTML一边生成一边写入相应流，而不是在最后一次全部写入。其结果是请求服务速度更快，没有缺点！\n\n为了使上一节应用代码适用流式渲染，可以简单的替换 `server.get('*',...)`为下面的代码：\n\n``` js\n// 拆分布局成两段HTML\nvar layoutSections = layout.split('<div id=\"app\"></div>')\nvar preAppHTML = layoutSections[0]\nvar postAppHTML = layoutSections[1]\n\n// 处理所有的Get请求\nserver.get('*', function (request, response) {\n  // 渲染我们的Vue实例作为流\n  var stream = renderer.renderToStream(require('./assets/app')())\n\n  // 将预先的HTML写入响应\n  response.write(preAppHTML)\n\n  // 每当新的块被渲染\n  stream.on('data', function (chunk) {\n    // 将块写入响应\n    response.write(chunk)\n  })\n\n  // 当所有的块被渲染完成\n  stream.on('end', function () {\n    // 将post-app HTML写入响应\n    response.end(postAppHTML)\n  })\n\n  // 当渲染时发生错误\n  stream.on('error', function (error) {\n    // 打印错误到控制台\n    console.error(error)\n    // 告诉客服端发生了错误\n    return response\n      .status(500)\n      .send('Server Error')\n  })\n})\n```\n\n这不比之前的版本复杂，甚至这对你来说都不是个新概念。我们做了：\n1. 建立流\n2. 在应用响应前写入HTML\n3. 在可获得时将应用HTML写入响应\n4. 在响应最后写入HTML\n5. 处理任何错误\n\n## 组件缓存\n\nVue的服务端渲染默认非常快，但是你可以通过缓存渲染好的组件进一步提高性能。这被认为是一种先进的功能，但是，如果缓存了错误的组件（或者正确的组件带有错误的内容）将导致应用渲染出错。特别注意：\n\n<p class=\"tip\">不应该缓存组件包含子组件依赖全局状态（例如来自vuex的状态）。如果这么做，子组件（事实上是整个子树）也会被缓存。所以要特别注意带有slots片段或者子组件的情况。</p>\n\n### 设置\n\n在警告情况之外的，我们可以用下面的方法缓存组件。\n\n首先，你需要提供给渲染器一个 [缓存对象](https://www.npmjs.com/package/vue-server-renderer#cache)。这有个简单的示例使用 [lru-cache](https://github.com/isaacs/node-lru-cache)\n\n``` js\nvar createRenderer = require('vue-server-renderer').createRenderer\nvar lru = require('lru-cache')\n\nvar renderer = createRenderer({\n  cache: lru(1000)\n})\n```\n\n这将缓存高达1000个独立的渲染。对于更进一步缓存到内容中的配置，看[lru-cache设置](https://github.com/isaacs/node-lru-cache#options)\n\n然后对于你想缓存的组件，你可以为他们提供：\n\n- 一个唯一的`名字`\n- 一个 `serverCacheKey`函数，返回一个唯一的组件作用域\n\n例如:\n\n``` js\nVue.component({\n  name: 'list-item',\n  template: '<li>{{ item.name }}</li>',\n  props: ['item'],\n  serverCacheKey: function (props) {\n    return props.item.type + '::' + props.item.id\n  }\n})\n```\n\n### 缓存的理想组件\n\n任何纯组件可以被安全缓存 -  这是保证给任何组件传递一样的数据产生相同的HTML。这些场景的例子包括：\n\n- 静态的组件 (例如 总是尝试一样的HTML,所以 `serverCacheKey` 函数可以被返回 `true`)\n- 列表组件（当有大量列表，缓存他们可以改善性能）\n- 通用UI组件 (例如 buttons, alerts, 等等 - 至少他们通过props获取数据而不是 slots或者子组件)\n\n## 构建过程，路由，和Vuex状态管理\n\n现在，应该理解服务端渲染背后的基本概念了。但是，构建过程、路由、Vuex每一个都有自己的注意事项。\n\n要真正掌握复杂应用下的服务端渲染，我们推荐深度熟悉以下资源：\n\n- [vue-server-renderer 文档](https://www.npmjs.com/package/vue-server-renderer#api):更多细节在这里，和更多先进的主题一起的文档。 例如 [preventing cross-request contamination](https://www.npmjs.com/package/vue-server-renderer#why-use-bundlerenderer) 和 [添加独立的服务构建](https://www.npmjs.com/package/vue-server-renderer#creating-the-server-bundle)\n- [vue-hackernews-2.0](https://github.com/vuejs/vue-hackernews-2.0): 明确整合了  所有主要的Vue库和概念在单个应用中\n\n***\n\n> 原文: http://vuejs.org/guide/ssr.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/ssr.html","comments":1,"layout":"page","_id":"ciwnajuyy001sjl2d23a0xpu6","content":"<h2 id=\"需要服务端渲染（SSR）吗？\"><a href=\"#需要服务端渲染（SSR）吗？\" class=\"headerlink\" title=\"需要服务端渲染（SSR）吗？\"></a>需要服务端渲染（SSR）吗？</h2><p>在开始服务端渲染前，我们先看看它能给我们带来什么，以及什么时候需要用它。</p>\n<h3 id=\"SEO（搜索引擎优化）\"><a href=\"#SEO（搜索引擎优化）\" class=\"headerlink\" title=\"SEO（搜索引擎优化）\"></a>SEO（搜索引擎优化）</h3><p>谷歌和Bing可以很好地索引同步的JavaScript应用。<em>同步</em>在这里是个关键词。如果应用启动时有一个加载动画，然后内容通过ajax获取，那爬虫不会等待他们加载完成。</p>\n<p>这意味着在异步获取内容的页面上很需要进行搜索引擎优化的时候，服务端渲染就很重要。</p>\n<h3 id=\"客户端的网络比较慢\"><a href=\"#客户端的网络比较慢\" class=\"headerlink\" title=\"客户端的网络比较慢\"></a>客户端的网络比较慢</h3><p>用户可能在网络比较慢的情况下从远处访问网站 - 或者通过比较差的带宽。 这些情况下，尽量减少页面请求数量，来保证用户尽快看到基本的内容。</p>\n<p>可以用 <a href=\"https://webpack.github.io/docs/code-splitting.html\" target=\"_blank\" rel=\"external\">Webpack的代码拆分</a> 避免强制用户下载整个单页面应用，但是，这样也远没有下载个单独的预先渲染过的HTML文件性能高。</p>\n<h3 id=\"客户端运行在老的-或者直接没有-JavaScript引擎上\"><a href=\"#客户端运行在老的-或者直接没有-JavaScript引擎上\" class=\"headerlink\" title=\"客户端运行在老的(或者直接没有)JavaScript引擎上\"></a>客户端运行在老的(或者直接没有)JavaScript引擎上</h3><p>对于世界上的一些地区人，可能只能用1998年产的电脑访问互联网的方式使用计算机。而Vue只能运行在IE9以上的浏览器，你可以也想为那些老式浏览器提供基础内容 - 或者是在命令行中使用 <a href=\"http://lynx.browser.org/\" target=\"_blank\" rel=\"external\">Lynx</a>的时髦的黑客。</p>\n<h3 id=\"服务端渲染-对比-预渲染-Prerendering\"><a href=\"#服务端渲染-对比-预渲染-Prerendering\" class=\"headerlink\" title=\"服务端渲染 对比 预渲染(Prerendering)\"></a>服务端渲染 对比 预渲染(Prerendering)</h3><p>如果你只是用服务端渲染来改善一个少数的营销页面（如 首页，关于，联系 等等）的SEO，那你可以用<strong>预渲染</strong>替换。预渲染不像服务器渲染那样即时编译HTML,预渲染只是在构建时为了特定的路由生成特定的几个静态页面。其优势是预渲染的设置更加简单，可以保持前端是一个完整的静态站。</p>\n<p>你用webpack可以很简单地通过<a href=\"https://github.com/chrisvfritz/prerender-spa-plugin\" target=\"_blank\" rel=\"external\">prerender-spa-plugin</a>来添加预渲染，它被广泛地用在Vue应用上 - 事实上，创建者也是Vue核心团队成员之一。</p>\n<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>准备在行动中体验服务端渲染吧。服务端渲染(即SSR)听起来很复杂，不过一个简单的Node脚本只需要3步就可以实现这个功能:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 步骤 1:创建一个Vue实例</span></div><div class=\"line\"><span class=\"keyword\">var</span> Vue = <span class=\"built_in\">require</span>(<span class=\"string\">'vue'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">h</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> h(<span class=\"string\">'p'</span>, <span class=\"string\">'hello world'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 步骤 2: 创建一个渲染器</span></div><div class=\"line\"><span class=\"keyword\">var</span> renderer = <span class=\"built_in\">require</span>(<span class=\"string\">'vue-server-renderer'</span>).createRenderer()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 步骤 3: 将 Vue实例 渲染成 HTML</span></div><div class=\"line\"></div><div class=\"line\">renderer.renderToString(app, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, html</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(html)</div><div class=\"line\">  <span class=\"comment\">// =&gt; &lt;p server-rendered=\"true\"&gt;hello world&lt;/p&gt;</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这并不困难。当然这个示例比大部分应用都简单。我们不必担心：</p>\n<ul>\n<li>一个Web服务器</li>\n<li>流式响应</li>\n<li>组件缓存</li>\n<li>构建过程</li>\n<li>路由</li>\n<li>Vuex状态管理</li>\n</ul>\n<p>这个指南的其余部分，我们将探讨这些功能怎样运作。一旦你理解了基础，我们会提供更多细节和进一步的示例来帮助你解决意外情况。</p>\n<h2 id=\"通过Express-Web服务器实现简单的服务端渲染\"><a href=\"#通过Express-Web服务器实现简单的服务端渲染\" class=\"headerlink\" title=\"通过Express Web服务器实现简单的服务端渲染\"></a>通过Express Web服务器实现简单的服务端渲染</h2><p>如果没有一个Web服务器，很难说是服务端渲染，所以我们来补充它。我们将构建一个非常简单的服务端渲染应用，只用ES5，也不带其他构建步骤或Vue插件。</p>\n<p>启动一个应用告诉用户他们在一个页面上花了多少时间。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;你已经在这花了 &#123;&#123; counter &#125;&#125; 秒。&lt;/div&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">counter</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">    setInterval(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      vm.counter += <span class=\"number\">1</span></div><div class=\"line\">    &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>为了适应服务端渲染，我们需要进行一些修改，让它可以在浏览器和Node中渲染：</p>\n<ul>\n<li>在浏览器中，将我们的应用实例添加到全局上下文（ <code>window</code>）上,我们可以安装它。</li>\n<li>在Node中，导出一个工厂函数让我们可以为每个请求创建应用实例。</li>\n</ul>\n<p>实现这个需要一点模板：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// assets/app.js</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"string\">'use strict'</span></div><div class=\"line\">  <span class=\"keyword\">var</span> createApp = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ---------------------</span></div><div class=\"line\">    <span class=\"comment\">// 开始常用的应用代码</span></div><div class=\"line\">    <span class=\"comment\">// ---------------------</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 主要的Vue实例必须返回，并且有一个根节点在id \"app\"上，这样客户端可以加载它。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div id=\"app\"&gt;你已经在这花了 &#123;&#123; counter &#125;&#125; 秒。&lt;/div&gt;'</span>,</div><div class=\"line\">      <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">counter</span>: <span class=\"number\">0</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">        setInterval(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          vm.counter += <span class=\"number\">1</span></div><div class=\"line\">        &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// -------------------</span></div><div class=\"line\">    <span class=\"comment\">// 结束常用的应用代码</span></div><div class=\"line\">    <span class=\"comment\">// -------------------</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">module</span>.exports) &#123;</div><div class=\"line\">    <span class=\"built_in\">module</span>.exports = createApp</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.app = createApp()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;).call(<span class=\"keyword\">this</span>)</div></pre></td></tr></table></figure>\n<p>现在有了应用代码，接着加一个 html文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>My Vue App<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/assets/vue.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/assets/app.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\">app.$mount(<span class=\"string\">'#app'</span>)</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>主要引用<code>assets</code>文件夹中我们先前创建的<code>app.js</code>，以及<code>vue.js</code>文件，我们就有了一个可以运行的单页面应用</p>\n<p>然后为了实现服务端渲染，在服务端需要加一个步骤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义全局的Vue为了服务端的app.js</span></div><div class=\"line\">global.Vue = <span class=\"built_in\">require</span>(<span class=\"string\">'vue'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取HTML布局</span></div><div class=\"line\"><span class=\"keyword\">var</span> layout = fs.readFileSync(<span class=\"string\">'./index.html'</span>, <span class=\"string\">'utf8'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建一个渲染器</span></div><div class=\"line\"><span class=\"keyword\">var</span> renderer = <span class=\"built_in\">require</span>(<span class=\"string\">'vue-server-renderer'</span>).createRenderer()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建一个Express服务器</span></div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> server = express()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 部署静态文件夹为 \"assets\"文件夹</span></div><div class=\"line\">server.use(<span class=\"string\">'/assets'</span>, express.static(</div><div class=\"line\">  path.resolve(__dirname, <span class=\"string\">'assets'</span>)</div><div class=\"line\">))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 处理所有的Get请求</span></div><div class=\"line\">server.get(<span class=\"string\">'*'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 渲染我们的Vue应用为一个字符串</span></div><div class=\"line\">  renderer.renderToString(</div><div class=\"line\">    <span class=\"comment\">// 创建一个应用实例</span></div><div class=\"line\">    <span class=\"built_in\">require</span>(<span class=\"string\">'./assets/app'</span>)(),</div><div class=\"line\">    <span class=\"comment\">// 处理渲染结果</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, html</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 如果渲染时发生了错误</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">        <span class=\"comment\">// 打印错误到控制台</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.error(error)</div><div class=\"line\">        <span class=\"comment\">// 告诉客户端错误</span></div><div class=\"line\">        <span class=\"keyword\">return</span> response</div><div class=\"line\">          .status(<span class=\"number\">500</span>)</div><div class=\"line\">          .send(<span class=\"string\">'Server Error'</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 发送布局和HTML文件</span></div><div class=\"line\">      response.send(layout.replace(<span class=\"string\">'&lt;div id=\"app\"&gt;&lt;/div&gt;'</span>, html))</div><div class=\"line\">    &#125;</div><div class=\"line\">  )</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 监听5000端口</span></div><div class=\"line\">server.listen(<span class=\"number\">5000</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server is running at localhost:5000'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样就完成了。<a href=\"https://github.com/chrisvfritz/vue-ssr-demo-simple\" target=\"_blank\" rel=\"external\">整个示例</a>，克隆下来深度实验。一旦它在本地运行时，你可以通过在页面右击选择<code>页面资源</code>（或类似操作）确认服务选渲染真的运行了。可以在body中看到：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span> <span class=\"attr\">server-rendered</span>=<span class=\"string\">\"true\"</span>&gt;</span>You have been here for 0 seconds&amp;period;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>代替:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"流式响应\"><a href=\"#流式响应\" class=\"headerlink\" title=\"流式响应\"></a>流式响应</h2><p>Vue还支持<strong>流式</strong>渲染，优先选择适用于支持流的Web服务器。允许HTML一边生成一边写入相应流，而不是在最后一次全部写入。其结果是请求服务速度更快，没有缺点！</p>\n<p>为了使上一节应用代码适用流式渲染，可以简单的替换 <code>server.get(&#39;*&#39;,...)</code>为下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 拆分布局成两段HTML</span></div><div class=\"line\"><span class=\"keyword\">var</span> layoutSections = layout.split(<span class=\"string\">'&lt;div id=\"app\"&gt;&lt;/div&gt;'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> preAppHTML = layoutSections[<span class=\"number\">0</span>]</div><div class=\"line\"><span class=\"keyword\">var</span> postAppHTML = layoutSections[<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 处理所有的Get请求</span></div><div class=\"line\">server.get(<span class=\"string\">'*'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 渲染我们的Vue实例作为流</span></div><div class=\"line\">  <span class=\"keyword\">var</span> stream = renderer.renderToStream(<span class=\"built_in\">require</span>(<span class=\"string\">'./assets/app'</span>)())</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 将预先的HTML写入响应</span></div><div class=\"line\">  response.write(preAppHTML)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 每当新的块被渲染</span></div><div class=\"line\">  stream.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">chunk</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将块写入响应</span></div><div class=\"line\">    response.write(chunk)</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 当所有的块被渲染完成</span></div><div class=\"line\">  stream.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将post-app HTML写入响应</span></div><div class=\"line\">    response.end(postAppHTML)</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 当渲染时发生错误</span></div><div class=\"line\">  stream.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 打印错误到控制台</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.error(error)</div><div class=\"line\">    <span class=\"comment\">// 告诉客服端发生了错误</span></div><div class=\"line\">    <span class=\"keyword\">return</span> response</div><div class=\"line\">      .status(<span class=\"number\">500</span>)</div><div class=\"line\">      .send(<span class=\"string\">'Server Error'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这不比之前的版本复杂，甚至这对你来说都不是个新概念。我们做了：</p>\n<ol>\n<li>建立流</li>\n<li>在应用响应前写入HTML</li>\n<li>在可获得时将应用HTML写入响应</li>\n<li>在响应最后写入HTML</li>\n<li>处理任何错误</li>\n</ol>\n<h2 id=\"组件缓存\"><a href=\"#组件缓存\" class=\"headerlink\" title=\"组件缓存\"></a>组件缓存</h2><p>Vue的服务端渲染默认非常快，但是你可以通过缓存渲染好的组件进一步提高性能。这被认为是一种先进的功能，但是，如果缓存了错误的组件（或者正确的组件带有错误的内容）将导致应用渲染出错。特别注意：</p>\n<p class=\"tip\">不应该缓存组件包含子组件依赖全局状态（例如来自vuex的状态）。如果这么做，子组件（事实上是整个子树）也会被缓存。所以要特别注意带有slots片段或者子组件的情况。</p>\n\n<h3 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h3><p>在警告情况之外的，我们可以用下面的方法缓存组件。</p>\n<p>首先，你需要提供给渲染器一个 <a href=\"https://www.npmjs.com/package/vue-server-renderer#cache\" target=\"_blank\" rel=\"external\">缓存对象</a>。这有个简单的示例使用 <a href=\"https://github.com/isaacs/node-lru-cache\" target=\"_blank\" rel=\"external\">lru-cache</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> createRenderer = <span class=\"built_in\">require</span>(<span class=\"string\">'vue-server-renderer'</span>).createRenderer</div><div class=\"line\"><span class=\"keyword\">var</span> lru = <span class=\"built_in\">require</span>(<span class=\"string\">'lru-cache'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> renderer = createRenderer(&#123;</div><div class=\"line\">  <span class=\"attr\">cache</span>: lru(<span class=\"number\">1000</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这将缓存高达1000个独立的渲染。对于更进一步缓存到内容中的配置，看<a href=\"https://github.com/isaacs/node-lru-cache#options\" target=\"_blank\" rel=\"external\">lru-cache设置</a></p>\n<p>然后对于你想缓存的组件，你可以为他们提供：</p>\n<ul>\n<li>一个唯一的<code>名字</code></li>\n<li>一个 <code>serverCacheKey</code>函数，返回一个唯一的组件作用域</li>\n</ul>\n<p>例如:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(&#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'list-item'</span>,</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'item'</span>],</div><div class=\"line\">  <span class=\"attr\">serverCacheKey</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> props.item.type + <span class=\"string\">'::'</span> + props.item.id</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"缓存的理想组件\"><a href=\"#缓存的理想组件\" class=\"headerlink\" title=\"缓存的理想组件\"></a>缓存的理想组件</h3><p>任何纯组件可以被安全缓存 -  这是保证给任何组件传递一样的数据产生相同的HTML。这些场景的例子包括：</p>\n<ul>\n<li>静态的组件 (例如 总是尝试一样的HTML,所以 <code>serverCacheKey</code> 函数可以被返回 <code>true</code>)</li>\n<li>列表组件（当有大量列表，缓存他们可以改善性能）</li>\n<li>通用UI组件 (例如 buttons, alerts, 等等 - 至少他们通过props获取数据而不是 slots或者子组件)</li>\n</ul>\n<h2 id=\"构建过程，路由，和Vuex状态管理\"><a href=\"#构建过程，路由，和Vuex状态管理\" class=\"headerlink\" title=\"构建过程，路由，和Vuex状态管理\"></a>构建过程，路由，和Vuex状态管理</h2><p>现在，应该理解服务端渲染背后的基本概念了。但是，构建过程、路由、Vuex每一个都有自己的注意事项。</p>\n<p>要真正掌握复杂应用下的服务端渲染，我们推荐深度熟悉以下资源：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/vue-server-renderer#api\" target=\"_blank\" rel=\"external\">vue-server-renderer 文档</a>:更多细节在这里，和更多先进的主题一起的文档。 例如 <a href=\"https://www.npmjs.com/package/vue-server-renderer#why-use-bundlerenderer\" target=\"_blank\" rel=\"external\">preventing cross-request contamination</a> 和 <a href=\"https://www.npmjs.com/package/vue-server-renderer#creating-the-server-bundle\" target=\"_blank\" rel=\"external\">添加独立的服务构建</a></li>\n<li><a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\" rel=\"external\">vue-hackernews-2.0</a>: 明确整合了  所有主要的Vue库和概念在单个应用中</li>\n</ul>\n<hr>\n<blockquote>\n<p>原文: <a href=\"http://vuejs.org/guide/ssr.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/ssr.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"需要服务端渲染（SSR）吗？\"><a href=\"#需要服务端渲染（SSR）吗？\" class=\"headerlink\" title=\"需要服务端渲染（SSR）吗？\"></a>需要服务端渲染（SSR）吗？</h2><p>在开始服务端渲染前，我们先看看它能给我们带来什么，以及什么时候需要用它。</p>\n<h3 id=\"SEO（搜索引擎优化）\"><a href=\"#SEO（搜索引擎优化）\" class=\"headerlink\" title=\"SEO（搜索引擎优化）\"></a>SEO（搜索引擎优化）</h3><p>谷歌和Bing可以很好地索引同步的JavaScript应用。<em>同步</em>在这里是个关键词。如果应用启动时有一个加载动画，然后内容通过ajax获取，那爬虫不会等待他们加载完成。</p>\n<p>这意味着在异步获取内容的页面上很需要进行搜索引擎优化的时候，服务端渲染就很重要。</p>\n<h3 id=\"客户端的网络比较慢\"><a href=\"#客户端的网络比较慢\" class=\"headerlink\" title=\"客户端的网络比较慢\"></a>客户端的网络比较慢</h3><p>用户可能在网络比较慢的情况下从远处访问网站 - 或者通过比较差的带宽。 这些情况下，尽量减少页面请求数量，来保证用户尽快看到基本的内容。</p>\n<p>可以用 <a href=\"https://webpack.github.io/docs/code-splitting.html\">Webpack的代码拆分</a> 避免强制用户下载整个单页面应用，但是，这样也远没有下载个单独的预先渲染过的HTML文件性能高。</p>\n<h3 id=\"客户端运行在老的-或者直接没有-JavaScript引擎上\"><a href=\"#客户端运行在老的-或者直接没有-JavaScript引擎上\" class=\"headerlink\" title=\"客户端运行在老的(或者直接没有)JavaScript引擎上\"></a>客户端运行在老的(或者直接没有)JavaScript引擎上</h3><p>对于世界上的一些地区人，可能只能用1998年产的电脑访问互联网的方式使用计算机。而Vue只能运行在IE9以上的浏览器，你可以也想为那些老式浏览器提供基础内容 - 或者是在命令行中使用 <a href=\"http://lynx.browser.org/\">Lynx</a>的时髦的黑客。</p>\n<h3 id=\"服务端渲染-对比-预渲染-Prerendering\"><a href=\"#服务端渲染-对比-预渲染-Prerendering\" class=\"headerlink\" title=\"服务端渲染 对比 预渲染(Prerendering)\"></a>服务端渲染 对比 预渲染(Prerendering)</h3><p>如果你只是用服务端渲染来改善一个少数的营销页面（如 首页，关于，联系 等等）的SEO，那你可以用<strong>预渲染</strong>替换。预渲染不像服务器渲染那样即时编译HTML,预渲染只是在构建时为了特定的路由生成特定的几个静态页面。其优势是预渲染的设置更加简单，可以保持前端是一个完整的静态站。</p>\n<p>你用webpack可以很简单地通过<a href=\"https://github.com/chrisvfritz/prerender-spa-plugin\">prerender-spa-plugin</a>来添加预渲染，它被广泛地用在Vue应用上 - 事实上，创建者也是Vue核心团队成员之一。</p>\n<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>准备在行动中体验服务端渲染吧。服务端渲染(即SSR)听起来很复杂，不过一个简单的Node脚本只需要3步就可以实现这个功能:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 步骤 1:创建一个Vue实例</span></div><div class=\"line\"><span class=\"keyword\">var</span> Vue = <span class=\"built_in\">require</span>(<span class=\"string\">'vue'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">h</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> h(<span class=\"string\">'p'</span>, <span class=\"string\">'hello world'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 步骤 2: 创建一个渲染器</span></div><div class=\"line\"><span class=\"keyword\">var</span> renderer = <span class=\"built_in\">require</span>(<span class=\"string\">'vue-server-renderer'</span>).createRenderer()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 步骤 3: 将 Vue实例 渲染成 HTML</span></div><div class=\"line\"></div><div class=\"line\">renderer.renderToString(app, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, html</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(html)</div><div class=\"line\">  <span class=\"comment\">// =&gt; &lt;p server-rendered=\"true\"&gt;hello world&lt;/p&gt;</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这并不困难。当然这个示例比大部分应用都简单。我们不必担心：</p>\n<ul>\n<li>一个Web服务器</li>\n<li>流式响应</li>\n<li>组件缓存</li>\n<li>构建过程</li>\n<li>路由</li>\n<li>Vuex状态管理</li>\n</ul>\n<p>这个指南的其余部分，我们将探讨这些功能怎样运作。一旦你理解了基础，我们会提供更多细节和进一步的示例来帮助你解决意外情况。</p>\n<h2 id=\"通过Express-Web服务器实现简单的服务端渲染\"><a href=\"#通过Express-Web服务器实现简单的服务端渲染\" class=\"headerlink\" title=\"通过Express Web服务器实现简单的服务端渲染\"></a>通过Express Web服务器实现简单的服务端渲染</h2><p>如果没有一个Web服务器，很难说是服务端渲染，所以我们来补充它。我们将构建一个非常简单的服务端渲染应用，只用ES5，也不带其他构建步骤或Vue插件。</p>\n<p>启动一个应用告诉用户他们在一个页面上花了多少时间。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;你已经在这花了 &#123;&#123; counter &#125;&#125; 秒。&lt;/div&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">counter</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">    setInterval(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      vm.counter += <span class=\"number\">1</span></div><div class=\"line\">    &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>为了适应服务端渲染，我们需要进行一些修改，让它可以在浏览器和Node中渲染：</p>\n<ul>\n<li>在浏览器中，将我们的应用实例添加到全局上下文（ <code>window</code>）上,我们可以安装它。</li>\n<li>在Node中，导出一个工厂函数让我们可以为每个请求创建应用实例。</li>\n</ul>\n<p>实现这个需要一点模板：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// assets/app.js</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"string\">'use strict'</span></div><div class=\"line\">  <span class=\"keyword\">var</span> createApp = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ---------------------</span></div><div class=\"line\">    <span class=\"comment\">// 开始常用的应用代码</span></div><div class=\"line\">    <span class=\"comment\">// ---------------------</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 主要的Vue实例必须返回，并且有一个根节点在id \"app\"上，这样客户端可以加载它。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div id=\"app\"&gt;你已经在这花了 &#123;&#123; counter &#125;&#125; 秒。&lt;/div&gt;'</span>,</div><div class=\"line\">      <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">counter</span>: <span class=\"number\">0</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">        setInterval(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          vm.counter += <span class=\"number\">1</span></div><div class=\"line\">        &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// -------------------</span></div><div class=\"line\">    <span class=\"comment\">// 结束常用的应用代码</span></div><div class=\"line\">    <span class=\"comment\">// -------------------</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">module</span>.exports) &#123;</div><div class=\"line\">    <span class=\"built_in\">module</span>.exports = createApp</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.app = createApp()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;).call(<span class=\"keyword\">this</span>)</div></pre></td></tr></table></figure>\n<p>现在有了应用代码，接着加一个 html文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>My Vue App<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/assets/vue.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/assets/app.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\">app.$mount(<span class=\"string\">'#app'</span>)</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>主要引用<code>assets</code>文件夹中我们先前创建的<code>app.js</code>，以及<code>vue.js</code>文件，我们就有了一个可以运行的单页面应用</p>\n<p>然后为了实现服务端渲染，在服务端需要加一个步骤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义全局的Vue为了服务端的app.js</span></div><div class=\"line\">global.Vue = <span class=\"built_in\">require</span>(<span class=\"string\">'vue'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取HTML布局</span></div><div class=\"line\"><span class=\"keyword\">var</span> layout = fs.readFileSync(<span class=\"string\">'./index.html'</span>, <span class=\"string\">'utf8'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建一个渲染器</span></div><div class=\"line\"><span class=\"keyword\">var</span> renderer = <span class=\"built_in\">require</span>(<span class=\"string\">'vue-server-renderer'</span>).createRenderer()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建一个Express服务器</span></div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> server = express()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 部署静态文件夹为 \"assets\"文件夹</span></div><div class=\"line\">server.use(<span class=\"string\">'/assets'</span>, express.static(</div><div class=\"line\">  path.resolve(__dirname, <span class=\"string\">'assets'</span>)</div><div class=\"line\">))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 处理所有的Get请求</span></div><div class=\"line\">server.get(<span class=\"string\">'*'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 渲染我们的Vue应用为一个字符串</span></div><div class=\"line\">  renderer.renderToString(</div><div class=\"line\">    <span class=\"comment\">// 创建一个应用实例</span></div><div class=\"line\">    <span class=\"built_in\">require</span>(<span class=\"string\">'./assets/app'</span>)(),</div><div class=\"line\">    <span class=\"comment\">// 处理渲染结果</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, html</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 如果渲染时发生了错误</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">        <span class=\"comment\">// 打印错误到控制台</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.error(error)</div><div class=\"line\">        <span class=\"comment\">// 告诉客户端错误</span></div><div class=\"line\">        <span class=\"keyword\">return</span> response</div><div class=\"line\">          .status(<span class=\"number\">500</span>)</div><div class=\"line\">          .send(<span class=\"string\">'Server Error'</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 发送布局和HTML文件</span></div><div class=\"line\">      response.send(layout.replace(<span class=\"string\">'&lt;div id=\"app\"&gt;&lt;/div&gt;'</span>, html))</div><div class=\"line\">    &#125;</div><div class=\"line\">  )</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 监听5000端口</span></div><div class=\"line\">server.listen(<span class=\"number\">5000</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server is running at localhost:5000'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样就完成了。<a href=\"https://github.com/chrisvfritz/vue-ssr-demo-simple\">整个示例</a>，克隆下来深度实验。一旦它在本地运行时，你可以通过在页面右击选择<code>页面资源</code>（或类似操作）确认服务选渲染真的运行了。可以在body中看到：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span> <span class=\"attr\">server-rendered</span>=<span class=\"string\">\"true\"</span>&gt;</span>You have been here for 0 seconds&amp;period;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>代替:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"流式响应\"><a href=\"#流式响应\" class=\"headerlink\" title=\"流式响应\"></a>流式响应</h2><p>Vue还支持<strong>流式</strong>渲染，优先选择适用于支持流的Web服务器。允许HTML一边生成一边写入相应流，而不是在最后一次全部写入。其结果是请求服务速度更快，没有缺点！</p>\n<p>为了使上一节应用代码适用流式渲染，可以简单的替换 <code>server.get(&#39;*&#39;,...)</code>为下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 拆分布局成两段HTML</span></div><div class=\"line\"><span class=\"keyword\">var</span> layoutSections = layout.split(<span class=\"string\">'&lt;div id=\"app\"&gt;&lt;/div&gt;'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> preAppHTML = layoutSections[<span class=\"number\">0</span>]</div><div class=\"line\"><span class=\"keyword\">var</span> postAppHTML = layoutSections[<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 处理所有的Get请求</span></div><div class=\"line\">server.get(<span class=\"string\">'*'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 渲染我们的Vue实例作为流</span></div><div class=\"line\">  <span class=\"keyword\">var</span> stream = renderer.renderToStream(<span class=\"built_in\">require</span>(<span class=\"string\">'./assets/app'</span>)())</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 将预先的HTML写入响应</span></div><div class=\"line\">  response.write(preAppHTML)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 每当新的块被渲染</span></div><div class=\"line\">  stream.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">chunk</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将块写入响应</span></div><div class=\"line\">    response.write(chunk)</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 当所有的块被渲染完成</span></div><div class=\"line\">  stream.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将post-app HTML写入响应</span></div><div class=\"line\">    response.end(postAppHTML)</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 当渲染时发生错误</span></div><div class=\"line\">  stream.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 打印错误到控制台</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.error(error)</div><div class=\"line\">    <span class=\"comment\">// 告诉客服端发生了错误</span></div><div class=\"line\">    <span class=\"keyword\">return</span> response</div><div class=\"line\">      .status(<span class=\"number\">500</span>)</div><div class=\"line\">      .send(<span class=\"string\">'Server Error'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这不比之前的版本复杂，甚至这对你来说都不是个新概念。我们做了：</p>\n<ol>\n<li>建立流</li>\n<li>在应用响应前写入HTML</li>\n<li>在可获得时将应用HTML写入响应</li>\n<li>在响应最后写入HTML</li>\n<li>处理任何错误</li>\n</ol>\n<h2 id=\"组件缓存\"><a href=\"#组件缓存\" class=\"headerlink\" title=\"组件缓存\"></a>组件缓存</h2><p>Vue的服务端渲染默认非常快，但是你可以通过缓存渲染好的组件进一步提高性能。这被认为是一种先进的功能，但是，如果缓存了错误的组件（或者正确的组件带有错误的内容）将导致应用渲染出错。特别注意：</p>\n<p class=\"tip\">不应该缓存组件包含子组件依赖全局状态（例如来自vuex的状态）。如果这么做，子组件（事实上是整个子树）也会被缓存。所以要特别注意带有slots片段或者子组件的情况。</p>\n\n<h3 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h3><p>在警告情况之外的，我们可以用下面的方法缓存组件。</p>\n<p>首先，你需要提供给渲染器一个 <a href=\"https://www.npmjs.com/package/vue-server-renderer#cache\">缓存对象</a>。这有个简单的示例使用 <a href=\"https://github.com/isaacs/node-lru-cache\">lru-cache</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> createRenderer = <span class=\"built_in\">require</span>(<span class=\"string\">'vue-server-renderer'</span>).createRenderer</div><div class=\"line\"><span class=\"keyword\">var</span> lru = <span class=\"built_in\">require</span>(<span class=\"string\">'lru-cache'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> renderer = createRenderer(&#123;</div><div class=\"line\">  <span class=\"attr\">cache</span>: lru(<span class=\"number\">1000</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这将缓存高达1000个独立的渲染。对于更进一步缓存到内容中的配置，看<a href=\"https://github.com/isaacs/node-lru-cache#options\">lru-cache设置</a></p>\n<p>然后对于你想缓存的组件，你可以为他们提供：</p>\n<ul>\n<li>一个唯一的<code>名字</code></li>\n<li>一个 <code>serverCacheKey</code>函数，返回一个唯一的组件作用域</li>\n</ul>\n<p>例如:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(&#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'list-item'</span>,</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'item'</span>],</div><div class=\"line\">  <span class=\"attr\">serverCacheKey</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> props.item.type + <span class=\"string\">'::'</span> + props.item.id</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"缓存的理想组件\"><a href=\"#缓存的理想组件\" class=\"headerlink\" title=\"缓存的理想组件\"></a>缓存的理想组件</h3><p>任何纯组件可以被安全缓存 -  这是保证给任何组件传递一样的数据产生相同的HTML。这些场景的例子包括：</p>\n<ul>\n<li>静态的组件 (例如 总是尝试一样的HTML,所以 <code>serverCacheKey</code> 函数可以被返回 <code>true</code>)</li>\n<li>列表组件（当有大量列表，缓存他们可以改善性能）</li>\n<li>通用UI组件 (例如 buttons, alerts, 等等 - 至少他们通过props获取数据而不是 slots或者子组件)</li>\n</ul>\n<h2 id=\"构建过程，路由，和Vuex状态管理\"><a href=\"#构建过程，路由，和Vuex状态管理\" class=\"headerlink\" title=\"构建过程，路由，和Vuex状态管理\"></a>构建过程，路由，和Vuex状态管理</h2><p>现在，应该理解服务端渲染背后的基本概念了。但是，构建过程、路由、Vuex每一个都有自己的注意事项。</p>\n<p>要真正掌握复杂应用下的服务端渲染，我们推荐深度熟悉以下资源：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/vue-server-renderer#api\">vue-server-renderer 文档</a>:更多细节在这里，和更多先进的主题一起的文档。 例如 <a href=\"https://www.npmjs.com/package/vue-server-renderer#why-use-bundlerenderer\">preventing cross-request contamination</a> 和 <a href=\"https://www.npmjs.com/package/vue-server-renderer#creating-the-server-bundle\">添加独立的服务构建</a></li>\n<li><a href=\"https://github.com/vuejs/vue-hackernews-2.0\">vue-hackernews-2.0</a>: 明确整合了  所有主要的Vue库和概念在单个应用中</li>\n</ul>\n<hr>\n<blockquote>\n<p>原文: <a href=\"http://vuejs.org/guide/ssr.html\">http://vuejs.org/guide/ssr.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"过渡状态","type":"guide","order":14,"_content":"\nVue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，比如：\n\n- 数字和运算\n- 颜色的显示\n- SVG 节点的位置\n- 元素的大小和其他的属性\n\n所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。\n\n\n## 状态动画 与 watcher\n\n通过 watcher 我们能监听到任何数值属性的数值更新。可能听起来很抽象，所以让我们先来看看使用Tweenjs一个例子：\n\n``` html\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n\n<div id=\"animated-number-demo\">\n  <input v-model.number=\"number\" type=\"number\" step=\"20\">\n  <p>{{ animatedNumber }}</p>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#animated-number-demo',\n  data: {\n    number: 0,\n    animatedNumber: 0\n  },\n  watch: {\n    number: function(newValue, oldValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningNumber: oldValue })\n        .easing(TWEEN.Easing.Quadratic.Out)\n        .to({ tweeningNumber: newValue }, 500)\n        .onUpdate(function () {\n          vm.animatedNumber = this.tweeningNumber.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\n```\n\n{% raw %}\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<div id=\"animated-number-demo\" class=\"demo\">\n  <input v-model.number=\"number\" type=\"number\" step=\"20\">\n  <p>{{ animatedNumber }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#animated-number-demo',\n  data: {\n    number: 0,\n    animatedNumber: 0\n  },\n  watch: {\n    number: function(newValue, oldValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningNumber: oldValue })\n        .easing(TWEEN.Easing.Quadratic.Out)\n        .to({ tweeningNumber: newValue }, 500)\n        .onUpdate(function () {\n          vm.animatedNumber = this.tweeningNumber.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\n</script>\n{% endraw %}\n\n当你把数值更新时，就会触发动画。这个是一个不错的演示，但是对于不能直接像数字一样存储的值，比如 CSS 中的 color 的值，通过下面的例子我们来通过 Color.js 实现一个例子：\n\n\n``` html\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<script src=\"https://unpkg.com/color-js@1.0.3/color.js\"></script>\n\n<div id=\"example-7\">\n  <input\n    v-model=\"colorQuery\"\n    v-on:keyup.enter=\"updateColor\"\n    placeholder=\"Enter a color\"\n  >\n  <button v-on:click=\"updateColor\">Update</button>\n  <p>Preview:</p>\n  <span\n    v-bind:style=\"{ backgroundColor: tweenedCSSColor }\"\n    class=\"example-7-color-preview\"\n  ></span>\n  <p>{{ tweenedCSSColor }}</p>\n</div>\n```\n\n``` js\nvar Color = net.brehaut.Color\n\nnew Vue({\n  el: '#example-7',\n  data: {\n    colorQuery: '',\n    color: {\n      red: 0,\n      green: 0,\n      blue: 0,\n      alpha: 1\n    },\n    tweenedColor: {}\n  },\n  created: function () {\n    this.tweenedColor = Object.assign({}, this.color)\n  },\n  watch: {\n    color: function () {\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween(this.tweenedColor)\n        .to(this.color, 750)\n        .start()\n      animate()\n    }\n  },\n  computed: {\n    tweenedCSSColor: function () {\n      return new Color({\n        red: this.tweenedColor.red,\n        green: this.tweenedColor.green,\n        blue: this.tweenedColor.blue,\n        alpha: this.tweenedColor.alpha\n      }).toCSS()\n    }\n  },\n  methods: {\n    updateColor: function () {\n      this.color = new Color(this.colorQuery).toRGB()\n      this.colorQuery = ''\n    }\n  }\n})\n```\n\n``` css\n.example-7-color-preview {\n  display: inline-block;\n  width: 50px;\n  height: 50px;\n}\n```\n\n{% raw %}\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<script src=\"https://unpkg.com/color-js@1.0.3/color.js\"></script>\n<div id=\"example-7\" class=\"demo\">\n  <input\n    v-model=\"colorQuery\"\n    v-on:keyup.enter=\"updateColor\"\n    placeholder=\"Enter a color\"\n  >\n  <button v-on:click=\"updateColor\">Update</button>\n  <p>Preview:</p>\n  <span\n    v-bind:style=\"{ backgroundColor: tweenedCSSColor }\"\n    class=\"example-7-color-preview\"\n  ></span>\n  <p>{{ tweenedCSSColor }}</p>\n</div>\n<script>\nvar Color = net.brehaut.Color\nnew Vue({\n  el: '#example-7',\n  data: {\n    colorQuery: '',\n    color: {\n      red: 0,\n      green: 0,\n      blue: 0,\n      alpha: 1\n    },\n    tweenedColor: {}\n  },\n  created: function () {\n    this.tweenedColor = Object.assign({}, this.color)\n  },\n  watch: {\n    color: function () {\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween(this.tweenedColor)\n        .to(this.color, 750)\n        .start()\n      animate()\n    }\n  },\n  computed: {\n    tweenedCSSColor: function () {\n      return new Color({\n        red: this.tweenedColor.red,\n        green: this.tweenedColor.green,\n        blue: this.tweenedColor.blue,\n        alpha: this.tweenedColor.alpha\n      }).toCSS()\n    }\n  },\n  methods: {\n    updateColor: function () {\n      this.color = new Color(this.colorQuery).toRGB()\n      this.colorQuery = ''\n    }\n  }\n})\n</script>\n<style>\n.example-7-color-preview {\n  display: inline-block;\n  width: 50px;\n  height: 50px;\n}\n</style>\n{% endraw %}\n\n## 动态状态转换\n\n就像 Vue 的过渡组件一样，数据背后状态转换会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可是实现很多难以想象的效果。\n\n\n{% raw %}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenLite.min.js\"></script>\n<div id=\"svg-polygon-demo\" class=\"demo\">\n  <svg width=\"200\" height=\"200\" class=\"demo-svg\">\n    <polygon :points=\"points\" class=\"demo-polygon\"></polygon>\n    <circle cx=\"100\" cy=\"100\" r=\"90\" class=\"demo-circle\"></circle>\n  </svg>\n  <label>Sides: {{ sides }}</label>\n  <input\n    class=\"demo-range-input\"\n    type=\"range\"\n    min=\"3\"\n    max=\"500\"\n    v-model.number=\"sides\"\n  >\n  <label>Minimum Radius: {{ minRadius }}%</label>\n  <input\n    class=\"demo-range-input\"\n    type=\"range\"\n    min=\"0\"\n    max=\"90\"\n    v-model.number=\"minRadius\"\n  >\n  <label>Update Interval: {{ updateInterval }} milliseconds</label>\n  <input\n    class=\"demo-range-input\"\n    type=\"range\"\n    min=\"10\"\n    max=\"2000\"\n    v-model.number=\"updateInterval\"\n  >\n</div>\n<script>\nnew Vue({\n  el: '#svg-polygon-demo',\n  data: function () {\n    var defaultSides = 10\n    var stats = Array.apply(null, { length: defaultSides })\n      .map(function () { return 100 })\n    return {\n      stats: stats,\n      points: generatePoints(stats),\n      sides: defaultSides,\n      minRadius: 50,\n      interval: null,\n      updateInterval: 500\n    }\n  },\n  watch: {\n    sides: function (newSides, oldSides) {\n      var sidesDifference = newSides - oldSides\n      if (sidesDifference > 0) {\n        for (var i = 1; i <= sidesDifference; i++) {\n          this.stats.push(this.newRandomValue())\n        }\n      } else {\n        var absoluteSidesDifference = Math.abs(sidesDifference)\n        for (var i = 1; i <= absoluteSidesDifference; i++) {\n          this.stats.shift()\n        }\n      }\n    },\n    stats: function (newStats) {\n      TweenLite.to(\n        this.$data,\n        this.updateInterval / 1000,\n        { points: generatePoints(newStats) }\n      )\n    },\n    updateInterval: function () {\n      this.resetInterval()\n    }\n  },\n  mounted: function () {\n    this.resetInterval()\n  },\n  methods: {\n    randomizeStats: function () {\n      var vm = this\n      this.stats = this.stats.map(function () {\n        return vm.newRandomValue()\n      })\n    },\n    newRandomValue: function () {\n      return Math.ceil(this.minRadius + Math.random() * (100 - this.minRadius))\n    },\n    resetInterval: function () {\n      var vm = this\n      clearInterval(this.interval)\n      this.randomizeStats()\n      this.interval = setInterval(function () {\n        vm.randomizeStats()\n      }, this.updateInterval)\n    }\n  }\n})\n\nfunction valueToPoint (value, index, total) {\n  var x     = 0\n  var y     = -value * 0.9\n  var angle = Math.PI * 2 / total * index\n  var cos   = Math.cos(angle)\n  var sin   = Math.sin(angle)\n  var tx    = x * cos - y * sin + 100\n  var ty    = x * sin + y * cos + 100\n  return { x: tx, y: ty }\n}\n\nfunction generatePoints (stats) {\n  var total = stats.length\n  return stats.map(function (stat, index) {\n    var point = valueToPoint(stat, index, total)\n    return point.x + ',' + point.y\n  }).join(' ')\n}\n</script>\n<style>\n.demo-svg { display: block; }\n.demo-polygon { fill: #41B883; }\n.demo-circle {\n  fill: transparent;\n  stroke: #35495E;\n}\n.demo-range-input {\n  display: block;\n  width: 100%;\n  margin-bottom: 15px;\n}\n</style>\n{% endraw %}\n\nSee [this fiddle](https://jsfiddle.net/chrisvfritz/65gLu2b6/) for the complete code behind the above demo.\n\n## 通过组件组织过渡\n\n管理太多的状态转换的很快会接近到 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。\n我们来将之前的示例改写一下：\n\n``` html\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n\n<div id=\"example-8\">\n  <input v-model.number=\"firstNumber\" type=\"number\" step=\"20\"> +\n  <input v-model.number=\"secondNumber\" type=\"number\" step=\"20\"> =\n  {{ result }}\n  <p>\n    <animated-integer v-bind:value=\"firstNumber\"></animated-integer> +\n    <animated-integer v-bind:value=\"secondNumber\"></animated-integer> =\n    <animated-integer v-bind:value=\"result\"></animated-integer>\n  </p>\n</div>\n```\n\n``` js\n// 这种复杂的补间动画逻辑可以被复用\n// 任何整数都可以执行动画\n// 组件化使我们的界面十分清晰\n// 可以支持更多更复杂的动态过渡\n// strategies.\nVue.component('animated-integer', {\n  template: '<span>{{ tweeningValue }}</span>',\n  props: {\n    value: {\n      type: Number,\n      required: true\n    }\n  },\n  data: function () {\n    return {\n      tweeningValue: 0\n    }\n  },\n  watch: {\n    value: function (newValue, oldValue) {\n      this.tween(oldValue, newValue)\n    }\n  },\n  mounted: function () {\n    this.tween(0, this.value)\n  },\n  methods: {\n    tween: function (startValue, endValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningValue: startValue })\n        .to({ tweeningValue: endValue }, 500)\n        .onUpdate(function () {\n          vm.tweeningValue = this.tweeningValue.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\n\n// All complexity has now been removed from the main Vue instance!\nnew Vue({\n  el: '#example-8',\n  data: {\n    firstNumber: 20,\n    secondNumber: 40\n  },\n  computed: {\n    result: function () {\n      return this.firstNumber + this.secondNumber\n    }\n  }\n})\n```\n\n{% raw %}\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<div id=\"example-8\" class=\"demo\">\n  <input v-model.number=\"firstNumber\" type=\"number\" step=\"20\"> +\n  <input v-model.number=\"secondNumber\" type=\"number\" step=\"20\"> =\n  {{ result }}\n  <p>\n    <animated-integer v-bind:value=\"firstNumber\"></animated-integer> +\n    <animated-integer v-bind:value=\"secondNumber\"></animated-integer> =\n    <animated-integer v-bind:value=\"result\"></animated-integer>\n  </p>\n</div>\n<script>\nVue.component('animated-integer', {\n  template: '<span>{{ tweeningValue }}</span>',\n  props: {\n    value: {\n      type: Number,\n      required: true\n    }\n  },\n  data: function () {\n    return {\n      tweeningValue: 0\n    }\n  },\n  watch: {\n    value: function (newValue, oldValue) {\n      this.tween(oldValue, newValue)\n    }\n  },\n  mounted: function () {\n    this.tween(0, this.value)\n  },\n  methods: {\n    tween: function (startValue, endValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningValue: startValue })\n        .to({ tweeningValue: endValue }, 500)\n        .onUpdate(function () {\n          vm.tweeningValue = this.tweeningValue.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\nnew Vue({\n  el: '#example-8',\n  data: {\n    firstNumber: 20,\n    secondNumber: 40\n  },\n  computed: {\n    result: function () {\n      return this.firstNumber + this.secondNumber\n    }\n  }\n})\n</script>\n{% endraw %}\n\n我们能在组件中结合使用这一节讲到各种过渡策略和 Vue [内建的过渡系统](transitions.html)。总之，对于完成各种过渡动效几乎没有阻碍。\n\n***\n\n> 原文： http://vuejs.org/guide/transitioning-state.html\n\n***\n\n","source":"v2/guide/transitioning-state.md","raw":"---\ntitle: 过渡状态\ntype: guide\norder: 14\n---\n\nVue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，比如：\n\n- 数字和运算\n- 颜色的显示\n- SVG 节点的位置\n- 元素的大小和其他的属性\n\n所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。\n\n\n## 状态动画 与 watcher\n\n通过 watcher 我们能监听到任何数值属性的数值更新。可能听起来很抽象，所以让我们先来看看使用Tweenjs一个例子：\n\n``` html\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n\n<div id=\"animated-number-demo\">\n  <input v-model.number=\"number\" type=\"number\" step=\"20\">\n  <p>{{ animatedNumber }}</p>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#animated-number-demo',\n  data: {\n    number: 0,\n    animatedNumber: 0\n  },\n  watch: {\n    number: function(newValue, oldValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningNumber: oldValue })\n        .easing(TWEEN.Easing.Quadratic.Out)\n        .to({ tweeningNumber: newValue }, 500)\n        .onUpdate(function () {\n          vm.animatedNumber = this.tweeningNumber.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\n```\n\n{% raw %}\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<div id=\"animated-number-demo\" class=\"demo\">\n  <input v-model.number=\"number\" type=\"number\" step=\"20\">\n  <p>{{ animatedNumber }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#animated-number-demo',\n  data: {\n    number: 0,\n    animatedNumber: 0\n  },\n  watch: {\n    number: function(newValue, oldValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningNumber: oldValue })\n        .easing(TWEEN.Easing.Quadratic.Out)\n        .to({ tweeningNumber: newValue }, 500)\n        .onUpdate(function () {\n          vm.animatedNumber = this.tweeningNumber.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\n</script>\n{% endraw %}\n\n当你把数值更新时，就会触发动画。这个是一个不错的演示，但是对于不能直接像数字一样存储的值，比如 CSS 中的 color 的值，通过下面的例子我们来通过 Color.js 实现一个例子：\n\n\n``` html\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<script src=\"https://unpkg.com/color-js@1.0.3/color.js\"></script>\n\n<div id=\"example-7\">\n  <input\n    v-model=\"colorQuery\"\n    v-on:keyup.enter=\"updateColor\"\n    placeholder=\"Enter a color\"\n  >\n  <button v-on:click=\"updateColor\">Update</button>\n  <p>Preview:</p>\n  <span\n    v-bind:style=\"{ backgroundColor: tweenedCSSColor }\"\n    class=\"example-7-color-preview\"\n  ></span>\n  <p>{{ tweenedCSSColor }}</p>\n</div>\n```\n\n``` js\nvar Color = net.brehaut.Color\n\nnew Vue({\n  el: '#example-7',\n  data: {\n    colorQuery: '',\n    color: {\n      red: 0,\n      green: 0,\n      blue: 0,\n      alpha: 1\n    },\n    tweenedColor: {}\n  },\n  created: function () {\n    this.tweenedColor = Object.assign({}, this.color)\n  },\n  watch: {\n    color: function () {\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween(this.tweenedColor)\n        .to(this.color, 750)\n        .start()\n      animate()\n    }\n  },\n  computed: {\n    tweenedCSSColor: function () {\n      return new Color({\n        red: this.tweenedColor.red,\n        green: this.tweenedColor.green,\n        blue: this.tweenedColor.blue,\n        alpha: this.tweenedColor.alpha\n      }).toCSS()\n    }\n  },\n  methods: {\n    updateColor: function () {\n      this.color = new Color(this.colorQuery).toRGB()\n      this.colorQuery = ''\n    }\n  }\n})\n```\n\n``` css\n.example-7-color-preview {\n  display: inline-block;\n  width: 50px;\n  height: 50px;\n}\n```\n\n{% raw %}\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<script src=\"https://unpkg.com/color-js@1.0.3/color.js\"></script>\n<div id=\"example-7\" class=\"demo\">\n  <input\n    v-model=\"colorQuery\"\n    v-on:keyup.enter=\"updateColor\"\n    placeholder=\"Enter a color\"\n  >\n  <button v-on:click=\"updateColor\">Update</button>\n  <p>Preview:</p>\n  <span\n    v-bind:style=\"{ backgroundColor: tweenedCSSColor }\"\n    class=\"example-7-color-preview\"\n  ></span>\n  <p>{{ tweenedCSSColor }}</p>\n</div>\n<script>\nvar Color = net.brehaut.Color\nnew Vue({\n  el: '#example-7',\n  data: {\n    colorQuery: '',\n    color: {\n      red: 0,\n      green: 0,\n      blue: 0,\n      alpha: 1\n    },\n    tweenedColor: {}\n  },\n  created: function () {\n    this.tweenedColor = Object.assign({}, this.color)\n  },\n  watch: {\n    color: function () {\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween(this.tweenedColor)\n        .to(this.color, 750)\n        .start()\n      animate()\n    }\n  },\n  computed: {\n    tweenedCSSColor: function () {\n      return new Color({\n        red: this.tweenedColor.red,\n        green: this.tweenedColor.green,\n        blue: this.tweenedColor.blue,\n        alpha: this.tweenedColor.alpha\n      }).toCSS()\n    }\n  },\n  methods: {\n    updateColor: function () {\n      this.color = new Color(this.colorQuery).toRGB()\n      this.colorQuery = ''\n    }\n  }\n})\n</script>\n<style>\n.example-7-color-preview {\n  display: inline-block;\n  width: 50px;\n  height: 50px;\n}\n</style>\n{% endraw %}\n\n## 动态状态转换\n\n就像 Vue 的过渡组件一样，数据背后状态转换会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可是实现很多难以想象的效果。\n\n\n{% raw %}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenLite.min.js\"></script>\n<div id=\"svg-polygon-demo\" class=\"demo\">\n  <svg width=\"200\" height=\"200\" class=\"demo-svg\">\n    <polygon :points=\"points\" class=\"demo-polygon\"></polygon>\n    <circle cx=\"100\" cy=\"100\" r=\"90\" class=\"demo-circle\"></circle>\n  </svg>\n  <label>Sides: {{ sides }}</label>\n  <input\n    class=\"demo-range-input\"\n    type=\"range\"\n    min=\"3\"\n    max=\"500\"\n    v-model.number=\"sides\"\n  >\n  <label>Minimum Radius: {{ minRadius }}%</label>\n  <input\n    class=\"demo-range-input\"\n    type=\"range\"\n    min=\"0\"\n    max=\"90\"\n    v-model.number=\"minRadius\"\n  >\n  <label>Update Interval: {{ updateInterval }} milliseconds</label>\n  <input\n    class=\"demo-range-input\"\n    type=\"range\"\n    min=\"10\"\n    max=\"2000\"\n    v-model.number=\"updateInterval\"\n  >\n</div>\n<script>\nnew Vue({\n  el: '#svg-polygon-demo',\n  data: function () {\n    var defaultSides = 10\n    var stats = Array.apply(null, { length: defaultSides })\n      .map(function () { return 100 })\n    return {\n      stats: stats,\n      points: generatePoints(stats),\n      sides: defaultSides,\n      minRadius: 50,\n      interval: null,\n      updateInterval: 500\n    }\n  },\n  watch: {\n    sides: function (newSides, oldSides) {\n      var sidesDifference = newSides - oldSides\n      if (sidesDifference > 0) {\n        for (var i = 1; i <= sidesDifference; i++) {\n          this.stats.push(this.newRandomValue())\n        }\n      } else {\n        var absoluteSidesDifference = Math.abs(sidesDifference)\n        for (var i = 1; i <= absoluteSidesDifference; i++) {\n          this.stats.shift()\n        }\n      }\n    },\n    stats: function (newStats) {\n      TweenLite.to(\n        this.$data,\n        this.updateInterval / 1000,\n        { points: generatePoints(newStats) }\n      )\n    },\n    updateInterval: function () {\n      this.resetInterval()\n    }\n  },\n  mounted: function () {\n    this.resetInterval()\n  },\n  methods: {\n    randomizeStats: function () {\n      var vm = this\n      this.stats = this.stats.map(function () {\n        return vm.newRandomValue()\n      })\n    },\n    newRandomValue: function () {\n      return Math.ceil(this.minRadius + Math.random() * (100 - this.minRadius))\n    },\n    resetInterval: function () {\n      var vm = this\n      clearInterval(this.interval)\n      this.randomizeStats()\n      this.interval = setInterval(function () {\n        vm.randomizeStats()\n      }, this.updateInterval)\n    }\n  }\n})\n\nfunction valueToPoint (value, index, total) {\n  var x     = 0\n  var y     = -value * 0.9\n  var angle = Math.PI * 2 / total * index\n  var cos   = Math.cos(angle)\n  var sin   = Math.sin(angle)\n  var tx    = x * cos - y * sin + 100\n  var ty    = x * sin + y * cos + 100\n  return { x: tx, y: ty }\n}\n\nfunction generatePoints (stats) {\n  var total = stats.length\n  return stats.map(function (stat, index) {\n    var point = valueToPoint(stat, index, total)\n    return point.x + ',' + point.y\n  }).join(' ')\n}\n</script>\n<style>\n.demo-svg { display: block; }\n.demo-polygon { fill: #41B883; }\n.demo-circle {\n  fill: transparent;\n  stroke: #35495E;\n}\n.demo-range-input {\n  display: block;\n  width: 100%;\n  margin-bottom: 15px;\n}\n</style>\n{% endraw %}\n\nSee [this fiddle](https://jsfiddle.net/chrisvfritz/65gLu2b6/) for the complete code behind the above demo.\n\n## 通过组件组织过渡\n\n管理太多的状态转换的很快会接近到 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。\n我们来将之前的示例改写一下：\n\n``` html\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n\n<div id=\"example-8\">\n  <input v-model.number=\"firstNumber\" type=\"number\" step=\"20\"> +\n  <input v-model.number=\"secondNumber\" type=\"number\" step=\"20\"> =\n  {{ result }}\n  <p>\n    <animated-integer v-bind:value=\"firstNumber\"></animated-integer> +\n    <animated-integer v-bind:value=\"secondNumber\"></animated-integer> =\n    <animated-integer v-bind:value=\"result\"></animated-integer>\n  </p>\n</div>\n```\n\n``` js\n// 这种复杂的补间动画逻辑可以被复用\n// 任何整数都可以执行动画\n// 组件化使我们的界面十分清晰\n// 可以支持更多更复杂的动态过渡\n// strategies.\nVue.component('animated-integer', {\n  template: '<span>{{ tweeningValue }}</span>',\n  props: {\n    value: {\n      type: Number,\n      required: true\n    }\n  },\n  data: function () {\n    return {\n      tweeningValue: 0\n    }\n  },\n  watch: {\n    value: function (newValue, oldValue) {\n      this.tween(oldValue, newValue)\n    }\n  },\n  mounted: function () {\n    this.tween(0, this.value)\n  },\n  methods: {\n    tween: function (startValue, endValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningValue: startValue })\n        .to({ tweeningValue: endValue }, 500)\n        .onUpdate(function () {\n          vm.tweeningValue = this.tweeningValue.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\n\n// All complexity has now been removed from the main Vue instance!\nnew Vue({\n  el: '#example-8',\n  data: {\n    firstNumber: 20,\n    secondNumber: 40\n  },\n  computed: {\n    result: function () {\n      return this.firstNumber + this.secondNumber\n    }\n  }\n})\n```\n\n{% raw %}\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<div id=\"example-8\" class=\"demo\">\n  <input v-model.number=\"firstNumber\" type=\"number\" step=\"20\"> +\n  <input v-model.number=\"secondNumber\" type=\"number\" step=\"20\"> =\n  {{ result }}\n  <p>\n    <animated-integer v-bind:value=\"firstNumber\"></animated-integer> +\n    <animated-integer v-bind:value=\"secondNumber\"></animated-integer> =\n    <animated-integer v-bind:value=\"result\"></animated-integer>\n  </p>\n</div>\n<script>\nVue.component('animated-integer', {\n  template: '<span>{{ tweeningValue }}</span>',\n  props: {\n    value: {\n      type: Number,\n      required: true\n    }\n  },\n  data: function () {\n    return {\n      tweeningValue: 0\n    }\n  },\n  watch: {\n    value: function (newValue, oldValue) {\n      this.tween(oldValue, newValue)\n    }\n  },\n  mounted: function () {\n    this.tween(0, this.value)\n  },\n  methods: {\n    tween: function (startValue, endValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningValue: startValue })\n        .to({ tweeningValue: endValue }, 500)\n        .onUpdate(function () {\n          vm.tweeningValue = this.tweeningValue.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\nnew Vue({\n  el: '#example-8',\n  data: {\n    firstNumber: 20,\n    secondNumber: 40\n  },\n  computed: {\n    result: function () {\n      return this.firstNumber + this.secondNumber\n    }\n  }\n})\n</script>\n{% endraw %}\n\n我们能在组件中结合使用这一节讲到各种过渡策略和 Vue [内建的过渡系统](transitions.html)。总之，对于完成各种过渡动效几乎没有阻碍。\n\n***\n\n> 原文： http://vuejs.org/guide/transitioning-state.html\n\n***\n\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/transitioning-state.html","comments":1,"layout":"page","_id":"ciwnajuz0001tjl2dtaeqb1ml","content":"<p>Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，比如：</p>\n<ul>\n<li>数字和运算</li>\n<li>颜色的显示</li>\n<li>SVG 节点的位置</li>\n<li>元素的大小和其他的属性</li>\n</ul>\n<p>所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。</p>\n<h2 id=\"状态动画-与-watcher\"><a href=\"#状态动画-与-watcher\" class=\"headerlink\" title=\"状态动画 与 watcher\"></a>状态动画 与 watcher</h2><p>通过 watcher 我们能监听到任何数值属性的数值更新。可能听起来很抽象，所以让我们先来看看使用Tweenjs一个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/tween.js@16.3.4\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"animated-number-demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">step</span>=<span class=\"string\">\"20\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; animatedNumber &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#animated-number-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</div><div class=\"line\">    <span class=\"attr\">animatedNumber</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">number</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue, oldValue</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animate</span> (<span class=\"params\">time</span>) </span>&#123;</div><div class=\"line\">        requestAnimationFrame(animate)</div><div class=\"line\">        TWEEN.update(time)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">new</span> TWEEN.Tween(&#123; <span class=\"attr\">tweeningNumber</span>: oldValue &#125;)</div><div class=\"line\">        .easing(TWEEN.Easing.Quadratic.Out)</div><div class=\"line\">        .to(&#123; <span class=\"attr\">tweeningNumber</span>: newValue &#125;, <span class=\"number\">500</span>)</div><div class=\"line\">        .onUpdate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          vm.animatedNumber = <span class=\"keyword\">this</span>.tweeningNumber.toFixed(<span class=\"number\">0</span>)</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .start()</div><div class=\"line\">      animate()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<div id=\"animated-number-demo\" class=\"demo\">\n  <input v-model.number=\"number\" type=\"number\" step=\"20\">\n  <p>{{ animatedNumber }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#animated-number-demo',\n  data: {\n    number: 0,\n    animatedNumber: 0\n  },\n  watch: {\n    number: function(newValue, oldValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningNumber: oldValue })\n        .easing(TWEEN.Easing.Quadratic.Out)\n        .to({ tweeningNumber: newValue }, 500)\n        .onUpdate(function () {\n          vm.animatedNumber = this.tweeningNumber.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\n</script>\n\n<p>当你把数值更新时，就会触发动画。这个是一个不错的演示，但是对于不能直接像数字一样存储的值，比如 CSS 中的 color 的值，通过下面的例子我们来通过 Color.js 实现一个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/tween.js@16.3.4\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/color-js@1.0.3/color.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-7\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span></span></div><div class=\"line\">    <span class=\"attr\">v-model</span>=<span class=\"string\">\"colorQuery\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:keyup.enter</span>=<span class=\"string\">\"updateColor\"</span></div><div class=\"line\">    <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span></div><div class=\"line\">  &gt;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"updateColor\"</span>&gt;</span>Update<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Preview:<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span></span></div><div class=\"line\">    <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"&#123; backgroundColor: tweenedCSSColor &#125;\"</span></div><div class=\"line\">    <span class=\"attr\">class</span>=<span class=\"string\">\"example-7-color-preview\"</span></div><div class=\"line\">  &gt;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; tweenedCSSColor &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Color = net.brehaut.Color</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-7'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">colorQuery</span>: <span class=\"string\">''</span>,</div><div class=\"line\">    <span class=\"attr\">color</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">red</span>: <span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"attr\">green</span>: <span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"attr\">blue</span>: <span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"attr\">alpha</span>: <span class=\"number\">1</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">tweenedColor</span>: &#123;&#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.tweenedColor = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, <span class=\"keyword\">this</span>.color)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animate</span> (<span class=\"params\">time</span>) </span>&#123;</div><div class=\"line\">        requestAnimationFrame(animate)</div><div class=\"line\">        TWEEN.update(time)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">new</span> TWEEN.Tween(<span class=\"keyword\">this</span>.tweenedColor)</div><div class=\"line\">        .to(<span class=\"keyword\">this</span>.color, <span class=\"number\">750</span>)</div><div class=\"line\">        .start()</div><div class=\"line\">      animate()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">tweenedCSSColor</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Color(&#123;</div><div class=\"line\">        <span class=\"attr\">red</span>: <span class=\"keyword\">this</span>.tweenedColor.red,</div><div class=\"line\">        <span class=\"attr\">green</span>: <span class=\"keyword\">this</span>.tweenedColor.green,</div><div class=\"line\">        <span class=\"attr\">blue</span>: <span class=\"keyword\">this</span>.tweenedColor.blue,</div><div class=\"line\">        <span class=\"attr\">alpha</span>: <span class=\"keyword\">this</span>.tweenedColor.alpha</div><div class=\"line\">      &#125;).toCSS()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">updateColor</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.color = <span class=\"keyword\">new</span> Color(<span class=\"keyword\">this</span>.colorQuery).toRGB()</div><div class=\"line\">      <span class=\"keyword\">this</span>.colorQuery = <span class=\"string\">''</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.example-7-color-preview</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<script src=\"https://unpkg.com/color-js@1.0.3/color.js\"></script>\n<div id=\"example-7\" class=\"demo\">\n  <input v-model=\"colorQuery\" v-on:keyup.enter=\"updateColor\" placeholder=\"Enter a color\">\n  <button v-on:click=\"updateColor\">Update</button>\n  <p>Preview:</p>\n  <span v-bind:style=\"{ backgroundColor: tweenedCSSColor }\" class=\"example-7-color-preview\"></span>\n  <p>{{ tweenedCSSColor }}</p>\n</div>\n<script>\nvar Color = net.brehaut.Color\nnew Vue({\n  el: '#example-7',\n  data: {\n    colorQuery: '',\n    color: {\n      red: 0,\n      green: 0,\n      blue: 0,\n      alpha: 1\n    },\n    tweenedColor: {}\n  },\n  created: function () {\n    this.tweenedColor = Object.assign({}, this.color)\n  },\n  watch: {\n    color: function () {\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween(this.tweenedColor)\n        .to(this.color, 750)\n        .start()\n      animate()\n    }\n  },\n  computed: {\n    tweenedCSSColor: function () {\n      return new Color({\n        red: this.tweenedColor.red,\n        green: this.tweenedColor.green,\n        blue: this.tweenedColor.blue,\n        alpha: this.tweenedColor.alpha\n      }).toCSS()\n    }\n  },\n  methods: {\n    updateColor: function () {\n      this.color = new Color(this.colorQuery).toRGB()\n      this.colorQuery = ''\n    }\n  }\n})\n</script>\n<style>\n.example-7-color-preview {\n  display: inline-block;\n  width: 50px;\n  height: 50px;\n}\n</style>\n\n<h2 id=\"动态状态转换\"><a href=\"#动态状态转换\" class=\"headerlink\" title=\"动态状态转换\"></a>动态状态转换</h2><p>就像 Vue 的过渡组件一样，数据背后状态转换会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可是实现很多难以想象的效果。</p>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenLite.min.js\"></script>\n<div id=\"svg-polygon-demo\" class=\"demo\">\n  <svg width=\"200\" height=\"200\" class=\"demo-svg\">\n    <polygon :points=\"points\" class=\"demo-polygon\"/>\n    <circle cx=\"100\" cy=\"100\" r=\"90\" class=\"demo-circle\"/>\n  </svg>\n  <label>Sides: {{ sides }}</label>\n  <input class=\"demo-range-input\" type=\"range\" min=\"3\" max=\"500\" v-model.number=\"sides\">\n  <label>Minimum Radius: {{ minRadius }}%</label>\n  <input class=\"demo-range-input\" type=\"range\" min=\"0\" max=\"90\" v-model.number=\"minRadius\">\n  <label>Update Interval: {{ updateInterval }} milliseconds</label>\n  <input class=\"demo-range-input\" type=\"range\" min=\"10\" max=\"2000\" v-model.number=\"updateInterval\">\n</div>\n<script>\nnew Vue({\n  el: '#svg-polygon-demo',\n  data: function () {\n    var defaultSides = 10\n    var stats = Array.apply(null, { length: defaultSides })\n      .map(function () { return 100 })\n    return {\n      stats: stats,\n      points: generatePoints(stats),\n      sides: defaultSides,\n      minRadius: 50,\n      interval: null,\n      updateInterval: 500\n    }\n  },\n  watch: {\n    sides: function (newSides, oldSides) {\n      var sidesDifference = newSides - oldSides\n      if (sidesDifference > 0) {\n        for (var i = 1; i <= sidesDifference; i++) {\n          this.stats.push(this.newRandomValue())\n        }\n      } else {\n        var absoluteSidesDifference = Math.abs(sidesDifference)\n        for (var i = 1; i <= absoluteSidesDifference; i++) {\n          this.stats.shift()\n        }\n      }\n    },\n    stats: function (newStats) {\n      TweenLite.to(\n        this.$data,\n        this.updateInterval / 1000,\n        { points: generatePoints(newStats) }\n      )\n    },\n    updateInterval: function () {\n      this.resetInterval()\n    }\n  },\n  mounted: function () {\n    this.resetInterval()\n  },\n  methods: {\n    randomizeStats: function () {\n      var vm = this\n      this.stats = this.stats.map(function () {\n        return vm.newRandomValue()\n      })\n    },\n    newRandomValue: function () {\n      return Math.ceil(this.minRadius + Math.random() * (100 - this.minRadius))\n    },\n    resetInterval: function () {\n      var vm = this\n      clearInterval(this.interval)\n      this.randomizeStats()\n      this.interval = setInterval(function () {\n        vm.randomizeStats()\n      }, this.updateInterval)\n    }\n  }\n})\n\nfunction valueToPoint (value, index, total) {\n  var x     = 0\n  var y     = -value * 0.9\n  var angle = Math.PI * 2 / total * index\n  var cos   = Math.cos(angle)\n  var sin   = Math.sin(angle)\n  var tx    = x * cos - y * sin + 100\n  var ty    = x * sin + y * cos + 100\n  return { x: tx, y: ty }\n}\n\nfunction generatePoints (stats) {\n  var total = stats.length\n  return stats.map(function (stat, index) {\n    var point = valueToPoint(stat, index, total)\n    return point.x + ',' + point.y\n  }).join(' ')\n}\n</script>\n<style>\n.demo-svg { display: block; }\n.demo-polygon { fill: #41B883; }\n.demo-circle {\n  fill: transparent;\n  stroke: #35495E;\n}\n.demo-range-input {\n  display: block;\n  width: 100%;\n  margin-bottom: 15px;\n}\n</style>\n\n<p>See <a href=\"https://jsfiddle.net/chrisvfritz/65gLu2b6/\" target=\"_blank\" rel=\"external\">this fiddle</a> for the complete code behind the above demo.</p>\n<h2 id=\"通过组件组织过渡\"><a href=\"#通过组件组织过渡\" class=\"headerlink\" title=\"通过组件组织过渡\"></a>通过组件组织过渡</h2><p>管理太多的状态转换的很快会接近到 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。<br>我们来将之前的示例改写一下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/tween.js@16.3.4\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-8\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"firstNumber\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">step</span>=<span class=\"string\">\"20\"</span>&gt;</span> +</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"secondNumber\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">step</span>=<span class=\"string\">\"20\"</span>&gt;</span> =</div><div class=\"line\">  &#123;&#123; result &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">animated-integer</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"firstNumber\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">animated-integer</span>&gt;</span> +</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">animated-integer</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"secondNumber\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">animated-integer</span>&gt;</span> =</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">animated-integer</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"result\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">animated-integer</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这种复杂的补间动画逻辑可以被复用</span></div><div class=\"line\"><span class=\"comment\">// 任何整数都可以执行动画</span></div><div class=\"line\"><span class=\"comment\">// 组件化使我们的界面十分清晰</span></div><div class=\"line\"><span class=\"comment\">// 可以支持更多更复杂的动态过渡</span></div><div class=\"line\"><span class=\"comment\">// strategies.</span></div><div class=\"line\">Vue.component(<span class=\"string\">'animated-integer'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">value</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">tweeningValue</span>: <span class=\"number\">0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">value</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newValue, oldValue</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.tween(oldValue, newValue)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">mounted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.tween(<span class=\"number\">0</span>, <span class=\"keyword\">this</span>.value)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">tween</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">startValue, endValue</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animate</span> (<span class=\"params\">time</span>) </span>&#123;</div><div class=\"line\">        requestAnimationFrame(animate)</div><div class=\"line\">        TWEEN.update(time)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">new</span> TWEEN.Tween(&#123; <span class=\"attr\">tweeningValue</span>: startValue &#125;)</div><div class=\"line\">        .to(&#123; <span class=\"attr\">tweeningValue</span>: endValue &#125;, <span class=\"number\">500</span>)</div><div class=\"line\">        .onUpdate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          vm.tweeningValue = <span class=\"keyword\">this</span>.tweeningValue.toFixed(<span class=\"number\">0</span>)</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .start()</div><div class=\"line\">      animate()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// All complexity has now been removed from the main Vue instance!</span></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-8'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">firstNumber</span>: <span class=\"number\">20</span>,</div><div class=\"line\">    <span class=\"attr\">secondNumber</span>: <span class=\"number\">40</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">result</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstNumber + <span class=\"keyword\">this</span>.secondNumber</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<div id=\"example-8\" class=\"demo\">\n  <input v-model.number=\"firstNumber\" type=\"number\" step=\"20\"> +\n  <input v-model.number=\"secondNumber\" type=\"number\" step=\"20\"> =\n  {{ result }}\n  <p>\n    <animated-integer v-bind:value=\"firstNumber\"></animated-integer> +\n    <animated-integer v-bind:value=\"secondNumber\"></animated-integer> =\n    <animated-integer v-bind:value=\"result\"></animated-integer>\n  </p>\n</div>\n<script>\nVue.component('animated-integer', {\n  template: '<span>{{ tweeningValue }}</span>',\n  props: {\n    value: {\n      type: Number,\n      required: true\n    }\n  },\n  data: function () {\n    return {\n      tweeningValue: 0\n    }\n  },\n  watch: {\n    value: function (newValue, oldValue) {\n      this.tween(oldValue, newValue)\n    }\n  },\n  mounted: function () {\n    this.tween(0, this.value)\n  },\n  methods: {\n    tween: function (startValue, endValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningValue: startValue })\n        .to({ tweeningValue: endValue }, 500)\n        .onUpdate(function () {\n          vm.tweeningValue = this.tweeningValue.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\nnew Vue({\n  el: '#example-8',\n  data: {\n    firstNumber: 20,\n    secondNumber: 40\n  },\n  computed: {\n    result: function () {\n      return this.firstNumber + this.secondNumber\n    }\n  }\n})\n</script>\n\n<p>我们能在组件中结合使用这一节讲到各种过渡策略和 Vue <a href=\"transitions.html\">内建的过渡系统</a>。总之，对于完成各种过渡动效几乎没有阻碍。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/transitioning-state.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/transitioning-state.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<p>Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，比如：</p>\n<ul>\n<li>数字和运算</li>\n<li>颜色的显示</li>\n<li>SVG 节点的位置</li>\n<li>元素的大小和其他的属性</li>\n</ul>\n<p>所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。</p>\n<h2 id=\"状态动画-与-watcher\"><a href=\"#状态动画-与-watcher\" class=\"headerlink\" title=\"状态动画 与 watcher\"></a>状态动画 与 watcher</h2><p>通过 watcher 我们能监听到任何数值属性的数值更新。可能听起来很抽象，所以让我们先来看看使用Tweenjs一个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/tween.js@16.3.4\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"animated-number-demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">step</span>=<span class=\"string\">\"20\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; animatedNumber &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#animated-number-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</div><div class=\"line\">    <span class=\"attr\">animatedNumber</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">number</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue, oldValue</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animate</span> (<span class=\"params\">time</span>) </span>&#123;</div><div class=\"line\">        requestAnimationFrame(animate)</div><div class=\"line\">        TWEEN.update(time)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">new</span> TWEEN.Tween(&#123; <span class=\"attr\">tweeningNumber</span>: oldValue &#125;)</div><div class=\"line\">        .easing(TWEEN.Easing.Quadratic.Out)</div><div class=\"line\">        .to(&#123; <span class=\"attr\">tweeningNumber</span>: newValue &#125;, <span class=\"number\">500</span>)</div><div class=\"line\">        .onUpdate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          vm.animatedNumber = <span class=\"keyword\">this</span>.tweeningNumber.toFixed(<span class=\"number\">0</span>)</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .start()</div><div class=\"line\">      animate()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<div id=\"animated-number-demo\" class=\"demo\">\n  <input v-model.number=\"number\" type=\"number\" step=\"20\">\n  <p>{{ animatedNumber }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#animated-number-demo',\n  data: {\n    number: 0,\n    animatedNumber: 0\n  },\n  watch: {\n    number: function(newValue, oldValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningNumber: oldValue })\n        .easing(TWEEN.Easing.Quadratic.Out)\n        .to({ tweeningNumber: newValue }, 500)\n        .onUpdate(function () {\n          vm.animatedNumber = this.tweeningNumber.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\n</script>\n\n<p>当你把数值更新时，就会触发动画。这个是一个不错的演示，但是对于不能直接像数字一样存储的值，比如 CSS 中的 color 的值，通过下面的例子我们来通过 Color.js 实现一个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/tween.js@16.3.4\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/color-js@1.0.3/color.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-7\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span></div><div class=\"line\">    <span class=\"attr\">v-model</span>=<span class=\"string\">\"colorQuery\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:keyup.enter</span>=<span class=\"string\">\"updateColor\"</span></div><div class=\"line\">    <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span></div><div class=\"line\">  &gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"updateColor\"</span>&gt;</span>Update<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Preview:<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span></div><div class=\"line\">    <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"&#123; backgroundColor: tweenedCSSColor &#125;\"</span></div><div class=\"line\">    <span class=\"attr\">class</span>=<span class=\"string\">\"example-7-color-preview\"</span></div><div class=\"line\">  &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; tweenedCSSColor &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Color = net.brehaut.Color</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-7'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">colorQuery</span>: <span class=\"string\">''</span>,</div><div class=\"line\">    <span class=\"attr\">color</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">red</span>: <span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"attr\">green</span>: <span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"attr\">blue</span>: <span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"attr\">alpha</span>: <span class=\"number\">1</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">tweenedColor</span>: &#123;&#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.tweenedColor = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, <span class=\"keyword\">this</span>.color)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animate</span> (<span class=\"params\">time</span>) </span>&#123;</div><div class=\"line\">        requestAnimationFrame(animate)</div><div class=\"line\">        TWEEN.update(time)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">new</span> TWEEN.Tween(<span class=\"keyword\">this</span>.tweenedColor)</div><div class=\"line\">        .to(<span class=\"keyword\">this</span>.color, <span class=\"number\">750</span>)</div><div class=\"line\">        .start()</div><div class=\"line\">      animate()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">tweenedCSSColor</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Color(&#123;</div><div class=\"line\">        <span class=\"attr\">red</span>: <span class=\"keyword\">this</span>.tweenedColor.red,</div><div class=\"line\">        <span class=\"attr\">green</span>: <span class=\"keyword\">this</span>.tweenedColor.green,</div><div class=\"line\">        <span class=\"attr\">blue</span>: <span class=\"keyword\">this</span>.tweenedColor.blue,</div><div class=\"line\">        <span class=\"attr\">alpha</span>: <span class=\"keyword\">this</span>.tweenedColor.alpha</div><div class=\"line\">      &#125;).toCSS()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">updateColor</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.color = <span class=\"keyword\">new</span> Color(<span class=\"keyword\">this</span>.colorQuery).toRGB()</div><div class=\"line\">      <span class=\"keyword\">this</span>.colorQuery = <span class=\"string\">''</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.example-7-color-preview</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<script src=\"https://unpkg.com/color-js@1.0.3/color.js\"></script>\n<div id=\"example-7\" class=\"demo\">\n  <input\n    v-model=\"colorQuery\"\n    v-on:keyup.enter=\"updateColor\"\n    placeholder=\"Enter a color\"\n  >\n  <button v-on:click=\"updateColor\">Update</button>\n  <p>Preview:</p>\n  <span\n    v-bind:style=\"{ backgroundColor: tweenedCSSColor }\"\n    class=\"example-7-color-preview\"\n  ></span>\n  <p>{{ tweenedCSSColor }}</p>\n</div>\n<script>\nvar Color = net.brehaut.Color\nnew Vue({\n  el: '#example-7',\n  data: {\n    colorQuery: '',\n    color: {\n      red: 0,\n      green: 0,\n      blue: 0,\n      alpha: 1\n    },\n    tweenedColor: {}\n  },\n  created: function () {\n    this.tweenedColor = Object.assign({}, this.color)\n  },\n  watch: {\n    color: function () {\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween(this.tweenedColor)\n        .to(this.color, 750)\n        .start()\n      animate()\n    }\n  },\n  computed: {\n    tweenedCSSColor: function () {\n      return new Color({\n        red: this.tweenedColor.red,\n        green: this.tweenedColor.green,\n        blue: this.tweenedColor.blue,\n        alpha: this.tweenedColor.alpha\n      }).toCSS()\n    }\n  },\n  methods: {\n    updateColor: function () {\n      this.color = new Color(this.colorQuery).toRGB()\n      this.colorQuery = ''\n    }\n  }\n})\n</script>\n<style>\n.example-7-color-preview {\n  display: inline-block;\n  width: 50px;\n  height: 50px;\n}\n</style>\n\n<h2 id=\"动态状态转换\"><a href=\"#动态状态转换\" class=\"headerlink\" title=\"动态状态转换\"></a>动态状态转换</h2><p>就像 Vue 的过渡组件一样，数据背后状态转换会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可是实现很多难以想象的效果。</p>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenLite.min.js\"></script>\n<div id=\"svg-polygon-demo\" class=\"demo\">\n  <svg width=\"200\" height=\"200\" class=\"demo-svg\">\n    <polygon :points=\"points\" class=\"demo-polygon\"></polygon>\n    <circle cx=\"100\" cy=\"100\" r=\"90\" class=\"demo-circle\"></circle>\n  </svg>\n  <label>Sides: {{ sides }}</label>\n  <input\n    class=\"demo-range-input\"\n    type=\"range\"\n    min=\"3\"\n    max=\"500\"\n    v-model.number=\"sides\"\n  >\n  <label>Minimum Radius: {{ minRadius }}%</label>\n  <input\n    class=\"demo-range-input\"\n    type=\"range\"\n    min=\"0\"\n    max=\"90\"\n    v-model.number=\"minRadius\"\n  >\n  <label>Update Interval: {{ updateInterval }} milliseconds</label>\n  <input\n    class=\"demo-range-input\"\n    type=\"range\"\n    min=\"10\"\n    max=\"2000\"\n    v-model.number=\"updateInterval\"\n  >\n</div>\n<script>\nnew Vue({\n  el: '#svg-polygon-demo',\n  data: function () {\n    var defaultSides = 10\n    var stats = Array.apply(null, { length: defaultSides })\n      .map(function () { return 100 })\n    return {\n      stats: stats,\n      points: generatePoints(stats),\n      sides: defaultSides,\n      minRadius: 50,\n      interval: null,\n      updateInterval: 500\n    }\n  },\n  watch: {\n    sides: function (newSides, oldSides) {\n      var sidesDifference = newSides - oldSides\n      if (sidesDifference > 0) {\n        for (var i = 1; i <= sidesDifference; i++) {\n          this.stats.push(this.newRandomValue())\n        }\n      } else {\n        var absoluteSidesDifference = Math.abs(sidesDifference)\n        for (var i = 1; i <= absoluteSidesDifference; i++) {\n          this.stats.shift()\n        }\n      }\n    },\n    stats: function (newStats) {\n      TweenLite.to(\n        this.$data,\n        this.updateInterval / 1000,\n        { points: generatePoints(newStats) }\n      )\n    },\n    updateInterval: function () {\n      this.resetInterval()\n    }\n  },\n  mounted: function () {\n    this.resetInterval()\n  },\n  methods: {\n    randomizeStats: function () {\n      var vm = this\n      this.stats = this.stats.map(function () {\n        return vm.newRandomValue()\n      })\n    },\n    newRandomValue: function () {\n      return Math.ceil(this.minRadius + Math.random() * (100 - this.minRadius))\n    },\n    resetInterval: function () {\n      var vm = this\n      clearInterval(this.interval)\n      this.randomizeStats()\n      this.interval = setInterval(function () {\n        vm.randomizeStats()\n      }, this.updateInterval)\n    }\n  }\n})\n\nfunction valueToPoint (value, index, total) {\n  var x     = 0\n  var y     = -value * 0.9\n  var angle = Math.PI * 2 / total * index\n  var cos   = Math.cos(angle)\n  var sin   = Math.sin(angle)\n  var tx    = x * cos - y * sin + 100\n  var ty    = x * sin + y * cos + 100\n  return { x: tx, y: ty }\n}\n\nfunction generatePoints (stats) {\n  var total = stats.length\n  return stats.map(function (stat, index) {\n    var point = valueToPoint(stat, index, total)\n    return point.x + ',' + point.y\n  }).join(' ')\n}\n</script>\n<style>\n.demo-svg { display: block; }\n.demo-polygon { fill: #41B883; }\n.demo-circle {\n  fill: transparent;\n  stroke: #35495E;\n}\n.demo-range-input {\n  display: block;\n  width: 100%;\n  margin-bottom: 15px;\n}\n</style>\n\n<p>See <a href=\"https://jsfiddle.net/chrisvfritz/65gLu2b6/\">this fiddle</a> for the complete code behind the above demo.</p>\n<h2 id=\"通过组件组织过渡\"><a href=\"#通过组件组织过渡\" class=\"headerlink\" title=\"通过组件组织过渡\"></a>通过组件组织过渡</h2><p>管理太多的状态转换的很快会接近到 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。<br>我们来将之前的示例改写一下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/tween.js@16.3.4\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-8\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"firstNumber\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">step</span>=<span class=\"string\">\"20\"</span>&gt;</span> +</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"secondNumber\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">step</span>=<span class=\"string\">\"20\"</span>&gt;</span> =</div><div class=\"line\">  &#123;&#123; result &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">animated-integer</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"firstNumber\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">animated-integer</span>&gt;</span> +</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">animated-integer</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"secondNumber\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">animated-integer</span>&gt;</span> =</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">animated-integer</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"result\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">animated-integer</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这种复杂的补间动画逻辑可以被复用</span></div><div class=\"line\"><span class=\"comment\">// 任何整数都可以执行动画</span></div><div class=\"line\"><span class=\"comment\">// 组件化使我们的界面十分清晰</span></div><div class=\"line\"><span class=\"comment\">// 可以支持更多更复杂的动态过渡</span></div><div class=\"line\"><span class=\"comment\">// strategies.</span></div><div class=\"line\">Vue.component(<span class=\"string\">'animated-integer'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">value</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">tweeningValue</span>: <span class=\"number\">0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">value</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newValue, oldValue</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.tween(oldValue, newValue)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">mounted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.tween(<span class=\"number\">0</span>, <span class=\"keyword\">this</span>.value)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">tween</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">startValue, endValue</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animate</span> (<span class=\"params\">time</span>) </span>&#123;</div><div class=\"line\">        requestAnimationFrame(animate)</div><div class=\"line\">        TWEEN.update(time)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">new</span> TWEEN.Tween(&#123; <span class=\"attr\">tweeningValue</span>: startValue &#125;)</div><div class=\"line\">        .to(&#123; <span class=\"attr\">tweeningValue</span>: endValue &#125;, <span class=\"number\">500</span>)</div><div class=\"line\">        .onUpdate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          vm.tweeningValue = <span class=\"keyword\">this</span>.tweeningValue.toFixed(<span class=\"number\">0</span>)</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .start()</div><div class=\"line\">      animate()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// All complexity has now been removed from the main Vue instance!</span></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-8'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">firstNumber</span>: <span class=\"number\">20</span>,</div><div class=\"line\">    <span class=\"attr\">secondNumber</span>: <span class=\"number\">40</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">result</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstNumber + <span class=\"keyword\">this</span>.secondNumber</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<script src=\"https://unpkg.com/tween.js@16.3.4\"></script>\n<div id=\"example-8\" class=\"demo\">\n  <input v-model.number=\"firstNumber\" type=\"number\" step=\"20\"> +\n  <input v-model.number=\"secondNumber\" type=\"number\" step=\"20\"> =\n  {{ result }}\n  <p>\n    <animated-integer v-bind:value=\"firstNumber\"></animated-integer> +\n    <animated-integer v-bind:value=\"secondNumber\"></animated-integer> =\n    <animated-integer v-bind:value=\"result\"></animated-integer>\n  </p>\n</div>\n<script>\nVue.component('animated-integer', {\n  template: '<span>{{ tweeningValue }}</span>',\n  props: {\n    value: {\n      type: Number,\n      required: true\n    }\n  },\n  data: function () {\n    return {\n      tweeningValue: 0\n    }\n  },\n  watch: {\n    value: function (newValue, oldValue) {\n      this.tween(oldValue, newValue)\n    }\n  },\n  mounted: function () {\n    this.tween(0, this.value)\n  },\n  methods: {\n    tween: function (startValue, endValue) {\n      var vm = this\n      function animate (time) {\n        requestAnimationFrame(animate)\n        TWEEN.update(time)\n      }\n      new TWEEN.Tween({ tweeningValue: startValue })\n        .to({ tweeningValue: endValue }, 500)\n        .onUpdate(function () {\n          vm.tweeningValue = this.tweeningValue.toFixed(0)\n        })\n        .start()\n      animate()\n    }\n  }\n})\nnew Vue({\n  el: '#example-8',\n  data: {\n    firstNumber: 20,\n    secondNumber: 40\n  },\n  computed: {\n    result: function () {\n      return this.firstNumber + this.secondNumber\n    }\n  }\n})\n</script>\n\n<p>我们能在组件中结合使用这一节讲到各种过渡策略和 Vue <a href=\"transitions.html\">内建的过渡系统</a>。总之，对于完成各种过渡动效几乎没有阻碍。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/transitioning-state.html\">http://vuejs.org/guide/transitioning-state.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"模板语法","type":"guide","order":4,"_content":"\nVue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。\n\n在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。\n\n如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，[直接写渲染（render）函数](render-function.html)，使用可选的 JSX 语法。\n\n## 插值\n\n### 文本\n\n数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：\n\n``` html\n<span>Message: {{ msg }}</span>\n```\n\nMustache 标签将会被替代为对应数据对象上 `msg` 属性的值。无论何时，绑定的数据对象上 `msg` 属性发生了改变，插值处的内容都会更新。\n\n通过使用 [v-once 指令](../api/#v-once)，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定：\n\n``` html\n<span v-once>This will never change: {{ msg }}</span>\n```\n\n### 纯 HTML\n\n双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 `v-html` 指令：\n\n``` html\n<div v-html=\"rawHtml\"></div>\n```\n\n被插入的内容都会被当做 HTML —— 数据绑定会被忽略。注意，你不能使用 `v-html` 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。组件更适合担任 UI 重用与复合的基本单元。\n\n<p class=\"tip\">你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容插值。</p>\n\n### 属性\n\nMustache 不能在 HTML 属性中使用，应使用 [v-bind 指令](../api/#v-bind)：\n\n``` html\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除： \n\n``` html\n<button v-bind:disabled=\"someDynamicCondition\">Button</button>\n```\n\n### 使用 JavaScript 表达式\n\n迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持。\n\n``` html\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div v-bind:id=\"'list-' + id\"></div>\n```\n\n这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。\n\n``` html\n<!-- 这是语句，不是表达式 -->\n{{ var a = 1 }}\n\n<!-- 流控制也不会生效，请使用三元表达式 -->\n{{ if (ok) { return message } }}\n```\n\n<p class=\"tip\">模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 `Math` 和 `Date` 。你不应该在模板表达式中试图访问用户定义的全局变量。</p>\n\n\n## 指令\n\n指令（Directives）是带有 `v-` 前缀的特殊属性。指令属性的值预期是**单一 JavaScript 表达式**（除了 `v-for`，之后再讨论）。指令的职责就是当其表达式的值改变时相应地将某些行为应用到 DOM 上。让我们回顾一下在介绍里的例子：\n\n``` html\n<p v-if=\"seen\">Now you see me</p>\n```\n\n这里， `v-if` 指令将根据表达式 `seen` 的值的真假来移除/插入 `<p>` 元素。\n\n### 参数\n\n一些指令能接受一个“参数”，在指令后以冒号指明。例如， `v-bind` 指令被用来响应地更新 HTML 属性：\n\n``` html\n<a v-bind:href=\"url\"></a>\n```\n\n在这里 `href` 是参数，告知 `v-bind` 指令将该元素的 `href` 属性与表达式 `url` 的值绑定。\n\n另一个例子是 `v-on` 指令，它用于监听 DOM 事件：\n\n``` html\n<a v-on:click=\"doSomething\">\n```\n\n在这里参数是监听的事件名。我们也会更详细地讨论事件处理。\n\n### 修饰符\n\n修饰符（Modifiers）是以半角句号 `.` 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：\n\n``` html\n<form v-on:submit.prevent=\"onSubmit\"></form>\n```\n\n之后当我们更深入地了解 `v-on` 与 `v-model`时，会看到更多修饰符的使用。\n\n## Filters\n\nVue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: **mustache interpolations and `v-bind` expressions**. Filters should be appended to the end of the JavaScript expression, denoted by the \"pipe\" symbol:\n\n### 过滤器\n\nVue.js 允许你自定义过滤器，被用作一些常见的文本格式化。过滤器应该被添加在 **mustache 插值**的尾部，由“管道符”指示：\n\n``` html\n{{ message | capitalize }}\n```\n\n\n``` html\n<!-- in mustaches -->\n{{ message | capitalize }}\n\n<!-- in v-bind -->\n<div v-bind:id=\"rawId | formatId\"></div>\n```\n\n<p class=\"tip\">Vue 2.x 中，过滤器只能在 mustache 绑定和 `v-bind` 表达式（从 2.1.0 开始支持）中使用，因为过滤器设计目的就是用于文本转换。为了在其他指令中实现更复杂的数据变换，你应该使用[计算属性](computed.html)。</p>\n\n过滤器函数总接受表达式的值作为第一个参数。\n\n\n``` js\nnew Vue({\n  // ...\n  filters: {\n    capitalize: function (value) {\n      if (!value) return ''\n      value = value.toString()\n      return value.charAt(0).toUpperCase() + value.slice(1)\n    }\n  }\n})\n```\n\n过滤器可以串联：\n\n``` html\n{{ message | filterA | filterB }}\n```\n\n过滤器是 JavaScript 函数，因此可以接受参数：\n\n``` html\n{{ message | filterA('arg1', arg2) }}\n```\n\n\n这里，字符串 `'arg1'` 将传给过滤器作为第二个参数， `arg2` 表达式的值将被求值然后传给过滤器作为第三个参数。\n\n## 缩写\n\n`v-` 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识。当你使用 Vue.js 为现有的标记添加动态行为时，它会很有用，但对于一些经常使用的指令来说有点繁琐。同时，当搭建 Vue.js 管理所有模板的 [SPA](https://en.wikipedia.org/wiki/Single-page_application) 时，`v-` 前缀也变得没那么重要了。因此，Vue.js 为两个最为常用的指令提供了特别的缩写：\n\n### `v-bind` 缩写\n\n``` html\n<!-- 完整语法 -->\n<a v-bind:href=\"url\"></a>\n\n<!-- 缩写 -->\n<a :href=\"url\"></a>\n```\n\n### `v-on` 缩写\n\n``` html\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\"></a>\n\n<!-- 缩写 -->\n<a @click=\"doSomething\"></a>\n```\n\n它们看起来可能与普通的 HTML 略有不同，但 `:` 与 `@` 对于属性名来说都是合法字符，在所有支持 Vue.js 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。\n\n***\n\n> 原文： http://vuejs.org/guide/syntax.html\n\n***\n","source":"v2/guide/syntax.md","raw":"---\ntitle: 模板语法\ntype: guide\norder: 4\n---\n\nVue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。\n\n在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。\n\n如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，[直接写渲染（render）函数](render-function.html)，使用可选的 JSX 语法。\n\n## 插值\n\n### 文本\n\n数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：\n\n``` html\n<span>Message: {{ msg }}</span>\n```\n\nMustache 标签将会被替代为对应数据对象上 `msg` 属性的值。无论何时，绑定的数据对象上 `msg` 属性发生了改变，插值处的内容都会更新。\n\n通过使用 [v-once 指令](../api/#v-once)，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定：\n\n``` html\n<span v-once>This will never change: {{ msg }}</span>\n```\n\n### 纯 HTML\n\n双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 `v-html` 指令：\n\n``` html\n<div v-html=\"rawHtml\"></div>\n```\n\n被插入的内容都会被当做 HTML —— 数据绑定会被忽略。注意，你不能使用 `v-html` 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。组件更适合担任 UI 重用与复合的基本单元。\n\n<p class=\"tip\">你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容插值。</p>\n\n### 属性\n\nMustache 不能在 HTML 属性中使用，应使用 [v-bind 指令](../api/#v-bind)：\n\n``` html\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除： \n\n``` html\n<button v-bind:disabled=\"someDynamicCondition\">Button</button>\n```\n\n### 使用 JavaScript 表达式\n\n迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持。\n\n``` html\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div v-bind:id=\"'list-' + id\"></div>\n```\n\n这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。\n\n``` html\n<!-- 这是语句，不是表达式 -->\n{{ var a = 1 }}\n\n<!-- 流控制也不会生效，请使用三元表达式 -->\n{{ if (ok) { return message } }}\n```\n\n<p class=\"tip\">模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 `Math` 和 `Date` 。你不应该在模板表达式中试图访问用户定义的全局变量。</p>\n\n\n## 指令\n\n指令（Directives）是带有 `v-` 前缀的特殊属性。指令属性的值预期是**单一 JavaScript 表达式**（除了 `v-for`，之后再讨论）。指令的职责就是当其表达式的值改变时相应地将某些行为应用到 DOM 上。让我们回顾一下在介绍里的例子：\n\n``` html\n<p v-if=\"seen\">Now you see me</p>\n```\n\n这里， `v-if` 指令将根据表达式 `seen` 的值的真假来移除/插入 `<p>` 元素。\n\n### 参数\n\n一些指令能接受一个“参数”，在指令后以冒号指明。例如， `v-bind` 指令被用来响应地更新 HTML 属性：\n\n``` html\n<a v-bind:href=\"url\"></a>\n```\n\n在这里 `href` 是参数，告知 `v-bind` 指令将该元素的 `href` 属性与表达式 `url` 的值绑定。\n\n另一个例子是 `v-on` 指令，它用于监听 DOM 事件：\n\n``` html\n<a v-on:click=\"doSomething\">\n```\n\n在这里参数是监听的事件名。我们也会更详细地讨论事件处理。\n\n### 修饰符\n\n修饰符（Modifiers）是以半角句号 `.` 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：\n\n``` html\n<form v-on:submit.prevent=\"onSubmit\"></form>\n```\n\n之后当我们更深入地了解 `v-on` 与 `v-model`时，会看到更多修饰符的使用。\n\n## Filters\n\nVue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: **mustache interpolations and `v-bind` expressions**. Filters should be appended to the end of the JavaScript expression, denoted by the \"pipe\" symbol:\n\n### 过滤器\n\nVue.js 允许你自定义过滤器，被用作一些常见的文本格式化。过滤器应该被添加在 **mustache 插值**的尾部，由“管道符”指示：\n\n``` html\n{{ message | capitalize }}\n```\n\n\n``` html\n<!-- in mustaches -->\n{{ message | capitalize }}\n\n<!-- in v-bind -->\n<div v-bind:id=\"rawId | formatId\"></div>\n```\n\n<p class=\"tip\">Vue 2.x 中，过滤器只能在 mustache 绑定和 `v-bind` 表达式（从 2.1.0 开始支持）中使用，因为过滤器设计目的就是用于文本转换。为了在其他指令中实现更复杂的数据变换，你应该使用[计算属性](computed.html)。</p>\n\n过滤器函数总接受表达式的值作为第一个参数。\n\n\n``` js\nnew Vue({\n  // ...\n  filters: {\n    capitalize: function (value) {\n      if (!value) return ''\n      value = value.toString()\n      return value.charAt(0).toUpperCase() + value.slice(1)\n    }\n  }\n})\n```\n\n过滤器可以串联：\n\n``` html\n{{ message | filterA | filterB }}\n```\n\n过滤器是 JavaScript 函数，因此可以接受参数：\n\n``` html\n{{ message | filterA('arg1', arg2) }}\n```\n\n\n这里，字符串 `'arg1'` 将传给过滤器作为第二个参数， `arg2` 表达式的值将被求值然后传给过滤器作为第三个参数。\n\n## 缩写\n\n`v-` 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识。当你使用 Vue.js 为现有的标记添加动态行为时，它会很有用，但对于一些经常使用的指令来说有点繁琐。同时，当搭建 Vue.js 管理所有模板的 [SPA](https://en.wikipedia.org/wiki/Single-page_application) 时，`v-` 前缀也变得没那么重要了。因此，Vue.js 为两个最为常用的指令提供了特别的缩写：\n\n### `v-bind` 缩写\n\n``` html\n<!-- 完整语法 -->\n<a v-bind:href=\"url\"></a>\n\n<!-- 缩写 -->\n<a :href=\"url\"></a>\n```\n\n### `v-on` 缩写\n\n``` html\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\"></a>\n\n<!-- 缩写 -->\n<a @click=\"doSomething\"></a>\n```\n\n它们看起来可能与普通的 HTML 略有不同，但 `:` 与 `@` 对于属性名来说都是合法字符，在所有支持 Vue.js 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。\n\n***\n\n> 原文： http://vuejs.org/guide/syntax.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/syntax.html","comments":1,"layout":"page","_id":"ciwnajuz5001ujl2ddkcyeebx","content":"<p>Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</p>\n<p>在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。</p>\n<p>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，<a href=\"render-function.html\">直接写渲染（render）函数</a>，使用可选的 JSX 语法。</p>\n<h2 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h2><h3 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h3><p>数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Mustache 标签将会被替代为对应数据对象上 <code>msg</code> 属性的值。无论何时，绑定的数据对象上 <code>msg</code> 属性发生了改变，插值处的内容都会更新。</p>\n<p>通过使用 <a href=\"../api/#v-once\">v-once 指令</a>，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-once</span>&gt;</span>This will never change: &#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"纯-HTML\"><a href=\"#纯-HTML\" class=\"headerlink\" title=\"纯 HTML\"></a>纯 HTML</h3><p>双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 <code>v-html</code> 指令：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"rawHtml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>被插入的内容都会被当做 HTML —— 数据绑定会被忽略。注意，你不能使用 <code>v-html</code> 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。组件更适合担任 UI 重用与复合的基本单元。</p>\n<p class=\"tip\">你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"external\">XSS 攻击</a>。请只对可信内容使用 HTML 插值，<strong>绝不要</strong>对用户提供的内容插值。</p>\n\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>Mustache 不能在 HTML 属性中使用，应使用 <a href=\"../api/#v-bind\">v-bind 指令</a>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"dynamicId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:disabled</span>=<span class=\"string\">\"someDynamicCondition\"</span>&gt;</span>Button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"使用-JavaScript-表达式\"><a href=\"#使用-JavaScript-表达式\" class=\"headerlink\" title=\"使用 JavaScript 表达式\"></a>使用 JavaScript 表达式</h3><p>迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&#123; number + 1 &#125;&#125;</div><div class=\"line\"></div><div class=\"line\">&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;</div><div class=\"line\"></div><div class=\"line\">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"'list-' + id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都<strong>不会</strong>生效。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 这是语句，不是表达式 --&gt;</span></div><div class=\"line\">&#123;&#123; var a = 1 &#125;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></div><div class=\"line\">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</div></pre></td></tr></table></figure>\n<p class=\"tip\">模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 <code>Math</code> 和 <code>Date</code> 。你不应该在模板表达式中试图访问用户定义的全局变量。</p>\n\n\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><p>指令（Directives）是带有 <code>v-</code> 前缀的特殊属性。指令属性的值预期是<strong>单一 JavaScript 表达式</strong>（除了 <code>v-for</code>，之后再讨论）。指令的职责就是当其表达式的值改变时相应地将某些行为应用到 DOM 上。让我们回顾一下在介绍里的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"seen\"</span>&gt;</span>Now you see me<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这里， <code>v-if</code> 指令将根据表达式 <code>seen</code> 的值的真假来移除/插入 <code>&lt;p&gt;</code> 元素。</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>一些指令能接受一个“参数”，在指令后以冒号指明。例如， <code>v-bind</code> 指令被用来响应地更新 HTML 属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-bind:href</span>=<span class=\"string\">\"url\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> 属性与表达式 <code>url</code> 的值绑定。</p>\n<p>另一个例子是 <code>v-on</code> 指令，它用于监听 DOM 事件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在这里参数是监听的事件名。我们也会更详细地讨论事件处理。</p>\n<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><p>修饰符（Modifiers）是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>之后当我们更深入地了解 <code>v-on</code> 与 <code>v-model</code>时，会看到更多修饰符的使用。</p>\n<h2 id=\"Filters\"><a href=\"#Filters\" class=\"headerlink\" title=\"Filters\"></a>Filters</h2><p>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: <strong>mustache interpolations and <code>v-bind</code> expressions</strong>. Filters should be appended to the end of the JavaScript expression, denoted by the “pipe” symbol:</p>\n<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。过滤器应该被添加在 <strong>mustache 插值</strong>的尾部，由“管道符”指示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&#123; message | capitalize &#125;&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- in mustaches --&gt;</span></div><div class=\"line\">&#123;&#123; message | capitalize &#125;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- in v-bind --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"rawId | formatId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">Vue 2.x 中，过滤器只能在 mustache 绑定和 <code>v-bind</code> 表达式（从 2.1.0 开始支持）中使用，因为过滤器设计目的就是用于文本转换。为了在其他指令中实现更复杂的数据变换，你应该使用<a href=\"computed.html\">计算属性</a>。</p>\n\n<p>过滤器函数总接受表达式的值作为第一个参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  filters: &#123;</div><div class=\"line\">    <span class=\"attr\">capitalize</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!value) <span class=\"keyword\">return</span> <span class=\"string\">''</span></div><div class=\"line\">      value = value.toString()</div><div class=\"line\">      <span class=\"keyword\">return</span> value.charAt(<span class=\"number\">0</span>).toUpperCase() + value.slice(<span class=\"number\">1</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>过滤器可以串联：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&#123; message | filterA | filterB &#125;&#125;</div></pre></td></tr></table></figure>\n<p>过滤器是 JavaScript 函数，因此可以接受参数：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</div></pre></td></tr></table></figure>\n<p>这里，字符串 <code>&#39;arg1&#39;</code> 将传给过滤器作为第二个参数， <code>arg2</code> 表达式的值将被求值然后传给过滤器作为第三个参数。</p>\n<h2 id=\"缩写\"><a href=\"#缩写\" class=\"headerlink\" title=\"缩写\"></a>缩写</h2><p><code>v-</code> 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识。当你使用 Vue.js 为现有的标记添加动态行为时，它会很有用，但对于一些经常使用的指令来说有点繁琐。同时，当搭建 Vue.js 管理所有模板的 <a href=\"https://en.wikipedia.org/wiki/Single-page_application\" target=\"_blank\" rel=\"external\">SPA</a> 时，<code>v-</code> 前缀也变得没那么重要了。因此，Vue.js 为两个最为常用的指令提供了特别的缩写：</p>\n<h3 id=\"v-bind-缩写\"><a href=\"#v-bind-缩写\" class=\"headerlink\" title=\"v-bind 缩写\"></a><code>v-bind</code> 缩写</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 完整语法 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-bind:href</span>=<span class=\"string\">\"url\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 缩写 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:href</span>=<span class=\"string\">\"url\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"v-on-缩写\"><a href=\"#v-on-缩写\" class=\"headerlink\" title=\"v-on 缩写\"></a><code>v-on</code> 缩写</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 完整语法 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 缩写 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>它们看起来可能与普通的 HTML 略有不同，但 <code>:</code> 与 <code>@</code> 对于属性名来说都是合法字符，在所有支持 Vue.js 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/syntax.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/syntax.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<p>Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</p>\n<p>在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。</p>\n<p>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，<a href=\"render-function.html\">直接写渲染（render）函数</a>，使用可选的 JSX 语法。</p>\n<h2 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h2><h3 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h3><p>数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Mustache 标签将会被替代为对应数据对象上 <code>msg</code> 属性的值。无论何时，绑定的数据对象上 <code>msg</code> 属性发生了改变，插值处的内容都会更新。</p>\n<p>通过使用 <a href=\"../api/#v-once\">v-once 指令</a>，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-once</span>&gt;</span>This will never change: &#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"纯-HTML\"><a href=\"#纯-HTML\" class=\"headerlink\" title=\"纯 HTML\"></a>纯 HTML</h3><p>双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 <code>v-html</code> 指令：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"rawHtml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>被插入的内容都会被当做 HTML —— 数据绑定会被忽略。注意，你不能使用 <code>v-html</code> 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。组件更适合担任 UI 重用与复合的基本单元。</p>\n<p class=\"tip\">你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">XSS 攻击</a>。请只对可信内容使用 HTML 插值，<strong>绝不要</strong>对用户提供的内容插值。</p>\n\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>Mustache 不能在 HTML 属性中使用，应使用 <a href=\"../api/#v-bind\">v-bind 指令</a>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"dynamicId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:disabled</span>=<span class=\"string\">\"someDynamicCondition\"</span>&gt;</span>Button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"使用-JavaScript-表达式\"><a href=\"#使用-JavaScript-表达式\" class=\"headerlink\" title=\"使用 JavaScript 表达式\"></a>使用 JavaScript 表达式</h3><p>迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&#123; number + 1 &#125;&#125;</div><div class=\"line\"></div><div class=\"line\">&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;</div><div class=\"line\"></div><div class=\"line\">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"'list-' + id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都<strong>不会</strong>生效。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 这是语句，不是表达式 --&gt;</span></div><div class=\"line\">&#123;&#123; var a = 1 &#125;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></div><div class=\"line\">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</div></pre></td></tr></table></figure>\n<p class=\"tip\">模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 <code>Math</code> 和 <code>Date</code> 。你不应该在模板表达式中试图访问用户定义的全局变量。</p>\n\n\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><p>指令（Directives）是带有 <code>v-</code> 前缀的特殊属性。指令属性的值预期是<strong>单一 JavaScript 表达式</strong>（除了 <code>v-for</code>，之后再讨论）。指令的职责就是当其表达式的值改变时相应地将某些行为应用到 DOM 上。让我们回顾一下在介绍里的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"seen\"</span>&gt;</span>Now you see me<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这里， <code>v-if</code> 指令将根据表达式 <code>seen</code> 的值的真假来移除/插入 <code>&lt;p&gt;</code> 元素。</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>一些指令能接受一个“参数”，在指令后以冒号指明。例如， <code>v-bind</code> 指令被用来响应地更新 HTML 属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-bind:href</span>=<span class=\"string\">\"url\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> 属性与表达式 <code>url</code> 的值绑定。</p>\n<p>另一个例子是 <code>v-on</code> 指令，它用于监听 DOM 事件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在这里参数是监听的事件名。我们也会更详细地讨论事件处理。</p>\n<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><p>修饰符（Modifiers）是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>之后当我们更深入地了解 <code>v-on</code> 与 <code>v-model</code>时，会看到更多修饰符的使用。</p>\n<h2 id=\"Filters\"><a href=\"#Filters\" class=\"headerlink\" title=\"Filters\"></a>Filters</h2><p>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: <strong>mustache interpolations and <code>v-bind</code> expressions</strong>. Filters should be appended to the end of the JavaScript expression, denoted by the “pipe” symbol:</p>\n<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。过滤器应该被添加在 <strong>mustache 插值</strong>的尾部，由“管道符”指示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&#123; message | capitalize &#125;&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- in mustaches --&gt;</span></div><div class=\"line\">&#123;&#123; message | capitalize &#125;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- in v-bind --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"rawId | formatId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">Vue 2.x 中，过滤器只能在 mustache 绑定和 <code>v-bind</code> 表达式（从 2.1.0 开始支持）中使用，因为过滤器设计目的就是用于文本转换。为了在其他指令中实现更复杂的数据变换，你应该使用<a href=\"computed.html\">计算属性</a>。</p>\n\n<p>过滤器函数总接受表达式的值作为第一个参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  filters: &#123;</div><div class=\"line\">    <span class=\"attr\">capitalize</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!value) <span class=\"keyword\">return</span> <span class=\"string\">''</span></div><div class=\"line\">      value = value.toString()</div><div class=\"line\">      <span class=\"keyword\">return</span> value.charAt(<span class=\"number\">0</span>).toUpperCase() + value.slice(<span class=\"number\">1</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>过滤器可以串联：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&#123; message | filterA | filterB &#125;&#125;</div></pre></td></tr></table></figure>\n<p>过滤器是 JavaScript 函数，因此可以接受参数：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</div></pre></td></tr></table></figure>\n<p>这里，字符串 <code>&#39;arg1&#39;</code> 将传给过滤器作为第二个参数， <code>arg2</code> 表达式的值将被求值然后传给过滤器作为第三个参数。</p>\n<h2 id=\"缩写\"><a href=\"#缩写\" class=\"headerlink\" title=\"缩写\"></a>缩写</h2><p><code>v-</code> 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识。当你使用 Vue.js 为现有的标记添加动态行为时，它会很有用，但对于一些经常使用的指令来说有点繁琐。同时，当搭建 Vue.js 管理所有模板的 <a href=\"https://en.wikipedia.org/wiki/Single-page_application\">SPA</a> 时，<code>v-</code> 前缀也变得没那么重要了。因此，Vue.js 为两个最为常用的指令提供了特别的缩写：</p>\n<h3 id=\"v-bind-缩写\"><a href=\"#v-bind-缩写\" class=\"headerlink\" title=\"v-bind 缩写\"></a><code>v-bind</code> 缩写</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 完整语法 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-bind:href</span>=<span class=\"string\">\"url\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 缩写 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:href</span>=<span class=\"string\">\"url\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"v-on-缩写\"><a href=\"#v-on-缩写\" class=\"headerlink\" title=\"v-on 缩写\"></a><code>v-on</code> 缩写</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 完整语法 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- 缩写 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>它们看起来可能与普通的 HTML 略有不同，但 <code>:</code> 与 <code>@</code> 对于属性名来说都是合法字符，在所有支持 Vue.js 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/syntax.html\">http://vuejs.org/guide/syntax.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"单元测试","type":"guide","order":23,"_content":"\n## 配置和工具\n\n任何兼容基于模块的构建系统都可以正常使用，但如果你需要一个具体的建议，可以使用 [Karma](http://karma-runner.github.io) 进行自动化测试。它有很多社区版的插件，包括对 [Webpack](https://github.com/webpack/karma-webpack) 和 [Browserify](https://github.com/Nikku/karma-browserify) 的支持。更多详细的安装步骤，请参考各项目的安装文档，通过这些 Karma 配置的例子可以快速帮助你上手（[Webpack](https://github.com/vuejs-templates/webpack/blob/master/template/test/unit/karma.conf.js) 配置，[Browserify](https://github.com/vuejs-templates/browserify/blob/master/template/karma.conf.js) 配置）。 \n\n## 简单的断言\n\n在测试的代码结构方面，你不必为了可测试在你的组件中做任何特殊的操作。只要导出原始设置就可以了：\n\n``` html\n<template>\n  <span>{{ message }}</span>\n</template>\n\n<script>\n  export default {\n    data () {\n      return {\n        message: 'hello!'\n      }\n    },\n    created () {\n      this.message = 'bye!'\n    }\n  }\n</script>\n```\n\n当测试的组件时，所要做的就是导入对象和 Vue 然后使用许多常见的断言：\n\n``` js\n// 导入 Vue.js 和组件，进行测试\nimport Vue from 'vue'\nimport MyComponent from 'path/to/MyComponent.vue'\n\n// 这里是一些 Jasmine 2.0 的测试，你也可以使用你喜欢的任何断言库或测试工具。\n\ndescribe('MyComponent', () => {\n  // 检查原始组件选项\n  it('has a created hook', () => {\n    expect(typeof MyComponent.created).toBe('function')\n  })\n\n  // 评估原始组件选项中的函数的结果\n  it('sets the correct default data', () => {\n    expect(typeof MyComponent.data).toBe('function')\n    const defaultData = MyComponent.data()\n    expect(defaultData.message).toBe('hello!')\n  })\n\n  // 检查mount中的组件实例\n  it('correctly sets the message when created', () => {\n    const vm = new Vue(MyComponent).$mount()\n    expect(vm.message).toBe('bye!')\n  })\n\n  // 创建一个实例并检查渲染输出\n  it('renders the correct message', () => {\n    const Ctor = Vue.extend(MyComponent)\n    const vm = new Ctor().$mount()\n    expect(vm.$el.textContent).toBe('bye!')\n  })\n})\n```\n\n## 编写可被测试的组件\n\n很多组件的渲染输出由它的 props 决定。事实上，如果一个组件的渲染输出完全取决于它的 props，那么它会让测试变得简单，就好像断言不同参数的纯函数的返回值。看下面这个例子:\n\n``` html\n<template>\n  <p>{{ msg }}</p>\n</template>\n\n<script>\n  export default {\n    props: ['msg']\n  }\n</script>\n```\n\n你可以在不同的 props 中，通过 `propsData` 选项断言它的渲染输出:\n\n``` js\nimport Vue from 'vue'\nimport MyComponent from './MyComponent.vue'\n\n// 挂载元素并返回已渲染的文本的工具函数 \nfunction getRenderedText (Component, propsData) {\n  const Ctor = Vue.extend(Component)\n  const vm = new Ctor({ propsData }).$mount()\n  return vm.$el.textContent\n}\n\ndescribe('MyComponent', () => {\n  it('render correctly with different props', () => {\n    expect(getRenderedText(MyComponent, {\n      msg: 'Hello'\n    })).toBe('Hello')\n\n    expect(getRenderedText(MyComponent, {\n      msg: 'Bye'\n    })).toBe('Bye')\n  })\n})\n```\n\n## 断言异步更新\n\n由于 Vue 进行 [异步更新DOM](reactivity.html#Async-Update-Queue) 的情况，一些依赖DOM更新结果的断言必须在 ` Vue.nextTick ` 回调中进行：\n\n``` js\n// 在状态更新后检查生成的 HTML\nit('updates the rendered message when vm.message updates', done => {\n  const vm = new Vue(MyComponent).$mount()\n  vm.message = 'foo'\n\n  // 在状态改变后和断言 DOM 更新前等待一刻\n  Vue.nextTick(() => {\n    expect(vm.$el.textContent).toBe('foo')\n    done()\n  })\n})\n```\n\n我们计划做一个通用的测试工具集，让不同策略的渲染输出（例如忽略子组件的基本渲染）和断言变得更简单。\n\n***\n\n> 原文： http://vuejs.org/guide/unit-testing.html\n\n***\n","source":"v2/guide/unit-testing.md","raw":"---\ntitle: 单元测试\ntype: guide\norder: 23\n---\n\n## 配置和工具\n\n任何兼容基于模块的构建系统都可以正常使用，但如果你需要一个具体的建议，可以使用 [Karma](http://karma-runner.github.io) 进行自动化测试。它有很多社区版的插件，包括对 [Webpack](https://github.com/webpack/karma-webpack) 和 [Browserify](https://github.com/Nikku/karma-browserify) 的支持。更多详细的安装步骤，请参考各项目的安装文档，通过这些 Karma 配置的例子可以快速帮助你上手（[Webpack](https://github.com/vuejs-templates/webpack/blob/master/template/test/unit/karma.conf.js) 配置，[Browserify](https://github.com/vuejs-templates/browserify/blob/master/template/karma.conf.js) 配置）。 \n\n## 简单的断言\n\n在测试的代码结构方面，你不必为了可测试在你的组件中做任何特殊的操作。只要导出原始设置就可以了：\n\n``` html\n<template>\n  <span>{{ message }}</span>\n</template>\n\n<script>\n  export default {\n    data () {\n      return {\n        message: 'hello!'\n      }\n    },\n    created () {\n      this.message = 'bye!'\n    }\n  }\n</script>\n```\n\n当测试的组件时，所要做的就是导入对象和 Vue 然后使用许多常见的断言：\n\n``` js\n// 导入 Vue.js 和组件，进行测试\nimport Vue from 'vue'\nimport MyComponent from 'path/to/MyComponent.vue'\n\n// 这里是一些 Jasmine 2.0 的测试，你也可以使用你喜欢的任何断言库或测试工具。\n\ndescribe('MyComponent', () => {\n  // 检查原始组件选项\n  it('has a created hook', () => {\n    expect(typeof MyComponent.created).toBe('function')\n  })\n\n  // 评估原始组件选项中的函数的结果\n  it('sets the correct default data', () => {\n    expect(typeof MyComponent.data).toBe('function')\n    const defaultData = MyComponent.data()\n    expect(defaultData.message).toBe('hello!')\n  })\n\n  // 检查mount中的组件实例\n  it('correctly sets the message when created', () => {\n    const vm = new Vue(MyComponent).$mount()\n    expect(vm.message).toBe('bye!')\n  })\n\n  // 创建一个实例并检查渲染输出\n  it('renders the correct message', () => {\n    const Ctor = Vue.extend(MyComponent)\n    const vm = new Ctor().$mount()\n    expect(vm.$el.textContent).toBe('bye!')\n  })\n})\n```\n\n## 编写可被测试的组件\n\n很多组件的渲染输出由它的 props 决定。事实上，如果一个组件的渲染输出完全取决于它的 props，那么它会让测试变得简单，就好像断言不同参数的纯函数的返回值。看下面这个例子:\n\n``` html\n<template>\n  <p>{{ msg }}</p>\n</template>\n\n<script>\n  export default {\n    props: ['msg']\n  }\n</script>\n```\n\n你可以在不同的 props 中，通过 `propsData` 选项断言它的渲染输出:\n\n``` js\nimport Vue from 'vue'\nimport MyComponent from './MyComponent.vue'\n\n// 挂载元素并返回已渲染的文本的工具函数 \nfunction getRenderedText (Component, propsData) {\n  const Ctor = Vue.extend(Component)\n  const vm = new Ctor({ propsData }).$mount()\n  return vm.$el.textContent\n}\n\ndescribe('MyComponent', () => {\n  it('render correctly with different props', () => {\n    expect(getRenderedText(MyComponent, {\n      msg: 'Hello'\n    })).toBe('Hello')\n\n    expect(getRenderedText(MyComponent, {\n      msg: 'Bye'\n    })).toBe('Bye')\n  })\n})\n```\n\n## 断言异步更新\n\n由于 Vue 进行 [异步更新DOM](reactivity.html#Async-Update-Queue) 的情况，一些依赖DOM更新结果的断言必须在 ` Vue.nextTick ` 回调中进行：\n\n``` js\n// 在状态更新后检查生成的 HTML\nit('updates the rendered message when vm.message updates', done => {\n  const vm = new Vue(MyComponent).$mount()\n  vm.message = 'foo'\n\n  // 在状态改变后和断言 DOM 更新前等待一刻\n  Vue.nextTick(() => {\n    expect(vm.$el.textContent).toBe('foo')\n    done()\n  })\n})\n```\n\n我们计划做一个通用的测试工具集，让不同策略的渲染输出（例如忽略子组件的基本渲染）和断言变得更简单。\n\n***\n\n> 原文： http://vuejs.org/guide/unit-testing.html\n\n***\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/unit-testing.html","comments":1,"layout":"page","_id":"ciwnajuz5001vjl2dbwggl00q","content":"<h2 id=\"配置和工具\"><a href=\"#配置和工具\" class=\"headerlink\" title=\"配置和工具\"></a>配置和工具</h2><p>任何兼容基于模块的构建系统都可以正常使用，但如果你需要一个具体的建议，可以使用 <a href=\"http://karma-runner.github.io\" target=\"_blank\" rel=\"external\">Karma</a> 进行自动化测试。它有很多社区版的插件，包括对 <a href=\"https://github.com/webpack/karma-webpack\" target=\"_blank\" rel=\"external\">Webpack</a> 和 <a href=\"https://github.com/Nikku/karma-browserify\" target=\"_blank\" rel=\"external\">Browserify</a> 的支持。更多详细的安装步骤，请参考各项目的安装文档，通过这些 Karma 配置的例子可以快速帮助你上手（<a href=\"https://github.com/vuejs-templates/webpack/blob/master/template/test/unit/karma.conf.js\" target=\"_blank\" rel=\"external\">Webpack</a> 配置，<a href=\"https://github.com/vuejs-templates/browserify/blob/master/template/karma.conf.js\" target=\"_blank\" rel=\"external\">Browserify</a> 配置）。 </p>\n<h2 id=\"简单的断言\"><a href=\"#简单的断言\" class=\"headerlink\" title=\"简单的断言\"></a>简单的断言</h2><p>在测试的代码结构方面，你不必为了可测试在你的组件中做任何特殊的操作。只要导出原始设置就可以了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    data () &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">message</span>: <span class=\"string\">'hello!'</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    created () &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.message = <span class=\"string\">'bye!'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当测试的组件时，所要做的就是导入对象和 Vue 然后使用许多常见的断言：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入 Vue.js 和组件，进行测试</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyComponent <span class=\"keyword\">from</span> <span class=\"string\">'path/to/MyComponent.vue'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这里是一些 Jasmine 2.0 的测试，你也可以使用你喜欢的任何断言库或测试工具。</span></div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'MyComponent'</span>, () =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">// 检查原始组件选项</span></div><div class=\"line\">  it(<span class=\"string\">'has a created hook'</span>, () =&gt; &#123;</div><div class=\"line\">    expect(<span class=\"keyword\">typeof</span> MyComponent.created).toBe(<span class=\"string\">'function'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 评估原始组件选项中的函数的结果</span></div><div class=\"line\">  it(<span class=\"string\">'sets the correct default data'</span>, () =&gt; &#123;</div><div class=\"line\">    expect(<span class=\"keyword\">typeof</span> MyComponent.data).toBe(<span class=\"string\">'function'</span>)</div><div class=\"line\">    <span class=\"keyword\">const</span> defaultData = MyComponent.data()</div><div class=\"line\">    expect(defaultData.message).toBe(<span class=\"string\">'hello!'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 检查mount中的组件实例</span></div><div class=\"line\">  it(<span class=\"string\">'correctly sets the message when created'</span>, () =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">new</span> Vue(MyComponent).$mount()</div><div class=\"line\">    expect(vm.message).toBe(<span class=\"string\">'bye!'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 创建一个实例并检查渲染输出</span></div><div class=\"line\">  it(<span class=\"string\">'renders the correct message'</span>, () =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> Ctor = Vue.extend(MyComponent)</div><div class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">new</span> Ctor().$mount()</div><div class=\"line\">    expect(vm.$el.textContent).toBe(<span class=\"string\">'bye!'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"编写可被测试的组件\"><a href=\"#编写可被测试的组件\" class=\"headerlink\" title=\"编写可被测试的组件\"></a>编写可被测试的组件</h2><p>很多组件的渲染输出由它的 props 决定。事实上，如果一个组件的渲染输出完全取决于它的 props，那么它会让测试变得简单，就好像断言不同参数的纯函数的返回值。看下面这个例子:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    <span class=\"attr\">props</span>: [<span class=\"string\">'msg'</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你可以在不同的 props 中，通过 <code>propsData</code> 选项断言它的渲染输出:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyComponent <span class=\"keyword\">from</span> <span class=\"string\">'./MyComponent.vue'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 挂载元素并返回已渲染的文本的工具函数 </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRenderedText</span> (<span class=\"params\">Component, propsData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> Ctor = Vue.extend(Component)</div><div class=\"line\">  <span class=\"keyword\">const</span> vm = <span class=\"keyword\">new</span> Ctor(&#123; propsData &#125;).$mount()</div><div class=\"line\">  <span class=\"keyword\">return</span> vm.$el.textContent</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'MyComponent'</span>, () =&gt; &#123;</div><div class=\"line\">  it(<span class=\"string\">'render correctly with different props'</span>, () =&gt; &#123;</div><div class=\"line\">    expect(getRenderedText(MyComponent, &#123;</div><div class=\"line\">      <span class=\"attr\">msg</span>: <span class=\"string\">'Hello'</span></div><div class=\"line\">    &#125;)).toBe(<span class=\"string\">'Hello'</span>)</div><div class=\"line\"></div><div class=\"line\">    expect(getRenderedText(MyComponent, &#123;</div><div class=\"line\">      <span class=\"attr\">msg</span>: <span class=\"string\">'Bye'</span></div><div class=\"line\">    &#125;)).toBe(<span class=\"string\">'Bye'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"断言异步更新\"><a href=\"#断言异步更新\" class=\"headerlink\" title=\"断言异步更新\"></a>断言异步更新</h2><p>由于 Vue 进行 <a href=\"reactivity.html#Async-Update-Queue\">异步更新DOM</a> 的情况，一些依赖DOM更新结果的断言必须在 <code>Vue.nextTick</code> 回调中进行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在状态更新后检查生成的 HTML</span></div><div class=\"line\">it(<span class=\"string\">'updates the rendered message when vm.message updates'</span>, done =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> vm = <span class=\"keyword\">new</span> Vue(MyComponent).$mount()</div><div class=\"line\">  vm.message = <span class=\"string\">'foo'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 在状态改变后和断言 DOM 更新前等待一刻</span></div><div class=\"line\">  Vue.nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    expect(vm.$el.textContent).toBe(<span class=\"string\">'foo'</span>)</div><div class=\"line\">    done()</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们计划做一个通用的测试工具集，让不同策略的渲染输出（例如忽略子组件的基本渲染）和断言变得更简单。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/unit-testing.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/unit-testing.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"配置和工具\"><a href=\"#配置和工具\" class=\"headerlink\" title=\"配置和工具\"></a>配置和工具</h2><p>任何兼容基于模块的构建系统都可以正常使用，但如果你需要一个具体的建议，可以使用 <a href=\"http://karma-runner.github.io\">Karma</a> 进行自动化测试。它有很多社区版的插件，包括对 <a href=\"https://github.com/webpack/karma-webpack\">Webpack</a> 和 <a href=\"https://github.com/Nikku/karma-browserify\">Browserify</a> 的支持。更多详细的安装步骤，请参考各项目的安装文档，通过这些 Karma 配置的例子可以快速帮助你上手（<a href=\"https://github.com/vuejs-templates/webpack/blob/master/template/test/unit/karma.conf.js\">Webpack</a> 配置，<a href=\"https://github.com/vuejs-templates/browserify/blob/master/template/karma.conf.js\">Browserify</a> 配置）。 </p>\n<h2 id=\"简单的断言\"><a href=\"#简单的断言\" class=\"headerlink\" title=\"简单的断言\"></a>简单的断言</h2><p>在测试的代码结构方面，你不必为了可测试在你的组件中做任何特殊的操作。只要导出原始设置就可以了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    data () &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">message</span>: <span class=\"string\">'hello!'</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    created () &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.message = <span class=\"string\">'bye!'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当测试的组件时，所要做的就是导入对象和 Vue 然后使用许多常见的断言：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入 Vue.js 和组件，进行测试</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyComponent <span class=\"keyword\">from</span> <span class=\"string\">'path/to/MyComponent.vue'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这里是一些 Jasmine 2.0 的测试，你也可以使用你喜欢的任何断言库或测试工具。</span></div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'MyComponent'</span>, () =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">// 检查原始组件选项</span></div><div class=\"line\">  it(<span class=\"string\">'has a created hook'</span>, () =&gt; &#123;</div><div class=\"line\">    expect(<span class=\"keyword\">typeof</span> MyComponent.created).toBe(<span class=\"string\">'function'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 评估原始组件选项中的函数的结果</span></div><div class=\"line\">  it(<span class=\"string\">'sets the correct default data'</span>, () =&gt; &#123;</div><div class=\"line\">    expect(<span class=\"keyword\">typeof</span> MyComponent.data).toBe(<span class=\"string\">'function'</span>)</div><div class=\"line\">    <span class=\"keyword\">const</span> defaultData = MyComponent.data()</div><div class=\"line\">    expect(defaultData.message).toBe(<span class=\"string\">'hello!'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 检查mount中的组件实例</span></div><div class=\"line\">  it(<span class=\"string\">'correctly sets the message when created'</span>, () =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">new</span> Vue(MyComponent).$mount()</div><div class=\"line\">    expect(vm.message).toBe(<span class=\"string\">'bye!'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 创建一个实例并检查渲染输出</span></div><div class=\"line\">  it(<span class=\"string\">'renders the correct message'</span>, () =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> Ctor = Vue.extend(MyComponent)</div><div class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">new</span> Ctor().$mount()</div><div class=\"line\">    expect(vm.$el.textContent).toBe(<span class=\"string\">'bye!'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"编写可被测试的组件\"><a href=\"#编写可被测试的组件\" class=\"headerlink\" title=\"编写可被测试的组件\"></a>编写可被测试的组件</h2><p>很多组件的渲染输出由它的 props 决定。事实上，如果一个组件的渲染输出完全取决于它的 props，那么它会让测试变得简单，就好像断言不同参数的纯函数的返回值。看下面这个例子:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    <span class=\"attr\">props</span>: [<span class=\"string\">'msg'</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你可以在不同的 props 中，通过 <code>propsData</code> 选项断言它的渲染输出:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyComponent <span class=\"keyword\">from</span> <span class=\"string\">'./MyComponent.vue'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 挂载元素并返回已渲染的文本的工具函数 </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRenderedText</span> (<span class=\"params\">Component, propsData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> Ctor = Vue.extend(Component)</div><div class=\"line\">  <span class=\"keyword\">const</span> vm = <span class=\"keyword\">new</span> Ctor(&#123; propsData &#125;).$mount()</div><div class=\"line\">  <span class=\"keyword\">return</span> vm.$el.textContent</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'MyComponent'</span>, () =&gt; &#123;</div><div class=\"line\">  it(<span class=\"string\">'render correctly with different props'</span>, () =&gt; &#123;</div><div class=\"line\">    expect(getRenderedText(MyComponent, &#123;</div><div class=\"line\">      <span class=\"attr\">msg</span>: <span class=\"string\">'Hello'</span></div><div class=\"line\">    &#125;)).toBe(<span class=\"string\">'Hello'</span>)</div><div class=\"line\"></div><div class=\"line\">    expect(getRenderedText(MyComponent, &#123;</div><div class=\"line\">      <span class=\"attr\">msg</span>: <span class=\"string\">'Bye'</span></div><div class=\"line\">    &#125;)).toBe(<span class=\"string\">'Bye'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"断言异步更新\"><a href=\"#断言异步更新\" class=\"headerlink\" title=\"断言异步更新\"></a>断言异步更新</h2><p>由于 Vue 进行 <a href=\"reactivity.html#Async-Update-Queue\">异步更新DOM</a> 的情况，一些依赖DOM更新结果的断言必须在 <code>Vue.nextTick</code> 回调中进行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在状态更新后检查生成的 HTML</span></div><div class=\"line\">it(<span class=\"string\">'updates the rendered message when vm.message updates'</span>, done =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> vm = <span class=\"keyword\">new</span> Vue(MyComponent).$mount()</div><div class=\"line\">  vm.message = <span class=\"string\">'foo'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 在状态改变后和断言 DOM 更新前等待一刻</span></div><div class=\"line\">  Vue.nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    expect(vm.$el.textContent).toBe(<span class=\"string\">'foo'</span>)</div><div class=\"line\">    done()</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们计划做一个通用的测试工具集，让不同策略的渲染输出（例如忽略子组件的基本渲染）和断言变得更简单。</p>\n<hr>\n<blockquote>\n<p>原文： <a href=\"http://vuejs.org/guide/unit-testing.html\">http://vuejs.org/guide/unit-testing.html</a></p>\n</blockquote>\n<hr>\n"},{"title":"过渡效果","type":"guide","order":13,"_content":"\n## 概述\n\nVue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。\n包括以下工具：\n\n- 在 CSS 过渡和动画中自动应用 class\n- 可以配合使用第三方 CSS 动画库，如 Animate.css\n- 在过渡钩子函数中使用 JavaScript 直接操作 DOM\n- 可以配合使用第三方 JavaScript 动画库，如 Velocity.js\n\n在这里，我们只会讲到进入、离开和列表的过渡， 你也可以看下一节的 [管理过渡状态](transitioning-state.html).\n\n## 单元素/组件的过渡\n\nVue 提供了 `transition` 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡\n\n- 条件渲染 （使用 `v-if`）\n- 条件展示 （使用 `v-show`）\n- 动态组件\n- 组件根节点\n\n这里是一个典型的例子：\n\n``` html\n<div id=\"demo\">\n  <button v-on:click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#demo',\n  data: {\n    show: true\n  }\n})\n```\n\n``` css\n.fade-enter-active, .fade-leave-active {\n  transition: opacity .5s\n}\n.fade-enter, .fade-leave-active {\n  opacity: 0\n}\n```\n\n{% raw %}\n<div id=\"demo\">\n  <button v-on:click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"demo-transition\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#demo',\n  data: {\n    show: true\n  }\n})\n</script>\n<style>\n.demo-transition-enter-active, .demo-transition-leave-active {\n  transition: opacity .5s\n}\n.demo-transition-enter, .demo-transition-leave-active {\n  opacity: 0\n}\n</style>\n{% endraw %}\n\n元素封装成过渡组件之后，在遇到插入或删除时，Vue 将\n\n\n1. 自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。\n\n2. 如果过渡组件设置了过渡的 [JavaScript 钩子函数](#JavaScript-Hooks)，会在相应的阶段调用钩子函数。\n\n3. 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 `nextTick` 概念不同)\n\n\n### 过渡的-CSS-类名\n\n会有 4 个(CSS)类名在 enter/leave 的过渡中切换\n\n1. `v-enter`: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。\n\n2. `v-enter-active`: 定义进入过渡的结束状态。在元素被插入时生效，在 `transition/animation` 完成之后移除。\n\n3. `v-leave`:  定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。\n\n4. `v-leave-active`: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 `transition/animation` 完成之后移除。\n\n\n![Transition Diagram](/images/transition.png)\n\n对于这些在 `enter/leave` 过渡中切换的类名，`v-` 是这些类名的前缀。使用 `<transition name=\"my-transition\">` 可以重置前缀，比如 `v-enter` 替换为 `my-transition-enter`。\n\n`v-enter-active` 和 `v-leave-active` 可以控制 进入/离开 过渡的不同阶段，在下面章节会有个示例说明。\n\n### CSS 过渡\n\n常用的过渡都是使用 CSS 过渡。\n\n下面是一个简单例子：\n\n``` html\n<div id=\"example-1\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition name=\"slide-fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#example-1',\n  data: {\n    show: true\n  }\n})\n```\n\n``` css\n/* 可以设置不同的进入和离开动画 */\n/* 设置持续时间和动画函数 */\n.slide-fade-enter-active {\n  transition: all .3s ease;\n}\n.slide-fade-leave-active {\n  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.slide-fade-enter, .slide-fade-leave-active {\n  transform: translateX(10px);\n  opacity: 0;\n}\n```\n\n{% raw %}\n<div id=\"example-1\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"slide-fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    show: true\n  }\n})\n</script>\n<style>\n.slide-fade-enter-active {\n  transition: all .3s ease;\n}\n.slide-fade-leave-active {\n  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.slide-fade-enter, .slide-fade-leave-active {\n  transform: translateX(10px);\n  opacity: 0;\n}\n</style>\n{% endraw %}\n\n\n### CSS 动画\n\n\nCSS 动画用法同 CSS 过渡，区别是在动画中 `v-enter` 类名在节点插入 DOM 后不会立即删除，而是在 `animationend` 事件触发时删除。\n\n示例： (省略了兼容性前缀)\n\n``` html\n<div id=\"example-2\">\n  <button @click=\"show = !show\">Toggle show</button>\n  <transition name=\"bounce\">\n    <p v-if=\"show\">Look at me!</p>\n  </transition>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#example-2',\n  data: {\n    show: true\n  }\n})\n```\n\n``` css\n.bounce-enter-active {\n  animation: bounce-in .5s;\n}\n.bounce-leave-active {\n  animation: bounce-out .5s;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n@keyframes bounce-out {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(0);\n  }\n}\n```\n\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <button @click=\"show = !show\">Toggle show</button>\n  <transition name=\"bounce\">\n    <p v-show=\"show\">Look at me!</p>\n  </transition>\n</div>\n\n<style>\n  .bounce-enter-active {\n    -webkit-animation: bounce-in .5s;\n    animation: bounce-in .5s;\n  }\n  .bounce-leave-active {\n    -webkit-animation: bounce-out .5s;\n    animation: bounce-out .5s;\n  }\n  @keyframes bounce-in {\n    0% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n  }\n  @keyframes bounce-out {\n    0% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n  }\n  @-webkit-keyframes bounce-in {\n    0% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n  }\n  @-webkit-keyframes bounce-out {\n    0% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n  }\n</style>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    show: true\n  }\n})\n</script>\n{% endraw %}\n\n\n### 自定义过渡类名\n\n我们可以通过以下特性来自定义过渡类名：\n\n- `enter-class`\n- `enter-active-class`\n- `leave-class`\n- `leave-active-class`\n\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 [Animate.css](https://daneden.github.io/animate.css/) 结合使用十分有用。\n\n示例：\n\n``` html\n<link href=\"https://unpkg.com/animate.css@3.5.1/animate.min.css\" rel=\"stylesheet\" type=\"text/css\">\n\n<div id=\"example-3\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition\n    name=\"custom-classes-transition\"\n    enter-active-class=\"animated tada\"\n    leave-active-class=\"animated bounceOutRight\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#example-3',\n  data: {\n    show: true\n  }\n})\n```\n\n{% raw %}\n<link href=\"https://unpkg.com/animate.css@3.5.1\" rel=\"stylesheet\" type=\"text/css\">\n<div id=\"example-3\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition\n    name=\"custom-classes-transition\"\n    enter-active-class=\"animated tada\"\n    leave-active-class=\"animated bounceOutRight\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    show: true\n  }\n})\n</script>\n{% endraw %}\n\n\n### 同时使用 Transitions 和 Animations\n\nVue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 `transitionend` 或 `animationend` ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。\n\n但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 `animation` 很快的被触发并完成了，而 `transition` 效果还没结束。在这种情况中，你就需要使用 `type` 特性并设置 `animation` 或 `transition` 来明确声明你需要 Vue 监听的类型。\n\n### JavaScript 钩子\n\n可以在属性中声明 JavaScript 钩子\n\n``` html\n<transition\n  v-on:before-enter=\"beforeEnter\"\n  v-on:enter=\"enter\"\n  v-on:after-enter=\"afterEnter\"\n  v-on:enter-cancelled=\"enterCancelled\"\n\n  v-on:before-leave=\"beforeLeave\"\n  v-on:leave=\"leave\"\n  v-on:after-leave=\"afterLeave\"\n  v-on:leave-cancelled=\"leaveCancelled\"\n>\n  <!-- ... -->\n</transition>\n```\n\n``` js\n// ...\nmethods: {\n  // --------\n  // 进入中\n  // --------\n\n  beforeEnter: function (el) {\n    // ...\n  },\n  // 此回调函数是可选项的设置\n  // 与 CSS 结合时使用\n  enter: function (el, done) {\n    // ...\n    done()\n  },\n  afterEnter: function (el) {\n    // ...\n  },\n  enterCancelled: function (el) {\n    // ...\n  },\n\n  // --------\n  // 离开时\n  // --------\n\n  beforeLeave: function (el) {\n    // ...\n  },\n  // 此回调函数是可选项的设置\n  // 与 CSS 结合时使用\n  leave: function (el, done) {\n    // ...\n    done()\n  },\n  afterLeave: function (el) {\n    // ...\n  },\n  // leaveCancelled 只用于 v-show 中\n  leaveCancelled: function (el) {\n    // ...\n  }\n}\n```\n\n这些钩子函数可以结合 CSS `transitions/animations` 使用，也可以单独使用。\n\n<p class=\"tip\">当只用 JavaScript 过渡的时候， ** 在 `enter` 和 `leave` 中，回调函数 `done` 是必须的 **。 否则，它们会被同步调用，过渡会立即完成。</p>\n\n<p class=\"tip\">推荐对于仅使用 JavaScript 过渡的元素添加 `v-bind:css=\"false\"`，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>\n\n一个使用 Velocity.js 的简单例子：\n\n``` html\n<!--\nVelocity works very much like jQuery.animate and is\na great option for JavaScript animations\n-->\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n\n<div id=\"example-4\">\n  <button @click=\"show = !show\">\n    Toggle\n  </button>\n  <transition\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n    v-bind:css=\"false\"\n  >\n    <p v-if=\"show\">\n      Demo\n    </p>\n  </transition>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#example-4',\n  data: {\n    show: false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.transformOrigin = 'left'\n    },\n    enter: function (el, done) {\n      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })\n      Velocity(el, { fontSize: '1em' }, { complete: done })\n    },\n    leave: function (el, done) {\n      Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })\n      Velocity(el, { rotateZ: '100deg' }, { loop: 2 })\n      Velocity(el, {\n        rotateZ: '45deg',\n        translateY: '30px',\n        translateX: '30px',\n        opacity: 0\n      }, { complete: done })\n    }\n  }\n})\n```\n\n{% raw %}\n<div id=\"example-4\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle\n  </button>\n  <transition\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <p v-if=\"show\">\n      Demo\n    </p>\n  </transition>\n</div>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    show: false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.transformOrigin = 'left'\n    },\n    enter: function (el, done) {\n      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })\n      Velocity(el, { fontSize: '1em' }, { complete: done })\n    },\n    leave: function (el, done) {\n      Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })\n      Velocity(el, { rotateZ: '100deg' }, { loop: 2 })\n      Velocity(el, {\n        rotateZ: '45deg',\n        translateY: '30px',\n        translateX: '30px',\n        opacity: 0\n      }, { complete: done })\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## 初始渲染的过渡\n\n可以通过 `appear` 特性设置节点的在初始渲染的过渡\n\n``` html\n<transition appear>\n  <!-- ... -->\n</transition>\n```\n\n这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。\n\n``` html\n<transition\n  appear\n  appear-class=\"custom-appear-class\"\n  appear-active-class=\"custom-appear-active-class\"\n>\n  <!-- ... -->\n</transition>\n```\n\n自定义 JavaScript 钩子： \n\n``` html\n<transition\n  appear\n  v-on:before-appear=\"customBeforeAppearHook\"\n  v-on:appear=\"customAppearHook\"\n  v-on:after-appear=\"customAfterAppearHook\"\n>\n  <!-- ... -->\n</transition>\n```\n\n## 多个元素的过渡\n\n我们之后讨论 [多个组件的过渡](#多个组件的过渡), 对于原生标签可以使用 `v-if`/`v-else` 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：\n\n``` html\n<transition>\n  <table v-if=\"items.length > 0\">\n    <!-- ... -->\n  </table>\n  <p v-else>Sorry, no items found.</p>\n</transition>\n```\n\n可以这样使用，但是有一点需要注意：\n\n<p class=\"tip\">当有**相同标签名**的元素切换时，需要通过 `key` 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，**给在 `<transition>` 组件中的多个元素设置 key  是一个更好的实践。**</p>\n\n示例:\n\n``` html\n<transition>\n  <button v-if=\"isEditing\" key=\"save\">\n    Save\n  </button>\n  <button v-else key=\"edit\">\n    Edit\n  </button>\n</transition>\n```\n\n在一些场景中，也可以给通过给同一个元素的 `key` 特性设置不同的状态来代替 `v-if` 和 `v-else`，上面的例子可以重写为：\n\n``` html\n<transition>\n  <button v-bind:key=\"isEditing\">\n    {{ isEditing ? 'Save' : 'Edit' }}\n  </button>\n</transition>\n```\n\n使用多个 `v-if` 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。 例如：\n\n``` html\n<transition>\n  <button v-if=\"docState === 'saved'\" key=\"saved\">\n    Edit\n  </button>\n  <button v-if=\"docState === 'edited'\" key=\"edited\">\n    Save\n  </button>\n  <button v-if=\"docState === 'editing'\" key=\"editing\">\n    Cancel\n  </button>\n</transition>\n```\n\n可以重写为：\n\n``` html\n<transition>\n  <button v-bind:key=\"docState\">\n    {{ buttonMessage }}\n  </button>\n</transition>\n```\n\n``` js\n// ...\ncomputed: {\n  buttonMessage: function () {\n    switch (docState) {\n      case 'saved': return 'Edit'\n      case 'edited': return 'Save'\n      case 'editing': return 'Cancel'\n    }\n  }\n}\n```\n\n### 过渡模式\n\n这里还有一个问题，试着点击下面的按钮：\n\n{% raw %}\n<div id=\"no-mode-demo\" class=\"demo\">\n  <transition name=\"no-mode-fade\">\n    <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n      on\n    </button>\n    <button v-else key=\"off\" @click=\"on = true\">\n      off\n    </button>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-fade-enter-active, .no-mode-fade-leave-active {\n  transition: opacity .5s\n}\n.no-mode-fade-enter, .no-mode-fade-leave-active {\n  opacity: 0\n}\n</style>\n{% endraw %}\n\n在 \"on\" 按钮和 \"off\" 按钮的过渡中，两个按钮都被重绘了，一个离开过渡的时候另一个开始进入过渡。这是 `<transition>` 的默认行为 - 进入和离开同时发生。\n\n在元素绝对定位在彼此之上的时候运行正常：\n\n{% raw %}\n<div id=\"no-mode-absolute-demo\" class=\"demo\">\n  <div class=\"no-mode-absolute-demo-wrapper\">\n    <transition name=\"no-mode-absolute-fade\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-absolute-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-absolute-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.no-mode-absolute-demo-wrapper button {\n  position: absolute;\n}\n.no-mode-absolute-fade-enter-active, .no-mode-absolute-fade-leave-active {\n  transition: opacity .5s;\n}\n.no-mode-absolute-fade-enter, .no-mode-absolute-fade-leave-active {\n  opacity: 0;\n}\n</style>\n{% endraw %}\n\n然后，我们加上 translate 让它们运动像滑动过渡：\n\n{% raw %}\n<div id=\"no-mode-translate-demo\" class=\"demo\">\n  <div class=\"no-mode-translate-demo-wrapper\">\n    <transition name=\"no-mode-translate-fade\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-translate-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-translate-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.no-mode-translate-demo-wrapper button {\n  position: absolute;\n}\n.no-mode-translate-fade-enter-active, .no-mode-translate-fade-leave-active {\n  transition: all 1s;\n}\n.no-mode-translate-fade-enter, .no-mode-translate-fade-leave-active {\n  opacity: 0;\n}\n.no-mode-translate-fade-enter {\n  transform: translateX(31px);\n}\n.no-mode-translate-fade-leave-active {\n  transform: translateX(-31px);\n}\n</style>\n{% endraw %}\n\n同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 **过渡模式**\n\n\n- `in-out`: 新元素先进行过渡，完成之后当前元素过渡离开。\n\n- `out-in`: 当前元素先进行过渡，完成之后新元素过渡进入。\n\n用 `out-in` 重写之前的开关按钮过渡：\n\n``` html\n<transition name=\"fade\" mode=\"out-in\">\n  <!-- ... the buttons ... -->\n</transition>\n```\n\n{% raw %}\n<div id=\"with-mode-demo\" class=\"demo\">\n  <transition name=\"with-mode-fade\" mode=\"out-in\">\n    <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n      on\n    </button>\n    <button v-else key=\"off\" @click=\"on = true\">\n      off\n    </button>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#with-mode-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.with-mode-fade-enter-active, .with-mode-fade-leave-active {\n  transition: opacity .5s\n}\n.with-mode-fade-enter, .with-mode-fade-leave-active {\n  opacity: 0\n}\n</style>\n{% endraw %}\n\n只用添加一个简单的特性，就解决了之前的过渡问题而无需任何额外的代码。\n\n`in-out` 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。\n将之前滑动淡出的例子结合：\n\n\n{% raw %}\n<div id=\"in-out-translate-demo\" class=\"demo\">\n  <div class=\"in-out-translate-demo-wrapper\">\n    <transition name=\"in-out-translate-fade\" mode=\"in-out\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#in-out-translate-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.in-out-translate-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.in-out-translate-demo-wrapper button {\n  position: absolute;\n}\n.in-out-translate-fade-enter-active, .in-out-translate-fade-leave-active {\n  transition: all .5s;\n}\n.in-out-translate-fade-enter, .in-out-translate-fade-leave-active {\n  opacity: 0;\n}\n.in-out-translate-fade-enter {\n  transform: translateX(31px);\n}\n.in-out-translate-fade-leave-active {\n  transform: translateX(-31px);\n}\n</style>\n{% endraw %}\n\n很酷吧？\n\n## 多个组件的过渡\n\n多个组件的过渡很简单很多 - 我们不需要使用 `key` 特性。相反，我们只需要使用[动态组件](components.html#动态组件):\n\n\n``` html\n<transition name=\"component-fade\" mode=\"out-in\">\n  <component v-bind:is=\"view\"></component>\n</transition>\n```\n\n``` js\nnew Vue({\n  el: '#transition-components-demo',\n  data: {\n    view: 'v-a'\n  },\n  components: {\n    'v-a': {\n      template: '<div>Component A</div>'\n    },\n    'v-b': {\n      template: '<div>Component B</div>'\n    }\n  }\n})\n```\n\n``` css\n.component-fade-enter-active, .component-fade-leave-active {\n  transition: opacity .3s ease;\n}\n.component-fade-enter, .component-fade-leave-active {\n  opacity: 0;\n}\n```\n\n{% raw %}\n<div id=\"transition-components-demo\" class=\"demo\">\n  <input v-model=\"view\" type=\"radio\" value=\"v-a\" id=\"a\" name=\"view\"><label for=\"a\">A</label>\n  <input v-model=\"view\" type=\"radio\" value=\"v-b\" id=\"b\" name=\"view\"><label for=\"b\">B</label>\n  <transition name=\"component-fade\" mode=\"out-in\">\n    <component v-bind:is=\"view\"></component>\n  </transition>\n</div>\n<style>\n.component-fade-enter-active, .component-fade-leave-active {\n  transition: opacity .3s ease;\n}\n.component-fade-enter, .component-fade-leave-active {\n  opacity: 0;\n}\n</style>\n<script>\nnew Vue({\n  el: '#transition-components-demo',\n  data: {\n    view: 'v-a'\n  },\n  components: {\n    'v-a': {\n      template: '<div>Component A</div>'\n    },\n    'v-b': {\n      template: '<div>Component B</div>'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## 列表过渡\n\n目前为止，关于过渡我们已经讲到：\n\n- 单个节点\n- 一次渲染多个节点\n\n那么怎么同时渲染整个列表，比如使用 `v-for` ？在这种场景中，使用  `<transition-group>` 组件。在我们深入例子之前，先了解关于这个组件的几个特点：\n\n- 不同于 `<transition>`， 它会以一个真实元素呈现：默认为一个 `<span>`。你也可以通过 `tag` 特性更换为其他元素。\n- 元素 **一定需要** 指定唯一的 `key` 特性值\n\n### 列表的进入和离开过渡\n\n现在让我们由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。\n\n``` html\n<div id=\"list-demo\" class=\"demo\">\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list\" tag=\"p\">\n    <span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-item\">\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n  }\n})\n```\n\n``` css\n.list-item {\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-enter-active, .list-leave-active {\n  transition: all 1s;\n}\n.list-enter, .list-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n```\n\n{% raw %}\n<div id=\"list-demo\" class=\"demo\">\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list\" tag=\"p\">\n    <span v-for=\"item in items\" :key=\"item\" class=\"list-item\">\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n  }\n})\n</script>\n<style>\n.list-item {\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-enter-active, .list-leave-active {\n  transition: all 1s;\n}\n.list-enter, .list-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n</style>\n{% endraw %}\n\n这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，我们下面会解决这个问题。\n\n\n### 列表的位移过渡\n\n`<transition-group>` 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 ** `v-move`  特性**，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 `name` 属性来自定义前缀，也可以通过 `move-class` 属性手动设置。\n\n`v-move` 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子：\n\n``` html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n\n<div id=\"flip-list-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <transition-group name=\"flip-list\" tag=\"ul\">\n    <li v-for=\"item in items\" v-bind:key=\"item\">\n      {{ item }}\n    </li>\n  </transition-group>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#flip-list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9]\n  },\n  methods: {\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n```\n\n``` css\n.flip-list-move {\n  transition: transform 1s;\n}\n```\n\n{% raw %}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n<div id=\"flip-list-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <transition-group name=\"flip-list\" tag=\"ul\">\n    <li v-for=\"item in items\" :key=\"item\">\n      {{ item }}\n    </li>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#flip-list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9]\n  },\n  methods: {\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n</script>\n<style>\n.flip-list-move {\n  transition: transform 1s;\n}\n</style>\n{% endraw %}\n\n这个看起来很神奇，内部的实现，Vue 使用了一个叫 [FLIP](https://aerotwist.com/blog/flip-your-animations/) 简单的动画队列\n使用 transforms 将元素从之前的位置平滑过渡新的位置。\n\n我们将之前实现的例子和这个技术结合，使我们列表的一切变动都会有动画过渡。\n``` html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n\n<div id=\"list-complete-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list-complete\" tag=\"p\">\n    <span\n      v-for=\"item in items\"\n      v-bind:key=\"item\"\n      class=\"list-complete-item\"\n    >\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#list-complete-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n```\n\n``` css\n.list-complete-item {\n  transition: all 1s;\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-complete-enter, .list-complete-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n.list-complete-leave-active {\n  position: absolute;\n}\n```\n\n{% raw %}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n<div id=\"list-complete-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list-complete\" tag=\"p\">\n    <span v-for=\"item in items\" :key=\"item\" class=\"list-complete-item\">\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#list-complete-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n</script>\n<style>\n.list-complete-item {\n  transition: all 1s;\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-complete-enter, .list-complete-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n.list-complete-leave-active {\n  position: absolute;\n}\n</style>\n{% endraw %}\n\n<p class=\"tip\">需要注意的是使用 FLIP 过渡的元素不能设置为 `display: inline` 。作为替代方案，可以设置为 `display: inline-block` 或者放置于 flex 中</p>\n\nFLIP 动画不仅可以实现单列过渡，多维网格的过渡也同样[简单](https://jsfiddle.net/chrisvfritz/sLrhk1bc/):\n\n{% raw %}\n<div id=\"sudoku-demo\" class=\"demo\">\n  <strong>Lazy Sudoku</strong>\n  <p>Keep hitting the shuffle button until you win.</p>\n  <button @click=\"shuffle\">\n    Shuffle\n  </button>\n  <transition-group name=\"cell\" tag=\"div\" class=\"sudoku-container\">\n    <div v-for=\"cell in cells\" :key=\"cell.id\" class=\"cell\">\n      {{ cell.number }}\n    </div>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#sudoku-demo',\n  data: {\n    cells: Array.apply(null, { length: 81 })\n      .map(function (_, index) {\n        return {\n          id: index,\n          number: index % 9 + 1\n        }\n      })\n  },\n  methods: {\n    shuffle: function () {\n      this.cells = _.shuffle(this.cells)\n    }\n  }\n})\n</script>\n<style>\n.sudoku-container {\n  display: flex;\n  flex-wrap: wrap;\n  width: 238px;\n  margin-top: 10px;\n}\n.cell {\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  width: 25px;\n  height: 25px;\n  border: 1px solid #aaa;\n  margin-right: -1px;\n  margin-bottom: -1px;\n}\n.cell:nth-child(3n) {\n  margin-right: 0;\n}\n.cell:nth-child(27n) {\n  margin-bottom: 0;\n}\n.cell-move {\n  transition: transform 1s;\n}\n</style>\n{% endraw %}\n\n### 列表的渐进过渡\n\n通过 data 属性与 JavaScript 通信 ，就可以实现列表的渐进过渡：\n\n``` html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n\n<div id=\"staggered-list-demo\">\n  <input v-model=\"query\">\n  <transition-group\n    name=\"staggered-fade\"\n    tag=\"ul\"\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <li\n      v-for=\"(item, index) in computedList\"\n      v-bind:key=\"item.msg\"\n      v-bind:data-index=\"index\"\n    >{{ item.msg }}</li>\n  </transition-group>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#staggered-list-demo',\n  data: {\n    query: '',\n    list: [\n      { msg: 'Bruce Lee' },\n      { msg: 'Jackie Chan' },\n      { msg: 'Chuck Norris' },\n      { msg: 'Jet Li' },\n      { msg: 'Kung Fury' }\n    ]\n  },\n  computed: {\n    computedList: function () {\n      var vm = this\n      return this.list.filter(function (item) {\n        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1\n      })\n    }\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.height = 0\n    },\n    enter: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 1, height: '1.6em' },\n          { complete: done }\n        )\n      }, delay)\n    },\n    leave: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 0, height: 0 },\n          { complete: done }\n        )\n      }, delay)\n    }\n  }\n})\n```\n\n{% raw %}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<div id=\"example-5\" class=\"demo\">\n  <input v-model=\"query\">\n  <transition-group\n    name=\"staggered-fade\"\n    tag=\"ul\"\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <li\n      v-for=\"(item, index) in computedList\"\n      v-bind:key=\"item.msg\"\n      v-bind:data-index=\"index\"\n    >{{ item.msg }}</li>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    query: '',\n    list: [\n      { msg: 'Bruce Lee' },\n      { msg: 'Jackie Chan' },\n      { msg: 'Chuck Norris' },\n      { msg: 'Jet Li' },\n      { msg: 'Kung Fury' }\n    ]\n  },\n  computed: {\n    computedList: function () {\n      var vm = this\n      return this.list.filter(function (item) {\n        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1\n      })\n    }\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.height = 0\n    },\n    enter: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 1, height: '1.6em' },\n          { complete: done }\n        )\n      }, delay)\n    },\n    leave: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 0, height: 0 },\n          { complete: done }\n        )\n      }, delay)\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## 可复用的过渡\n\n过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 `<transition>` 或者 `<transition-group>` 作为根组件，然后将任何子组件放置在其中就可以了。\n\n使用 template 的简单例子：\n\n``` js\nVue.component('my-special-transition', {\n  template: '\\\n    <transition\\\n      name=\"very-special-transition\"\\\n      mode=\"out-in\"\\\n      v-on:before-enter=\"beforeEnter\"\\\n      v-on:after-enter=\"afterEnter\"\\\n    >\\\n      <slot></slot>\\\n    </transition>\\\n  ',\n  methods: {\n    beforeEnter: function (el) {\n      // ...\n    },\n    afterEnter: function (el) {\n      // ...\n    }\n  }\n})\n```\n\n函数组件更适合完成这个任务：\n\n``` js\nVue.component('my-special-transition', {\n  functional: true,\n  render: function (createElement, context) {\n    var data = {\n      props: {\n        name: 'very-special-transition'\n        mode: 'out-in'\n      },\n      on: {\n        beforeEnter: function (el) {\n          // ...\n        },\n        afterEnter: function (el) {\n          // ...\n        }\n      }\n    }\n    return createElement('transition', data, context.children)\n  }\n})\n```\n\n## 动态过渡\n\n在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 `name` 特性来绑定动态值。\n\n```html\n<transition v-bind:name=\"transitionName\">\n  <!-- ... -->\n</transition>\n```\n当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用。\n\n所有的过渡特性都是动态绑定。它不仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。这意味着，可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果。\n\n``` html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n\n<div id=\"dynamic-fade-demo\">\n  Fade In: <input type=\"range\" v-model=\"fadeInDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  Fade Out: <input type=\"range\" v-model=\"fadeOutDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  <transition\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n  <button v-on:click=\"stop = true\">Stop it!</button>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#dynamic-fade-demo',\n  data: {\n    show: true,\n    fadeInDuration: 1000,\n    fadeOutDuration: 1000,\n    maxFadeDuration: 1500,\n    stop: false\n  },\n  mounted: function () {\n    this.show = false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n    },\n    enter: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 1 },\n        {\n          duration: this.fadeInDuration,\n          complete: function () {\n            done()\n            if (!vm.stop) vm.show = false\n          }\n        }\n      )\n    },\n    leave: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 0 },\n        {\n          duration: this.fadeOutDuration,\n          complete: function () {\n            done()\n            vm.show = true\n          }\n        }\n      )\n    }\n  }\n})\n```\n\n{% raw %}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<div id=\"dynamic-fade-demo\" class=\"demo\">\n  Fade In: <input type=\"range\" v-model=\"fadeInDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  Fade Out: <input type=\"range\" v-model=\"fadeOutDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  <transition\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n  <button v-on:click=\"stop = true\">Stop it!</button>\n</div>\n<script>\nnew Vue({\n  el: '#dynamic-fade-demo',\n  data: {\n    show: true,\n    fadeInDuration: 1000,\n    fadeOutDuration: 1000,\n    maxFadeDuration: 1500,\n    stop: false\n  },\n  mounted: function () {\n    this.show = false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n    },\n    enter: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 1 },\n        {\n          duration: this.fadeInDuration,\n          complete: function () {\n            done()\n            if (!vm.stop) vm.show = false\n          }\n        }\n      )\n    },\n    leave: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 0 },\n        {\n          duration: this.fadeOutDuration,\n          complete: function () {\n            done()\n            vm.show = true\n          }\n        }\n      )\n    }\n  }\n})\n</script>\n{% endraw %}\n\n最后，创建动态过渡的最终方案是组件通过接受 props 来动态修改之前的过渡。一句老话，唯一的限制是你的想象力。\n\n***\n\n> 原文：http://vuejs.org/guide/transitions.html\n\n***\n\n\n","source":"v2/guide/transitions.md","raw":"---\ntitle: 过渡效果\ntype: guide\norder: 13\n---\n\n## 概述\n\nVue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。\n包括以下工具：\n\n- 在 CSS 过渡和动画中自动应用 class\n- 可以配合使用第三方 CSS 动画库，如 Animate.css\n- 在过渡钩子函数中使用 JavaScript 直接操作 DOM\n- 可以配合使用第三方 JavaScript 动画库，如 Velocity.js\n\n在这里，我们只会讲到进入、离开和列表的过渡， 你也可以看下一节的 [管理过渡状态](transitioning-state.html).\n\n## 单元素/组件的过渡\n\nVue 提供了 `transition` 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡\n\n- 条件渲染 （使用 `v-if`）\n- 条件展示 （使用 `v-show`）\n- 动态组件\n- 组件根节点\n\n这里是一个典型的例子：\n\n``` html\n<div id=\"demo\">\n  <button v-on:click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#demo',\n  data: {\n    show: true\n  }\n})\n```\n\n``` css\n.fade-enter-active, .fade-leave-active {\n  transition: opacity .5s\n}\n.fade-enter, .fade-leave-active {\n  opacity: 0\n}\n```\n\n{% raw %}\n<div id=\"demo\">\n  <button v-on:click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"demo-transition\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#demo',\n  data: {\n    show: true\n  }\n})\n</script>\n<style>\n.demo-transition-enter-active, .demo-transition-leave-active {\n  transition: opacity .5s\n}\n.demo-transition-enter, .demo-transition-leave-active {\n  opacity: 0\n}\n</style>\n{% endraw %}\n\n元素封装成过渡组件之后，在遇到插入或删除时，Vue 将\n\n\n1. 自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。\n\n2. 如果过渡组件设置了过渡的 [JavaScript 钩子函数](#JavaScript-Hooks)，会在相应的阶段调用钩子函数。\n\n3. 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 `nextTick` 概念不同)\n\n\n### 过渡的-CSS-类名\n\n会有 4 个(CSS)类名在 enter/leave 的过渡中切换\n\n1. `v-enter`: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。\n\n2. `v-enter-active`: 定义进入过渡的结束状态。在元素被插入时生效，在 `transition/animation` 完成之后移除。\n\n3. `v-leave`:  定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。\n\n4. `v-leave-active`: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 `transition/animation` 完成之后移除。\n\n\n![Transition Diagram](/images/transition.png)\n\n对于这些在 `enter/leave` 过渡中切换的类名，`v-` 是这些类名的前缀。使用 `<transition name=\"my-transition\">` 可以重置前缀，比如 `v-enter` 替换为 `my-transition-enter`。\n\n`v-enter-active` 和 `v-leave-active` 可以控制 进入/离开 过渡的不同阶段，在下面章节会有个示例说明。\n\n### CSS 过渡\n\n常用的过渡都是使用 CSS 过渡。\n\n下面是一个简单例子：\n\n``` html\n<div id=\"example-1\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition name=\"slide-fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#example-1',\n  data: {\n    show: true\n  }\n})\n```\n\n``` css\n/* 可以设置不同的进入和离开动画 */\n/* 设置持续时间和动画函数 */\n.slide-fade-enter-active {\n  transition: all .3s ease;\n}\n.slide-fade-leave-active {\n  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.slide-fade-enter, .slide-fade-leave-active {\n  transform: translateX(10px);\n  opacity: 0;\n}\n```\n\n{% raw %}\n<div id=\"example-1\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"slide-fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    show: true\n  }\n})\n</script>\n<style>\n.slide-fade-enter-active {\n  transition: all .3s ease;\n}\n.slide-fade-leave-active {\n  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.slide-fade-enter, .slide-fade-leave-active {\n  transform: translateX(10px);\n  opacity: 0;\n}\n</style>\n{% endraw %}\n\n\n### CSS 动画\n\n\nCSS 动画用法同 CSS 过渡，区别是在动画中 `v-enter` 类名在节点插入 DOM 后不会立即删除，而是在 `animationend` 事件触发时删除。\n\n示例： (省略了兼容性前缀)\n\n``` html\n<div id=\"example-2\">\n  <button @click=\"show = !show\">Toggle show</button>\n  <transition name=\"bounce\">\n    <p v-if=\"show\">Look at me!</p>\n  </transition>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#example-2',\n  data: {\n    show: true\n  }\n})\n```\n\n``` css\n.bounce-enter-active {\n  animation: bounce-in .5s;\n}\n.bounce-leave-active {\n  animation: bounce-out .5s;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n@keyframes bounce-out {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(0);\n  }\n}\n```\n\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <button @click=\"show = !show\">Toggle show</button>\n  <transition name=\"bounce\">\n    <p v-show=\"show\">Look at me!</p>\n  </transition>\n</div>\n\n<style>\n  .bounce-enter-active {\n    -webkit-animation: bounce-in .5s;\n    animation: bounce-in .5s;\n  }\n  .bounce-leave-active {\n    -webkit-animation: bounce-out .5s;\n    animation: bounce-out .5s;\n  }\n  @keyframes bounce-in {\n    0% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n  }\n  @keyframes bounce-out {\n    0% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n  }\n  @-webkit-keyframes bounce-in {\n    0% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n  }\n  @-webkit-keyframes bounce-out {\n    0% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n  }\n</style>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    show: true\n  }\n})\n</script>\n{% endraw %}\n\n\n### 自定义过渡类名\n\n我们可以通过以下特性来自定义过渡类名：\n\n- `enter-class`\n- `enter-active-class`\n- `leave-class`\n- `leave-active-class`\n\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 [Animate.css](https://daneden.github.io/animate.css/) 结合使用十分有用。\n\n示例：\n\n``` html\n<link href=\"https://unpkg.com/animate.css@3.5.1/animate.min.css\" rel=\"stylesheet\" type=\"text/css\">\n\n<div id=\"example-3\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition\n    name=\"custom-classes-transition\"\n    enter-active-class=\"animated tada\"\n    leave-active-class=\"animated bounceOutRight\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#example-3',\n  data: {\n    show: true\n  }\n})\n```\n\n{% raw %}\n<link href=\"https://unpkg.com/animate.css@3.5.1\" rel=\"stylesheet\" type=\"text/css\">\n<div id=\"example-3\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition\n    name=\"custom-classes-transition\"\n    enter-active-class=\"animated tada\"\n    leave-active-class=\"animated bounceOutRight\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    show: true\n  }\n})\n</script>\n{% endraw %}\n\n\n### 同时使用 Transitions 和 Animations\n\nVue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 `transitionend` 或 `animationend` ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。\n\n但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 `animation` 很快的被触发并完成了，而 `transition` 效果还没结束。在这种情况中，你就需要使用 `type` 特性并设置 `animation` 或 `transition` 来明确声明你需要 Vue 监听的类型。\n\n### JavaScript 钩子\n\n可以在属性中声明 JavaScript 钩子\n\n``` html\n<transition\n  v-on:before-enter=\"beforeEnter\"\n  v-on:enter=\"enter\"\n  v-on:after-enter=\"afterEnter\"\n  v-on:enter-cancelled=\"enterCancelled\"\n\n  v-on:before-leave=\"beforeLeave\"\n  v-on:leave=\"leave\"\n  v-on:after-leave=\"afterLeave\"\n  v-on:leave-cancelled=\"leaveCancelled\"\n>\n  <!-- ... -->\n</transition>\n```\n\n``` js\n// ...\nmethods: {\n  // --------\n  // 进入中\n  // --------\n\n  beforeEnter: function (el) {\n    // ...\n  },\n  // 此回调函数是可选项的设置\n  // 与 CSS 结合时使用\n  enter: function (el, done) {\n    // ...\n    done()\n  },\n  afterEnter: function (el) {\n    // ...\n  },\n  enterCancelled: function (el) {\n    // ...\n  },\n\n  // --------\n  // 离开时\n  // --------\n\n  beforeLeave: function (el) {\n    // ...\n  },\n  // 此回调函数是可选项的设置\n  // 与 CSS 结合时使用\n  leave: function (el, done) {\n    // ...\n    done()\n  },\n  afterLeave: function (el) {\n    // ...\n  },\n  // leaveCancelled 只用于 v-show 中\n  leaveCancelled: function (el) {\n    // ...\n  }\n}\n```\n\n这些钩子函数可以结合 CSS `transitions/animations` 使用，也可以单独使用。\n\n<p class=\"tip\">当只用 JavaScript 过渡的时候， ** 在 `enter` 和 `leave` 中，回调函数 `done` 是必须的 **。 否则，它们会被同步调用，过渡会立即完成。</p>\n\n<p class=\"tip\">推荐对于仅使用 JavaScript 过渡的元素添加 `v-bind:css=\"false\"`，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>\n\n一个使用 Velocity.js 的简单例子：\n\n``` html\n<!--\nVelocity works very much like jQuery.animate and is\na great option for JavaScript animations\n-->\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n\n<div id=\"example-4\">\n  <button @click=\"show = !show\">\n    Toggle\n  </button>\n  <transition\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n    v-bind:css=\"false\"\n  >\n    <p v-if=\"show\">\n      Demo\n    </p>\n  </transition>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#example-4',\n  data: {\n    show: false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.transformOrigin = 'left'\n    },\n    enter: function (el, done) {\n      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })\n      Velocity(el, { fontSize: '1em' }, { complete: done })\n    },\n    leave: function (el, done) {\n      Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })\n      Velocity(el, { rotateZ: '100deg' }, { loop: 2 })\n      Velocity(el, {\n        rotateZ: '45deg',\n        translateY: '30px',\n        translateX: '30px',\n        opacity: 0\n      }, { complete: done })\n    }\n  }\n})\n```\n\n{% raw %}\n<div id=\"example-4\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle\n  </button>\n  <transition\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <p v-if=\"show\">\n      Demo\n    </p>\n  </transition>\n</div>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    show: false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.transformOrigin = 'left'\n    },\n    enter: function (el, done) {\n      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })\n      Velocity(el, { fontSize: '1em' }, { complete: done })\n    },\n    leave: function (el, done) {\n      Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })\n      Velocity(el, { rotateZ: '100deg' }, { loop: 2 })\n      Velocity(el, {\n        rotateZ: '45deg',\n        translateY: '30px',\n        translateX: '30px',\n        opacity: 0\n      }, { complete: done })\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## 初始渲染的过渡\n\n可以通过 `appear` 特性设置节点的在初始渲染的过渡\n\n``` html\n<transition appear>\n  <!-- ... -->\n</transition>\n```\n\n这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。\n\n``` html\n<transition\n  appear\n  appear-class=\"custom-appear-class\"\n  appear-active-class=\"custom-appear-active-class\"\n>\n  <!-- ... -->\n</transition>\n```\n\n自定义 JavaScript 钩子： \n\n``` html\n<transition\n  appear\n  v-on:before-appear=\"customBeforeAppearHook\"\n  v-on:appear=\"customAppearHook\"\n  v-on:after-appear=\"customAfterAppearHook\"\n>\n  <!-- ... -->\n</transition>\n```\n\n## 多个元素的过渡\n\n我们之后讨论 [多个组件的过渡](#多个组件的过渡), 对于原生标签可以使用 `v-if`/`v-else` 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：\n\n``` html\n<transition>\n  <table v-if=\"items.length > 0\">\n    <!-- ... -->\n  </table>\n  <p v-else>Sorry, no items found.</p>\n</transition>\n```\n\n可以这样使用，但是有一点需要注意：\n\n<p class=\"tip\">当有**相同标签名**的元素切换时，需要通过 `key` 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，**给在 `<transition>` 组件中的多个元素设置 key  是一个更好的实践。**</p>\n\n示例:\n\n``` html\n<transition>\n  <button v-if=\"isEditing\" key=\"save\">\n    Save\n  </button>\n  <button v-else key=\"edit\">\n    Edit\n  </button>\n</transition>\n```\n\n在一些场景中，也可以给通过给同一个元素的 `key` 特性设置不同的状态来代替 `v-if` 和 `v-else`，上面的例子可以重写为：\n\n``` html\n<transition>\n  <button v-bind:key=\"isEditing\">\n    {{ isEditing ? 'Save' : 'Edit' }}\n  </button>\n</transition>\n```\n\n使用多个 `v-if` 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。 例如：\n\n``` html\n<transition>\n  <button v-if=\"docState === 'saved'\" key=\"saved\">\n    Edit\n  </button>\n  <button v-if=\"docState === 'edited'\" key=\"edited\">\n    Save\n  </button>\n  <button v-if=\"docState === 'editing'\" key=\"editing\">\n    Cancel\n  </button>\n</transition>\n```\n\n可以重写为：\n\n``` html\n<transition>\n  <button v-bind:key=\"docState\">\n    {{ buttonMessage }}\n  </button>\n</transition>\n```\n\n``` js\n// ...\ncomputed: {\n  buttonMessage: function () {\n    switch (docState) {\n      case 'saved': return 'Edit'\n      case 'edited': return 'Save'\n      case 'editing': return 'Cancel'\n    }\n  }\n}\n```\n\n### 过渡模式\n\n这里还有一个问题，试着点击下面的按钮：\n\n{% raw %}\n<div id=\"no-mode-demo\" class=\"demo\">\n  <transition name=\"no-mode-fade\">\n    <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n      on\n    </button>\n    <button v-else key=\"off\" @click=\"on = true\">\n      off\n    </button>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-fade-enter-active, .no-mode-fade-leave-active {\n  transition: opacity .5s\n}\n.no-mode-fade-enter, .no-mode-fade-leave-active {\n  opacity: 0\n}\n</style>\n{% endraw %}\n\n在 \"on\" 按钮和 \"off\" 按钮的过渡中，两个按钮都被重绘了，一个离开过渡的时候另一个开始进入过渡。这是 `<transition>` 的默认行为 - 进入和离开同时发生。\n\n在元素绝对定位在彼此之上的时候运行正常：\n\n{% raw %}\n<div id=\"no-mode-absolute-demo\" class=\"demo\">\n  <div class=\"no-mode-absolute-demo-wrapper\">\n    <transition name=\"no-mode-absolute-fade\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-absolute-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-absolute-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.no-mode-absolute-demo-wrapper button {\n  position: absolute;\n}\n.no-mode-absolute-fade-enter-active, .no-mode-absolute-fade-leave-active {\n  transition: opacity .5s;\n}\n.no-mode-absolute-fade-enter, .no-mode-absolute-fade-leave-active {\n  opacity: 0;\n}\n</style>\n{% endraw %}\n\n然后，我们加上 translate 让它们运动像滑动过渡：\n\n{% raw %}\n<div id=\"no-mode-translate-demo\" class=\"demo\">\n  <div class=\"no-mode-translate-demo-wrapper\">\n    <transition name=\"no-mode-translate-fade\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-translate-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-translate-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.no-mode-translate-demo-wrapper button {\n  position: absolute;\n}\n.no-mode-translate-fade-enter-active, .no-mode-translate-fade-leave-active {\n  transition: all 1s;\n}\n.no-mode-translate-fade-enter, .no-mode-translate-fade-leave-active {\n  opacity: 0;\n}\n.no-mode-translate-fade-enter {\n  transform: translateX(31px);\n}\n.no-mode-translate-fade-leave-active {\n  transform: translateX(-31px);\n}\n</style>\n{% endraw %}\n\n同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 **过渡模式**\n\n\n- `in-out`: 新元素先进行过渡，完成之后当前元素过渡离开。\n\n- `out-in`: 当前元素先进行过渡，完成之后新元素过渡进入。\n\n用 `out-in` 重写之前的开关按钮过渡：\n\n``` html\n<transition name=\"fade\" mode=\"out-in\">\n  <!-- ... the buttons ... -->\n</transition>\n```\n\n{% raw %}\n<div id=\"with-mode-demo\" class=\"demo\">\n  <transition name=\"with-mode-fade\" mode=\"out-in\">\n    <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n      on\n    </button>\n    <button v-else key=\"off\" @click=\"on = true\">\n      off\n    </button>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#with-mode-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.with-mode-fade-enter-active, .with-mode-fade-leave-active {\n  transition: opacity .5s\n}\n.with-mode-fade-enter, .with-mode-fade-leave-active {\n  opacity: 0\n}\n</style>\n{% endraw %}\n\n只用添加一个简单的特性，就解决了之前的过渡问题而无需任何额外的代码。\n\n`in-out` 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。\n将之前滑动淡出的例子结合：\n\n\n{% raw %}\n<div id=\"in-out-translate-demo\" class=\"demo\">\n  <div class=\"in-out-translate-demo-wrapper\">\n    <transition name=\"in-out-translate-fade\" mode=\"in-out\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#in-out-translate-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.in-out-translate-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.in-out-translate-demo-wrapper button {\n  position: absolute;\n}\n.in-out-translate-fade-enter-active, .in-out-translate-fade-leave-active {\n  transition: all .5s;\n}\n.in-out-translate-fade-enter, .in-out-translate-fade-leave-active {\n  opacity: 0;\n}\n.in-out-translate-fade-enter {\n  transform: translateX(31px);\n}\n.in-out-translate-fade-leave-active {\n  transform: translateX(-31px);\n}\n</style>\n{% endraw %}\n\n很酷吧？\n\n## 多个组件的过渡\n\n多个组件的过渡很简单很多 - 我们不需要使用 `key` 特性。相反，我们只需要使用[动态组件](components.html#动态组件):\n\n\n``` html\n<transition name=\"component-fade\" mode=\"out-in\">\n  <component v-bind:is=\"view\"></component>\n</transition>\n```\n\n``` js\nnew Vue({\n  el: '#transition-components-demo',\n  data: {\n    view: 'v-a'\n  },\n  components: {\n    'v-a': {\n      template: '<div>Component A</div>'\n    },\n    'v-b': {\n      template: '<div>Component B</div>'\n    }\n  }\n})\n```\n\n``` css\n.component-fade-enter-active, .component-fade-leave-active {\n  transition: opacity .3s ease;\n}\n.component-fade-enter, .component-fade-leave-active {\n  opacity: 0;\n}\n```\n\n{% raw %}\n<div id=\"transition-components-demo\" class=\"demo\">\n  <input v-model=\"view\" type=\"radio\" value=\"v-a\" id=\"a\" name=\"view\"><label for=\"a\">A</label>\n  <input v-model=\"view\" type=\"radio\" value=\"v-b\" id=\"b\" name=\"view\"><label for=\"b\">B</label>\n  <transition name=\"component-fade\" mode=\"out-in\">\n    <component v-bind:is=\"view\"></component>\n  </transition>\n</div>\n<style>\n.component-fade-enter-active, .component-fade-leave-active {\n  transition: opacity .3s ease;\n}\n.component-fade-enter, .component-fade-leave-active {\n  opacity: 0;\n}\n</style>\n<script>\nnew Vue({\n  el: '#transition-components-demo',\n  data: {\n    view: 'v-a'\n  },\n  components: {\n    'v-a': {\n      template: '<div>Component A</div>'\n    },\n    'v-b': {\n      template: '<div>Component B</div>'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## 列表过渡\n\n目前为止，关于过渡我们已经讲到：\n\n- 单个节点\n- 一次渲染多个节点\n\n那么怎么同时渲染整个列表，比如使用 `v-for` ？在这种场景中，使用  `<transition-group>` 组件。在我们深入例子之前，先了解关于这个组件的几个特点：\n\n- 不同于 `<transition>`， 它会以一个真实元素呈现：默认为一个 `<span>`。你也可以通过 `tag` 特性更换为其他元素。\n- 元素 **一定需要** 指定唯一的 `key` 特性值\n\n### 列表的进入和离开过渡\n\n现在让我们由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。\n\n``` html\n<div id=\"list-demo\" class=\"demo\">\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list\" tag=\"p\">\n    <span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-item\">\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n  }\n})\n```\n\n``` css\n.list-item {\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-enter-active, .list-leave-active {\n  transition: all 1s;\n}\n.list-enter, .list-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n```\n\n{% raw %}\n<div id=\"list-demo\" class=\"demo\">\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list\" tag=\"p\">\n    <span v-for=\"item in items\" :key=\"item\" class=\"list-item\">\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n  }\n})\n</script>\n<style>\n.list-item {\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-enter-active, .list-leave-active {\n  transition: all 1s;\n}\n.list-enter, .list-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n</style>\n{% endraw %}\n\n这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，我们下面会解决这个问题。\n\n\n### 列表的位移过渡\n\n`<transition-group>` 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 ** `v-move`  特性**，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 `name` 属性来自定义前缀，也可以通过 `move-class` 属性手动设置。\n\n`v-move` 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子：\n\n``` html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n\n<div id=\"flip-list-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <transition-group name=\"flip-list\" tag=\"ul\">\n    <li v-for=\"item in items\" v-bind:key=\"item\">\n      {{ item }}\n    </li>\n  </transition-group>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#flip-list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9]\n  },\n  methods: {\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n```\n\n``` css\n.flip-list-move {\n  transition: transform 1s;\n}\n```\n\n{% raw %}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n<div id=\"flip-list-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <transition-group name=\"flip-list\" tag=\"ul\">\n    <li v-for=\"item in items\" :key=\"item\">\n      {{ item }}\n    </li>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#flip-list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9]\n  },\n  methods: {\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n</script>\n<style>\n.flip-list-move {\n  transition: transform 1s;\n}\n</style>\n{% endraw %}\n\n这个看起来很神奇，内部的实现，Vue 使用了一个叫 [FLIP](https://aerotwist.com/blog/flip-your-animations/) 简单的动画队列\n使用 transforms 将元素从之前的位置平滑过渡新的位置。\n\n我们将之前实现的例子和这个技术结合，使我们列表的一切变动都会有动画过渡。\n``` html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n\n<div id=\"list-complete-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list-complete\" tag=\"p\">\n    <span\n      v-for=\"item in items\"\n      v-bind:key=\"item\"\n      class=\"list-complete-item\"\n    >\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#list-complete-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n```\n\n``` css\n.list-complete-item {\n  transition: all 1s;\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-complete-enter, .list-complete-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n.list-complete-leave-active {\n  position: absolute;\n}\n```\n\n{% raw %}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n<div id=\"list-complete-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list-complete\" tag=\"p\">\n    <span v-for=\"item in items\" :key=\"item\" class=\"list-complete-item\">\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#list-complete-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n</script>\n<style>\n.list-complete-item {\n  transition: all 1s;\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-complete-enter, .list-complete-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n.list-complete-leave-active {\n  position: absolute;\n}\n</style>\n{% endraw %}\n\n<p class=\"tip\">需要注意的是使用 FLIP 过渡的元素不能设置为 `display: inline` 。作为替代方案，可以设置为 `display: inline-block` 或者放置于 flex 中</p>\n\nFLIP 动画不仅可以实现单列过渡，多维网格的过渡也同样[简单](https://jsfiddle.net/chrisvfritz/sLrhk1bc/):\n\n{% raw %}\n<div id=\"sudoku-demo\" class=\"demo\">\n  <strong>Lazy Sudoku</strong>\n  <p>Keep hitting the shuffle button until you win.</p>\n  <button @click=\"shuffle\">\n    Shuffle\n  </button>\n  <transition-group name=\"cell\" tag=\"div\" class=\"sudoku-container\">\n    <div v-for=\"cell in cells\" :key=\"cell.id\" class=\"cell\">\n      {{ cell.number }}\n    </div>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#sudoku-demo',\n  data: {\n    cells: Array.apply(null, { length: 81 })\n      .map(function (_, index) {\n        return {\n          id: index,\n          number: index % 9 + 1\n        }\n      })\n  },\n  methods: {\n    shuffle: function () {\n      this.cells = _.shuffle(this.cells)\n    }\n  }\n})\n</script>\n<style>\n.sudoku-container {\n  display: flex;\n  flex-wrap: wrap;\n  width: 238px;\n  margin-top: 10px;\n}\n.cell {\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  width: 25px;\n  height: 25px;\n  border: 1px solid #aaa;\n  margin-right: -1px;\n  margin-bottom: -1px;\n}\n.cell:nth-child(3n) {\n  margin-right: 0;\n}\n.cell:nth-child(27n) {\n  margin-bottom: 0;\n}\n.cell-move {\n  transition: transform 1s;\n}\n</style>\n{% endraw %}\n\n### 列表的渐进过渡\n\n通过 data 属性与 JavaScript 通信 ，就可以实现列表的渐进过渡：\n\n``` html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n\n<div id=\"staggered-list-demo\">\n  <input v-model=\"query\">\n  <transition-group\n    name=\"staggered-fade\"\n    tag=\"ul\"\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <li\n      v-for=\"(item, index) in computedList\"\n      v-bind:key=\"item.msg\"\n      v-bind:data-index=\"index\"\n    >{{ item.msg }}</li>\n  </transition-group>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#staggered-list-demo',\n  data: {\n    query: '',\n    list: [\n      { msg: 'Bruce Lee' },\n      { msg: 'Jackie Chan' },\n      { msg: 'Chuck Norris' },\n      { msg: 'Jet Li' },\n      { msg: 'Kung Fury' }\n    ]\n  },\n  computed: {\n    computedList: function () {\n      var vm = this\n      return this.list.filter(function (item) {\n        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1\n      })\n    }\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.height = 0\n    },\n    enter: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 1, height: '1.6em' },\n          { complete: done }\n        )\n      }, delay)\n    },\n    leave: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 0, height: 0 },\n          { complete: done }\n        )\n      }, delay)\n    }\n  }\n})\n```\n\n{% raw %}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<div id=\"example-5\" class=\"demo\">\n  <input v-model=\"query\">\n  <transition-group\n    name=\"staggered-fade\"\n    tag=\"ul\"\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <li\n      v-for=\"(item, index) in computedList\"\n      v-bind:key=\"item.msg\"\n      v-bind:data-index=\"index\"\n    >{{ item.msg }}</li>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    query: '',\n    list: [\n      { msg: 'Bruce Lee' },\n      { msg: 'Jackie Chan' },\n      { msg: 'Chuck Norris' },\n      { msg: 'Jet Li' },\n      { msg: 'Kung Fury' }\n    ]\n  },\n  computed: {\n    computedList: function () {\n      var vm = this\n      return this.list.filter(function (item) {\n        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1\n      })\n    }\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.height = 0\n    },\n    enter: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 1, height: '1.6em' },\n          { complete: done }\n        )\n      }, delay)\n    },\n    leave: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 0, height: 0 },\n          { complete: done }\n        )\n      }, delay)\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## 可复用的过渡\n\n过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 `<transition>` 或者 `<transition-group>` 作为根组件，然后将任何子组件放置在其中就可以了。\n\n使用 template 的简单例子：\n\n``` js\nVue.component('my-special-transition', {\n  template: '\\\n    <transition\\\n      name=\"very-special-transition\"\\\n      mode=\"out-in\"\\\n      v-on:before-enter=\"beforeEnter\"\\\n      v-on:after-enter=\"afterEnter\"\\\n    >\\\n      <slot></slot>\\\n    </transition>\\\n  ',\n  methods: {\n    beforeEnter: function (el) {\n      // ...\n    },\n    afterEnter: function (el) {\n      // ...\n    }\n  }\n})\n```\n\n函数组件更适合完成这个任务：\n\n``` js\nVue.component('my-special-transition', {\n  functional: true,\n  render: function (createElement, context) {\n    var data = {\n      props: {\n        name: 'very-special-transition'\n        mode: 'out-in'\n      },\n      on: {\n        beforeEnter: function (el) {\n          // ...\n        },\n        afterEnter: function (el) {\n          // ...\n        }\n      }\n    }\n    return createElement('transition', data, context.children)\n  }\n})\n```\n\n## 动态过渡\n\n在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 `name` 特性来绑定动态值。\n\n```html\n<transition v-bind:name=\"transitionName\">\n  <!-- ... -->\n</transition>\n```\n当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用。\n\n所有的过渡特性都是动态绑定。它不仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。这意味着，可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果。\n\n``` html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n\n<div id=\"dynamic-fade-demo\">\n  Fade In: <input type=\"range\" v-model=\"fadeInDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  Fade Out: <input type=\"range\" v-model=\"fadeOutDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  <transition\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n  <button v-on:click=\"stop = true\">Stop it!</button>\n</div>\n```\n\n``` js\nnew Vue({\n  el: '#dynamic-fade-demo',\n  data: {\n    show: true,\n    fadeInDuration: 1000,\n    fadeOutDuration: 1000,\n    maxFadeDuration: 1500,\n    stop: false\n  },\n  mounted: function () {\n    this.show = false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n    },\n    enter: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 1 },\n        {\n          duration: this.fadeInDuration,\n          complete: function () {\n            done()\n            if (!vm.stop) vm.show = false\n          }\n        }\n      )\n    },\n    leave: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 0 },\n        {\n          duration: this.fadeOutDuration,\n          complete: function () {\n            done()\n            vm.show = true\n          }\n        }\n      )\n    }\n  }\n})\n```\n\n{% raw %}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<div id=\"dynamic-fade-demo\" class=\"demo\">\n  Fade In: <input type=\"range\" v-model=\"fadeInDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  Fade Out: <input type=\"range\" v-model=\"fadeOutDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  <transition\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n  <button v-on:click=\"stop = true\">Stop it!</button>\n</div>\n<script>\nnew Vue({\n  el: '#dynamic-fade-demo',\n  data: {\n    show: true,\n    fadeInDuration: 1000,\n    fadeOutDuration: 1000,\n    maxFadeDuration: 1500,\n    stop: false\n  },\n  mounted: function () {\n    this.show = false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n    },\n    enter: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 1 },\n        {\n          duration: this.fadeInDuration,\n          complete: function () {\n            done()\n            if (!vm.stop) vm.show = false\n          }\n        }\n      )\n    },\n    leave: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 0 },\n        {\n          duration: this.fadeOutDuration,\n          complete: function () {\n            done()\n            vm.show = true\n          }\n        }\n      )\n    }\n  }\n})\n</script>\n{% endraw %}\n\n最后，创建动态过渡的最终方案是组件通过接受 props 来动态修改之前的过渡。一句老话，唯一的限制是你的想象力。\n\n***\n\n> 原文：http://vuejs.org/guide/transitions.html\n\n***\n\n\n","date":"2016-12-12T14:00:24.000Z","updated":"2016-12-11T12:20:30.000Z","path":"v2/guide/transitions.html","comments":1,"layout":"page","_id":"ciwnajuz6001wjl2dw1mq8nq0","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。<br>包括以下工具：</p>\n<ul>\n<li>在 CSS 过渡和动画中自动应用 class</li>\n<li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>\n<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>\n<li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>\n</ul>\n<p>在这里，我们只会讲到进入、离开和列表的过渡， 你也可以看下一节的 <a href=\"transitioning-state.html\">管理过渡状态</a>.</p>\n<h2 id=\"单元素-组件的过渡\"><a href=\"#单元素-组件的过渡\" class=\"headerlink\" title=\"单元素/组件的过渡\"></a>单元素/组件的过渡</h2><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡</p>\n<ul>\n<li>条件渲染 （使用 <code>v-if</code>）</li>\n<li>条件展示 （使用 <code>v-show</code>）</li>\n<li>动态组件</li>\n<li>组件根节点</li>\n</ul>\n<p>这里是一个典型的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"show = !show\"</span>&gt;</span></div><div class=\"line\">    Toggle</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.fade-enter-active</span>, <span class=\"selector-class\">.fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: opacity .<span class=\"number\">5s</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.fade-enter</span>, <span class=\"selector-class\">.fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div id=\"demo\">\n  <button v-on:click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"demo-transition\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#demo',\n  data: {\n    show: true\n  }\n})\n</script>\n<style>\n.demo-transition-enter-active, .demo-transition-leave-active {\n  transition: opacity .5s\n}\n.demo-transition-enter, .demo-transition-leave-active {\n  opacity: 0\n}\n</style>\n\n<p>元素封装成过渡组件之后，在遇到插入或删除时，Vue 将</p>\n<ol>\n<li><p>自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。</p>\n</li>\n<li><p>如果过渡组件设置了过渡的 <a href=\"#JavaScript-Hooks\">JavaScript 钩子函数</a>，会在相应的阶段调用钩子函数。</p>\n</li>\n<li><p>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 <code>nextTick</code> 概念不同)</p>\n</li>\n</ol>\n<h3 id=\"过渡的-CSS-类名\"><a href=\"#过渡的-CSS-类名\" class=\"headerlink\" title=\"过渡的-CSS-类名\"></a>过渡的-CSS-类名</h3><p>会有 4 个(CSS)类名在 enter/leave 的过渡中切换</p>\n<ol>\n<li><p><code>v-enter</code>: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</p>\n</li>\n<li><p><code>v-enter-active</code>: 定义进入过渡的结束状态。在元素被插入时生效，在 <code>transition/animation</code> 完成之后移除。</p>\n</li>\n<li><p><code>v-leave</code>:  定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</p>\n</li>\n<li><p><code>v-leave-active</code>: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 <code>transition/animation</code> 完成之后移除。</p>\n</li>\n</ol>\n<p><img src=\"/images/transition.png\" alt=\"Transition Diagram\"></p>\n<p>对于这些在 <code>enter/leave</code> 过渡中切换的类名，<code>v-</code> 是这些类名的前缀。使用 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code> 可以重置前缀，比如 <code>v-enter</code> 替换为 <code>my-transition-enter</code>。</p>\n<p><code>v-enter-active</code> 和 <code>v-leave-active</code> 可以控制 进入/离开 过渡的不同阶段，在下面章节会有个示例说明。</p>\n<h3 id=\"CSS-过渡\"><a href=\"#CSS-过渡\" class=\"headerlink\" title=\"CSS 过渡\"></a>CSS 过渡</h3><p>常用的过渡都是使用 CSS 过渡。</p>\n<p>下面是一个简单例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-1\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"show = !show\"</span>&gt;</span></div><div class=\"line\">    Toggle render</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"slide-fade\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-1'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 可以设置不同的进入和离开动画 */</span></div><div class=\"line\"><span class=\"comment\">/* 设置持续时间和动画函数 */</span></div><div class=\"line\"><span class=\"selector-class\">.slide-fade-enter-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">3s</span> ease;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.slide-fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">8s</span> <span class=\"built_in\">cubic-bezier</span>(1.0, 0.5, 0.8, 1.0);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.slide-fade-enter</span>, <span class=\"selector-class\">.slide-fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(10px);</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div id=\"example-1\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"slide-fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    show: true\n  }\n})\n</script>\n<style>\n.slide-fade-enter-active {\n  transition: all .3s ease;\n}\n.slide-fade-leave-active {\n  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.slide-fade-enter, .slide-fade-leave-active {\n  transform: translateX(10px);\n  opacity: 0;\n}\n</style>\n\n<h3 id=\"CSS-动画\"><a href=\"#CSS-动画\" class=\"headerlink\" title=\"CSS 动画\"></a>CSS 动画</h3><p>CSS 动画用法同 CSS 过渡，区别是在动画中 <code>v-enter</code> 类名在节点插入 DOM 后不会立即删除，而是在 <code>animationend</code> 事件触发时删除。</p>\n<p>示例： (省略了兼容性前缀)</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"show = !show\"</span>&gt;</span>Toggle show<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"bounce\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>Look at me!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-2'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.bounce-enter-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">animation</span>: bounce-in .<span class=\"number\">5s</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.bounce-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">animation</span>: bounce-out .<span class=\"number\">5s</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">@<span class=\"keyword\">keyframes</span> bounce-in &#123;</div><div class=\"line\">  0% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0);</div><div class=\"line\">  &#125;</div><div class=\"line\">  50% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(1.5);</div><div class=\"line\">  &#125;</div><div class=\"line\">  100% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(1);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@<span class=\"keyword\">keyframes</span> bounce-out &#123;</div><div class=\"line\">  0% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(1);</div><div class=\"line\">  &#125;</div><div class=\"line\">  50% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(1.5);</div><div class=\"line\">  &#125;</div><div class=\"line\">  100% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div id=\"example-2\" class=\"demo\">\n  <button @click=\"show = !show\">Toggle show</button>\n  <transition name=\"bounce\">\n    <p v-show=\"show\">Look at me!</p>\n  </transition>\n</div>\n\n<style>\n  .bounce-enter-active {\n    -webkit-animation: bounce-in .5s;\n    animation: bounce-in .5s;\n  }\n  .bounce-leave-active {\n    -webkit-animation: bounce-out .5s;\n    animation: bounce-out .5s;\n  }\n  @keyframes bounce-in {\n    0% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n  }\n  @keyframes bounce-out {\n    0% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n  }\n  @-webkit-keyframes bounce-in {\n    0% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n  }\n  @-webkit-keyframes bounce-out {\n    0% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n  }\n</style>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    show: true\n  }\n})\n</script>\n\n<h3 id=\"自定义过渡类名\"><a href=\"#自定义过渡类名\" class=\"headerlink\" title=\"自定义过渡类名\"></a>自定义过渡类名</h3><p>我们可以通过以下特性来自定义过渡类名：</p>\n<ul>\n<li><code>enter-class</code></li>\n<li><code>enter-active-class</code></li>\n<li><code>leave-class</code></li>\n<li><code>leave-active-class</code></li>\n</ul>\n<p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 <a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\" rel=\"external\">Animate.css</a> 结合使用十分有用。</p>\n<p>示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://unpkg.com/animate.css@3.5.1/animate.min.css\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-3\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"show = !show\"</span>&gt;</span></div><div class=\"line\">    Toggle render</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span></span></div><div class=\"line\">    <span class=\"attr\">name</span>=<span class=\"string\">\"custom-classes-transition\"</span></div><div class=\"line\">    <span class=\"attr\">enter-active-class</span>=<span class=\"string\">\"animated tada\"</span></div><div class=\"line\">    <span class=\"attr\">leave-active-class</span>=<span class=\"string\">\"animated bounceOutRight\"</span></div><div class=\"line\">  &gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-3'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<link href=\"https://unpkg.com/animate.css@3.5.1\" rel=\"stylesheet\" type=\"text/css\">\n<div id=\"example-3\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition name=\"custom-classes-transition\" enter-active-class=\"animated tada\" leave-active-class=\"animated bounceOutRight\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    show: true\n  }\n})\n</script>\n\n<h3 id=\"同时使用-Transitions-和-Animations\"><a href=\"#同时使用-Transitions-和-Animations\" class=\"headerlink\" title=\"同时使用 Transitions 和 Animations\"></a>同时使用 Transitions 和 Animations</h3><p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 <code>transitionend</code> 或 <code>animationend</code> ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p>\n<p>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 <code>animation</code> 很快的被触发并完成了，而 <code>transition</code> 效果还没结束。在这种情况中，你就需要使用 <code>type</code> 特性并设置 <code>animation</code> 或 <code>transition</code> 来明确声明你需要 Vue 监听的类型。</p>\n<h3 id=\"JavaScript-钩子\"><a href=\"#JavaScript-钩子\" class=\"headerlink\" title=\"JavaScript 钩子\"></a>JavaScript 钩子</h3><p>可以在属性中声明 JavaScript 钩子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></span></div><div class=\"line\">  <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:after-enter</span>=<span class=\"string\">\"afterEnter\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:enter-cancelled</span>=<span class=\"string\">\"enterCancelled\"</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">v-on:before-leave</span>=<span class=\"string\">\"beforeLeave\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:after-leave</span>=<span class=\"string\">\"afterLeave\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:leave-cancelled</span>=<span class=\"string\">\"leaveCancelled\"</span></div><div class=\"line\">&gt;</div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"comment\">// --------</span></div><div class=\"line\">  <span class=\"comment\">// 进入中</span></div><div class=\"line\">  <span class=\"comment\">// --------</span></div><div class=\"line\"></div><div class=\"line\">  beforeEnter: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 此回调函数是可选项的设置</span></div><div class=\"line\">  <span class=\"comment\">// 与 CSS 结合时使用</span></div><div class=\"line\">  enter: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    done()</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">afterEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">enterCancelled</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// --------</span></div><div class=\"line\">  <span class=\"comment\">// 离开时</span></div><div class=\"line\">  <span class=\"comment\">// --------</span></div><div class=\"line\"></div><div class=\"line\">  beforeLeave: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 此回调函数是可选项的设置</span></div><div class=\"line\">  <span class=\"comment\">// 与 CSS 结合时使用</span></div><div class=\"line\">  leave: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    done()</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">afterLeave</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// leaveCancelled 只用于 v-show 中</span></div><div class=\"line\">  leaveCancelled: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这些钩子函数可以结合 CSS <code>transitions/animations</code> 使用，也可以单独使用。</p>\n<p class=\"tip\">当只用 JavaScript 过渡的时候， <strong> 在 <code>enter</code> 和 <code>leave</code> 中，回调函数 <code>done</code> 是必须的 </strong>。 否则，它们会被同步调用，过渡会立即完成。</p>\n\n<p class=\"tip\">推荐对于仅使用 JavaScript 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>\n\n<p>一个使用 Velocity.js 的简单例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!--</span></div><div class=\"line\">Velocity works very much like jQuery.animate and is</div><div class=\"line\">a great option for JavaScript animations</div><div class=\"line\">--&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-4\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"show = !show\"</span>&gt;</span></div><div class=\"line\">    Toggle</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span></span></div><div class=\"line\">    <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></div><div class=\"line\">    <span class=\"attr\">v-bind:css</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">  &gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span></div><div class=\"line\">      Demo</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-4'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">beforeEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      el.style.opacity = <span class=\"number\">0</span></div><div class=\"line\">      el.style.transformOrigin = <span class=\"string\">'left'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">enter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      Velocity(el, &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">1</span>, <span class=\"attr\">fontSize</span>: <span class=\"string\">'1.4em'</span> &#125;, &#123; <span class=\"attr\">duration</span>: <span class=\"number\">300</span> &#125;)</div><div class=\"line\">      Velocity(el, &#123; <span class=\"attr\">fontSize</span>: <span class=\"string\">'1em'</span> &#125;, &#123; <span class=\"attr\">complete</span>: done &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">leave</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      Velocity(el, &#123; <span class=\"attr\">translateX</span>: <span class=\"string\">'15px'</span>, <span class=\"attr\">rotateZ</span>: <span class=\"string\">'50deg'</span> &#125;, &#123; <span class=\"attr\">duration</span>: <span class=\"number\">600</span> &#125;)</div><div class=\"line\">      Velocity(el, &#123; <span class=\"attr\">rotateZ</span>: <span class=\"string\">'100deg'</span> &#125;, &#123; <span class=\"attr\">loop</span>: <span class=\"number\">2</span> &#125;)</div><div class=\"line\">      Velocity(el, &#123;</div><div class=\"line\">        <span class=\"attr\">rotateZ</span>: <span class=\"string\">'45deg'</span>,</div><div class=\"line\">        <span class=\"attr\">translateY</span>: <span class=\"string\">'30px'</span>,</div><div class=\"line\">        <span class=\"attr\">translateX</span>: <span class=\"string\">'30px'</span>,</div><div class=\"line\">        <span class=\"attr\">opacity</span>: <span class=\"number\">0</span></div><div class=\"line\">      &#125;, &#123; <span class=\"attr\">complete</span>: done &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"example-4\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle\n  </button>\n  <transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\">\n    <p v-if=\"show\">\n      Demo\n    </p>\n  </transition>\n</div>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    show: false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.transformOrigin = 'left'\n    },\n    enter: function (el, done) {\n      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })\n      Velocity(el, { fontSize: '1em' }, { complete: done })\n    },\n    leave: function (el, done) {\n      Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })\n      Velocity(el, { rotateZ: '100deg' }, { loop: 2 })\n      Velocity(el, {\n        rotateZ: '45deg',\n        translateY: '30px',\n        translateX: '30px',\n        opacity: 0\n      }, { complete: done })\n    }\n  }\n})\n</script>\n\n<h2 id=\"初始渲染的过渡\"><a href=\"#初始渲染的过渡\" class=\"headerlink\" title=\"初始渲染的过渡\"></a>初始渲染的过渡</h2><p>可以通过 <code>appear</code> 特性设置节点的在初始渲染的过渡</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">appear</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></span></div><div class=\"line\">  <span class=\"attr\">appear</span></div><div class=\"line\">  <span class=\"attr\">appear-class</span>=<span class=\"string\">\"custom-appear-class\"</span></div><div class=\"line\">  <span class=\"attr\">appear-active-class</span>=<span class=\"string\">\"custom-appear-active-class\"</span></div><div class=\"line\">&gt;</div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>自定义 JavaScript 钩子： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></span></div><div class=\"line\">  <span class=\"attr\">appear</span></div><div class=\"line\">  <span class=\"attr\">v-on:before-appear</span>=<span class=\"string\">\"customBeforeAppearHook\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:appear</span>=<span class=\"string\">\"customAppearHook\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:after-appear</span>=<span class=\"string\">\"customAfterAppearHook\"</span></div><div class=\"line\">&gt;</div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"多个元素的过渡\"><a href=\"#多个元素的过渡\" class=\"headerlink\" title=\"多个元素的过渡\"></a>多个元素的过渡</h2><p>我们之后讨论 <a href=\"#多个组件的过渡\">多个组件的过渡</a>, 对于原生标签可以使用 <code>v-if</code>/<code>v-else</code> 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"items.length &gt; 0\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>Sorry, no items found.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>可以这样使用，但是有一点需要注意：</p>\n<p class=\"tip\">当有<strong>相同标签名</strong>的元素切换时，需要通过 <code>key</code> 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，<strong>给在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key  是一个更好的实践。</strong></p>\n\n<p>示例:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"isEditing\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"save\"</span>&gt;</span></div><div class=\"line\">    Save</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-else</span> <span class=\"attr\">key</span>=<span class=\"string\">\"edit\"</span>&gt;</span></div><div class=\"line\">    Edit</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在一些场景中，也可以给通过给同一个元素的 <code>key</code> 特性设置不同的状态来代替 <code>v-if</code> 和 <code>v-else</code>，上面的例子可以重写为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"isEditing\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; isEditing ? 'Save' : 'Edit' &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>使用多个 <code>v-if</code> 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。 例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"docState === 'saved'\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"saved\"</span>&gt;</span></div><div class=\"line\">    Edit</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"docState === 'edited'\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"edited\"</span>&gt;</span></div><div class=\"line\">    Save</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"docState === 'editing'\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"editing\"</span>&gt;</span></div><div class=\"line\">    Cancel</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>可以重写为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"docState\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; buttonMessage &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">buttonMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (docState) &#123;</div><div class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'saved'</span>: <span class=\"keyword\">return</span> <span class=\"string\">'Edit'</span></div><div class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'edited'</span>: <span class=\"keyword\">return</span> <span class=\"string\">'Save'</span></div><div class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'editing'</span>: <span class=\"keyword\">return</span> <span class=\"string\">'Cancel'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"过渡模式\"><a href=\"#过渡模式\" class=\"headerlink\" title=\"过渡模式\"></a>过渡模式</h3><p>这里还有一个问题，试着点击下面的按钮：</p>\n\n<div id=\"no-mode-demo\" class=\"demo\">\n  <transition name=\"no-mode-fade\">\n    <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n      on\n    </button>\n    <button v-else=\"\" key=\"off\" @click=\"on = true\">\n      off\n    </button>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-fade-enter-active, .no-mode-fade-leave-active {\n  transition: opacity .5s\n}\n.no-mode-fade-enter, .no-mode-fade-leave-active {\n  opacity: 0\n}\n</style>\n\n<p>在 “on” 按钮和 “off” 按钮的过渡中，两个按钮都被重绘了，一个离开过渡的时候另一个开始进入过渡。这是 <code>&lt;transition&gt;</code> 的默认行为 - 进入和离开同时发生。</p>\n<p>在元素绝对定位在彼此之上的时候运行正常：</p>\n\n<div id=\"no-mode-absolute-demo\" class=\"demo\">\n  <div class=\"no-mode-absolute-demo-wrapper\">\n    <transition name=\"no-mode-absolute-fade\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else=\"\" key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-absolute-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-absolute-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.no-mode-absolute-demo-wrapper button {\n  position: absolute;\n}\n.no-mode-absolute-fade-enter-active, .no-mode-absolute-fade-leave-active {\n  transition: opacity .5s;\n}\n.no-mode-absolute-fade-enter, .no-mode-absolute-fade-leave-active {\n  opacity: 0;\n}\n</style>\n\n<p>然后，我们加上 translate 让它们运动像滑动过渡：</p>\n\n<div id=\"no-mode-translate-demo\" class=\"demo\">\n  <div class=\"no-mode-translate-demo-wrapper\">\n    <transition name=\"no-mode-translate-fade\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else=\"\" key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-translate-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-translate-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.no-mode-translate-demo-wrapper button {\n  position: absolute;\n}\n.no-mode-translate-fade-enter-active, .no-mode-translate-fade-leave-active {\n  transition: all 1s;\n}\n.no-mode-translate-fade-enter, .no-mode-translate-fade-leave-active {\n  opacity: 0;\n}\n.no-mode-translate-fade-enter {\n  transform: translateX(31px);\n}\n.no-mode-translate-fade-leave-active {\n  transform: translateX(-31px);\n}\n</style>\n\n<p>同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 <strong>过渡模式</strong></p>\n<ul>\n<li><p><code>in-out</code>: 新元素先进行过渡，完成之后当前元素过渡离开。</p>\n</li>\n<li><p><code>out-in</code>: 当前元素先进行过渡，完成之后新元素过渡进入。</p>\n</li>\n</ul>\n<p>用 <code>out-in</code> 重写之前的开关按钮过渡：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span> <span class=\"attr\">mode</span>=<span class=\"string\">\"out-in\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... the buttons ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"with-mode-demo\" class=\"demo\">\n  <transition name=\"with-mode-fade\" mode=\"out-in\">\n    <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n      on\n    </button>\n    <button v-else=\"\" key=\"off\" @click=\"on = true\">\n      off\n    </button>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#with-mode-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.with-mode-fade-enter-active, .with-mode-fade-leave-active {\n  transition: opacity .5s\n}\n.with-mode-fade-enter, .with-mode-fade-leave-active {\n  opacity: 0\n}\n</style>\n\n<p>只用添加一个简单的特性，就解决了之前的过渡问题而无需任何额外的代码。</p>\n<p><code>in-out</code> 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。<br>将之前滑动淡出的例子结合：</p>\n\n<div id=\"in-out-translate-demo\" class=\"demo\">\n  <div class=\"in-out-translate-demo-wrapper\">\n    <transition name=\"in-out-translate-fade\" mode=\"in-out\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else=\"\" key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#in-out-translate-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.in-out-translate-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.in-out-translate-demo-wrapper button {\n  position: absolute;\n}\n.in-out-translate-fade-enter-active, .in-out-translate-fade-leave-active {\n  transition: all .5s;\n}\n.in-out-translate-fade-enter, .in-out-translate-fade-leave-active {\n  opacity: 0;\n}\n.in-out-translate-fade-enter {\n  transform: translateX(31px);\n}\n.in-out-translate-fade-leave-active {\n  transform: translateX(-31px);\n}\n</style>\n\n<p>很酷吧？</p>\n<h2 id=\"多个组件的过渡\"><a href=\"#多个组件的过渡\" class=\"headerlink\" title=\"多个组件的过渡\"></a>多个组件的过渡</h2><p>多个组件的过渡很简单很多 - 我们不需要使用 <code>key</code> 特性。相反，我们只需要使用<a href=\"components.html#动态组件\">动态组件</a>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"component-fade\"</span> <span class=\"attr\">mode</span>=<span class=\"string\">\"out-in\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#transition-components-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">view</span>: <span class=\"string\">'v-a'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">components</span>: &#123;</div><div class=\"line\">    <span class=\"string\">'v-a'</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;Component A&lt;/div&gt;'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'v-b'</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;Component B&lt;/div&gt;'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.component-fade-enter-active</span>, <span class=\"selector-class\">.component-fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: opacity .<span class=\"number\">3s</span> ease;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.component-fade-enter</span>, <span class=\"selector-class\">.component-fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div id=\"transition-components-demo\" class=\"demo\">\n  <input v-model=\"view\" type=\"radio\" value=\"v-a\" id=\"a\" name=\"view\"><label for=\"a\">A</label>\n  <input v-model=\"view\" type=\"radio\" value=\"v-b\" id=\"b\" name=\"view\"><label for=\"b\">B</label>\n  <transition name=\"component-fade\" mode=\"out-in\">\n    <component v-bind:is=\"view\"></component>\n  </transition>\n</div>\n<style>\n.component-fade-enter-active, .component-fade-leave-active {\n  transition: opacity .3s ease;\n}\n.component-fade-enter, .component-fade-leave-active {\n  opacity: 0;\n}\n</style>\n<script>\nnew Vue({\n  el: '#transition-components-demo',\n  data: {\n    view: 'v-a'\n  },\n  components: {\n    'v-a': {\n      template: '<div>Component A</div>'\n    },\n    'v-b': {\n      template: '<div>Component B</div>'\n    }\n  }\n})\n</script>\n\n<h2 id=\"列表过渡\"><a href=\"#列表过渡\" class=\"headerlink\" title=\"列表过渡\"></a>列表过渡</h2><p>目前为止，关于过渡我们已经讲到：</p>\n<ul>\n<li>单个节点</li>\n<li>一次渲染多个节点</li>\n</ul>\n<p>那么怎么同时渲染整个列表，比如使用 <code>v-for</code> ？在这种场景中，使用  <code>&lt;transition-group&gt;</code> 组件。在我们深入例子之前，先了解关于这个组件的几个特点：</p>\n<ul>\n<li>不同于 <code>&lt;transition&gt;</code>， 它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>。你也可以通过 <code>tag</code> 特性更换为其他元素。</li>\n<li>元素 <strong>一定需要</strong> 指定唯一的 <code>key</code> 特性值</li>\n</ul>\n<h3 id=\"列表的进入和离开过渡\"><a href=\"#列表的进入和离开过渡\" class=\"headerlink\" title=\"列表的进入和离开过渡\"></a>列表的进入和离开过渡</h3><p>现在让我们由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"list-demo\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"add\"</span>&gt;</span>Add<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"remove\"</span>&gt;</span>Remove<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">name</span>=<span class=\"string\">\"list\"</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"p\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"list-item\"</span>&gt;</span></div><div class=\"line\">      &#123;&#123; item &#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#list-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">items</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>],</div><div class=\"line\">    <span class=\"attr\">nextNum</span>: <span class=\"number\">10</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">randomIndex</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"keyword\">this</span>.items.length)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">add</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items.splice(<span class=\"keyword\">this</span>.randomIndex(), <span class=\"number\">0</span>, <span class=\"keyword\">this</span>.nextNum++)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">remove</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items.splice(<span class=\"keyword\">this</span>.randomIndex(), <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.list-item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.list-enter-active</span>, <span class=\"selector-class\">.list-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: all <span class=\"number\">1s</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.list-enter</span>, <span class=\"selector-class\">.list-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(30px);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div id=\"list-demo\" class=\"demo\">\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list\" tag=\"p\">\n    <span v-for=\"item in items\" :key=\"item\" class=\"list-item\">\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n  }\n})\n</script>\n<style>\n.list-item {\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-enter-active, .list-leave-active {\n  transition: all 1s;\n}\n.list-enter, .list-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n</style>\n\n<p>这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，我们下面会解决这个问题。</p>\n<h3 id=\"列表的位移过渡\"><a href=\"#列表的位移过渡\" class=\"headerlink\" title=\"列表的位移过渡\"></a>列表的位移过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 <strong> <code>v-move</code>  特性</strong>，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 <code>name</code> 属性来自定义前缀，也可以通过 <code>move-class</code> 属性手动设置。</p>\n<p><code>v-move</code> 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"flip-list-demo\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"shuffle\"</span>&gt;</span>Shuffle<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">name</span>=<span class=\"string\">\"flip-list\"</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"ul\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item\"</span>&gt;</span></div><div class=\"line\">      &#123;&#123; item &#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#flip-list-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">items</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">shuffle</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items = _.shuffle(<span class=\"keyword\">this</span>.items)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.flip-list-move</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: transform <span class=\"number\">1s</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n<div id=\"flip-list-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <transition-group name=\"flip-list\" tag=\"ul\">\n    <li v-for=\"item in items\" :key=\"item\">\n      {{ item }}\n    </li>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#flip-list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9]\n  },\n  methods: {\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n</script>\n<style>\n.flip-list-move {\n  transition: transform 1s;\n}\n</style>\n\n<p>这个看起来很神奇，内部的实现，Vue 使用了一个叫 <a href=\"https://aerotwist.com/blog/flip-your-animations/\" target=\"_blank\" rel=\"external\">FLIP</a> 简单的动画队列<br>使用 transforms 将元素从之前的位置平滑过渡新的位置。</p>\n<p>我们将之前实现的例子和这个技术结合，使我们列表的一切变动都会有动画过渡。<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"list-complete-demo\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"shuffle\"</span>&gt;</span>Shuffle<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"add\"</span>&gt;</span>Add<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"remove\"</span>&gt;</span>Remove<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">name</span>=<span class=\"string\">\"list-complete\"</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"p\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span></span></div><div class=\"line\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span></div><div class=\"line\">      <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item\"</span></div><div class=\"line\">      <span class=\"attr\">class</span>=<span class=\"string\">\"list-complete-item\"</span></div><div class=\"line\">    &gt;</div><div class=\"line\">      &#123;&#123; item &#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#list-complete-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">items</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>],</div><div class=\"line\">    <span class=\"attr\">nextNum</span>: <span class=\"number\">10</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">randomIndex</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"keyword\">this</span>.items.length)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">add</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items.splice(<span class=\"keyword\">this</span>.randomIndex(), <span class=\"number\">0</span>, <span class=\"keyword\">this</span>.nextNum++)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">remove</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items.splice(<span class=\"keyword\">this</span>.randomIndex(), <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">shuffle</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items = _.shuffle(<span class=\"keyword\">this</span>.items)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.list-complete-item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: all <span class=\"number\">1s</span>;</div><div class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.list-complete-enter</span>, <span class=\"selector-class\">.list-complete-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(30px);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.list-complete-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n<div id=\"list-complete-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list-complete\" tag=\"p\">\n    <span v-for=\"item in items\" :key=\"item\" class=\"list-complete-item\">\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#list-complete-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n</script>\n<style>\n.list-complete-item {\n  transition: all 1s;\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-complete-enter, .list-complete-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n.list-complete-leave-active {\n  position: absolute;\n}\n</style>\n\n<p class=\"tip\">需要注意的是使用 FLIP 过渡的元素不能设置为 <code>display: inline</code> 。作为替代方案，可以设置为 <code>display: inline-block</code> 或者放置于 flex 中</p>\n\n<p>FLIP 动画不仅可以实现单列过渡，多维网格的过渡也同样<a href=\"https://jsfiddle.net/chrisvfritz/sLrhk1bc/\" target=\"_blank\" rel=\"external\">简单</a>:</p>\n\n<div id=\"sudoku-demo\" class=\"demo\">\n  <strong>Lazy Sudoku</strong>\n  <p>Keep hitting the shuffle button until you win.</p>\n  <button @click=\"shuffle\">\n    Shuffle\n  </button>\n  <transition-group name=\"cell\" tag=\"div\" class=\"sudoku-container\">\n    <div v-for=\"cell in cells\" :key=\"cell.id\" class=\"cell\">\n      {{ cell.number }}\n    </div>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#sudoku-demo',\n  data: {\n    cells: Array.apply(null, { length: 81 })\n      .map(function (_, index) {\n        return {\n          id: index,\n          number: index % 9 + 1\n        }\n      })\n  },\n  methods: {\n    shuffle: function () {\n      this.cells = _.shuffle(this.cells)\n    }\n  }\n})\n</script>\n<style>\n.sudoku-container {\n  display: flex;\n  flex-wrap: wrap;\n  width: 238px;\n  margin-top: 10px;\n}\n.cell {\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  width: 25px;\n  height: 25px;\n  border: 1px solid #aaa;\n  margin-right: -1px;\n  margin-bottom: -1px;\n}\n.cell:nth-child(3n) {\n  margin-right: 0;\n}\n.cell:nth-child(27n) {\n  margin-bottom: 0;\n}\n.cell-move {\n  transition: transform 1s;\n}\n</style>\n\n<h3 id=\"列表的渐进过渡\"><a href=\"#列表的渐进过渡\" class=\"headerlink\" title=\"列表的渐进过渡\"></a>列表的渐进过渡</h3><p>通过 data 属性与 JavaScript 通信 ，就可以实现列表的渐进过渡：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"staggered-list-demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"query\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition-group</span></span></div><div class=\"line\">    <span class=\"attr\">name</span>=<span class=\"string\">\"staggered-fade\"</span></div><div class=\"line\">    <span class=\"attr\">tag</span>=<span class=\"string\">\"ul\"</span></div><div class=\"line\">    <span class=\"attr\">v-bind:css</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></div><div class=\"line\">  &gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span></span></div><div class=\"line\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in computedList\"</span></div><div class=\"line\">      <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item.msg\"</span></div><div class=\"line\">      <span class=\"attr\">v-bind:data-index</span>=<span class=\"string\">\"index\"</span></div><div class=\"line\">    &gt;&#123;&#123; item.msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#staggered-list-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">query</span>: <span class=\"string\">''</span>,</div><div class=\"line\">    <span class=\"attr\">list</span>: [</div><div class=\"line\">      &#123; <span class=\"attr\">msg</span>: <span class=\"string\">'Bruce Lee'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">msg</span>: <span class=\"string\">'Jackie Chan'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">msg</span>: <span class=\"string\">'Chuck Norris'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">msg</span>: <span class=\"string\">'Jet Li'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">msg</span>: <span class=\"string\">'Kung Fury'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">computedList</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== <span class=\"number\">-1</span></div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">beforeEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      el.style.opacity = <span class=\"number\">0</span></div><div class=\"line\">      el.style.height = <span class=\"number\">0</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">enter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> delay = el.dataset.index * <span class=\"number\">150</span></div><div class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        Velocity(</div><div class=\"line\">          el,</div><div class=\"line\">          &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">1</span>, <span class=\"attr\">height</span>: <span class=\"string\">'1.6em'</span> &#125;,</div><div class=\"line\">          &#123; <span class=\"attr\">complete</span>: done &#125;</div><div class=\"line\">        )</div><div class=\"line\">      &#125;, delay)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">leave</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> delay = el.dataset.index * <span class=\"number\">150</span></div><div class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        Velocity(</div><div class=\"line\">          el,</div><div class=\"line\">          &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">0</span>, <span class=\"attr\">height</span>: <span class=\"number\">0</span> &#125;,</div><div class=\"line\">          &#123; <span class=\"attr\">complete</span>: done &#125;</div><div class=\"line\">        )</div><div class=\"line\">      &#125;, delay)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<div id=\"example-5\" class=\"demo\">\n  <input v-model=\"query\">\n  <transition-group name=\"staggered-fade\" tag=\"ul\" v-bind:css=\"false\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\">\n    <li v-for=\"(item, index) in computedList\" v-bind:key=\"item.msg\" v-bind:data-index=\"index\">{{ item.msg }}</li>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    query: '',\n    list: [\n      { msg: 'Bruce Lee' },\n      { msg: 'Jackie Chan' },\n      { msg: 'Chuck Norris' },\n      { msg: 'Jet Li' },\n      { msg: 'Kung Fury' }\n    ]\n  },\n  computed: {\n    computedList: function () {\n      var vm = this\n      return this.list.filter(function (item) {\n        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1\n      })\n    }\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.height = 0\n    },\n    enter: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 1, height: '1.6em' },\n          { complete: done }\n        )\n      }, delay)\n    },\n    leave: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 0, height: 0 },\n          { complete: done }\n        )\n      }, delay)\n    }\n  }\n})\n</script>\n\n<h2 id=\"可复用的过渡\"><a href=\"#可复用的过渡\" class=\"headerlink\" title=\"可复用的过渡\"></a>可复用的过渡</h2><p>过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 <code>&lt;transition&gt;</code> 或者 <code>&lt;transition-group&gt;</code> 作为根组件，然后将任何子组件放置在其中就可以了。</p>\n<p>使用 template 的简单例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-special-transition'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'\\</span></div><div class=\"line\">    &lt;transition\\</div><div class=\"line\">      name=\"very-special-transition\"\\</div><div class=\"line\">      mode=\"out-in\"\\</div><div class=\"line\">      v-on:before-enter=\"beforeEnter\"\\</div><div class=\"line\">      v-on:after-enter=\"afterEnter\"\\</div><div class=\"line\">    &gt;\\</div><div class=\"line\">      &lt;slot&gt;&lt;/slot&gt;\\</div><div class=\"line\">    &lt;/transition&gt;\\</div><div class=\"line\">  ',</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">beforeEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// ...</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">afterEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>函数组件更适合完成这个任务：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-special-transition'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">functional</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = &#123;</div><div class=\"line\">      <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">'very-special-transition'</span></div><div class=\"line\">        mode: <span class=\"string\">'out-in'</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"attr\">on</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">beforeEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">          <span class=\"comment\">// ...</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"attr\">afterEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">          <span class=\"comment\">// ...</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">'transition'</span>, data, context.children)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"动态过渡\"><a href=\"#动态过渡\" class=\"headerlink\" title=\"动态过渡\"></a>动态过渡</h2><p>在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 <code>name</code> 特性来绑定动态值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">v-bind:name</span>=<span class=\"string\">\"transitionName\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用。</p>\n<p>所有的过渡特性都是动态绑定。它不仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。这意味着，可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dynamic-fade-demo\"</span>&gt;</span></div><div class=\"line\">  Fade In: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"range\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"fadeInDuration\"</span> <span class=\"attr\">min</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">v-bind:max</span>=<span class=\"string\">\"maxFadeDuration\"</span>&gt;</span></div><div class=\"line\">  Fade Out: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"range\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"fadeOutDuration\"</span> <span class=\"attr\">min</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">v-bind:max</span>=<span class=\"string\">\"maxFadeDuration\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span></span></div><div class=\"line\">    <span class=\"attr\">v-bind:css</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></div><div class=\"line\">  &gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"stop = true\"</span>&gt;</span>Stop it!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#dynamic-fade-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">fadeInDuration</span>: <span class=\"number\">1000</span>,</div><div class=\"line\">    <span class=\"attr\">fadeOutDuration</span>: <span class=\"number\">1000</span>,</div><div class=\"line\">    <span class=\"attr\">maxFadeDuration</span>: <span class=\"number\">1500</span>,</div><div class=\"line\">    <span class=\"attr\">stop</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">mounted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.show = <span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">beforeEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      el.style.opacity = <span class=\"number\">0</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">enter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">      Velocity(el,</div><div class=\"line\">        &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">1</span> &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">          <span class=\"attr\">duration</span>: <span class=\"keyword\">this</span>.fadeInDuration,</div><div class=\"line\">          <span class=\"attr\">complete</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            done()</div><div class=\"line\">            <span class=\"keyword\">if</span> (!vm.stop) vm.show = <span class=\"literal\">false</span></div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      )</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">leave</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">      Velocity(el,</div><div class=\"line\">        &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">0</span> &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">          <span class=\"attr\">duration</span>: <span class=\"keyword\">this</span>.fadeOutDuration,</div><div class=\"line\">          <span class=\"attr\">complete</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            done()</div><div class=\"line\">            vm.show = <span class=\"literal\">true</span></div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      )</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<div id=\"dynamic-fade-demo\" class=\"demo\">\n  Fade In: <input type=\"range\" v-model=\"fadeInDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  Fade Out: <input type=\"range\" v-model=\"fadeOutDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  <transition v-bind:css=\"false\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n  <button v-on:click=\"stop = true\">Stop it!</button>\n</div>\n<script>\nnew Vue({\n  el: '#dynamic-fade-demo',\n  data: {\n    show: true,\n    fadeInDuration: 1000,\n    fadeOutDuration: 1000,\n    maxFadeDuration: 1500,\n    stop: false\n  },\n  mounted: function () {\n    this.show = false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n    },\n    enter: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 1 },\n        {\n          duration: this.fadeInDuration,\n          complete: function () {\n            done()\n            if (!vm.stop) vm.show = false\n          }\n        }\n      )\n    },\n    leave: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 0 },\n        {\n          duration: this.fadeOutDuration,\n          complete: function () {\n            done()\n            vm.show = true\n          }\n        }\n      )\n    }\n  }\n})\n</script>\n\n<p>最后，创建动态过渡的最终方案是组件通过接受 props 来动态修改之前的过渡。一句老话，唯一的限制是你的想象力。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/transitions.html\" target=\"_blank\" rel=\"external\">http://vuejs.org/guide/transitions.html</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。<br>包括以下工具：</p>\n<ul>\n<li>在 CSS 过渡和动画中自动应用 class</li>\n<li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>\n<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>\n<li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>\n</ul>\n<p>在这里，我们只会讲到进入、离开和列表的过渡， 你也可以看下一节的 <a href=\"transitioning-state.html\">管理过渡状态</a>.</p>\n<h2 id=\"单元素-组件的过渡\"><a href=\"#单元素-组件的过渡\" class=\"headerlink\" title=\"单元素/组件的过渡\"></a>单元素/组件的过渡</h2><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡</p>\n<ul>\n<li>条件渲染 （使用 <code>v-if</code>）</li>\n<li>条件展示 （使用 <code>v-show</code>）</li>\n<li>动态组件</li>\n<li>组件根节点</li>\n</ul>\n<p>这里是一个典型的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"show = !show\"</span>&gt;</span></div><div class=\"line\">    Toggle</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.fade-enter-active</span>, <span class=\"selector-class\">.fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: opacity .<span class=\"number\">5s</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.fade-enter</span>, <span class=\"selector-class\">.fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div id=\"demo\">\n  <button v-on:click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"demo-transition\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#demo',\n  data: {\n    show: true\n  }\n})\n</script>\n<style>\n.demo-transition-enter-active, .demo-transition-leave-active {\n  transition: opacity .5s\n}\n.demo-transition-enter, .demo-transition-leave-active {\n  opacity: 0\n}\n</style>\n\n<p>元素封装成过渡组件之后，在遇到插入或删除时，Vue 将</p>\n<ol>\n<li><p>自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。</p>\n</li>\n<li><p>如果过渡组件设置了过渡的 <a href=\"#JavaScript-Hooks\">JavaScript 钩子函数</a>，会在相应的阶段调用钩子函数。</p>\n</li>\n<li><p>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 <code>nextTick</code> 概念不同)</p>\n</li>\n</ol>\n<h3 id=\"过渡的-CSS-类名\"><a href=\"#过渡的-CSS-类名\" class=\"headerlink\" title=\"过渡的-CSS-类名\"></a>过渡的-CSS-类名</h3><p>会有 4 个(CSS)类名在 enter/leave 的过渡中切换</p>\n<ol>\n<li><p><code>v-enter</code>: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</p>\n</li>\n<li><p><code>v-enter-active</code>: 定义进入过渡的结束状态。在元素被插入时生效，在 <code>transition/animation</code> 完成之后移除。</p>\n</li>\n<li><p><code>v-leave</code>:  定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</p>\n</li>\n<li><p><code>v-leave-active</code>: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 <code>transition/animation</code> 完成之后移除。</p>\n</li>\n</ol>\n<p><img src=\"/images/transition.png\" alt=\"Transition Diagram\"></p>\n<p>对于这些在 <code>enter/leave</code> 过渡中切换的类名，<code>v-</code> 是这些类名的前缀。使用 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code> 可以重置前缀，比如 <code>v-enter</code> 替换为 <code>my-transition-enter</code>。</p>\n<p><code>v-enter-active</code> 和 <code>v-leave-active</code> 可以控制 进入/离开 过渡的不同阶段，在下面章节会有个示例说明。</p>\n<h3 id=\"CSS-过渡\"><a href=\"#CSS-过渡\" class=\"headerlink\" title=\"CSS 过渡\"></a>CSS 过渡</h3><p>常用的过渡都是使用 CSS 过渡。</p>\n<p>下面是一个简单例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-1\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"show = !show\"</span>&gt;</span></div><div class=\"line\">    Toggle render</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"slide-fade\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-1'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 可以设置不同的进入和离开动画 */</span></div><div class=\"line\"><span class=\"comment\">/* 设置持续时间和动画函数 */</span></div><div class=\"line\"><span class=\"selector-class\">.slide-fade-enter-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">3s</span> ease;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.slide-fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">8s</span> <span class=\"built_in\">cubic-bezier</span>(1.0, 0.5, 0.8, 1.0);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.slide-fade-enter</span>, <span class=\"selector-class\">.slide-fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(10px);</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div id=\"example-1\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"slide-fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    show: true\n  }\n})\n</script>\n<style>\n.slide-fade-enter-active {\n  transition: all .3s ease;\n}\n.slide-fade-leave-active {\n  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.slide-fade-enter, .slide-fade-leave-active {\n  transform: translateX(10px);\n  opacity: 0;\n}\n</style>\n\n<h3 id=\"CSS-动画\"><a href=\"#CSS-动画\" class=\"headerlink\" title=\"CSS 动画\"></a>CSS 动画</h3><p>CSS 动画用法同 CSS 过渡，区别是在动画中 <code>v-enter</code> 类名在节点插入 DOM 后不会立即删除，而是在 <code>animationend</code> 事件触发时删除。</p>\n<p>示例： (省略了兼容性前缀)</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"show = !show\"</span>&gt;</span>Toggle show<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"bounce\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>Look at me!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-2'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.bounce-enter-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">animation</span>: bounce-in .<span class=\"number\">5s</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.bounce-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">animation</span>: bounce-out .<span class=\"number\">5s</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">@<span class=\"keyword\">keyframes</span> bounce-in &#123;</div><div class=\"line\">  0% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0);</div><div class=\"line\">  &#125;</div><div class=\"line\">  50% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(1.5);</div><div class=\"line\">  &#125;</div><div class=\"line\">  100% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(1);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@<span class=\"keyword\">keyframes</span> bounce-out &#123;</div><div class=\"line\">  0% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(1);</div><div class=\"line\">  &#125;</div><div class=\"line\">  50% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(1.5);</div><div class=\"line\">  &#125;</div><div class=\"line\">  100% &#123;</div><div class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div id=\"example-2\" class=\"demo\">\n  <button @click=\"show = !show\">Toggle show</button>\n  <transition name=\"bounce\">\n    <p v-show=\"show\">Look at me!</p>\n  </transition>\n</div>\n\n<style>\n  .bounce-enter-active {\n    -webkit-animation: bounce-in .5s;\n    animation: bounce-in .5s;\n  }\n  .bounce-leave-active {\n    -webkit-animation: bounce-out .5s;\n    animation: bounce-out .5s;\n  }\n  @keyframes bounce-in {\n    0% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n  }\n  @keyframes bounce-out {\n    0% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n  }\n  @-webkit-keyframes bounce-in {\n    0% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n  }\n  @-webkit-keyframes bounce-out {\n    0% {\n      -webkit-transform: scale(1);\n      transform: scale(1);\n    }\n    50% {\n      -webkit-transform: scale(1.5);\n      transform: scale(1.5);\n    }\n    100% {\n      -webkit-transform: scale(0);\n      transform: scale(0);\n    }\n  }\n</style>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    show: true\n  }\n})\n</script>\n\n<h3 id=\"自定义过渡类名\"><a href=\"#自定义过渡类名\" class=\"headerlink\" title=\"自定义过渡类名\"></a>自定义过渡类名</h3><p>我们可以通过以下特性来自定义过渡类名：</p>\n<ul>\n<li><code>enter-class</code></li>\n<li><code>enter-active-class</code></li>\n<li><code>leave-class</code></li>\n<li><code>leave-active-class</code></li>\n</ul>\n<p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 <a href=\"https://daneden.github.io/animate.css/\">Animate.css</a> 结合使用十分有用。</p>\n<p>示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://unpkg.com/animate.css@3.5.1/animate.min.css\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-3\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"show = !show\"</span>&gt;</span></div><div class=\"line\">    Toggle render</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span></div><div class=\"line\">    <span class=\"attr\">name</span>=<span class=\"string\">\"custom-classes-transition\"</span></div><div class=\"line\">    <span class=\"attr\">enter-active-class</span>=<span class=\"string\">\"animated tada\"</span></div><div class=\"line\">    <span class=\"attr\">leave-active-class</span>=<span class=\"string\">\"animated bounceOutRight\"</span></div><div class=\"line\">  &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-3'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<link href=\"https://unpkg.com/animate.css@3.5.1\" rel=\"stylesheet\" type=\"text/css\">\n<div id=\"example-3\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition\n    name=\"custom-classes-transition\"\n    enter-active-class=\"animated tada\"\n    leave-active-class=\"animated bounceOutRight\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    show: true\n  }\n})\n</script>\n\n<h3 id=\"同时使用-Transitions-和-Animations\"><a href=\"#同时使用-Transitions-和-Animations\" class=\"headerlink\" title=\"同时使用 Transitions 和 Animations\"></a>同时使用 Transitions 和 Animations</h3><p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 <code>transitionend</code> 或 <code>animationend</code> ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p>\n<p>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 <code>animation</code> 很快的被触发并完成了，而 <code>transition</code> 效果还没结束。在这种情况中，你就需要使用 <code>type</code> 特性并设置 <code>animation</code> 或 <code>transition</code> 来明确声明你需要 Vue 监听的类型。</p>\n<h3 id=\"JavaScript-钩子\"><a href=\"#JavaScript-钩子\" class=\"headerlink\" title=\"JavaScript 钩子\"></a>JavaScript 钩子</h3><p>可以在属性中声明 JavaScript 钩子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></div><div class=\"line\">  <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:after-enter</span>=<span class=\"string\">\"afterEnter\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:enter-cancelled</span>=<span class=\"string\">\"enterCancelled\"</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">v-on:before-leave</span>=<span class=\"string\">\"beforeLeave\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:after-leave</span>=<span class=\"string\">\"afterLeave\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:leave-cancelled</span>=<span class=\"string\">\"leaveCancelled\"</span></div><div class=\"line\">&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">methods: &#123;</div><div class=\"line\">  <span class=\"comment\">// --------</span></div><div class=\"line\">  <span class=\"comment\">// 进入中</span></div><div class=\"line\">  <span class=\"comment\">// --------</span></div><div class=\"line\"></div><div class=\"line\">  beforeEnter: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 此回调函数是可选项的设置</span></div><div class=\"line\">  <span class=\"comment\">// 与 CSS 结合时使用</span></div><div class=\"line\">  enter: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    done()</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">afterEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">enterCancelled</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// --------</span></div><div class=\"line\">  <span class=\"comment\">// 离开时</span></div><div class=\"line\">  <span class=\"comment\">// --------</span></div><div class=\"line\"></div><div class=\"line\">  beforeLeave: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 此回调函数是可选项的设置</span></div><div class=\"line\">  <span class=\"comment\">// 与 CSS 结合时使用</span></div><div class=\"line\">  leave: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    done()</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">afterLeave</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// leaveCancelled 只用于 v-show 中</span></div><div class=\"line\">  leaveCancelled: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这些钩子函数可以结合 CSS <code>transitions/animations</code> 使用，也可以单独使用。</p>\n<p class=\"tip\">当只用 JavaScript 过渡的时候， <strong> 在 <code>enter</code> 和 <code>leave</code> 中，回调函数 <code>done</code> 是必须的 </strong>。 否则，它们会被同步调用，过渡会立即完成。</p>\n\n<p class=\"tip\">推荐对于仅使用 JavaScript 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>\n\n<p>一个使用 Velocity.js 的简单例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!--</div><div class=\"line\">Velocity works very much like jQuery.animate and is</div><div class=\"line\">a great option for JavaScript animations</div><div class=\"line\">--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-4\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"show = !show\"</span>&gt;</span></div><div class=\"line\">    Toggle</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span></div><div class=\"line\">    <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></div><div class=\"line\">    <span class=\"attr\">v-bind:css</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">  &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span></div><div class=\"line\">      Demo</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#example-4'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">beforeEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      el.style.opacity = <span class=\"number\">0</span></div><div class=\"line\">      el.style.transformOrigin = <span class=\"string\">'left'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">enter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      Velocity(el, &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">1</span>, <span class=\"attr\">fontSize</span>: <span class=\"string\">'1.4em'</span> &#125;, &#123; <span class=\"attr\">duration</span>: <span class=\"number\">300</span> &#125;)</div><div class=\"line\">      Velocity(el, &#123; <span class=\"attr\">fontSize</span>: <span class=\"string\">'1em'</span> &#125;, &#123; <span class=\"attr\">complete</span>: done &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">leave</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      Velocity(el, &#123; <span class=\"attr\">translateX</span>: <span class=\"string\">'15px'</span>, <span class=\"attr\">rotateZ</span>: <span class=\"string\">'50deg'</span> &#125;, &#123; <span class=\"attr\">duration</span>: <span class=\"number\">600</span> &#125;)</div><div class=\"line\">      Velocity(el, &#123; <span class=\"attr\">rotateZ</span>: <span class=\"string\">'100deg'</span> &#125;, &#123; <span class=\"attr\">loop</span>: <span class=\"number\">2</span> &#125;)</div><div class=\"line\">      Velocity(el, &#123;</div><div class=\"line\">        <span class=\"attr\">rotateZ</span>: <span class=\"string\">'45deg'</span>,</div><div class=\"line\">        <span class=\"attr\">translateY</span>: <span class=\"string\">'30px'</span>,</div><div class=\"line\">        <span class=\"attr\">translateX</span>: <span class=\"string\">'30px'</span>,</div><div class=\"line\">        <span class=\"attr\">opacity</span>: <span class=\"number\">0</span></div><div class=\"line\">      &#125;, &#123; <span class=\"attr\">complete</span>: done &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<div id=\"example-4\" class=\"demo\">\n  <button @click=\"show = !show\">\n    Toggle\n  </button>\n  <transition\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <p v-if=\"show\">\n      Demo\n    </p>\n  </transition>\n</div>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    show: false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.transformOrigin = 'left'\n    },\n    enter: function (el, done) {\n      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })\n      Velocity(el, { fontSize: '1em' }, { complete: done })\n    },\n    leave: function (el, done) {\n      Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })\n      Velocity(el, { rotateZ: '100deg' }, { loop: 2 })\n      Velocity(el, {\n        rotateZ: '45deg',\n        translateY: '30px',\n        translateX: '30px',\n        opacity: 0\n      }, { complete: done })\n    }\n  }\n})\n</script>\n\n<h2 id=\"初始渲染的过渡\"><a href=\"#初始渲染的过渡\" class=\"headerlink\" title=\"初始渲染的过渡\"></a>初始渲染的过渡</h2><p>可以通过 <code>appear</code> 特性设置节点的在初始渲染的过渡</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">appear</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></div><div class=\"line\">  <span class=\"attr\">appear</span></div><div class=\"line\">  <span class=\"attr\">appear-class</span>=<span class=\"string\">\"custom-appear-class\"</span></div><div class=\"line\">  <span class=\"attr\">appear-active-class</span>=<span class=\"string\">\"custom-appear-active-class\"</span></div><div class=\"line\">&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>自定义 JavaScript 钩子： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></div><div class=\"line\">  <span class=\"attr\">appear</span></div><div class=\"line\">  <span class=\"attr\">v-on:before-appear</span>=<span class=\"string\">\"customBeforeAppearHook\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:appear</span>=<span class=\"string\">\"customAppearHook\"</span></div><div class=\"line\">  <span class=\"attr\">v-on:after-appear</span>=<span class=\"string\">\"customAfterAppearHook\"</span></div><div class=\"line\">&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"多个元素的过渡\"><a href=\"#多个元素的过渡\" class=\"headerlink\" title=\"多个元素的过渡\"></a>多个元素的过渡</h2><p>我们之后讨论 <a href=\"#多个组件的过渡\">多个组件的过渡</a>, 对于原生标签可以使用 <code>v-if</code>/<code>v-else</code> 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"items.length &gt; 0\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>Sorry, no items found.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>可以这样使用，但是有一点需要注意：</p>\n<p class=\"tip\">当有<strong>相同标签名</strong>的元素切换时，需要通过 <code>key</code> 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，<strong>给在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key  是一个更好的实践。</strong></p>\n\n<p>示例:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"isEditing\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"save\"</span>&gt;</span></div><div class=\"line\">    Save</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-else</span> <span class=\"attr\">key</span>=<span class=\"string\">\"edit\"</span>&gt;</span></div><div class=\"line\">    Edit</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在一些场景中，也可以给通过给同一个元素的 <code>key</code> 特性设置不同的状态来代替 <code>v-if</code> 和 <code>v-else</code>，上面的例子可以重写为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"isEditing\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; isEditing ? 'Save' : 'Edit' &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>使用多个 <code>v-if</code> 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。 例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"docState === 'saved'\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"saved\"</span>&gt;</span></div><div class=\"line\">    Edit</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"docState === 'edited'\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"edited\"</span>&gt;</span></div><div class=\"line\">    Save</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"docState === 'editing'\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"editing\"</span>&gt;</span></div><div class=\"line\">    Cancel</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>可以重写为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"docState\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; buttonMessage &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">computed: &#123;</div><div class=\"line\">  <span class=\"attr\">buttonMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (docState) &#123;</div><div class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'saved'</span>: <span class=\"keyword\">return</span> <span class=\"string\">'Edit'</span></div><div class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'edited'</span>: <span class=\"keyword\">return</span> <span class=\"string\">'Save'</span></div><div class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'editing'</span>: <span class=\"keyword\">return</span> <span class=\"string\">'Cancel'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"过渡模式\"><a href=\"#过渡模式\" class=\"headerlink\" title=\"过渡模式\"></a>过渡模式</h3><p>这里还有一个问题，试着点击下面的按钮：</p>\n\n<div id=\"no-mode-demo\" class=\"demo\">\n  <transition name=\"no-mode-fade\">\n    <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n      on\n    </button>\n    <button v-else key=\"off\" @click=\"on = true\">\n      off\n    </button>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-fade-enter-active, .no-mode-fade-leave-active {\n  transition: opacity .5s\n}\n.no-mode-fade-enter, .no-mode-fade-leave-active {\n  opacity: 0\n}\n</style>\n\n<p>在 “on” 按钮和 “off” 按钮的过渡中，两个按钮都被重绘了，一个离开过渡的时候另一个开始进入过渡。这是 <code>&lt;transition&gt;</code> 的默认行为 - 进入和离开同时发生。</p>\n<p>在元素绝对定位在彼此之上的时候运行正常：</p>\n\n<div id=\"no-mode-absolute-demo\" class=\"demo\">\n  <div class=\"no-mode-absolute-demo-wrapper\">\n    <transition name=\"no-mode-absolute-fade\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-absolute-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-absolute-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.no-mode-absolute-demo-wrapper button {\n  position: absolute;\n}\n.no-mode-absolute-fade-enter-active, .no-mode-absolute-fade-leave-active {\n  transition: opacity .5s;\n}\n.no-mode-absolute-fade-enter, .no-mode-absolute-fade-leave-active {\n  opacity: 0;\n}\n</style>\n\n<p>然后，我们加上 translate 让它们运动像滑动过渡：</p>\n\n<div id=\"no-mode-translate-demo\" class=\"demo\">\n  <div class=\"no-mode-translate-demo-wrapper\">\n    <transition name=\"no-mode-translate-fade\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#no-mode-translate-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.no-mode-translate-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.no-mode-translate-demo-wrapper button {\n  position: absolute;\n}\n.no-mode-translate-fade-enter-active, .no-mode-translate-fade-leave-active {\n  transition: all 1s;\n}\n.no-mode-translate-fade-enter, .no-mode-translate-fade-leave-active {\n  opacity: 0;\n}\n.no-mode-translate-fade-enter {\n  transform: translateX(31px);\n}\n.no-mode-translate-fade-leave-active {\n  transform: translateX(-31px);\n}\n</style>\n\n<p>同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 <strong>过渡模式</strong></p>\n<ul>\n<li><p><code>in-out</code>: 新元素先进行过渡，完成之后当前元素过渡离开。</p>\n</li>\n<li><p><code>out-in</code>: 当前元素先进行过渡，完成之后新元素过渡进入。</p>\n</li>\n</ul>\n<p>用 <code>out-in</code> 重写之前的开关按钮过渡：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span> <span class=\"attr\">mode</span>=<span class=\"string\">\"out-in\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... the buttons ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<div id=\"with-mode-demo\" class=\"demo\">\n  <transition name=\"with-mode-fade\" mode=\"out-in\">\n    <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n      on\n    </button>\n    <button v-else key=\"off\" @click=\"on = true\">\n      off\n    </button>\n  </transition>\n</div>\n<script>\nnew Vue({\n  el: '#with-mode-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.with-mode-fade-enter-active, .with-mode-fade-leave-active {\n  transition: opacity .5s\n}\n.with-mode-fade-enter, .with-mode-fade-leave-active {\n  opacity: 0\n}\n</style>\n\n<p>只用添加一个简单的特性，就解决了之前的过渡问题而无需任何额外的代码。</p>\n<p><code>in-out</code> 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。<br>将之前滑动淡出的例子结合：</p>\n\n<div id=\"in-out-translate-demo\" class=\"demo\">\n  <div class=\"in-out-translate-demo-wrapper\">\n    <transition name=\"in-out-translate-fade\" mode=\"in-out\">\n      <button v-if=\"on\" key=\"on\" @click=\"on = false\">\n        on\n      </button>\n      <button v-else key=\"off\" @click=\"on = true\">\n        off\n      </button>\n    </transition>\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#in-out-translate-demo',\n  data: {\n    on: false\n  }\n})\n</script>\n<style>\n.in-out-translate-demo-wrapper {\n  position: relative;\n  height: 18px;\n}\n.in-out-translate-demo-wrapper button {\n  position: absolute;\n}\n.in-out-translate-fade-enter-active, .in-out-translate-fade-leave-active {\n  transition: all .5s;\n}\n.in-out-translate-fade-enter, .in-out-translate-fade-leave-active {\n  opacity: 0;\n}\n.in-out-translate-fade-enter {\n  transform: translateX(31px);\n}\n.in-out-translate-fade-leave-active {\n  transform: translateX(-31px);\n}\n</style>\n\n<p>很酷吧？</p>\n<h2 id=\"多个组件的过渡\"><a href=\"#多个组件的过渡\" class=\"headerlink\" title=\"多个组件的过渡\"></a>多个组件的过渡</h2><p>多个组件的过渡很简单很多 - 我们不需要使用 <code>key</code> 特性。相反，我们只需要使用<a href=\"components.html#动态组件\">动态组件</a>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"component-fade\"</span> <span class=\"attr\">mode</span>=<span class=\"string\">\"out-in\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#transition-components-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">view</span>: <span class=\"string\">'v-a'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">components</span>: &#123;</div><div class=\"line\">    <span class=\"string\">'v-a'</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;Component A&lt;/div&gt;'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'v-b'</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;Component B&lt;/div&gt;'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.component-fade-enter-active</span>, <span class=\"selector-class\">.component-fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: opacity .<span class=\"number\">3s</span> ease;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.component-fade-enter</span>, <span class=\"selector-class\">.component-fade-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div id=\"transition-components-demo\" class=\"demo\">\n  <input v-model=\"view\" type=\"radio\" value=\"v-a\" id=\"a\" name=\"view\"><label for=\"a\">A</label>\n  <input v-model=\"view\" type=\"radio\" value=\"v-b\" id=\"b\" name=\"view\"><label for=\"b\">B</label>\n  <transition name=\"component-fade\" mode=\"out-in\">\n    <component v-bind:is=\"view\"></component>\n  </transition>\n</div>\n<style>\n.component-fade-enter-active, .component-fade-leave-active {\n  transition: opacity .3s ease;\n}\n.component-fade-enter, .component-fade-leave-active {\n  opacity: 0;\n}\n</style>\n<script>\nnew Vue({\n  el: '#transition-components-demo',\n  data: {\n    view: 'v-a'\n  },\n  components: {\n    'v-a': {\n      template: '<div>Component A</div>'\n    },\n    'v-b': {\n      template: '<div>Component B</div>'\n    }\n  }\n})\n</script>\n\n<h2 id=\"列表过渡\"><a href=\"#列表过渡\" class=\"headerlink\" title=\"列表过渡\"></a>列表过渡</h2><p>目前为止，关于过渡我们已经讲到：</p>\n<ul>\n<li>单个节点</li>\n<li>一次渲染多个节点</li>\n</ul>\n<p>那么怎么同时渲染整个列表，比如使用 <code>v-for</code> ？在这种场景中，使用  <code>&lt;transition-group&gt;</code> 组件。在我们深入例子之前，先了解关于这个组件的几个特点：</p>\n<ul>\n<li>不同于 <code>&lt;transition&gt;</code>， 它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>。你也可以通过 <code>tag</code> 特性更换为其他元素。</li>\n<li>元素 <strong>一定需要</strong> 指定唯一的 <code>key</code> 特性值</li>\n</ul>\n<h3 id=\"列表的进入和离开过渡\"><a href=\"#列表的进入和离开过渡\" class=\"headerlink\" title=\"列表的进入和离开过渡\"></a>列表的进入和离开过渡</h3><p>现在让我们由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"list-demo\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"add\"</span>&gt;</span>Add<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"remove\"</span>&gt;</span>Remove<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">name</span>=<span class=\"string\">\"list\"</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"p\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"list-item\"</span>&gt;</span></div><div class=\"line\">      &#123;&#123; item &#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#list-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">items</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>],</div><div class=\"line\">    <span class=\"attr\">nextNum</span>: <span class=\"number\">10</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">randomIndex</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"keyword\">this</span>.items.length)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">add</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items.splice(<span class=\"keyword\">this</span>.randomIndex(), <span class=\"number\">0</span>, <span class=\"keyword\">this</span>.nextNum++)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">remove</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items.splice(<span class=\"keyword\">this</span>.randomIndex(), <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.list-item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.list-enter-active</span>, <span class=\"selector-class\">.list-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: all <span class=\"number\">1s</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.list-enter</span>, <span class=\"selector-class\">.list-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(30px);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<div id=\"list-demo\" class=\"demo\">\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list\" tag=\"p\">\n    <span v-for=\"item in items\" :key=\"item\" class=\"list-item\">\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n  }\n})\n</script>\n<style>\n.list-item {\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-enter-active, .list-leave-active {\n  transition: all 1s;\n}\n.list-enter, .list-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n</style>\n\n<p>这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，我们下面会解决这个问题。</p>\n<h3 id=\"列表的位移过渡\"><a href=\"#列表的位移过渡\" class=\"headerlink\" title=\"列表的位移过渡\"></a>列表的位移过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 <strong> <code>v-move</code>  特性</strong>，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 <code>name</code> 属性来自定义前缀，也可以通过 <code>move-class</code> 属性手动设置。</p>\n<p><code>v-move</code> 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"flip-list-demo\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"shuffle\"</span>&gt;</span>Shuffle<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">name</span>=<span class=\"string\">\"flip-list\"</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"ul\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item\"</span>&gt;</span></div><div class=\"line\">      &#123;&#123; item &#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#flip-list-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">items</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">shuffle</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items = _.shuffle(<span class=\"keyword\">this</span>.items)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.flip-list-move</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: transform <span class=\"number\">1s</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n<div id=\"flip-list-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <transition-group name=\"flip-list\" tag=\"ul\">\n    <li v-for=\"item in items\" :key=\"item\">\n      {{ item }}\n    </li>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#flip-list-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9]\n  },\n  methods: {\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n</script>\n<style>\n.flip-list-move {\n  transition: transform 1s;\n}\n</style>\n\n<p>这个看起来很神奇，内部的实现，Vue 使用了一个叫 <a href=\"https://aerotwist.com/blog/flip-your-animations/\">FLIP</a> 简单的动画队列<br>使用 transforms 将元素从之前的位置平滑过渡新的位置。</p>\n<p>我们将之前实现的例子和这个技术结合，使我们列表的一切变动都会有动画过渡。<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"list-complete-demo\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"shuffle\"</span>&gt;</span>Shuffle<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"add\"</span>&gt;</span>Add<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"remove\"</span>&gt;</span>Remove<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">name</span>=<span class=\"string\">\"list-complete\"</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"p\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span></div><div class=\"line\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span></div><div class=\"line\">      <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item\"</span></div><div class=\"line\">      <span class=\"attr\">class</span>=<span class=\"string\">\"list-complete-item\"</span></div><div class=\"line\">    &gt;</span></div><div class=\"line\">      &#123;&#123; item &#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#list-complete-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">items</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>],</div><div class=\"line\">    <span class=\"attr\">nextNum</span>: <span class=\"number\">10</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">randomIndex</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"keyword\">this</span>.items.length)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">add</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items.splice(<span class=\"keyword\">this</span>.randomIndex(), <span class=\"number\">0</span>, <span class=\"keyword\">this</span>.nextNum++)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">remove</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items.splice(<span class=\"keyword\">this</span>.randomIndex(), <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">shuffle</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items = _.shuffle(<span class=\"keyword\">this</span>.items)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.list-complete-item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: all <span class=\"number\">1s</span>;</div><div class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.list-complete-enter</span>, <span class=\"selector-class\">.list-complete-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(30px);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.list-complete-leave-active</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"></script>\n<div id=\"list-complete-demo\" class=\"demo\">\n  <button v-on:click=\"shuffle\">Shuffle</button>\n  <button v-on:click=\"add\">Add</button>\n  <button v-on:click=\"remove\">Remove</button>\n  <transition-group name=\"list-complete\" tag=\"p\">\n    <span v-for=\"item in items\" :key=\"item\" class=\"list-complete-item\">\n      {{ item }}\n    </span>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#list-complete-demo',\n  data: {\n    items: [1,2,3,4,5,6,7,8,9],\n    nextNum: 10\n  },\n  methods: {\n    randomIndex: function () {\n      return Math.floor(Math.random() * this.items.length)\n    },\n    add: function () {\n      this.items.splice(this.randomIndex(), 0, this.nextNum++)\n    },\n    remove: function () {\n      this.items.splice(this.randomIndex(), 1)\n    },\n    shuffle: function () {\n      this.items = _.shuffle(this.items)\n    }\n  }\n})\n</script>\n<style>\n.list-complete-item {\n  transition: all 1s;\n  display: inline-block;\n  margin-right: 10px;\n}\n.list-complete-enter, .list-complete-leave-active {\n  opacity: 0;\n  transform: translateY(30px);\n}\n.list-complete-leave-active {\n  position: absolute;\n}\n</style>\n\n<p class=\"tip\">需要注意的是使用 FLIP 过渡的元素不能设置为 <code>display: inline</code> 。作为替代方案，可以设置为 <code>display: inline-block</code> 或者放置于 flex 中</p>\n\n<p>FLIP 动画不仅可以实现单列过渡，多维网格的过渡也同样<a href=\"https://jsfiddle.net/chrisvfritz/sLrhk1bc/\">简单</a>:</p>\n\n<div id=\"sudoku-demo\" class=\"demo\">\n  <strong>Lazy Sudoku</strong>\n  <p>Keep hitting the shuffle button until you win.</p>\n  <button @click=\"shuffle\">\n    Shuffle\n  </button>\n  <transition-group name=\"cell\" tag=\"div\" class=\"sudoku-container\">\n    <div v-for=\"cell in cells\" :key=\"cell.id\" class=\"cell\">\n      {{ cell.number }}\n    </div>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#sudoku-demo',\n  data: {\n    cells: Array.apply(null, { length: 81 })\n      .map(function (_, index) {\n        return {\n          id: index,\n          number: index % 9 + 1\n        }\n      })\n  },\n  methods: {\n    shuffle: function () {\n      this.cells = _.shuffle(this.cells)\n    }\n  }\n})\n</script>\n<style>\n.sudoku-container {\n  display: flex;\n  flex-wrap: wrap;\n  width: 238px;\n  margin-top: 10px;\n}\n.cell {\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  width: 25px;\n  height: 25px;\n  border: 1px solid #aaa;\n  margin-right: -1px;\n  margin-bottom: -1px;\n}\n.cell:nth-child(3n) {\n  margin-right: 0;\n}\n.cell:nth-child(27n) {\n  margin-bottom: 0;\n}\n.cell-move {\n  transition: transform 1s;\n}\n</style>\n\n<h3 id=\"列表的渐进过渡\"><a href=\"#列表的渐进过渡\" class=\"headerlink\" title=\"列表的渐进过渡\"></a>列表的渐进过渡</h3><p>通过 data 属性与 JavaScript 通信 ，就可以实现列表的渐进过渡：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"staggered-list-demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"query\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition-group</span></div><div class=\"line\">    <span class=\"attr\">name</span>=<span class=\"string\">\"staggered-fade\"</span></div><div class=\"line\">    <span class=\"attr\">tag</span>=<span class=\"string\">\"ul\"</span></div><div class=\"line\">    <span class=\"attr\">v-bind:css</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></div><div class=\"line\">  &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span></div><div class=\"line\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in computedList\"</span></div><div class=\"line\">      <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item.msg\"</span></div><div class=\"line\">      <span class=\"attr\">v-bind:data-index</span>=<span class=\"string\">\"index\"</span></div><div class=\"line\">    &gt;</span>&#123;&#123; item.msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#staggered-list-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">query</span>: <span class=\"string\">''</span>,</div><div class=\"line\">    <span class=\"attr\">list</span>: [</div><div class=\"line\">      &#123; <span class=\"attr\">msg</span>: <span class=\"string\">'Bruce Lee'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">msg</span>: <span class=\"string\">'Jackie Chan'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">msg</span>: <span class=\"string\">'Chuck Norris'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">msg</span>: <span class=\"string\">'Jet Li'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">msg</span>: <span class=\"string\">'Kung Fury'</span> &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">computedList</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== <span class=\"number\">-1</span></div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">beforeEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      el.style.opacity = <span class=\"number\">0</span></div><div class=\"line\">      el.style.height = <span class=\"number\">0</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">enter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> delay = el.dataset.index * <span class=\"number\">150</span></div><div class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        Velocity(</div><div class=\"line\">          el,</div><div class=\"line\">          &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">1</span>, <span class=\"attr\">height</span>: <span class=\"string\">'1.6em'</span> &#125;,</div><div class=\"line\">          &#123; <span class=\"attr\">complete</span>: done &#125;</div><div class=\"line\">        )</div><div class=\"line\">      &#125;, delay)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">leave</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> delay = el.dataset.index * <span class=\"number\">150</span></div><div class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        Velocity(</div><div class=\"line\">          el,</div><div class=\"line\">          &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">0</span>, <span class=\"attr\">height</span>: <span class=\"number\">0</span> &#125;,</div><div class=\"line\">          &#123; <span class=\"attr\">complete</span>: done &#125;</div><div class=\"line\">        )</div><div class=\"line\">      &#125;, delay)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<div id=\"example-5\" class=\"demo\">\n  <input v-model=\"query\">\n  <transition-group\n    name=\"staggered-fade\"\n    tag=\"ul\"\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <li\n      v-for=\"(item, index) in computedList\"\n      v-bind:key=\"item.msg\"\n      v-bind:data-index=\"index\"\n    >{{ item.msg }}</li>\n  </transition-group>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    query: '',\n    list: [\n      { msg: 'Bruce Lee' },\n      { msg: 'Jackie Chan' },\n      { msg: 'Chuck Norris' },\n      { msg: 'Jet Li' },\n      { msg: 'Kung Fury' }\n    ]\n  },\n  computed: {\n    computedList: function () {\n      var vm = this\n      return this.list.filter(function (item) {\n        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1\n      })\n    }\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.height = 0\n    },\n    enter: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 1, height: '1.6em' },\n          { complete: done }\n        )\n      }, delay)\n    },\n    leave: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 0, height: 0 },\n          { complete: done }\n        )\n      }, delay)\n    }\n  }\n})\n</script>\n\n<h2 id=\"可复用的过渡\"><a href=\"#可复用的过渡\" class=\"headerlink\" title=\"可复用的过渡\"></a>可复用的过渡</h2><p>过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 <code>&lt;transition&gt;</code> 或者 <code>&lt;transition-group&gt;</code> 作为根组件，然后将任何子组件放置在其中就可以了。</p>\n<p>使用 template 的简单例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-special-transition'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'\\</div><div class=\"line\">    &lt;transition\\</div><div class=\"line\">      name=\"very-special-transition\"\\</div><div class=\"line\">      mode=\"out-in\"\\</div><div class=\"line\">      v-on:before-enter=\"beforeEnter\"\\</div><div class=\"line\">      v-on:after-enter=\"afterEnter\"\\</div><div class=\"line\">    &gt;\\</div><div class=\"line\">      &lt;slot&gt;&lt;/slot&gt;\\</div><div class=\"line\">    &lt;/transition&gt;\\</div><div class=\"line\">  '</span>,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">beforeEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// ...</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">afterEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>函数组件更适合完成这个任务：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-special-transition'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">functional</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = &#123;</div><div class=\"line\">      <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">'very-special-transition'</span></div><div class=\"line\">        mode: <span class=\"string\">'out-in'</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"attr\">on</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">beforeEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">          <span class=\"comment\">// ...</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"attr\">afterEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">          <span class=\"comment\">// ...</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">'transition'</span>, data, context.children)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"动态过渡\"><a href=\"#动态过渡\" class=\"headerlink\" title=\"动态过渡\"></a>动态过渡</h2><p>在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 <code>name</code> 特性来绑定动态值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">v-bind:name</span>=<span class=\"string\">\"transitionName\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用。</p>\n<p>所有的过渡特性都是动态绑定。它不仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。这意味着，可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dynamic-fade-demo\"</span>&gt;</span></div><div class=\"line\">  Fade In: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"range\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"fadeInDuration\"</span> <span class=\"attr\">min</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">v-bind:max</span>=<span class=\"string\">\"maxFadeDuration\"</span>&gt;</span></div><div class=\"line\">  Fade Out: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"range\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"fadeOutDuration\"</span> <span class=\"attr\">min</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">v-bind:max</span>=<span class=\"string\">\"maxFadeDuration\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span></div><div class=\"line\">    <span class=\"attr\">v-bind:css</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></div><div class=\"line\">    <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></div><div class=\"line\">  &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"stop = true\"</span>&gt;</span>Stop it!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#dynamic-fade-demo'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">fadeInDuration</span>: <span class=\"number\">1000</span>,</div><div class=\"line\">    <span class=\"attr\">fadeOutDuration</span>: <span class=\"number\">1000</span>,</div><div class=\"line\">    <span class=\"attr\">maxFadeDuration</span>: <span class=\"number\">1500</span>,</div><div class=\"line\">    <span class=\"attr\">stop</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">mounted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.show = <span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">beforeEnter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      el.style.opacity = <span class=\"number\">0</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">enter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">      Velocity(el,</div><div class=\"line\">        &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">1</span> &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">          <span class=\"attr\">duration</span>: <span class=\"keyword\">this</span>.fadeInDuration,</div><div class=\"line\">          <span class=\"attr\">complete</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            done()</div><div class=\"line\">            <span class=\"keyword\">if</span> (!vm.stop) vm.show = <span class=\"literal\">false</span></div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      )</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">leave</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, done</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span></div><div class=\"line\">      Velocity(el,</div><div class=\"line\">        &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">0</span> &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">          <span class=\"attr\">duration</span>: <span class=\"keyword\">this</span>.fadeOutDuration,</div><div class=\"line\">          <span class=\"attr\">complete</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            done()</div><div class=\"line\">            vm.show = <span class=\"literal\">true</span></div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      )</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n<div id=\"dynamic-fade-demo\" class=\"demo\">\n  Fade In: <input type=\"range\" v-model=\"fadeInDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  Fade Out: <input type=\"range\" v-model=\"fadeOutDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\">\n  <transition\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n  <button v-on:click=\"stop = true\">Stop it!</button>\n</div>\n<script>\nnew Vue({\n  el: '#dynamic-fade-demo',\n  data: {\n    show: true,\n    fadeInDuration: 1000,\n    fadeOutDuration: 1000,\n    maxFadeDuration: 1500,\n    stop: false\n  },\n  mounted: function () {\n    this.show = false\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n    },\n    enter: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 1 },\n        {\n          duration: this.fadeInDuration,\n          complete: function () {\n            done()\n            if (!vm.stop) vm.show = false\n          }\n        }\n      )\n    },\n    leave: function (el, done) {\n      var vm = this\n      Velocity(el,\n        { opacity: 0 },\n        {\n          duration: this.fadeOutDuration,\n          complete: function () {\n            done()\n            vm.show = true\n          }\n        }\n      )\n    }\n  }\n})\n</script>\n\n<p>最后，创建动态过渡的最终方案是组件通过接受 props 来动态修改之前的过渡。一句老话，唯一的限制是你的想象力。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"http://vuejs.org/guide/transitions.html\">http://vuejs.org/guide/transitions.html</a></p>\n</blockquote>\n<hr>\n"}],"Post":[{"title":"Vue.js 0.12 released!","date":"2015-06-11T09:37:30.000Z","_content":"\nI'm really excited to announce that [Vue.js 0.12: Dragon Ball](https://github.com/yyx990803/vue/releases/tag/0.12.0) is finally here! Thanks to everyone who tried out the beta/rc versions and provided feedback / bug reports along the way.\n\nThere's a lot to cover in this release, and we will talk about a few highlights below. However, it is still recommended to carefully go through the [Full Release Note](https://github.com/yyx990803/vue/releases/tag/0.12.0) and updated docs if you are upgrading from 0.11. You can report bugs on GitHub, send questions to [vuejs/Discussion](https://github.com/vuejs/Discussion/issues), or join us in the [Gitter chat channel](https://gitter.im/yyx990803/vue).\n\n<!-- more -->\n\n### More Consistent Component Syntax\n\nPreviously in 0.11 you have two ways to use a Vue.js component: using the `v-component` directive, or using custom elements. There are also two ways to pass data down to child components: using the `v-with` directive, or using the `paramAttributes` option. Although both custom elements and param attributes get compiled down to directives eventually, it is confusing and redundant to have two sets of syntax for the same functionality.\n\nIn addition, it should be noted that the component system is a first-class concept in Vue.js, even more important than directives. It defines how we encapsulate our higher-level view logic and compose our application. In the meanwhile, having a clear and declarative way to pass data into child components is also very important. Components and param attributes really deserve their own dedicated syntax to differentiate from other directives.\n\nAs a result, `v-component` and `v-with` have been deprecated in 0.12. `paramAttributes` has also been renamed to `props`, which is shorter and cleaner. From now on, most Vue.js components will look like this:\n\n``` html\n<my-component prop=\"{{parentData}}\"></my-component>\n```\n\nThere are also additional props-related improvements such as explicit one-time or one-way props, expression as props, methods as prop callbacks and more. You can find out more details in the 0.12 release notes linked above and the updated [Component System](/guide/components.html) section of the guide.\n\n### Filter Arguments Improvements\n\nIn 0.11, filters always receive their arguments as plain strings. An argument can be enclosed in quotes to include whitespace, but the quotes are not automatically stripped when passed into the filter function. Some users were also confused about how to retrive a dynamic value on the vm instead of a plain string.\n\nIn 0.12, the filter argument syntax now follows a simple rule: if an argument is enclosed in quotes, it will be passed in as a plain string; otherwise, it will be evaluated against the current vm as a dynamic value.\n\nThis means the usage of some existing filters will have to change:\n\n``` html\n<a v-on=\"keyup: onKeyUp | key 'enter'\"></a>\n{{ items.length | pluralize 'item' }}\n```\n\nBut it would make custom filters that rely on dynamic values much easier to write:\n\n``` html\n{{ msg | concat otherMsg }}\n```\n\nHere the first argument to the `concat` filter will be the value of `this.otherMsg`.\n\n### Asynchronous Components\n\nIt is common practice to bundle all the JavaScript into one file when building large single page applications. But when the file becomes too large, we may want to defer loading parts of our application for a faster initial load. However, this does pose some constraints on how the application architecture should be designed. It could be very tricky to figure out how to properly split up your JavaScript bundles.\n\nWell, with Vue.js we can already build our applications as decoupled components. If we can lazily load a dynamic component only when it is needed, wouldn't it be awesome? As a matter of fact, in 0.12 this would be trivially easy with the new Asynchronous Component feature.\n\nIn 0.12, you can define a component as a factory function that asynchronously resolves a component definition (can be just a plain options object). Vue.js will only trigger the factory function when the component actually needs to be rendered, and will cache the result for future re-renders:\n\n``` js\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```\n\nIt is up to you to decide how to load the component from the server, e.g. `$.getScript()` or require.js; but the recommended usage is to pair it up with Webpack's [Code Splitting feature](http://webpack.github.io/docs/code-splitting.html):\n\n``` js\nVue.component('async-webpack-example', function (resolve, reject) {\n  // In Webpack AMD like syntax indicates a code split point\n  require(['./my-async-component'], resolve)\n})\n```\n\nThat's all you need to do. You can use the component just like before, without even thinking about it being async. Webpack will automatically split your final JavaScript into separate bundles with correct dependencies, and automatically load a bundle via Ajax when it is required. You can check out a fully functional example [here](https://github.com/vuejs/vue-webpack-example).\n\n### Improved Transition System\n\nVue.js' transition system is really easy to use, but in the past it has the limitation that you cannot mix CSS and JavaScript-based transitions together. In 0.12 that is no longer the case! The improved transition system now allows you to add JavaScript hooks to a CSS-based transition for additional control. The amount of hooks exposed have also been expanded to give you finer-grained control at every stage of the transition.\n\n`v-repeat` now also ships with built-in support for staggering transitions. It is as simple as adding `stagger=\"100\"` to your repeated element. It is also possible to define separate staggering for enter and leaving, or even dynamically calculate the staggering delay in a JavaScript hook.\n\nFor full details on the new transition system, check out the [updated guide](/guide/transitions.html).\n\n### Performance Tuning\n\nVue.js' precise dependency tracking makes it the one of the most efficient view layer for small hot updates, but there's always room for improvement. In 0.12, internal instance creation and compilation refactors have improved first-render performance for large lists by up to 40%. With proper `track-by` usage, [re-rendering with large, brand new dataset](http://vuejs.github.io/js-repaint-perfs/vue/) is also comparable to, or even faster than other Virtual-DOM based frameworks.\n\n### One More Thing...\n\nWith 0.12 out of the door, more efforts will now be spent on the official vue-router, a dedicated routing library for Vue.js with nested view matching, full transition support, and asynchronous data hooks. I have expressed that Vue.js core intends to stay as a no-frills, drop-in view layer library, and that will not change. The vue-router will be shipped separately and is totally optional, however you can expect it to work seamlessly with Vue.js core when you need it.\n","source":"_posts/012-release.md","raw":"---\ntitle: Vue.js 0.12 released!\ndate: 2015-06-11 17:37:30\n---\n\nI'm really excited to announce that [Vue.js 0.12: Dragon Ball](https://github.com/yyx990803/vue/releases/tag/0.12.0) is finally here! Thanks to everyone who tried out the beta/rc versions and provided feedback / bug reports along the way.\n\nThere's a lot to cover in this release, and we will talk about a few highlights below. However, it is still recommended to carefully go through the [Full Release Note](https://github.com/yyx990803/vue/releases/tag/0.12.0) and updated docs if you are upgrading from 0.11. You can report bugs on GitHub, send questions to [vuejs/Discussion](https://github.com/vuejs/Discussion/issues), or join us in the [Gitter chat channel](https://gitter.im/yyx990803/vue).\n\n<!-- more -->\n\n### More Consistent Component Syntax\n\nPreviously in 0.11 you have two ways to use a Vue.js component: using the `v-component` directive, or using custom elements. There are also two ways to pass data down to child components: using the `v-with` directive, or using the `paramAttributes` option. Although both custom elements and param attributes get compiled down to directives eventually, it is confusing and redundant to have two sets of syntax for the same functionality.\n\nIn addition, it should be noted that the component system is a first-class concept in Vue.js, even more important than directives. It defines how we encapsulate our higher-level view logic and compose our application. In the meanwhile, having a clear and declarative way to pass data into child components is also very important. Components and param attributes really deserve their own dedicated syntax to differentiate from other directives.\n\nAs a result, `v-component` and `v-with` have been deprecated in 0.12. `paramAttributes` has also been renamed to `props`, which is shorter and cleaner. From now on, most Vue.js components will look like this:\n\n``` html\n<my-component prop=\"{{parentData}}\"></my-component>\n```\n\nThere are also additional props-related improvements such as explicit one-time or one-way props, expression as props, methods as prop callbacks and more. You can find out more details in the 0.12 release notes linked above and the updated [Component System](/guide/components.html) section of the guide.\n\n### Filter Arguments Improvements\n\nIn 0.11, filters always receive their arguments as plain strings. An argument can be enclosed in quotes to include whitespace, but the quotes are not automatically stripped when passed into the filter function. Some users were also confused about how to retrive a dynamic value on the vm instead of a plain string.\n\nIn 0.12, the filter argument syntax now follows a simple rule: if an argument is enclosed in quotes, it will be passed in as a plain string; otherwise, it will be evaluated against the current vm as a dynamic value.\n\nThis means the usage of some existing filters will have to change:\n\n``` html\n<a v-on=\"keyup: onKeyUp | key 'enter'\"></a>\n{{ items.length | pluralize 'item' }}\n```\n\nBut it would make custom filters that rely on dynamic values much easier to write:\n\n``` html\n{{ msg | concat otherMsg }}\n```\n\nHere the first argument to the `concat` filter will be the value of `this.otherMsg`.\n\n### Asynchronous Components\n\nIt is common practice to bundle all the JavaScript into one file when building large single page applications. But when the file becomes too large, we may want to defer loading parts of our application for a faster initial load. However, this does pose some constraints on how the application architecture should be designed. It could be very tricky to figure out how to properly split up your JavaScript bundles.\n\nWell, with Vue.js we can already build our applications as decoupled components. If we can lazily load a dynamic component only when it is needed, wouldn't it be awesome? As a matter of fact, in 0.12 this would be trivially easy with the new Asynchronous Component feature.\n\nIn 0.12, you can define a component as a factory function that asynchronously resolves a component definition (can be just a plain options object). Vue.js will only trigger the factory function when the component actually needs to be rendered, and will cache the result for future re-renders:\n\n``` js\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```\n\nIt is up to you to decide how to load the component from the server, e.g. `$.getScript()` or require.js; but the recommended usage is to pair it up with Webpack's [Code Splitting feature](http://webpack.github.io/docs/code-splitting.html):\n\n``` js\nVue.component('async-webpack-example', function (resolve, reject) {\n  // In Webpack AMD like syntax indicates a code split point\n  require(['./my-async-component'], resolve)\n})\n```\n\nThat's all you need to do. You can use the component just like before, without even thinking about it being async. Webpack will automatically split your final JavaScript into separate bundles with correct dependencies, and automatically load a bundle via Ajax when it is required. You can check out a fully functional example [here](https://github.com/vuejs/vue-webpack-example).\n\n### Improved Transition System\n\nVue.js' transition system is really easy to use, but in the past it has the limitation that you cannot mix CSS and JavaScript-based transitions together. In 0.12 that is no longer the case! The improved transition system now allows you to add JavaScript hooks to a CSS-based transition for additional control. The amount of hooks exposed have also been expanded to give you finer-grained control at every stage of the transition.\n\n`v-repeat` now also ships with built-in support for staggering transitions. It is as simple as adding `stagger=\"100\"` to your repeated element. It is also possible to define separate staggering for enter and leaving, or even dynamically calculate the staggering delay in a JavaScript hook.\n\nFor full details on the new transition system, check out the [updated guide](/guide/transitions.html).\n\n### Performance Tuning\n\nVue.js' precise dependency tracking makes it the one of the most efficient view layer for small hot updates, but there's always room for improvement. In 0.12, internal instance creation and compilation refactors have improved first-render performance for large lists by up to 40%. With proper `track-by` usage, [re-rendering with large, brand new dataset](http://vuejs.github.io/js-repaint-perfs/vue/) is also comparable to, or even faster than other Virtual-DOM based frameworks.\n\n### One More Thing...\n\nWith 0.12 out of the door, more efforts will now be spent on the official vue-router, a dedicated routing library for Vue.js with nested view matching, full transition support, and asynchronous data hooks. I have expressed that Vue.js core intends to stay as a no-frills, drop-in view layer library, and that will not change. The vue-router will be shipped separately and is totally optional, however you can expect it to work seamlessly with Vue.js core when you need it.\n","slug":"012-release","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajuw90001jl2dfu67dz3j","content":"<p>I’m really excited to announce that <a href=\"https://github.com/yyx990803/vue/releases/tag/0.12.0\" target=\"_blank\" rel=\"external\">Vue.js 0.12: Dragon Ball</a> is finally here! Thanks to everyone who tried out the beta/rc versions and provided feedback / bug reports along the way.</p>\n<p>There’s a lot to cover in this release, and we will talk about a few highlights below. However, it is still recommended to carefully go through the <a href=\"https://github.com/yyx990803/vue/releases/tag/0.12.0\" target=\"_blank\" rel=\"external\">Full Release Note</a> and updated docs if you are upgrading from 0.11. You can report bugs on GitHub, send questions to <a href=\"https://github.com/vuejs/Discussion/issues\" target=\"_blank\" rel=\"external\">vuejs/Discussion</a>, or join us in the <a href=\"https://gitter.im/yyx990803/vue\" target=\"_blank\" rel=\"external\">Gitter chat channel</a>.</p>\n<a id=\"more\"></a>\n<h3 id=\"More-Consistent-Component-Syntax\"><a href=\"#More-Consistent-Component-Syntax\" class=\"headerlink\" title=\"More Consistent Component Syntax\"></a>More Consistent Component Syntax</h3><p>Previously in 0.11 you have two ways to use a Vue.js component: using the <code>v-component</code> directive, or using custom elements. There are also two ways to pass data down to child components: using the <code>v-with</code> directive, or using the <code>paramAttributes</code> option. Although both custom elements and param attributes get compiled down to directives eventually, it is confusing and redundant to have two sets of syntax for the same functionality.</p>\n<p>In addition, it should be noted that the component system is a first-class concept in Vue.js, even more important than directives. It defines how we encapsulate our higher-level view logic and compose our application. In the meanwhile, having a clear and declarative way to pass data into child components is also very important. Components and param attributes really deserve their own dedicated syntax to differentiate from other directives.</p>\n<p>As a result, <code>v-component</code> and <code>v-with</code> have been deprecated in 0.12. <code>paramAttributes</code> has also been renamed to <code>props</code>, which is shorter and cleaner. From now on, most Vue.js components will look like this:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">prop</span>=<span class=\"string\">\"&#123;&#123;parentData&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>There are also additional props-related improvements such as explicit one-time or one-way props, expression as props, methods as prop callbacks and more. You can find out more details in the 0.12 release notes linked above and the updated <a href=\"/guide/components.html\">Component System</a> section of the guide.</p>\n<h3 id=\"Filter-Arguments-Improvements\"><a href=\"#Filter-Arguments-Improvements\" class=\"headerlink\" title=\"Filter Arguments Improvements\"></a>Filter Arguments Improvements</h3><p>In 0.11, filters always receive their arguments as plain strings. An argument can be enclosed in quotes to include whitespace, but the quotes are not automatically stripped when passed into the filter function. Some users were also confused about how to retrive a dynamic value on the vm instead of a plain string.</p>\n<p>In 0.12, the filter argument syntax now follows a simple rule: if an argument is enclosed in quotes, it will be passed in as a plain string; otherwise, it will be evaluated against the current vm as a dynamic value.</p>\n<p>This means the usage of some existing filters will have to change:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on</span>=<span class=\"string\">\"keyup: onKeyUp | key 'enter'\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">&#123;&#123; items.length | pluralize 'item' &#125;&#125;</div></pre></td></tr></table></figure>\n<p>But it would make custom filters that rely on dynamic values much easier to write:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&#123; msg | concat otherMsg &#125;&#125;</div></pre></td></tr></table></figure>\n<p>Here the first argument to the <code>concat</code> filter will be the value of <code>this.otherMsg</code>.</p>\n<h3 id=\"Asynchronous-Components\"><a href=\"#Asynchronous-Components\" class=\"headerlink\" title=\"Asynchronous Components\"></a>Asynchronous Components</h3><p>It is common practice to bundle all the JavaScript into one file when building large single page applications. But when the file becomes too large, we may want to defer loading parts of our application for a faster initial load. However, this does pose some constraints on how the application architecture should be designed. It could be very tricky to figure out how to properly split up your JavaScript bundles.</p>\n<p>Well, with Vue.js we can already build our applications as decoupled components. If we can lazily load a dynamic component only when it is needed, wouldn’t it be awesome? As a matter of fact, in 0.12 this would be trivially easy with the new Asynchronous Component feature.</p>\n<p>In 0.12, you can define a component as a factory function that asynchronously resolves a component definition (can be just a plain options object). Vue.js will only trigger the factory function when the component actually needs to be rendered, and will cache the result for future re-renders:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'async-example'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    resolve(&#123;</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;I am async!&lt;/div&gt;'</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>It is up to you to decide how to load the component from the server, e.g. <code>$.getScript()</code> or require.js; but the recommended usage is to pair it up with Webpack’s <a href=\"http://webpack.github.io/docs/code-splitting.html\" target=\"_blank\" rel=\"external\">Code Splitting feature</a>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'async-webpack-example'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// In Webpack AMD like syntax indicates a code split point</span></div><div class=\"line\">  <span class=\"built_in\">require</span>([<span class=\"string\">'./my-async-component'</span>], resolve)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>That’s all you need to do. You can use the component just like before, without even thinking about it being async. Webpack will automatically split your final JavaScript into separate bundles with correct dependencies, and automatically load a bundle via Ajax when it is required. You can check out a fully functional example <a href=\"https://github.com/vuejs/vue-webpack-example\" target=\"_blank\" rel=\"external\">here</a>.</p>\n<h3 id=\"Improved-Transition-System\"><a href=\"#Improved-Transition-System\" class=\"headerlink\" title=\"Improved Transition System\"></a>Improved Transition System</h3><p>Vue.js’ transition system is really easy to use, but in the past it has the limitation that you cannot mix CSS and JavaScript-based transitions together. In 0.12 that is no longer the case! The improved transition system now allows you to add JavaScript hooks to a CSS-based transition for additional control. The amount of hooks exposed have also been expanded to give you finer-grained control at every stage of the transition.</p>\n<p><code>v-repeat</code> now also ships with built-in support for staggering transitions. It is as simple as adding <code>stagger=&quot;100&quot;</code> to your repeated element. It is also possible to define separate staggering for enter and leaving, or even dynamically calculate the staggering delay in a JavaScript hook.</p>\n<p>For full details on the new transition system, check out the <a href=\"/guide/transitions.html\">updated guide</a>.</p>\n<h3 id=\"Performance-Tuning\"><a href=\"#Performance-Tuning\" class=\"headerlink\" title=\"Performance Tuning\"></a>Performance Tuning</h3><p>Vue.js’ precise dependency tracking makes it the one of the most efficient view layer for small hot updates, but there’s always room for improvement. In 0.12, internal instance creation and compilation refactors have improved first-render performance for large lists by up to 40%. With proper <code>track-by</code> usage, <a href=\"http://vuejs.github.io/js-repaint-perfs/vue/\" target=\"_blank\" rel=\"external\">re-rendering with large, brand new dataset</a> is also comparable to, or even faster than other Virtual-DOM based frameworks.</p>\n<h3 id=\"One-More-Thing…\"><a href=\"#One-More-Thing…\" class=\"headerlink\" title=\"One More Thing…\"></a>One More Thing…</h3><p>With 0.12 out of the door, more efforts will now be spent on the official vue-router, a dedicated routing library for Vue.js with nested view matching, full transition support, and asynchronous data hooks. I have expressed that Vue.js core intends to stay as a no-frills, drop-in view layer library, and that will not change. The vue-router will be shipped separately and is totally optional, however you can expect it to work seamlessly with Vue.js core when you need it.</p>\n","excerpt":"<p>I’m really excited to announce that <a href=\"https://github.com/yyx990803/vue/releases/tag/0.12.0\">Vue.js 0.12: Dragon Ball</a> is finally here! Thanks to everyone who tried out the beta/rc versions and provided feedback / bug reports along the way.</p>\n<p>There’s a lot to cover in this release, and we will talk about a few highlights below. However, it is still recommended to carefully go through the <a href=\"https://github.com/yyx990803/vue/releases/tag/0.12.0\">Full Release Note</a> and updated docs if you are upgrading from 0.11. You can report bugs on GitHub, send questions to <a href=\"https://github.com/vuejs/Discussion/issues\">vuejs/Discussion</a>, or join us in the <a href=\"https://gitter.im/yyx990803/vue\">Gitter chat channel</a>.</p>","more":"<h3 id=\"More-Consistent-Component-Syntax\"><a href=\"#More-Consistent-Component-Syntax\" class=\"headerlink\" title=\"More Consistent Component Syntax\"></a>More Consistent Component Syntax</h3><p>Previously in 0.11 you have two ways to use a Vue.js component: using the <code>v-component</code> directive, or using custom elements. There are also two ways to pass data down to child components: using the <code>v-with</code> directive, or using the <code>paramAttributes</code> option. Although both custom elements and param attributes get compiled down to directives eventually, it is confusing and redundant to have two sets of syntax for the same functionality.</p>\n<p>In addition, it should be noted that the component system is a first-class concept in Vue.js, even more important than directives. It defines how we encapsulate our higher-level view logic and compose our application. In the meanwhile, having a clear and declarative way to pass data into child components is also very important. Components and param attributes really deserve their own dedicated syntax to differentiate from other directives.</p>\n<p>As a result, <code>v-component</code> and <code>v-with</code> have been deprecated in 0.12. <code>paramAttributes</code> has also been renamed to <code>props</code>, which is shorter and cleaner. From now on, most Vue.js components will look like this:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">prop</span>=<span class=\"string\">\"&#123;&#123;parentData&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>There are also additional props-related improvements such as explicit one-time or one-way props, expression as props, methods as prop callbacks and more. You can find out more details in the 0.12 release notes linked above and the updated <a href=\"/guide/components.html\">Component System</a> section of the guide.</p>\n<h3 id=\"Filter-Arguments-Improvements\"><a href=\"#Filter-Arguments-Improvements\" class=\"headerlink\" title=\"Filter Arguments Improvements\"></a>Filter Arguments Improvements</h3><p>In 0.11, filters always receive their arguments as plain strings. An argument can be enclosed in quotes to include whitespace, but the quotes are not automatically stripped when passed into the filter function. Some users were also confused about how to retrive a dynamic value on the vm instead of a plain string.</p>\n<p>In 0.12, the filter argument syntax now follows a simple rule: if an argument is enclosed in quotes, it will be passed in as a plain string; otherwise, it will be evaluated against the current vm as a dynamic value.</p>\n<p>This means the usage of some existing filters will have to change:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on</span>=<span class=\"string\">\"keyup: onKeyUp | key 'enter'\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">&#123;&#123; items.length | pluralize 'item' &#125;&#125;</div></pre></td></tr></table></figure>\n<p>But it would make custom filters that rely on dynamic values much easier to write:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&#123; msg | concat otherMsg &#125;&#125;</div></pre></td></tr></table></figure>\n<p>Here the first argument to the <code>concat</code> filter will be the value of <code>this.otherMsg</code>.</p>\n<h3 id=\"Asynchronous-Components\"><a href=\"#Asynchronous-Components\" class=\"headerlink\" title=\"Asynchronous Components\"></a>Asynchronous Components</h3><p>It is common practice to bundle all the JavaScript into one file when building large single page applications. But when the file becomes too large, we may want to defer loading parts of our application for a faster initial load. However, this does pose some constraints on how the application architecture should be designed. It could be very tricky to figure out how to properly split up your JavaScript bundles.</p>\n<p>Well, with Vue.js we can already build our applications as decoupled components. If we can lazily load a dynamic component only when it is needed, wouldn’t it be awesome? As a matter of fact, in 0.12 this would be trivially easy with the new Asynchronous Component feature.</p>\n<p>In 0.12, you can define a component as a factory function that asynchronously resolves a component definition (can be just a plain options object). Vue.js will only trigger the factory function when the component actually needs to be rendered, and will cache the result for future re-renders:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'async-example'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    resolve(&#123;</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;I am async!&lt;/div&gt;'</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>It is up to you to decide how to load the component from the server, e.g. <code>$.getScript()</code> or require.js; but the recommended usage is to pair it up with Webpack’s <a href=\"http://webpack.github.io/docs/code-splitting.html\">Code Splitting feature</a>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'async-webpack-example'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// In Webpack AMD like syntax indicates a code split point</span></div><div class=\"line\">  <span class=\"built_in\">require</span>([<span class=\"string\">'./my-async-component'</span>], resolve)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>That’s all you need to do. You can use the component just like before, without even thinking about it being async. Webpack will automatically split your final JavaScript into separate bundles with correct dependencies, and automatically load a bundle via Ajax when it is required. You can check out a fully functional example <a href=\"https://github.com/vuejs/vue-webpack-example\">here</a>.</p>\n<h3 id=\"Improved-Transition-System\"><a href=\"#Improved-Transition-System\" class=\"headerlink\" title=\"Improved Transition System\"></a>Improved Transition System</h3><p>Vue.js’ transition system is really easy to use, but in the past it has the limitation that you cannot mix CSS and JavaScript-based transitions together. In 0.12 that is no longer the case! The improved transition system now allows you to add JavaScript hooks to a CSS-based transition for additional control. The amount of hooks exposed have also been expanded to give you finer-grained control at every stage of the transition.</p>\n<p><code>v-repeat</code> now also ships with built-in support for staggering transitions. It is as simple as adding <code>stagger=&quot;100&quot;</code> to your repeated element. It is also possible to define separate staggering for enter and leaving, or even dynamically calculate the staggering delay in a JavaScript hook.</p>\n<p>For full details on the new transition system, check out the <a href=\"/guide/transitions.html\">updated guide</a>.</p>\n<h3 id=\"Performance-Tuning\"><a href=\"#Performance-Tuning\" class=\"headerlink\" title=\"Performance Tuning\"></a>Performance Tuning</h3><p>Vue.js’ precise dependency tracking makes it the one of the most efficient view layer for small hot updates, but there’s always room for improvement. In 0.12, internal instance creation and compilation refactors have improved first-render performance for large lists by up to 40%. With proper <code>track-by</code> usage, <a href=\"http://vuejs.github.io/js-repaint-perfs/vue/\">re-rendering with large, brand new dataset</a> is also comparable to, or even faster than other Virtual-DOM based frameworks.</p>\n<h3 id=\"One-More-Thing…\"><a href=\"#One-More-Thing…\" class=\"headerlink\" title=\"One More Thing…\"></a>One More Thing…</h3><p>With 0.12 out of the door, more efforts will now be spent on the official vue-router, a dedicated routing library for Vue.js with nested view matching, full transition support, and asynchronous data hooks. I have expressed that Vue.js core intends to stay as a no-frills, drop-in view layer library, and that will not change. The vue-router will be shipped separately and is totally optional, however you can expect it to work seamlessly with Vue.js core when you need it.</p>"},{"title":"0.11 Component Tips","date":"2014-12-08T07:02:14.000Z","_content":"\n<p class=\"tip\">Note: this post contains information for the outdated 0.11 version. Please refer to the [0.12 release notes](https://github.com/yyx990803/vue/releases) for the changes in the API.</p>\n\nThe release of 0.11 introduced [many changes](https://github.com/yyx990803/vue/blob/master/changes.md), but the most important one is how the new component scope works. Previously in 0.10.x, components have inherited scope by default. That means in a child component template you can reference parent scope properties. This often leads to tightly-coupled components, where a child component assumes knowledge of what properties are present in the parent scope. It is also possible to accidentally refer to a parent scope property in a child component.\n\n<!-- more -->\n\n### Isolated Scope and Data Passing\n\nStarting in 0.11, all child components have isolated scope by default, and the recommended way to control component data access is via [Explicit Data Passing](/guide/components.html#Explicit_Data_Passing) using [`v-with`](/api/directives.html#v-with) or [`paramAttributes`](/api/options.html#paramAttributes).\n\n`paramAttributes` enables us to write Web Component style templates:\n\n``` js\nVue.component('my-component', {\n  paramAttributes: ['params'],\n  compiled: function () {\n    console.log(this.params) // passed from parent\n  }\n})\n```\n\n``` html\n<my-component params=\"{{params}}\"></my-component>\n```\n\n### Where Does It Belong?\n\nPreviously in 0.10, all directives on a component's container element are compiled in the child component's scope. Because it inherited parent scope, this worked in most situations. Starting in 0.11.1, we want to provide a cleaner separation between component scopes. The rule of thumbs is: if something appears in the parent template, it will be compiled in parent scope; if it appears in child template, it will be compiled in child scope. For example:\n\n``` html\n<!-- parent template -->\n<div v-component=\"child\" v-on=\"click:onParentClick\">\n  <p>{{parentMessage}}</p>\n</div>\n```\n\n``` html\n<!-- child template, with replace: true -->\n<div v-on=\"click:onChildClick\">\n  <h1>{{childMessage}}</h1>\n  <content></content>\n</div>\n```\n\nEverything in the parent template will be compiled in the parent's scope, including the content that's going to be inserted into the child component.\n\nThe only exception to the rule is `v-with` (and `paramAttributes` which compiles down to `v-with`), which works in both places - so you don't need to worry about it too much.\n\n### Cleaner Event Communication\n\nPreviously the standard way for a child component to communicate to its parent is via dispatching events. However, with this approach, the event listeners on the parent component are not guaranteed to be listening on the desired child component only. It's also possible to trigger undesired listners further up the chain if we do not cancel the event.\n\nThe most common use case is for a parent to react to the events from a specific, direct child component. So in 0.11.4, [a new directive `v-events`](/api/directives.html#v-events) has been introduced to enable exactly this behavior.\n\n0.11.4 has already been released, go try it out!\n","source":"_posts/011-component.md","raw":"---\ntitle: 0.11 Component Tips\ndate: 2014-12-08 15:02:14\ntags:\n---\n\n<p class=\"tip\">Note: this post contains information for the outdated 0.11 version. Please refer to the [0.12 release notes](https://github.com/yyx990803/vue/releases) for the changes in the API.</p>\n\nThe release of 0.11 introduced [many changes](https://github.com/yyx990803/vue/blob/master/changes.md), but the most important one is how the new component scope works. Previously in 0.10.x, components have inherited scope by default. That means in a child component template you can reference parent scope properties. This often leads to tightly-coupled components, where a child component assumes knowledge of what properties are present in the parent scope. It is also possible to accidentally refer to a parent scope property in a child component.\n\n<!-- more -->\n\n### Isolated Scope and Data Passing\n\nStarting in 0.11, all child components have isolated scope by default, and the recommended way to control component data access is via [Explicit Data Passing](/guide/components.html#Explicit_Data_Passing) using [`v-with`](/api/directives.html#v-with) or [`paramAttributes`](/api/options.html#paramAttributes).\n\n`paramAttributes` enables us to write Web Component style templates:\n\n``` js\nVue.component('my-component', {\n  paramAttributes: ['params'],\n  compiled: function () {\n    console.log(this.params) // passed from parent\n  }\n})\n```\n\n``` html\n<my-component params=\"{{params}}\"></my-component>\n```\n\n### Where Does It Belong?\n\nPreviously in 0.10, all directives on a component's container element are compiled in the child component's scope. Because it inherited parent scope, this worked in most situations. Starting in 0.11.1, we want to provide a cleaner separation between component scopes. The rule of thumbs is: if something appears in the parent template, it will be compiled in parent scope; if it appears in child template, it will be compiled in child scope. For example:\n\n``` html\n<!-- parent template -->\n<div v-component=\"child\" v-on=\"click:onParentClick\">\n  <p>{{parentMessage}}</p>\n</div>\n```\n\n``` html\n<!-- child template, with replace: true -->\n<div v-on=\"click:onChildClick\">\n  <h1>{{childMessage}}</h1>\n  <content></content>\n</div>\n```\n\nEverything in the parent template will be compiled in the parent's scope, including the content that's going to be inserted into the child component.\n\nThe only exception to the rule is `v-with` (and `paramAttributes` which compiles down to `v-with`), which works in both places - so you don't need to worry about it too much.\n\n### Cleaner Event Communication\n\nPreviously the standard way for a child component to communicate to its parent is via dispatching events. However, with this approach, the event listeners on the parent component are not guaranteed to be listening on the desired child component only. It's also possible to trigger undesired listners further up the chain if we do not cancel the event.\n\nThe most common use case is for a parent to react to the events from a specific, direct child component. So in 0.11.4, [a new directive `v-events`](/api/directives.html#v-events) has been introduced to enable exactly this behavior.\n\n0.11.4 has already been released, go try it out!\n","slug":"011-component","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajuwg0003jl2ddqhwchaj","content":"<p class=\"tip\">Note: this post contains information for the outdated 0.11 version. Please refer to the <a href=\"https://github.com/yyx990803/vue/releases\" target=\"_blank\" rel=\"external\">0.12 release notes</a> for the changes in the API.</p>\n\n<p>The release of 0.11 introduced <a href=\"https://github.com/yyx990803/vue/blob/master/changes.md\" target=\"_blank\" rel=\"external\">many changes</a>, but the most important one is how the new component scope works. Previously in 0.10.x, components have inherited scope by default. That means in a child component template you can reference parent scope properties. This often leads to tightly-coupled components, where a child component assumes knowledge of what properties are present in the parent scope. It is also possible to accidentally refer to a parent scope property in a child component.</p>\n<a id=\"more\"></a>\n<h3 id=\"Isolated-Scope-and-Data-Passing\"><a href=\"#Isolated-Scope-and-Data-Passing\" class=\"headerlink\" title=\"Isolated Scope and Data Passing\"></a>Isolated Scope and Data Passing</h3><p>Starting in 0.11, all child components have isolated scope by default, and the recommended way to control component data access is via <a href=\"/guide/components.html#Explicit_Data_Passing\">Explicit Data Passing</a> using <a href=\"/api/directives.html#v-with\"><code>v-with</code></a> or <a href=\"/api/options.html#paramAttributes\"><code>paramAttributes</code></a>.</p>\n<p><code>paramAttributes</code> enables us to write Web Component style templates:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">paramAttributes</span>: [<span class=\"string\">'params'</span>],</div><div class=\"line\">  <span class=\"attr\">compiled</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.params) <span class=\"comment\">// passed from parent</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">params</span>=<span class=\"string\">\"&#123;&#123;params&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"Where-Does-It-Belong\"><a href=\"#Where-Does-It-Belong\" class=\"headerlink\" title=\"Where Does It Belong?\"></a>Where Does It Belong?</h3><p>Previously in 0.10, all directives on a component’s container element are compiled in the child component’s scope. Because it inherited parent scope, this worked in most situations. Starting in 0.11.1, we want to provide a cleaner separation between component scopes. The rule of thumbs is: if something appears in the parent template, it will be compiled in parent scope; if it appears in child template, it will be compiled in child scope. For example:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- parent template --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-component</span>=<span class=\"string\">\"child\"</span> <span class=\"attr\">v-on</span>=<span class=\"string\">\"click:onParentClick\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;parentMessage&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- child template, with replace: true --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on</span>=<span class=\"string\">\"click:onChildClick\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123;childMessage&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">content</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Everything in the parent template will be compiled in the parent’s scope, including the content that’s going to be inserted into the child component.</p>\n<p>The only exception to the rule is <code>v-with</code> (and <code>paramAttributes</code> which compiles down to <code>v-with</code>), which works in both places - so you don’t need to worry about it too much.</p>\n<h3 id=\"Cleaner-Event-Communication\"><a href=\"#Cleaner-Event-Communication\" class=\"headerlink\" title=\"Cleaner Event Communication\"></a>Cleaner Event Communication</h3><p>Previously the standard way for a child component to communicate to its parent is via dispatching events. However, with this approach, the event listeners on the parent component are not guaranteed to be listening on the desired child component only. It’s also possible to trigger undesired listners further up the chain if we do not cancel the event.</p>\n<p>The most common use case is for a parent to react to the events from a specific, direct child component. So in 0.11.4, <a href=\"/api/directives.html#v-events\">a new directive <code>v-events</code></a> has been introduced to enable exactly this behavior.</p>\n<p>0.11.4 has already been released, go try it out!</p>\n","excerpt":"<p class=\"tip\">Note: this post contains information for the outdated 0.11 version. Please refer to the <a href=\"https://github.com/yyx990803/vue/releases\">0.12 release notes</a> for the changes in the API.</p>\n\n<p>The release of 0.11 introduced <a href=\"https://github.com/yyx990803/vue/blob/master/changes.md\">many changes</a>, but the most important one is how the new component scope works. Previously in 0.10.x, components have inherited scope by default. That means in a child component template you can reference parent scope properties. This often leads to tightly-coupled components, where a child component assumes knowledge of what properties are present in the parent scope. It is also possible to accidentally refer to a parent scope property in a child component.</p>","more":"<h3 id=\"Isolated-Scope-and-Data-Passing\"><a href=\"#Isolated-Scope-and-Data-Passing\" class=\"headerlink\" title=\"Isolated Scope and Data Passing\"></a>Isolated Scope and Data Passing</h3><p>Starting in 0.11, all child components have isolated scope by default, and the recommended way to control component data access is via <a href=\"/guide/components.html#Explicit_Data_Passing\">Explicit Data Passing</a> using <a href=\"/api/directives.html#v-with\"><code>v-with</code></a> or <a href=\"/api/options.html#paramAttributes\"><code>paramAttributes</code></a>.</p>\n<p><code>paramAttributes</code> enables us to write Web Component style templates:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">paramAttributes</span>: [<span class=\"string\">'params'</span>],</div><div class=\"line\">  <span class=\"attr\">compiled</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.params) <span class=\"comment\">// passed from parent</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">params</span>=<span class=\"string\">\"&#123;&#123;params&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"Where-Does-It-Belong\"><a href=\"#Where-Does-It-Belong\" class=\"headerlink\" title=\"Where Does It Belong?\"></a>Where Does It Belong?</h3><p>Previously in 0.10, all directives on a component’s container element are compiled in the child component’s scope. Because it inherited parent scope, this worked in most situations. Starting in 0.11.1, we want to provide a cleaner separation between component scopes. The rule of thumbs is: if something appears in the parent template, it will be compiled in parent scope; if it appears in child template, it will be compiled in child scope. For example:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- parent template --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-component</span>=<span class=\"string\">\"child\"</span> <span class=\"attr\">v-on</span>=<span class=\"string\">\"click:onParentClick\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;parentMessage&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- child template, with replace: true --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on</span>=<span class=\"string\">\"click:onChildClick\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123;childMessage&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">content</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Everything in the parent template will be compiled in the parent’s scope, including the content that’s going to be inserted into the child component.</p>\n<p>The only exception to the rule is <code>v-with</code> (and <code>paramAttributes</code> which compiles down to <code>v-with</code>), which works in both places - so you don’t need to worry about it too much.</p>\n<h3 id=\"Cleaner-Event-Communication\"><a href=\"#Cleaner-Event-Communication\" class=\"headerlink\" title=\"Cleaner Event Communication\"></a>Cleaner Event Communication</h3><p>Previously the standard way for a child component to communicate to its parent is via dispatching events. However, with this approach, the event listeners on the parent component are not guaranteed to be listening on the desired child component only. It’s also possible to trigger undesired listners further up the chain if we do not cancel the event.</p>\n<p>The most common use case is for a parent to react to the events from a specific, direct child component. So in 0.11.4, <a href=\"/api/directives.html#v-events\">a new directive <code>v-events</code></a> has been introduced to enable exactly this behavior.</p>\n<p>0.11.4 has already been released, go try it out!</p>"},{"title":"Vue.js 1.0.0 Released","date":"2015-10-26T02:00:00.000Z","_content":"\n> Hi HN! If you are not familiar with Vue.js, you might want to read this [blog post](http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/) for a higher level overview.\n\nAfter 300+ commits, 8 alphas, 4 betas and 2 release candidates, today I am very proud to announce the release of [Vue.js 1.0.0 Evangelion](https://github.com/vuejs/vue/releases/tag/1.0.0)! Many thanks to all those who participated in the API re-design process - it would not have been possible without all the input from the community.\n\n<!-- more -->\n\n### Improved Template Syntax\n\nThe 1.0 template syntax resolves a lot of subtle consistency issues and makes Vue templates more concise and more readable in general. The most notable new feature is the shorthand syntax for `v-on` and `v-bind`:\n\n``` html\n<!-- short for v-bind:href -->\n<a :href=\"someURL\"></a>\n\n<!-- short for v-on:click -->\n<button @click=\"onClick\"></button>\n```\n\nWhen used on a child component, `v-on` listens for custom events and `v-bind` can be used to bind props. The shorthands using child components very succinct:\n\n``` html\n<item-list\n  :items=\"items\"\n  @ready=\"onItemsReady\"\n  @update=\"onItemsUpdate\">\n</item-list>\n```\n\n### API Cleanup\n\nThe overall goal for Vue.js 1.0 is to make it suitable for larger projects. This is why there are many API deprecations. Except for ones that are barely used, the most common reason for a deprecation is that the feature leads to patterns that damages maintainability. Specifically, we are deprecating features that make it hard to maintain and refactor a component in isolation without affecting the rest of the project.\n\nFor example, the default asset resolution in 0.12 has implicit fallbacks to parents in the component tree. This makes the assets available to a component non-deterministic and subject how it is used at runtime. In 1.0, all assets are now resolved in strict mode and there are no longer implicit fallbacks to parent. The `inherit` option is also removed, because it too often leads to tightly coupled components that are hard to refactor.\n\n### Faster Initial Rendering\n\n1.0 replaces the old `v-repeat` directive with `v-for`. In addition to providing the same functionality and more intuitive scoping, `v-for` provides up to **100%** initial render performance boost when rendering large lists and tables!\n\n### More Powerful Tooling\n\nThere are also exciting things going on outside of Vue.js core - [vue-loader](https://github.com/vuejs/vue-loader) and [vueify](https://github.com/vuejs/vueify) have received major upgrades including:\n\n- Hot component reloading. When a `*.vue` component is edited, all of its active instances are hot swapped without reloading the page. This means when making small changes, e.g. tweaking the styles or the template, your app doesn't need to fully reload; the state of the app the swapped component can be preserved, drastically improving the development experience.\n\n- Scoped CSS. By simply adding a `scoped` attribute to your `*.vue` component style tags, the component's template and final generated CSS are magically re-written to ensure a component's styles are only applied to its own elements. Most importantly, the styles specified in a parent component **does not** leak down to child components nested within it.\n\n- ES2015 by default. JavaScript is evolving. You can write much cleaner and expressive code using the latest syntax. `vue-loader` and `vueify` now transpiles the JavaScript in your `*.vue` components out of the box, without the need for extra setup. Write future JavaScript today!\n\nCombined with [vue-router](https://github.com/vuejs/vue-router), Vue.js is now more than a library - it provides a solid foundation for building complex SPAs.\n\n### What's Next?\n\nAs what 1.0.0 usually suggests, the core API will stay stable for the foreseeable future and the library is ready for production use. Future development will focus on:\n\n1. Improving `vue-router` and make it production ready.\n\n2. Streamlining the developer experience, e.g. a better devtool and a CLI for scaffolding Vue.js projects and components.\n\n3. Providing more learning resources such as tutorials and examples.\n","source":"_posts/1.0.0-release.md","raw":"---\ntitle: Vue.js 1.0.0 Released\ndate: 2015-10-26 10:00:00\n---\n\n> Hi HN! If you are not familiar with Vue.js, you might want to read this [blog post](http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/) for a higher level overview.\n\nAfter 300+ commits, 8 alphas, 4 betas and 2 release candidates, today I am very proud to announce the release of [Vue.js 1.0.0 Evangelion](https://github.com/vuejs/vue/releases/tag/1.0.0)! Many thanks to all those who participated in the API re-design process - it would not have been possible without all the input from the community.\n\n<!-- more -->\n\n### Improved Template Syntax\n\nThe 1.0 template syntax resolves a lot of subtle consistency issues and makes Vue templates more concise and more readable in general. The most notable new feature is the shorthand syntax for `v-on` and `v-bind`:\n\n``` html\n<!-- short for v-bind:href -->\n<a :href=\"someURL\"></a>\n\n<!-- short for v-on:click -->\n<button @click=\"onClick\"></button>\n```\n\nWhen used on a child component, `v-on` listens for custom events and `v-bind` can be used to bind props. The shorthands using child components very succinct:\n\n``` html\n<item-list\n  :items=\"items\"\n  @ready=\"onItemsReady\"\n  @update=\"onItemsUpdate\">\n</item-list>\n```\n\n### API Cleanup\n\nThe overall goal for Vue.js 1.0 is to make it suitable for larger projects. This is why there are many API deprecations. Except for ones that are barely used, the most common reason for a deprecation is that the feature leads to patterns that damages maintainability. Specifically, we are deprecating features that make it hard to maintain and refactor a component in isolation without affecting the rest of the project.\n\nFor example, the default asset resolution in 0.12 has implicit fallbacks to parents in the component tree. This makes the assets available to a component non-deterministic and subject how it is used at runtime. In 1.0, all assets are now resolved in strict mode and there are no longer implicit fallbacks to parent. The `inherit` option is also removed, because it too often leads to tightly coupled components that are hard to refactor.\n\n### Faster Initial Rendering\n\n1.0 replaces the old `v-repeat` directive with `v-for`. In addition to providing the same functionality and more intuitive scoping, `v-for` provides up to **100%** initial render performance boost when rendering large lists and tables!\n\n### More Powerful Tooling\n\nThere are also exciting things going on outside of Vue.js core - [vue-loader](https://github.com/vuejs/vue-loader) and [vueify](https://github.com/vuejs/vueify) have received major upgrades including:\n\n- Hot component reloading. When a `*.vue` component is edited, all of its active instances are hot swapped without reloading the page. This means when making small changes, e.g. tweaking the styles or the template, your app doesn't need to fully reload; the state of the app the swapped component can be preserved, drastically improving the development experience.\n\n- Scoped CSS. By simply adding a `scoped` attribute to your `*.vue` component style tags, the component's template and final generated CSS are magically re-written to ensure a component's styles are only applied to its own elements. Most importantly, the styles specified in a parent component **does not** leak down to child components nested within it.\n\n- ES2015 by default. JavaScript is evolving. You can write much cleaner and expressive code using the latest syntax. `vue-loader` and `vueify` now transpiles the JavaScript in your `*.vue` components out of the box, without the need for extra setup. Write future JavaScript today!\n\nCombined with [vue-router](https://github.com/vuejs/vue-router), Vue.js is now more than a library - it provides a solid foundation for building complex SPAs.\n\n### What's Next?\n\nAs what 1.0.0 usually suggests, the core API will stay stable for the foreseeable future and the library is ready for production use. Future development will focus on:\n\n1. Improving `vue-router` and make it production ready.\n\n2. Streamlining the developer experience, e.g. a better devtool and a CLI for scaffolding Vue.js projects and components.\n\n3. Providing more learning resources such as tutorials and examples.\n","slug":"1.0.0-release","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajuwj0005jl2d8yn6pwmv","content":"<blockquote>\n<p>Hi HN! If you are not familiar with Vue.js, you might want to read this <a href=\"http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/\" target=\"_blank\" rel=\"external\">blog post</a> for a higher level overview.</p>\n</blockquote>\n<p>After 300+ commits, 8 alphas, 4 betas and 2 release candidates, today I am very proud to announce the release of <a href=\"https://github.com/vuejs/vue/releases/tag/1.0.0\" target=\"_blank\" rel=\"external\">Vue.js 1.0.0 Evangelion</a>! Many thanks to all those who participated in the API re-design process - it would not have been possible without all the input from the community.</p>\n<a id=\"more\"></a>\n<h3 id=\"Improved-Template-Syntax\"><a href=\"#Improved-Template-Syntax\" class=\"headerlink\" title=\"Improved Template Syntax\"></a>Improved Template Syntax</h3><p>The 1.0 template syntax resolves a lot of subtle consistency issues and makes Vue templates more concise and more readable in general. The most notable new feature is the shorthand syntax for <code>v-on</code> and <code>v-bind</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- short for v-bind:href --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:href</span>=<span class=\"string\">\"someURL\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- short for v-on:click --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"onClick\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>When used on a child component, <code>v-on</code> listens for custom events and <code>v-bind</code> can be used to bind props. The shorthands using child components very succinct:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item-list</span></span></div><div class=\"line\">  <span class=\"attr\">:items</span>=<span class=\"string\">\"items\"</span></div><div class=\"line\">  @<span class=\"attr\">ready</span>=<span class=\"string\">\"onItemsReady\"</span></div><div class=\"line\">  @<span class=\"attr\">update</span>=<span class=\"string\">\"onItemsUpdate\"</span>&gt;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">item-list</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"API-Cleanup\"><a href=\"#API-Cleanup\" class=\"headerlink\" title=\"API Cleanup\"></a>API Cleanup</h3><p>The overall goal for Vue.js 1.0 is to make it suitable for larger projects. This is why there are many API deprecations. Except for ones that are barely used, the most common reason for a deprecation is that the feature leads to patterns that damages maintainability. Specifically, we are deprecating features that make it hard to maintain and refactor a component in isolation without affecting the rest of the project.</p>\n<p>For example, the default asset resolution in 0.12 has implicit fallbacks to parents in the component tree. This makes the assets available to a component non-deterministic and subject how it is used at runtime. In 1.0, all assets are now resolved in strict mode and there are no longer implicit fallbacks to parent. The <code>inherit</code> option is also removed, because it too often leads to tightly coupled components that are hard to refactor.</p>\n<h3 id=\"Faster-Initial-Rendering\"><a href=\"#Faster-Initial-Rendering\" class=\"headerlink\" title=\"Faster Initial Rendering\"></a>Faster Initial Rendering</h3><p>1.0 replaces the old <code>v-repeat</code> directive with <code>v-for</code>. In addition to providing the same functionality and more intuitive scoping, <code>v-for</code> provides up to <strong>100%</strong> initial render performance boost when rendering large lists and tables!</p>\n<h3 id=\"More-Powerful-Tooling\"><a href=\"#More-Powerful-Tooling\" class=\"headerlink\" title=\"More Powerful Tooling\"></a>More Powerful Tooling</h3><p>There are also exciting things going on outside of Vue.js core - <a href=\"https://github.com/vuejs/vue-loader\" target=\"_blank\" rel=\"external\">vue-loader</a> and <a href=\"https://github.com/vuejs/vueify\" target=\"_blank\" rel=\"external\">vueify</a> have received major upgrades including:</p>\n<ul>\n<li><p>Hot component reloading. When a <code>*.vue</code> component is edited, all of its active instances are hot swapped without reloading the page. This means when making small changes, e.g. tweaking the styles or the template, your app doesn’t need to fully reload; the state of the app the swapped component can be preserved, drastically improving the development experience.</p>\n</li>\n<li><p>Scoped CSS. By simply adding a <code>scoped</code> attribute to your <code>*.vue</code> component style tags, the component’s template and final generated CSS are magically re-written to ensure a component’s styles are only applied to its own elements. Most importantly, the styles specified in a parent component <strong>does not</strong> leak down to child components nested within it.</p>\n</li>\n<li><p>ES2015 by default. JavaScript is evolving. You can write much cleaner and expressive code using the latest syntax. <code>vue-loader</code> and <code>vueify</code> now transpiles the JavaScript in your <code>*.vue</code> components out of the box, without the need for extra setup. Write future JavaScript today!</p>\n</li>\n</ul>\n<p>Combined with <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"external\">vue-router</a>, Vue.js is now more than a library - it provides a solid foundation for building complex SPAs.</p>\n<h3 id=\"What’s-Next\"><a href=\"#What’s-Next\" class=\"headerlink\" title=\"What’s Next?\"></a>What’s Next?</h3><p>As what 1.0.0 usually suggests, the core API will stay stable for the foreseeable future and the library is ready for production use. Future development will focus on:</p>\n<ol>\n<li><p>Improving <code>vue-router</code> and make it production ready.</p>\n</li>\n<li><p>Streamlining the developer experience, e.g. a better devtool and a CLI for scaffolding Vue.js projects and components.</p>\n</li>\n<li><p>Providing more learning resources such as tutorials and examples.</p>\n</li>\n</ol>\n","excerpt":"<blockquote>\n<p>Hi HN! If you are not familiar with Vue.js, you might want to read this <a href=\"http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/\">blog post</a> for a higher level overview.</p>\n</blockquote>\n<p>After 300+ commits, 8 alphas, 4 betas and 2 release candidates, today I am very proud to announce the release of <a href=\"https://github.com/vuejs/vue/releases/tag/1.0.0\">Vue.js 1.0.0 Evangelion</a>! Many thanks to all those who participated in the API re-design process - it would not have been possible without all the input from the community.</p>","more":"<h3 id=\"Improved-Template-Syntax\"><a href=\"#Improved-Template-Syntax\" class=\"headerlink\" title=\"Improved Template Syntax\"></a>Improved Template Syntax</h3><p>The 1.0 template syntax resolves a lot of subtle consistency issues and makes Vue templates more concise and more readable in general. The most notable new feature is the shorthand syntax for <code>v-on</code> and <code>v-bind</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- short for v-bind:href --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:href</span>=<span class=\"string\">\"someURL\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- short for v-on:click --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"onClick\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>When used on a child component, <code>v-on</code> listens for custom events and <code>v-bind</code> can be used to bind props. The shorthands using child components very succinct:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item-list</span></div><div class=\"line\">  <span class=\"attr\">:items</span>=<span class=\"string\">\"items\"</span></div><div class=\"line\">  @<span class=\"attr\">ready</span>=<span class=\"string\">\"onItemsReady\"</span></div><div class=\"line\">  @<span class=\"attr\">update</span>=<span class=\"string\">\"onItemsUpdate\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">item-list</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"API-Cleanup\"><a href=\"#API-Cleanup\" class=\"headerlink\" title=\"API Cleanup\"></a>API Cleanup</h3><p>The overall goal for Vue.js 1.0 is to make it suitable for larger projects. This is why there are many API deprecations. Except for ones that are barely used, the most common reason for a deprecation is that the feature leads to patterns that damages maintainability. Specifically, we are deprecating features that make it hard to maintain and refactor a component in isolation without affecting the rest of the project.</p>\n<p>For example, the default asset resolution in 0.12 has implicit fallbacks to parents in the component tree. This makes the assets available to a component non-deterministic and subject how it is used at runtime. In 1.0, all assets are now resolved in strict mode and there are no longer implicit fallbacks to parent. The <code>inherit</code> option is also removed, because it too often leads to tightly coupled components that are hard to refactor.</p>\n<h3 id=\"Faster-Initial-Rendering\"><a href=\"#Faster-Initial-Rendering\" class=\"headerlink\" title=\"Faster Initial Rendering\"></a>Faster Initial Rendering</h3><p>1.0 replaces the old <code>v-repeat</code> directive with <code>v-for</code>. In addition to providing the same functionality and more intuitive scoping, <code>v-for</code> provides up to <strong>100%</strong> initial render performance boost when rendering large lists and tables!</p>\n<h3 id=\"More-Powerful-Tooling\"><a href=\"#More-Powerful-Tooling\" class=\"headerlink\" title=\"More Powerful Tooling\"></a>More Powerful Tooling</h3><p>There are also exciting things going on outside of Vue.js core - <a href=\"https://github.com/vuejs/vue-loader\">vue-loader</a> and <a href=\"https://github.com/vuejs/vueify\">vueify</a> have received major upgrades including:</p>\n<ul>\n<li><p>Hot component reloading. When a <code>*.vue</code> component is edited, all of its active instances are hot swapped without reloading the page. This means when making small changes, e.g. tweaking the styles or the template, your app doesn’t need to fully reload; the state of the app the swapped component can be preserved, drastically improving the development experience.</p>\n</li>\n<li><p>Scoped CSS. By simply adding a <code>scoped</code> attribute to your <code>*.vue</code> component style tags, the component’s template and final generated CSS are magically re-written to ensure a component’s styles are only applied to its own elements. Most importantly, the styles specified in a parent component <strong>does not</strong> leak down to child components nested within it.</p>\n</li>\n<li><p>ES2015 by default. JavaScript is evolving. You can write much cleaner and expressive code using the latest syntax. <code>vue-loader</code> and <code>vueify</code> now transpiles the JavaScript in your <code>*.vue</code> components out of the box, without the need for extra setup. Write future JavaScript today!</p>\n</li>\n</ul>\n<p>Combined with <a href=\"https://github.com/vuejs/vue-router\">vue-router</a>, Vue.js is now more than a library - it provides a solid foundation for building complex SPAs.</p>\n<h3 id=\"What’s-Next\"><a href=\"#What’s-Next\" class=\"headerlink\" title=\"What’s Next?\"></a>What’s Next?</h3><p>As what 1.0.0 usually suggests, the core API will stay stable for the foreseeable future and the library is ready for production use. Future development will focus on:</p>\n<ol>\n<li><p>Improving <code>vue-router</code> and make it production ready.</p>\n</li>\n<li><p>Streamlining the developer experience, e.g. a better devtool and a CLI for scaffolding Vue.js projects and components.</p>\n</li>\n<li><p>Providing more learning resources such as tutorials and examples.</p>\n</li>\n</ol>"},{"title":"Announcing Vue.js 2.0","date":"2016-04-27T05:33:00.000Z","_content":"\nToday I am thrilled to announce the first public preview of Vue.js 2.0, which brings along many exciting improvements and new features. Let's take a peek at what's in store!\n\n<!-- more -->\n\n## Even Leaner, Even Faster\n\nVue.js has always focused on staying light and fast, but 2.0 pushes it even further. The rendering layer is now based on a lightweight virtual-DOM implementation (based on [Snabbdom](https://github.com/paldepind/snabbdom)) that improves initial rendering speed and memory consumption by up to 2~4x in most scenarios (check out [these benchmarks](https://github.com/vuejs/vue/tree/next/benchmarks)). The template-to-virtual-DOM compiler and the runtime can be separated, so you can pre-compile templates and ship your app with only the runtime, which is less than 12kb min+gzip (as a reference, React 15 is 44kb min+gzip). The compiler also works in the browser, which means you can still drop in one script tag and start hacking, just like before. Even with the compiler included, the build is sitting at 17kb min+gzip, still lighter than the current 1.0 build.\n\n## Not Your Average Virtual-DOM\n\nNow, just virtual-DOM sounds boring because there are so many implementations out there - but this one is different. Combined with Vue's reactivity system, it provides optimized re-rendering out of the box without you having to do anything. Each component keeps track of its reactive dependencies during its render, so the system knows precisely when to re-render, and which components to re-render. No need for `shouldComponentUpdate` or immutable data structures - **it just works**.\n\nIn addition, Vue 2.0 applies some advanced optimizations during the template-to-virtual-DOM compilation phase:\n\n1. It detects static class names and attributes so that they are never diffed after the initial render.\n\n2. It detects the maximum static sub trees (sub trees with no dynamic bindings) and hoist them out of the render function. So on each re-render, it directly reuses the exact same virtual nodes and skips the diffing.\n\nThese advanced optimizations can usually only be achieved via Babel plugins when using JSX, but with Vue 2.0 you can get them even using the in-browser compiler.\n\nThe new rendering system also allows you to disable reactive conversions by simply freezing your data and manually force updates, essentially giving you full control over the re-rendering process.\n\nWith these techniques combined, Vue 2.0 ensures blazing fast performance in every possible scenario while requiring minimal optimization efforts from the developer.\n\n## Templates, JSX, or Hyperscript?\n\nDevelopers tend to have strong opinions on templates vs. JSX. On the one hand, templates are closer to HTML - they map better to the semantic structure of your app and make it much easier to think visually about the design, layout and styling. On the other hand, templates are limited to the DSL while the programmatic nature of JSX/hyperscript provides the full expressive power of a turing-complete language.\n\nBeing a designer/developer hybrid, I prefer writing most of my interfaces in templates, but in certain cases I do miss the flexibility of JSX/hyperscript. An example would be writing a component that programmatically handles its children, something not feasible with just the template-based slot mechanism.\n\nWell, why not have both? In Vue 2.0, you can keep using the familiar template syntax, or drop down to the virtual-DOM layer whenever you feel constrained by the template DSL. Instead of the `template` option, just replace it with a `render` function. You can even embed render functions in your templates using the special `<render>` tag! The best of both worlds, in the same framework.\n\n## Streaming Server-side Rendering\n\nWith the migration to virtual-DOM, Vue 2.0 naturally supports server-side rendering with client-side hydration. One pain point of current mainstream server rendering implementations, such as React's, is that the rendering is synchronous so it can block the server's event loop if the app is complex. Synchronous server-side rendering may even adversely affect time-to-content on the client. Vue 2.0 provides built-in streaming server-side rendering, so that you can render your component, get a readable stream back and directly pipe it to the HTTP response. This ensures your server is responsive, and gets the rendered content to your users faster.\n\n## Unlocking More Possibilities\n\nWith the new architecture, there are even more possibilities to explore - for example, rendering to native interfaces on mobile. Currently, we are exploring a port of Vue.js 2.0 that uses [weex](http://alibaba.github.io/weex/) as a native rendering backend, a project maintained by engineers at Alibaba Group, the biggest tech enterprise of China. It is also technically feasible to adapt Vue 2.0's virtual-DOM to run inside ReactNative. We are excited to see how it goes!\n\n## Compatibility and What to Expect Next\n\nVue.js 2.0 is still in pre-alpha, but you can checkout the source code [here](https://github.com/vuejs/vue/tree/next/). Despite being a full rewrite, the API is largely compatible with 1.0 with the exception of some intentional deprecations. Check out [the same official examples written in 2.0](https://github.com/vuejs/vue/tree/next/examples) - you will see that not much has changed!\n\nThe feature deprecations are part of our continued effort to provide the simplest API possible for maximum developer productivity. You can check out a 1.0 vs. 2.0 feature comparison [here](https://github.com/vuejs/vue/wiki/2.0-features). This does mean that it will take some effort to migrate an existing app if you happen to use some of these deprecated features heavily, but we will provide detailed upgrade guides in the future.\n\nThere is still much work left to be done. We will be releasing the first alpha once we reach satisfactory test coverage, and we are aiming for beta by end of May / early June. In addition to more tests, we also need to update the supporting libraries (vue-router, Vuex, vue-loader, vueify...). Currently only Vuex works with 2.0 out of the box, but we will make sure that everything works smoothly together when 2.0 ships.\n\nWe are also not forgetting about 1.x! 1.1 will be released alongside 2.0 beta, with an LTS period of 6-month critical bug fixes and 9-month security updates. It will also ship with optional deprecation warnings to get you prepared for upgrading to 2.0. Stay tuned!\n","source":"_posts/announcing-2.0.md","raw":"---\ntitle: Announcing Vue.js 2.0\ndate: 2016-04-27 13:33:00\n---\n\nToday I am thrilled to announce the first public preview of Vue.js 2.0, which brings along many exciting improvements and new features. Let's take a peek at what's in store!\n\n<!-- more -->\n\n## Even Leaner, Even Faster\n\nVue.js has always focused on staying light and fast, but 2.0 pushes it even further. The rendering layer is now based on a lightweight virtual-DOM implementation (based on [Snabbdom](https://github.com/paldepind/snabbdom)) that improves initial rendering speed and memory consumption by up to 2~4x in most scenarios (check out [these benchmarks](https://github.com/vuejs/vue/tree/next/benchmarks)). The template-to-virtual-DOM compiler and the runtime can be separated, so you can pre-compile templates and ship your app with only the runtime, which is less than 12kb min+gzip (as a reference, React 15 is 44kb min+gzip). The compiler also works in the browser, which means you can still drop in one script tag and start hacking, just like before. Even with the compiler included, the build is sitting at 17kb min+gzip, still lighter than the current 1.0 build.\n\n## Not Your Average Virtual-DOM\n\nNow, just virtual-DOM sounds boring because there are so many implementations out there - but this one is different. Combined with Vue's reactivity system, it provides optimized re-rendering out of the box without you having to do anything. Each component keeps track of its reactive dependencies during its render, so the system knows precisely when to re-render, and which components to re-render. No need for `shouldComponentUpdate` or immutable data structures - **it just works**.\n\nIn addition, Vue 2.0 applies some advanced optimizations during the template-to-virtual-DOM compilation phase:\n\n1. It detects static class names and attributes so that they are never diffed after the initial render.\n\n2. It detects the maximum static sub trees (sub trees with no dynamic bindings) and hoist them out of the render function. So on each re-render, it directly reuses the exact same virtual nodes and skips the diffing.\n\nThese advanced optimizations can usually only be achieved via Babel plugins when using JSX, but with Vue 2.0 you can get them even using the in-browser compiler.\n\nThe new rendering system also allows you to disable reactive conversions by simply freezing your data and manually force updates, essentially giving you full control over the re-rendering process.\n\nWith these techniques combined, Vue 2.0 ensures blazing fast performance in every possible scenario while requiring minimal optimization efforts from the developer.\n\n## Templates, JSX, or Hyperscript?\n\nDevelopers tend to have strong opinions on templates vs. JSX. On the one hand, templates are closer to HTML - they map better to the semantic structure of your app and make it much easier to think visually about the design, layout and styling. On the other hand, templates are limited to the DSL while the programmatic nature of JSX/hyperscript provides the full expressive power of a turing-complete language.\n\nBeing a designer/developer hybrid, I prefer writing most of my interfaces in templates, but in certain cases I do miss the flexibility of JSX/hyperscript. An example would be writing a component that programmatically handles its children, something not feasible with just the template-based slot mechanism.\n\nWell, why not have both? In Vue 2.0, you can keep using the familiar template syntax, or drop down to the virtual-DOM layer whenever you feel constrained by the template DSL. Instead of the `template` option, just replace it with a `render` function. You can even embed render functions in your templates using the special `<render>` tag! The best of both worlds, in the same framework.\n\n## Streaming Server-side Rendering\n\nWith the migration to virtual-DOM, Vue 2.0 naturally supports server-side rendering with client-side hydration. One pain point of current mainstream server rendering implementations, such as React's, is that the rendering is synchronous so it can block the server's event loop if the app is complex. Synchronous server-side rendering may even adversely affect time-to-content on the client. Vue 2.0 provides built-in streaming server-side rendering, so that you can render your component, get a readable stream back and directly pipe it to the HTTP response. This ensures your server is responsive, and gets the rendered content to your users faster.\n\n## Unlocking More Possibilities\n\nWith the new architecture, there are even more possibilities to explore - for example, rendering to native interfaces on mobile. Currently, we are exploring a port of Vue.js 2.0 that uses [weex](http://alibaba.github.io/weex/) as a native rendering backend, a project maintained by engineers at Alibaba Group, the biggest tech enterprise of China. It is also technically feasible to adapt Vue 2.0's virtual-DOM to run inside ReactNative. We are excited to see how it goes!\n\n## Compatibility and What to Expect Next\n\nVue.js 2.0 is still in pre-alpha, but you can checkout the source code [here](https://github.com/vuejs/vue/tree/next/). Despite being a full rewrite, the API is largely compatible with 1.0 with the exception of some intentional deprecations. Check out [the same official examples written in 2.0](https://github.com/vuejs/vue/tree/next/examples) - you will see that not much has changed!\n\nThe feature deprecations are part of our continued effort to provide the simplest API possible for maximum developer productivity. You can check out a 1.0 vs. 2.0 feature comparison [here](https://github.com/vuejs/vue/wiki/2.0-features). This does mean that it will take some effort to migrate an existing app if you happen to use some of these deprecated features heavily, but we will provide detailed upgrade guides in the future.\n\nThere is still much work left to be done. We will be releasing the first alpha once we reach satisfactory test coverage, and we are aiming for beta by end of May / early June. In addition to more tests, we also need to update the supporting libraries (vue-router, Vuex, vue-loader, vueify...). Currently only Vuex works with 2.0 out of the box, but we will make sure that everything works smoothly together when 2.0 ships.\n\nWe are also not forgetting about 1.x! 1.1 will be released alongside 2.0 beta, with an LTS period of 6-month critical bug fixes and 9-month security updates. It will also ship with optional deprecation warnings to get you prepared for upgrading to 2.0. Stay tuned!\n","slug":"announcing-2.0","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajuwl0007jl2dat62cszi","content":"<p>Today I am thrilled to announce the first public preview of Vue.js 2.0, which brings along many exciting improvements and new features. Let’s take a peek at what’s in store!</p>\n<a id=\"more\"></a>\n<h2 id=\"Even-Leaner-Even-Faster\"><a href=\"#Even-Leaner-Even-Faster\" class=\"headerlink\" title=\"Even Leaner, Even Faster\"></a>Even Leaner, Even Faster</h2><p>Vue.js has always focused on staying light and fast, but 2.0 pushes it even further. The rendering layer is now based on a lightweight virtual-DOM implementation (based on <a href=\"https://github.com/paldepind/snabbdom\" target=\"_blank\" rel=\"external\">Snabbdom</a>) that improves initial rendering speed and memory consumption by up to 2~4x in most scenarios (check out <a href=\"https://github.com/vuejs/vue/tree/next/benchmarks\" target=\"_blank\" rel=\"external\">these benchmarks</a>). The template-to-virtual-DOM compiler and the runtime can be separated, so you can pre-compile templates and ship your app with only the runtime, which is less than 12kb min+gzip (as a reference, React 15 is 44kb min+gzip). The compiler also works in the browser, which means you can still drop in one script tag and start hacking, just like before. Even with the compiler included, the build is sitting at 17kb min+gzip, still lighter than the current 1.0 build.</p>\n<h2 id=\"Not-Your-Average-Virtual-DOM\"><a href=\"#Not-Your-Average-Virtual-DOM\" class=\"headerlink\" title=\"Not Your Average Virtual-DOM\"></a>Not Your Average Virtual-DOM</h2><p>Now, just virtual-DOM sounds boring because there are so many implementations out there - but this one is different. Combined with Vue’s reactivity system, it provides optimized re-rendering out of the box without you having to do anything. Each component keeps track of its reactive dependencies during its render, so the system knows precisely when to re-render, and which components to re-render. No need for <code>shouldComponentUpdate</code> or immutable data structures - <strong>it just works</strong>.</p>\n<p>In addition, Vue 2.0 applies some advanced optimizations during the template-to-virtual-DOM compilation phase:</p>\n<ol>\n<li><p>It detects static class names and attributes so that they are never diffed after the initial render.</p>\n</li>\n<li><p>It detects the maximum static sub trees (sub trees with no dynamic bindings) and hoist them out of the render function. So on each re-render, it directly reuses the exact same virtual nodes and skips the diffing.</p>\n</li>\n</ol>\n<p>These advanced optimizations can usually only be achieved via Babel plugins when using JSX, but with Vue 2.0 you can get them even using the in-browser compiler.</p>\n<p>The new rendering system also allows you to disable reactive conversions by simply freezing your data and manually force updates, essentially giving you full control over the re-rendering process.</p>\n<p>With these techniques combined, Vue 2.0 ensures blazing fast performance in every possible scenario while requiring minimal optimization efforts from the developer.</p>\n<h2 id=\"Templates-JSX-or-Hyperscript\"><a href=\"#Templates-JSX-or-Hyperscript\" class=\"headerlink\" title=\"Templates, JSX, or Hyperscript?\"></a>Templates, JSX, or Hyperscript?</h2><p>Developers tend to have strong opinions on templates vs. JSX. On the one hand, templates are closer to HTML - they map better to the semantic structure of your app and make it much easier to think visually about the design, layout and styling. On the other hand, templates are limited to the DSL while the programmatic nature of JSX/hyperscript provides the full expressive power of a turing-complete language.</p>\n<p>Being a designer/developer hybrid, I prefer writing most of my interfaces in templates, but in certain cases I do miss the flexibility of JSX/hyperscript. An example would be writing a component that programmatically handles its children, something not feasible with just the template-based slot mechanism.</p>\n<p>Well, why not have both? In Vue 2.0, you can keep using the familiar template syntax, or drop down to the virtual-DOM layer whenever you feel constrained by the template DSL. Instead of the <code>template</code> option, just replace it with a <code>render</code> function. You can even embed render functions in your templates using the special <code>&lt;render&gt;</code> tag! The best of both worlds, in the same framework.</p>\n<h2 id=\"Streaming-Server-side-Rendering\"><a href=\"#Streaming-Server-side-Rendering\" class=\"headerlink\" title=\"Streaming Server-side Rendering\"></a>Streaming Server-side Rendering</h2><p>With the migration to virtual-DOM, Vue 2.0 naturally supports server-side rendering with client-side hydration. One pain point of current mainstream server rendering implementations, such as React’s, is that the rendering is synchronous so it can block the server’s event loop if the app is complex. Synchronous server-side rendering may even adversely affect time-to-content on the client. Vue 2.0 provides built-in streaming server-side rendering, so that you can render your component, get a readable stream back and directly pipe it to the HTTP response. This ensures your server is responsive, and gets the rendered content to your users faster.</p>\n<h2 id=\"Unlocking-More-Possibilities\"><a href=\"#Unlocking-More-Possibilities\" class=\"headerlink\" title=\"Unlocking More Possibilities\"></a>Unlocking More Possibilities</h2><p>With the new architecture, there are even more possibilities to explore - for example, rendering to native interfaces on mobile. Currently, we are exploring a port of Vue.js 2.0 that uses <a href=\"http://alibaba.github.io/weex/\" target=\"_blank\" rel=\"external\">weex</a> as a native rendering backend, a project maintained by engineers at Alibaba Group, the biggest tech enterprise of China. It is also technically feasible to adapt Vue 2.0’s virtual-DOM to run inside ReactNative. We are excited to see how it goes!</p>\n<h2 id=\"Compatibility-and-What-to-Expect-Next\"><a href=\"#Compatibility-and-What-to-Expect-Next\" class=\"headerlink\" title=\"Compatibility and What to Expect Next\"></a>Compatibility and What to Expect Next</h2><p>Vue.js 2.0 is still in pre-alpha, but you can checkout the source code <a href=\"https://github.com/vuejs/vue/tree/next/\" target=\"_blank\" rel=\"external\">here</a>. Despite being a full rewrite, the API is largely compatible with 1.0 with the exception of some intentional deprecations. Check out <a href=\"https://github.com/vuejs/vue/tree/next/examples\" target=\"_blank\" rel=\"external\">the same official examples written in 2.0</a> - you will see that not much has changed!</p>\n<p>The feature deprecations are part of our continued effort to provide the simplest API possible for maximum developer productivity. You can check out a 1.0 vs. 2.0 feature comparison <a href=\"https://github.com/vuejs/vue/wiki/2.0-features\" target=\"_blank\" rel=\"external\">here</a>. This does mean that it will take some effort to migrate an existing app if you happen to use some of these deprecated features heavily, but we will provide detailed upgrade guides in the future.</p>\n<p>There is still much work left to be done. We will be releasing the first alpha once we reach satisfactory test coverage, and we are aiming for beta by end of May / early June. In addition to more tests, we also need to update the supporting libraries (vue-router, Vuex, vue-loader, vueify…). Currently only Vuex works with 2.0 out of the box, but we will make sure that everything works smoothly together when 2.0 ships.</p>\n<p>We are also not forgetting about 1.x! 1.1 will be released alongside 2.0 beta, with an LTS period of 6-month critical bug fixes and 9-month security updates. It will also ship with optional deprecation warnings to get you prepared for upgrading to 2.0. Stay tuned!</p>\n","excerpt":"<p>Today I am thrilled to announce the first public preview of Vue.js 2.0, which brings along many exciting improvements and new features. Let’s take a peek at what’s in store!</p>","more":"<h2 id=\"Even-Leaner-Even-Faster\"><a href=\"#Even-Leaner-Even-Faster\" class=\"headerlink\" title=\"Even Leaner, Even Faster\"></a>Even Leaner, Even Faster</h2><p>Vue.js has always focused on staying light and fast, but 2.0 pushes it even further. The rendering layer is now based on a lightweight virtual-DOM implementation (based on <a href=\"https://github.com/paldepind/snabbdom\">Snabbdom</a>) that improves initial rendering speed and memory consumption by up to 2~4x in most scenarios (check out <a href=\"https://github.com/vuejs/vue/tree/next/benchmarks\">these benchmarks</a>). The template-to-virtual-DOM compiler and the runtime can be separated, so you can pre-compile templates and ship your app with only the runtime, which is less than 12kb min+gzip (as a reference, React 15 is 44kb min+gzip). The compiler also works in the browser, which means you can still drop in one script tag and start hacking, just like before. Even with the compiler included, the build is sitting at 17kb min+gzip, still lighter than the current 1.0 build.</p>\n<h2 id=\"Not-Your-Average-Virtual-DOM\"><a href=\"#Not-Your-Average-Virtual-DOM\" class=\"headerlink\" title=\"Not Your Average Virtual-DOM\"></a>Not Your Average Virtual-DOM</h2><p>Now, just virtual-DOM sounds boring because there are so many implementations out there - but this one is different. Combined with Vue’s reactivity system, it provides optimized re-rendering out of the box without you having to do anything. Each component keeps track of its reactive dependencies during its render, so the system knows precisely when to re-render, and which components to re-render. No need for <code>shouldComponentUpdate</code> or immutable data structures - <strong>it just works</strong>.</p>\n<p>In addition, Vue 2.0 applies some advanced optimizations during the template-to-virtual-DOM compilation phase:</p>\n<ol>\n<li><p>It detects static class names and attributes so that they are never diffed after the initial render.</p>\n</li>\n<li><p>It detects the maximum static sub trees (sub trees with no dynamic bindings) and hoist them out of the render function. So on each re-render, it directly reuses the exact same virtual nodes and skips the diffing.</p>\n</li>\n</ol>\n<p>These advanced optimizations can usually only be achieved via Babel plugins when using JSX, but with Vue 2.0 you can get them even using the in-browser compiler.</p>\n<p>The new rendering system also allows you to disable reactive conversions by simply freezing your data and manually force updates, essentially giving you full control over the re-rendering process.</p>\n<p>With these techniques combined, Vue 2.0 ensures blazing fast performance in every possible scenario while requiring minimal optimization efforts from the developer.</p>\n<h2 id=\"Templates-JSX-or-Hyperscript\"><a href=\"#Templates-JSX-or-Hyperscript\" class=\"headerlink\" title=\"Templates, JSX, or Hyperscript?\"></a>Templates, JSX, or Hyperscript?</h2><p>Developers tend to have strong opinions on templates vs. JSX. On the one hand, templates are closer to HTML - they map better to the semantic structure of your app and make it much easier to think visually about the design, layout and styling. On the other hand, templates are limited to the DSL while the programmatic nature of JSX/hyperscript provides the full expressive power of a turing-complete language.</p>\n<p>Being a designer/developer hybrid, I prefer writing most of my interfaces in templates, but in certain cases I do miss the flexibility of JSX/hyperscript. An example would be writing a component that programmatically handles its children, something not feasible with just the template-based slot mechanism.</p>\n<p>Well, why not have both? In Vue 2.0, you can keep using the familiar template syntax, or drop down to the virtual-DOM layer whenever you feel constrained by the template DSL. Instead of the <code>template</code> option, just replace it with a <code>render</code> function. You can even embed render functions in your templates using the special <code>&lt;render&gt;</code> tag! The best of both worlds, in the same framework.</p>\n<h2 id=\"Streaming-Server-side-Rendering\"><a href=\"#Streaming-Server-side-Rendering\" class=\"headerlink\" title=\"Streaming Server-side Rendering\"></a>Streaming Server-side Rendering</h2><p>With the migration to virtual-DOM, Vue 2.0 naturally supports server-side rendering with client-side hydration. One pain point of current mainstream server rendering implementations, such as React’s, is that the rendering is synchronous so it can block the server’s event loop if the app is complex. Synchronous server-side rendering may even adversely affect time-to-content on the client. Vue 2.0 provides built-in streaming server-side rendering, so that you can render your component, get a readable stream back and directly pipe it to the HTTP response. This ensures your server is responsive, and gets the rendered content to your users faster.</p>\n<h2 id=\"Unlocking-More-Possibilities\"><a href=\"#Unlocking-More-Possibilities\" class=\"headerlink\" title=\"Unlocking More Possibilities\"></a>Unlocking More Possibilities</h2><p>With the new architecture, there are even more possibilities to explore - for example, rendering to native interfaces on mobile. Currently, we are exploring a port of Vue.js 2.0 that uses <a href=\"http://alibaba.github.io/weex/\">weex</a> as a native rendering backend, a project maintained by engineers at Alibaba Group, the biggest tech enterprise of China. It is also technically feasible to adapt Vue 2.0’s virtual-DOM to run inside ReactNative. We are excited to see how it goes!</p>\n<h2 id=\"Compatibility-and-What-to-Expect-Next\"><a href=\"#Compatibility-and-What-to-Expect-Next\" class=\"headerlink\" title=\"Compatibility and What to Expect Next\"></a>Compatibility and What to Expect Next</h2><p>Vue.js 2.0 is still in pre-alpha, but you can checkout the source code <a href=\"https://github.com/vuejs/vue/tree/next/\">here</a>. Despite being a full rewrite, the API is largely compatible with 1.0 with the exception of some intentional deprecations. Check out <a href=\"https://github.com/vuejs/vue/tree/next/examples\">the same official examples written in 2.0</a> - you will see that not much has changed!</p>\n<p>The feature deprecations are part of our continued effort to provide the simplest API possible for maximum developer productivity. You can check out a 1.0 vs. 2.0 feature comparison <a href=\"https://github.com/vuejs/vue/wiki/2.0-features\">here</a>. This does mean that it will take some effort to migrate an existing app if you happen to use some of these deprecated features heavily, but we will provide detailed upgrade guides in the future.</p>\n<p>There is still much work left to be done. We will be releasing the first alpha once we reach satisfactory test coverage, and we are aiming for beta by end of May / early June. In addition to more tests, we also need to update the supporting libraries (vue-router, Vuex, vue-loader, vueify…). Currently only Vuex works with 2.0 out of the box, but we will make sure that everything works smoothly together when 2.0 ships.</p>\n<p>We are also not forgetting about 1.x! 1.1 will be released alongside 2.0 beta, with an LTS period of 6-month critical bug fixes and 9-month security updates. It will also ship with optional deprecation warnings to get you prepared for upgrading to 2.0. Stay tuned!</p>"},{"title":"Vue.js 0.11 released!","date":"2014-11-09T01:23:40.000Z","_content":"\nAfter the long wait, [Vue.js 0.11 **Cowboy Bebop**](https://github.com/yyx990803/vue/releases/tag/0.11.0) is finally here! Thanks to everyone who tried out the release candidate versions and provided feedback / bug reports along the way.\n\n<!-- more -->\n\nThe 0.11 release introduced many new features and also a fair number of breaking changes, so please carefully read through the [0.11 Change List](https://github.com/yyx990803/vue/blob/master/changes.md) before upgrading. Aside from the API changes, 0.11 also ships with better [code quality](https://codeclimate.com/github/yyx990803/vue) and [test coverage](https://coveralls.io/r/yyx990803/vue), and is considerably more robust in almost every aspect.\n\nThis documentation site has been fully upgraded to match the new 0.11 API. For the now legacy 0.10.6 version, you can still find documentations for it at [legacy.vuejs.org](http://legacy.vuejs.org).\n","source":"_posts/vue-011-release.md","raw":"---\ntitle: Vue.js 0.11 released!\ndate: 2014-11-09 09:23:40\n---\n\nAfter the long wait, [Vue.js 0.11 **Cowboy Bebop**](https://github.com/yyx990803/vue/releases/tag/0.11.0) is finally here! Thanks to everyone who tried out the release candidate versions and provided feedback / bug reports along the way.\n\n<!-- more -->\n\nThe 0.11 release introduced many new features and also a fair number of breaking changes, so please carefully read through the [0.11 Change List](https://github.com/yyx990803/vue/blob/master/changes.md) before upgrading. Aside from the API changes, 0.11 also ships with better [code quality](https://codeclimate.com/github/yyx990803/vue) and [test coverage](https://coveralls.io/r/yyx990803/vue), and is considerably more robust in almost every aspect.\n\nThis documentation site has been fully upgraded to match the new 0.11 API. For the now legacy 0.10.6 version, you can still find documentations for it at [legacy.vuejs.org](http://legacy.vuejs.org).\n","slug":"vue-011-release","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajuwu0008jl2dvu1re8uw","content":"<p>After the long wait, <a href=\"https://github.com/yyx990803/vue/releases/tag/0.11.0\" target=\"_blank\" rel=\"external\">Vue.js 0.11 <strong>Cowboy Bebop</strong></a> is finally here! Thanks to everyone who tried out the release candidate versions and provided feedback / bug reports along the way.</p>\n<a id=\"more\"></a>\n<p>The 0.11 release introduced many new features and also a fair number of breaking changes, so please carefully read through the <a href=\"https://github.com/yyx990803/vue/blob/master/changes.md\" target=\"_blank\" rel=\"external\">0.11 Change List</a> before upgrading. Aside from the API changes, 0.11 also ships with better <a href=\"https://codeclimate.com/github/yyx990803/vue\" target=\"_blank\" rel=\"external\">code quality</a> and <a href=\"https://coveralls.io/r/yyx990803/vue\" target=\"_blank\" rel=\"external\">test coverage</a>, and is considerably more robust in almost every aspect.</p>\n<p>This documentation site has been fully upgraded to match the new 0.11 API. For the now legacy 0.10.6 version, you can still find documentations for it at <a href=\"http://legacy.vuejs.org\" target=\"_blank\" rel=\"external\">legacy.vuejs.org</a>.</p>\n","excerpt":"<p>After the long wait, <a href=\"https://github.com/yyx990803/vue/releases/tag/0.11.0\">Vue.js 0.11 <strong>Cowboy Bebop</strong></a> is finally here! Thanks to everyone who tried out the release candidate versions and provided feedback / bug reports along the way.</p>","more":"<p>The 0.11 release introduced many new features and also a fair number of breaking changes, so please carefully read through the <a href=\"https://github.com/yyx990803/vue/blob/master/changes.md\">0.11 Change List</a> before upgrading. Aside from the API changes, 0.11 also ships with better <a href=\"https://codeclimate.com/github/yyx990803/vue\">code quality</a> and <a href=\"https://coveralls.io/r/yyx990803/vue\">test coverage</a>, and is considerably more robust in almost every aspect.</p>\n<p>This documentation site has been fully upgraded to match the new 0.11 API. For the now legacy 0.10.6 version, you can still find documentations for it at <a href=\"http://legacy.vuejs.org\">legacy.vuejs.org</a>.</p>"},{"title":"Announcing vue-cli","date":"2015-12-27T16:00:00.000Z","_content":"\nRecently there has been a lot of [discussion around the tooling hurdle](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.chg95e5p6) when you start a React project. Luckily for Vue.js, all you need to do to start with a quick prototype is including it from a CDN via a `<script>` tag, so we've got that part covered. However, that's not how you'd build a real world application. In real world applications we inevitably need a certain amount of tooling to give us modularization, transpilers, pre-processors, hot-reload, linting and testing. These tools are necessary for the long-term maintainability and productivity of large projects, but the initial setup can be a big pain. This is why we are announcing [vue-cli](https://github.com/vuejs/vue-cli), a simple CLI tool to help you quickly scaffold Vue.js projects with opinionated, battery-included build setups.\n\n<!-- more -->\n\n### Just The Scaffolding\n\nThe usage looks like this:\n\n``` bash\nnpm install -g vue-cli\nvue init webpack my-project\n# answer prompts\ncd my-project\nnpm install\nnpm run dev # tada!\n```\n\nAll the CLI does is pulling down templates from the [vuejs-templates](https://github.com/vuejs-templates) organization on GitHub. Dependencies are handled via NPM, and build tasks are simply NPM scripts.\n\n### Official Templates\n\nThe purpose of official Vue project templates is providing opinionated, battery-included development tooling setups so that users can get started with actual app code as fast as possible. However, these templates are un-opinionated in terms of how you structure your app code and what libraries you use in addition to Vue.js.\n\nAll official project templates are repos in the [vuejs-templates organization](https://github.com/vuejs-templates). When a new template is added to the organization, you will be able to run `vue init <template-name> <project-name>` to use that template. You can also run `vue list` to see all available official templates.\n\nCurrent available templates include:\n\n- [browserify](https://github.com/vuejs-templates/browserify) - A full-featured Browserify + vueify setup with hot-reload, linting & unit testing.\n\n- [browserify-simple](https://github.com/vuejs-templates/browserify-simple) - A simple Browserify + vueify setup for quick prototyping.\n\n- [webpack](https://github.com/vuejs-templates/webpack) - A full-featured Webpack + vue-loader setup with hot reload, linting, testing & css extraction.\n\n- [webpack-simple](https://github.com/vuejs-templates/webpack-simple) - A simple Webpack + vue-loader setup for quick prototyping.\n\n### Bring Your Own Setup\n\nIf you are not happy with the official templates, you can fork these templates, modify them to fit your specific needs (or even create your own from scratch), and use them via `vue-cli` too, because `vue-cli` can work directly on GitHub repos:\n\n``` bash\nvue init username/repo my-project\n```\n\n### Vue Components Everywhere\n\nThere are different templates for different purposes: simple setups for quick prototyping, and full-featured setups for ambitious applications. A common feature among these templates though, is that they all support `*.vue` single file components. This means any third party Vue components written as valid `*.vue` files can be shared among projects using these setups, and simply be distributed over NPM - let's create more reusable components!\n","source":"_posts/vue-cli.md","raw":"---\ntitle: Announcing vue-cli\ndate: 2015-12-28 00:00:00\n---\n\nRecently there has been a lot of [discussion around the tooling hurdle](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.chg95e5p6) when you start a React project. Luckily for Vue.js, all you need to do to start with a quick prototype is including it from a CDN via a `<script>` tag, so we've got that part covered. However, that's not how you'd build a real world application. In real world applications we inevitably need a certain amount of tooling to give us modularization, transpilers, pre-processors, hot-reload, linting and testing. These tools are necessary for the long-term maintainability and productivity of large projects, but the initial setup can be a big pain. This is why we are announcing [vue-cli](https://github.com/vuejs/vue-cli), a simple CLI tool to help you quickly scaffold Vue.js projects with opinionated, battery-included build setups.\n\n<!-- more -->\n\n### Just The Scaffolding\n\nThe usage looks like this:\n\n``` bash\nnpm install -g vue-cli\nvue init webpack my-project\n# answer prompts\ncd my-project\nnpm install\nnpm run dev # tada!\n```\n\nAll the CLI does is pulling down templates from the [vuejs-templates](https://github.com/vuejs-templates) organization on GitHub. Dependencies are handled via NPM, and build tasks are simply NPM scripts.\n\n### Official Templates\n\nThe purpose of official Vue project templates is providing opinionated, battery-included development tooling setups so that users can get started with actual app code as fast as possible. However, these templates are un-opinionated in terms of how you structure your app code and what libraries you use in addition to Vue.js.\n\nAll official project templates are repos in the [vuejs-templates organization](https://github.com/vuejs-templates). When a new template is added to the organization, you will be able to run `vue init <template-name> <project-name>` to use that template. You can also run `vue list` to see all available official templates.\n\nCurrent available templates include:\n\n- [browserify](https://github.com/vuejs-templates/browserify) - A full-featured Browserify + vueify setup with hot-reload, linting & unit testing.\n\n- [browserify-simple](https://github.com/vuejs-templates/browserify-simple) - A simple Browserify + vueify setup for quick prototyping.\n\n- [webpack](https://github.com/vuejs-templates/webpack) - A full-featured Webpack + vue-loader setup with hot reload, linting, testing & css extraction.\n\n- [webpack-simple](https://github.com/vuejs-templates/webpack-simple) - A simple Webpack + vue-loader setup for quick prototyping.\n\n### Bring Your Own Setup\n\nIf you are not happy with the official templates, you can fork these templates, modify them to fit your specific needs (or even create your own from scratch), and use them via `vue-cli` too, because `vue-cli` can work directly on GitHub repos:\n\n``` bash\nvue init username/repo my-project\n```\n\n### Vue Components Everywhere\n\nThere are different templates for different purposes: simple setups for quick prototyping, and full-featured setups for ambitious applications. A common feature among these templates though, is that they all support `*.vue` single file components. This means any third party Vue components written as valid `*.vue` files can be shared among projects using these setups, and simply be distributed over NPM - let's create more reusable components!\n","slug":"vue-cli","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajuwv0009jl2d7d3whvvs","content":"<p>Recently there has been a lot of <a href=\"https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.chg95e5p6\" target=\"_blank\" rel=\"external\">discussion around the tooling hurdle</a> when you start a React project. Luckily for Vue.js, all you need to do to start with a quick prototype is including it from a CDN via a <code>&lt;script&gt;</code> tag, so we’ve got that part covered. However, that’s not how you’d build a real world application. In real world applications we inevitably need a certain amount of tooling to give us modularization, transpilers, pre-processors, hot-reload, linting and testing. These tools are necessary for the long-term maintainability and productivity of large projects, but the initial setup can be a big pain. This is why we are announcing <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"external\">vue-cli</a>, a simple CLI tool to help you quickly scaffold Vue.js projects with opinionated, battery-included build setups.</p>\n<a id=\"more\"></a>\n<h3 id=\"Just-The-Scaffolding\"><a href=\"#Just-The-Scaffolding\" class=\"headerlink\" title=\"Just The Scaffolding\"></a>Just The Scaffolding</h3><p>The usage looks like this:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">npm install -g vue-cli</div><div class=\"line\">vue init webpack my-project</div><div class=\"line\"><span class=\"comment\"># answer prompts</span></div><div class=\"line\"><span class=\"built_in\">cd</span> my-project</div><div class=\"line\">npm install</div><div class=\"line\">npm run dev <span class=\"comment\"># tada!</span></div></pre></td></tr></table></figure>\n<p>All the CLI does is pulling down templates from the <a href=\"https://github.com/vuejs-templates\" target=\"_blank\" rel=\"external\">vuejs-templates</a> organization on GitHub. Dependencies are handled via NPM, and build tasks are simply NPM scripts.</p>\n<h3 id=\"Official-Templates\"><a href=\"#Official-Templates\" class=\"headerlink\" title=\"Official Templates\"></a>Official Templates</h3><p>The purpose of official Vue project templates is providing opinionated, battery-included development tooling setups so that users can get started with actual app code as fast as possible. However, these templates are un-opinionated in terms of how you structure your app code and what libraries you use in addition to Vue.js.</p>\n<p>All official project templates are repos in the <a href=\"https://github.com/vuejs-templates\" target=\"_blank\" rel=\"external\">vuejs-templates organization</a>. When a new template is added to the organization, you will be able to run <code>vue init &lt;template-name&gt; &lt;project-name&gt;</code> to use that template. You can also run <code>vue list</code> to see all available official templates.</p>\n<p>Current available templates include:</p>\n<ul>\n<li><p><a href=\"https://github.com/vuejs-templates/browserify\" target=\"_blank\" rel=\"external\">browserify</a> - A full-featured Browserify + vueify setup with hot-reload, linting &amp; unit testing.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/browserify-simple\" target=\"_blank\" rel=\"external\">browserify-simple</a> - A simple Browserify + vueify setup for quick prototyping.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"external\">webpack</a> - A full-featured Webpack + vue-loader setup with hot reload, linting, testing &amp; css extraction.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/webpack-simple\" target=\"_blank\" rel=\"external\">webpack-simple</a> - A simple Webpack + vue-loader setup for quick prototyping.</p>\n</li>\n</ul>\n<h3 id=\"Bring-Your-Own-Setup\"><a href=\"#Bring-Your-Own-Setup\" class=\"headerlink\" title=\"Bring Your Own Setup\"></a>Bring Your Own Setup</h3><p>If you are not happy with the official templates, you can fork these templates, modify them to fit your specific needs (or even create your own from scratch), and use them via <code>vue-cli</code> too, because <code>vue-cli</code> can work directly on GitHub repos:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">vue init username/repo my-project</div></pre></td></tr></table></figure>\n<h3 id=\"Vue-Components-Everywhere\"><a href=\"#Vue-Components-Everywhere\" class=\"headerlink\" title=\"Vue Components Everywhere\"></a>Vue Components Everywhere</h3><p>There are different templates for different purposes: simple setups for quick prototyping, and full-featured setups for ambitious applications. A common feature among these templates though, is that they all support <code>*.vue</code> single file components. This means any third party Vue components written as valid <code>*.vue</code> files can be shared among projects using these setups, and simply be distributed over NPM - let’s create more reusable components!</p>\n","excerpt":"<p>Recently there has been a lot of <a href=\"https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.chg95e5p6\">discussion around the tooling hurdle</a> when you start a React project. Luckily for Vue.js, all you need to do to start with a quick prototype is including it from a CDN via a <code>&lt;script&gt;</code> tag, so we’ve got that part covered. However, that’s not how you’d build a real world application. In real world applications we inevitably need a certain amount of tooling to give us modularization, transpilers, pre-processors, hot-reload, linting and testing. These tools are necessary for the long-term maintainability and productivity of large projects, but the initial setup can be a big pain. This is why we are announcing <a href=\"https://github.com/vuejs/vue-cli\">vue-cli</a>, a simple CLI tool to help you quickly scaffold Vue.js projects with opinionated, battery-included build setups.</p>","more":"<h3 id=\"Just-The-Scaffolding\"><a href=\"#Just-The-Scaffolding\" class=\"headerlink\" title=\"Just The Scaffolding\"></a>Just The Scaffolding</h3><p>The usage looks like this:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">npm install -g vue-cli</div><div class=\"line\">vue init webpack my-project</div><div class=\"line\"><span class=\"comment\"># answer prompts</span></div><div class=\"line\"><span class=\"built_in\">cd</span> my-project</div><div class=\"line\">npm install</div><div class=\"line\">npm run dev <span class=\"comment\"># tada!</span></div></pre></td></tr></table></figure>\n<p>All the CLI does is pulling down templates from the <a href=\"https://github.com/vuejs-templates\">vuejs-templates</a> organization on GitHub. Dependencies are handled via NPM, and build tasks are simply NPM scripts.</p>\n<h3 id=\"Official-Templates\"><a href=\"#Official-Templates\" class=\"headerlink\" title=\"Official Templates\"></a>Official Templates</h3><p>The purpose of official Vue project templates is providing opinionated, battery-included development tooling setups so that users can get started with actual app code as fast as possible. However, these templates are un-opinionated in terms of how you structure your app code and what libraries you use in addition to Vue.js.</p>\n<p>All official project templates are repos in the <a href=\"https://github.com/vuejs-templates\">vuejs-templates organization</a>. When a new template is added to the organization, you will be able to run <code>vue init &lt;template-name&gt; &lt;project-name&gt;</code> to use that template. You can also run <code>vue list</code> to see all available official templates.</p>\n<p>Current available templates include:</p>\n<ul>\n<li><p><a href=\"https://github.com/vuejs-templates/browserify\">browserify</a> - A full-featured Browserify + vueify setup with hot-reload, linting &amp; unit testing.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/browserify-simple\">browserify-simple</a> - A simple Browserify + vueify setup for quick prototyping.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/webpack\">webpack</a> - A full-featured Webpack + vue-loader setup with hot reload, linting, testing &amp; css extraction.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/webpack-simple\">webpack-simple</a> - A simple Webpack + vue-loader setup for quick prototyping.</p>\n</li>\n</ul>\n<h3 id=\"Bring-Your-Own-Setup\"><a href=\"#Bring-Your-Own-Setup\" class=\"headerlink\" title=\"Bring Your Own Setup\"></a>Bring Your Own Setup</h3><p>If you are not happy with the official templates, you can fork these templates, modify them to fit your specific needs (or even create your own from scratch), and use them via <code>vue-cli</code> too, because <code>vue-cli</code> can work directly on GitHub repos:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">vue init username/repo my-project</div></pre></td></tr></table></figure>\n<h3 id=\"Vue-Components-Everywhere\"><a href=\"#Vue-Components-Everywhere\" class=\"headerlink\" title=\"Vue Components Everywhere\"></a>Vue Components Everywhere</h3><p>There are different templates for different purposes: simple setups for quick prototyping, and full-featured setups for ambitious applications. A common feature among these templates though, is that they all support <code>*.vue</code> single file components. This means any third party Vue components written as valid <code>*.vue</code> files can be shared among projects using these setups, and simply be distributed over NPM - let’s create more reusable components!</p>"},{"title":"Common Beginner Gotchas","date":"2016-02-06T02:00:00.000Z","_content":"\nThere are few types of questions that we frequently see from users who are new to Vue.js. Although they are all mentioned somewhere in the guide, they are easy to miss and can be hard to find when you do get bitten by the gotchas. Therefore we are aggregating them in this post and hopefully it can save you some time!\n\n<!-- more -->\n\n### Why isn't the DOM updating?\n\nMost of the time, when you change a Vue instance's data, the view updates. But there are two edge cases:\n\n1. When you are **adding a new property** that wasn't present when the data was observed. Due to the limitation of ES5 and to ensure consistent behavior across browsers, Vue.js cannot detect property addition/deletions. The best practice is to always declare properties that need to be reactive upfront. In cases where you absolutely need to add or delete properties at runtime, use the global [`Vue.set`](/api/#Vue-set) or [`Vue.delete`](/api/#Vue-delete) methods.\n\n2. When you modify an Array by directly setting an index (e.g. `arr[0] = val`) or modifying its `length` property. Similarly, Vue.js cannot pickup these changes. Always modify arrays by using an Array instance method, or replacing it entirely. Vue provides a convenience method `arr.$set(index, value)` which is just syntax sugar for `arr.splice(index, 1, value)`.\n\nFurther reading: [Reactivity in Depth](/guide/reactivity.html) and [Array Change Detection](http://vuejs.org/guide/list.html#Array-Change-Detection).\n\n### When is the DOM updated?\n\nVue.js uses an asynchronous queue to batch DOM updates. This means when you modify some data, the DOM updates do not happen instantly: they are applied asynchronously when the queue is flushed. So how do you know when the DOM has been updated? Use `Vue.nextTick` right after you modify the data. The callback function you pass to it will be called once the queue has been flushed.\n\nFurther reading: [Async Update Queue](/guide/reactivity.html#Async-Update-Queue).\n\n### Why does `data` need to be a function?\n\nIn the basic examples, we declare the `data` directly as a plain object. This is because we are creating only a single instance with `new Vue()`. However, when defining a **component**, `data` must be declared as a function that returns the initial data object. Why? Because there will be many instances created using the same definition. If we still use a plain object for `data`, that same object will be **shared by reference** across all instance created! By providing a `data` function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data.\n\nFurther reading: [Component Option Caveats](/guide/components.html#Component-Option-Caveats).\n\n### HTML case insensitivity\n\nAll Vue.js templates are valid, parsable HTML markup, and Vue.js relies on spec-compliant parsers to process its templates. However, as specified in the standard, HTML is case-insensitive when matching tag and attribute names. This means camelCase attributes like `:myProp=\"123\"` will be matched as `:myprop=\"123\"`. As a rule of thumb, you should use camelCase in JavaScript and kebab-case in templates. For example a prop defined in JavaScript as `myProp` should be bound in templates as `:my-prop`.\n\nFurther reading: [camelCase vs. kebab-case](http://vuejs.org/guide/components.html#camelCase-vs-kebab-case).\n\nWe are also discussing the possibility of eliminating this inconsistency by resolving props and components in a case-insensitive manner. Join the conversation [here](https://github.com/vuejs/vue/issues/2308).\n","source":"_posts/common-gotchas.md","raw":"---\ntitle: Common Beginner Gotchas\ndate: 2016-02-06 10:00:00\n---\n\nThere are few types of questions that we frequently see from users who are new to Vue.js. Although they are all mentioned somewhere in the guide, they are easy to miss and can be hard to find when you do get bitten by the gotchas. Therefore we are aggregating them in this post and hopefully it can save you some time!\n\n<!-- more -->\n\n### Why isn't the DOM updating?\n\nMost of the time, when you change a Vue instance's data, the view updates. But there are two edge cases:\n\n1. When you are **adding a new property** that wasn't present when the data was observed. Due to the limitation of ES5 and to ensure consistent behavior across browsers, Vue.js cannot detect property addition/deletions. The best practice is to always declare properties that need to be reactive upfront. In cases where you absolutely need to add or delete properties at runtime, use the global [`Vue.set`](/api/#Vue-set) or [`Vue.delete`](/api/#Vue-delete) methods.\n\n2. When you modify an Array by directly setting an index (e.g. `arr[0] = val`) or modifying its `length` property. Similarly, Vue.js cannot pickup these changes. Always modify arrays by using an Array instance method, or replacing it entirely. Vue provides a convenience method `arr.$set(index, value)` which is just syntax sugar for `arr.splice(index, 1, value)`.\n\nFurther reading: [Reactivity in Depth](/guide/reactivity.html) and [Array Change Detection](http://vuejs.org/guide/list.html#Array-Change-Detection).\n\n### When is the DOM updated?\n\nVue.js uses an asynchronous queue to batch DOM updates. This means when you modify some data, the DOM updates do not happen instantly: they are applied asynchronously when the queue is flushed. So how do you know when the DOM has been updated? Use `Vue.nextTick` right after you modify the data. The callback function you pass to it will be called once the queue has been flushed.\n\nFurther reading: [Async Update Queue](/guide/reactivity.html#Async-Update-Queue).\n\n### Why does `data` need to be a function?\n\nIn the basic examples, we declare the `data` directly as a plain object. This is because we are creating only a single instance with `new Vue()`. However, when defining a **component**, `data` must be declared as a function that returns the initial data object. Why? Because there will be many instances created using the same definition. If we still use a plain object for `data`, that same object will be **shared by reference** across all instance created! By providing a `data` function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data.\n\nFurther reading: [Component Option Caveats](/guide/components.html#Component-Option-Caveats).\n\n### HTML case insensitivity\n\nAll Vue.js templates are valid, parsable HTML markup, and Vue.js relies on spec-compliant parsers to process its templates. However, as specified in the standard, HTML is case-insensitive when matching tag and attribute names. This means camelCase attributes like `:myProp=\"123\"` will be matched as `:myprop=\"123\"`. As a rule of thumb, you should use camelCase in JavaScript and kebab-case in templates. For example a prop defined in JavaScript as `myProp` should be bound in templates as `:my-prop`.\n\nFurther reading: [camelCase vs. kebab-case](http://vuejs.org/guide/components.html#camelCase-vs-kebab-case).\n\nWe are also discussing the possibility of eliminating this inconsistency by resolving props and components in a case-insensitive manner. Join the conversation [here](https://github.com/vuejs/vue/issues/2308).\n","slug":"common-gotchas","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajuww000ajl2dahufdtjw","content":"<p>There are few types of questions that we frequently see from users who are new to Vue.js. Although they are all mentioned somewhere in the guide, they are easy to miss and can be hard to find when you do get bitten by the gotchas. Therefore we are aggregating them in this post and hopefully it can save you some time!</p>\n<a id=\"more\"></a>\n<h3 id=\"Why-isn’t-the-DOM-updating\"><a href=\"#Why-isn’t-the-DOM-updating\" class=\"headerlink\" title=\"Why isn’t the DOM updating?\"></a>Why isn’t the DOM updating?</h3><p>Most of the time, when you change a Vue instance’s data, the view updates. But there are two edge cases:</p>\n<ol>\n<li><p>When you are <strong>adding a new property</strong> that wasn’t present when the data was observed. Due to the limitation of ES5 and to ensure consistent behavior across browsers, Vue.js cannot detect property addition/deletions. The best practice is to always declare properties that need to be reactive upfront. In cases where you absolutely need to add or delete properties at runtime, use the global <a href=\"/api/#Vue-set\"><code>Vue.set</code></a> or <a href=\"/api/#Vue-delete\"><code>Vue.delete</code></a> methods.</p>\n</li>\n<li><p>When you modify an Array by directly setting an index (e.g. <code>arr[0] = val</code>) or modifying its <code>length</code> property. Similarly, Vue.js cannot pickup these changes. Always modify arrays by using an Array instance method, or replacing it entirely. Vue provides a convenience method <code>arr.$set(index, value)</code> which is just syntax sugar for <code>arr.splice(index, 1, value)</code>.</p>\n</li>\n</ol>\n<p>Further reading: <a href=\"/guide/reactivity.html\">Reactivity in Depth</a> and <a href=\"http://vuejs.org/guide/list.html#Array-Change-Detection\" target=\"_blank\" rel=\"external\">Array Change Detection</a>.</p>\n<h3 id=\"When-is-the-DOM-updated\"><a href=\"#When-is-the-DOM-updated\" class=\"headerlink\" title=\"When is the DOM updated?\"></a>When is the DOM updated?</h3><p>Vue.js uses an asynchronous queue to batch DOM updates. This means when you modify some data, the DOM updates do not happen instantly: they are applied asynchronously when the queue is flushed. So how do you know when the DOM has been updated? Use <code>Vue.nextTick</code> right after you modify the data. The callback function you pass to it will be called once the queue has been flushed.</p>\n<p>Further reading: <a href=\"/guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a>.</p>\n<h3 id=\"Why-does-data-need-to-be-a-function\"><a href=\"#Why-does-data-need-to-be-a-function\" class=\"headerlink\" title=\"Why does data need to be a function?\"></a>Why does <code>data</code> need to be a function?</h3><p>In the basic examples, we declare the <code>data</code> directly as a plain object. This is because we are creating only a single instance with <code>new Vue()</code>. However, when defining a <strong>component</strong>, <code>data</code> must be declared as a function that returns the initial data object. Why? Because there will be many instances created using the same definition. If we still use a plain object for <code>data</code>, that same object will be <strong>shared by reference</strong> across all instance created! By providing a <code>data</code> function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data.</p>\n<p>Further reading: <a href=\"/guide/components.html#Component-Option-Caveats\">Component Option Caveats</a>.</p>\n<h3 id=\"HTML-case-insensitivity\"><a href=\"#HTML-case-insensitivity\" class=\"headerlink\" title=\"HTML case insensitivity\"></a>HTML case insensitivity</h3><p>All Vue.js templates are valid, parsable HTML markup, and Vue.js relies on spec-compliant parsers to process its templates. However, as specified in the standard, HTML is case-insensitive when matching tag and attribute names. This means camelCase attributes like <code>:myProp=&quot;123&quot;</code> will be matched as <code>:myprop=&quot;123&quot;</code>. As a rule of thumb, you should use camelCase in JavaScript and kebab-case in templates. For example a prop defined in JavaScript as <code>myProp</code> should be bound in templates as <code>:my-prop</code>.</p>\n<p>Further reading: <a href=\"http://vuejs.org/guide/components.html#camelCase-vs-kebab-case\" target=\"_blank\" rel=\"external\">camelCase vs. kebab-case</a>.</p>\n<p>We are also discussing the possibility of eliminating this inconsistency by resolving props and components in a case-insensitive manner. Join the conversation <a href=\"https://github.com/vuejs/vue/issues/2308\" target=\"_blank\" rel=\"external\">here</a>.</p>\n","excerpt":"<p>There are few types of questions that we frequently see from users who are new to Vue.js. Although they are all mentioned somewhere in the guide, they are easy to miss and can be hard to find when you do get bitten by the gotchas. Therefore we are aggregating them in this post and hopefully it can save you some time!</p>","more":"<h3 id=\"Why-isn’t-the-DOM-updating\"><a href=\"#Why-isn’t-the-DOM-updating\" class=\"headerlink\" title=\"Why isn’t the DOM updating?\"></a>Why isn’t the DOM updating?</h3><p>Most of the time, when you change a Vue instance’s data, the view updates. But there are two edge cases:</p>\n<ol>\n<li><p>When you are <strong>adding a new property</strong> that wasn’t present when the data was observed. Due to the limitation of ES5 and to ensure consistent behavior across browsers, Vue.js cannot detect property addition/deletions. The best practice is to always declare properties that need to be reactive upfront. In cases where you absolutely need to add or delete properties at runtime, use the global <a href=\"/api/#Vue-set\"><code>Vue.set</code></a> or <a href=\"/api/#Vue-delete\"><code>Vue.delete</code></a> methods.</p>\n</li>\n<li><p>When you modify an Array by directly setting an index (e.g. <code>arr[0] = val</code>) or modifying its <code>length</code> property. Similarly, Vue.js cannot pickup these changes. Always modify arrays by using an Array instance method, or replacing it entirely. Vue provides a convenience method <code>arr.$set(index, value)</code> which is just syntax sugar for <code>arr.splice(index, 1, value)</code>.</p>\n</li>\n</ol>\n<p>Further reading: <a href=\"/guide/reactivity.html\">Reactivity in Depth</a> and <a href=\"http://vuejs.org/guide/list.html#Array-Change-Detection\">Array Change Detection</a>.</p>\n<h3 id=\"When-is-the-DOM-updated\"><a href=\"#When-is-the-DOM-updated\" class=\"headerlink\" title=\"When is the DOM updated?\"></a>When is the DOM updated?</h3><p>Vue.js uses an asynchronous queue to batch DOM updates. This means when you modify some data, the DOM updates do not happen instantly: they are applied asynchronously when the queue is flushed. So how do you know when the DOM has been updated? Use <code>Vue.nextTick</code> right after you modify the data. The callback function you pass to it will be called once the queue has been flushed.</p>\n<p>Further reading: <a href=\"/guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a>.</p>\n<h3 id=\"Why-does-data-need-to-be-a-function\"><a href=\"#Why-does-data-need-to-be-a-function\" class=\"headerlink\" title=\"Why does data need to be a function?\"></a>Why does <code>data</code> need to be a function?</h3><p>In the basic examples, we declare the <code>data</code> directly as a plain object. This is because we are creating only a single instance with <code>new Vue()</code>. However, when defining a <strong>component</strong>, <code>data</code> must be declared as a function that returns the initial data object. Why? Because there will be many instances created using the same definition. If we still use a plain object for <code>data</code>, that same object will be <strong>shared by reference</strong> across all instance created! By providing a <code>data</code> function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data.</p>\n<p>Further reading: <a href=\"/guide/components.html#Component-Option-Caveats\">Component Option Caveats</a>.</p>\n<h3 id=\"HTML-case-insensitivity\"><a href=\"#HTML-case-insensitivity\" class=\"headerlink\" title=\"HTML case insensitivity\"></a>HTML case insensitivity</h3><p>All Vue.js templates are valid, parsable HTML markup, and Vue.js relies on spec-compliant parsers to process its templates. However, as specified in the standard, HTML is case-insensitive when matching tag and attribute names. This means camelCase attributes like <code>:myProp=&quot;123&quot;</code> will be matched as <code>:myprop=&quot;123&quot;</code>. As a rule of thumb, you should use camelCase in JavaScript and kebab-case in templates. For example a prop defined in JavaScript as <code>myProp</code> should be bound in templates as <code>:my-prop</code>.</p>\n<p>Further reading: <a href=\"http://vuejs.org/guide/components.html#camelCase-vs-kebab-case\">camelCase vs. kebab-case</a>.</p>\n<p>We are also discussing the possibility of eliminating this inconsistency by resolving props and components in a case-insensitive manner. Join the conversation <a href=\"https://github.com/vuejs/vue/issues/2308\">here</a>.</p>"},{"title":"Vue.js 0.10.6, and what's next","date":"2014-07-28T16:04:55.000Z","_content":"\n## 0.10.6\n\nVue.js 0.10.6 has been released! This is another small bug-fix release and will be the last maintainance version before the next major release.\n\n<!-- more -->\n\n- fix `v-style` error when value is falsy or a number. ( thanks to [@dmfilipenko](https://github.com/dmfilipenko) )\n- fix the built-in `currency` filter error when value is a string ( thanks to [@dmfilipenko](https://github.com/dmfilipenko) )\n- fix `Vue.require` for building with Component v1.0+ ( thanks to [@kewah](https://github.com/kewah) )\n- Allow template nodes to be passed as a template option ( thanks to [@jordangarcia](https://github.com/jordangarcia) )\n- `vm.$destroy()` now accepts an optional argument `noRemove`. When passed in as `true` it will leave the vm's DOM node intact after the vm is destroyed.\n\n## Vue-next\n\nSome of you might have noticed there is a [next](https://github.com/yyx990803/vue/tree/next) branch in the repo. And yes, I am re-writing Vue.js from scratch. There are two main reasons:\n\n- Fix some issues that are caused by design flaws in the current version. Because these changes affect the design of some core modules, it is actually easier to rewrite than to apply on the current codebase.\n- Improve general code quality (in particular, `compiler.js` as of now is a big pile of mess, and comments are not consistent across the codebase.)\n\nTake note that the `next` branch is still in **very** early stage. The internals will change a lot, and when it comes out it **will** break current applications. Despite that I will try to keep the API changes to a minimum. Major differences with current 0.10 branch are documented in [`changes.md`](https://github.com/yyx990803/vue/blob/next/changes.md). The list is obviously incomplete and subject to change, some of them are simply ideas, but it at least gives you a taste of what to expect, and I'd appreicate your feedback on any of the topics.\n\nShare your thoughts at [vuejs/Discussion](https://github.com/vuejs/Discussion/issues).\n","source":"_posts/vue-next.md","raw":"---\ntitle: Vue.js 0.10.6, and what's next\ndate: 2014-07-29 00:04:55\n---\n\n## 0.10.6\n\nVue.js 0.10.6 has been released! This is another small bug-fix release and will be the last maintainance version before the next major release.\n\n<!-- more -->\n\n- fix `v-style` error when value is falsy or a number. ( thanks to [@dmfilipenko](https://github.com/dmfilipenko) )\n- fix the built-in `currency` filter error when value is a string ( thanks to [@dmfilipenko](https://github.com/dmfilipenko) )\n- fix `Vue.require` for building with Component v1.0+ ( thanks to [@kewah](https://github.com/kewah) )\n- Allow template nodes to be passed as a template option ( thanks to [@jordangarcia](https://github.com/jordangarcia) )\n- `vm.$destroy()` now accepts an optional argument `noRemove`. When passed in as `true` it will leave the vm's DOM node intact after the vm is destroyed.\n\n## Vue-next\n\nSome of you might have noticed there is a [next](https://github.com/yyx990803/vue/tree/next) branch in the repo. And yes, I am re-writing Vue.js from scratch. There are two main reasons:\n\n- Fix some issues that are caused by design flaws in the current version. Because these changes affect the design of some core modules, it is actually easier to rewrite than to apply on the current codebase.\n- Improve general code quality (in particular, `compiler.js` as of now is a big pile of mess, and comments are not consistent across the codebase.)\n\nTake note that the `next` branch is still in **very** early stage. The internals will change a lot, and when it comes out it **will** break current applications. Despite that I will try to keep the API changes to a minimum. Major differences with current 0.10 branch are documented in [`changes.md`](https://github.com/yyx990803/vue/blob/next/changes.md). The list is obviously incomplete and subject to change, some of them are simply ideas, but it at least gives you a taste of what to expect, and I'd appreicate your feedback on any of the topics.\n\nShare your thoughts at [vuejs/Discussion](https://github.com/vuejs/Discussion/issues).\n","slug":"vue-next","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajuwy000bjl2d9aufrry0","content":"<h2 id=\"0-10-6\"><a href=\"#0-10-6\" class=\"headerlink\" title=\"0.10.6\"></a>0.10.6</h2><p>Vue.js 0.10.6 has been released! This is another small bug-fix release and will be the last maintainance version before the next major release.</p>\n<a id=\"more\"></a>\n<ul>\n<li>fix <code>v-style</code> error when value is falsy or a number. ( thanks to <a href=\"https://github.com/dmfilipenko\" target=\"_blank\" rel=\"external\">@dmfilipenko</a> )</li>\n<li>fix the built-in <code>currency</code> filter error when value is a string ( thanks to <a href=\"https://github.com/dmfilipenko\" target=\"_blank\" rel=\"external\">@dmfilipenko</a> )</li>\n<li>fix <code>Vue.require</code> for building with Component v1.0+ ( thanks to <a href=\"https://github.com/kewah\" target=\"_blank\" rel=\"external\">@kewah</a> )</li>\n<li>Allow template nodes to be passed as a template option ( thanks to <a href=\"https://github.com/jordangarcia\" target=\"_blank\" rel=\"external\">@jordangarcia</a> )</li>\n<li><code>vm.$destroy()</code> now accepts an optional argument <code>noRemove</code>. When passed in as <code>true</code> it will leave the vm’s DOM node intact after the vm is destroyed.</li>\n</ul>\n<h2 id=\"Vue-next\"><a href=\"#Vue-next\" class=\"headerlink\" title=\"Vue-next\"></a>Vue-next</h2><p>Some of you might have noticed there is a <a href=\"https://github.com/yyx990803/vue/tree/next\" target=\"_blank\" rel=\"external\">next</a> branch in the repo. And yes, I am re-writing Vue.js from scratch. There are two main reasons:</p>\n<ul>\n<li>Fix some issues that are caused by design flaws in the current version. Because these changes affect the design of some core modules, it is actually easier to rewrite than to apply on the current codebase.</li>\n<li>Improve general code quality (in particular, <code>compiler.js</code> as of now is a big pile of mess, and comments are not consistent across the codebase.)</li>\n</ul>\n<p>Take note that the <code>next</code> branch is still in <strong>very</strong> early stage. The internals will change a lot, and when it comes out it <strong>will</strong> break current applications. Despite that I will try to keep the API changes to a minimum. Major differences with current 0.10 branch are documented in <a href=\"https://github.com/yyx990803/vue/blob/next/changes.md\" target=\"_blank\" rel=\"external\"><code>changes.md</code></a>. The list is obviously incomplete and subject to change, some of them are simply ideas, but it at least gives you a taste of what to expect, and I’d appreicate your feedback on any of the topics.</p>\n<p>Share your thoughts at <a href=\"https://github.com/vuejs/Discussion/issues\" target=\"_blank\" rel=\"external\">vuejs/Discussion</a>.</p>\n","excerpt":"<h2 id=\"0-10-6\"><a href=\"#0-10-6\" class=\"headerlink\" title=\"0.10.6\"></a>0.10.6</h2><p>Vue.js 0.10.6 has been released! This is another small bug-fix release and will be the last maintainance version before the next major release.</p>","more":"<ul>\n<li>fix <code>v-style</code> error when value is falsy or a number. ( thanks to <a href=\"https://github.com/dmfilipenko\">@dmfilipenko</a> )</li>\n<li>fix the built-in <code>currency</code> filter error when value is a string ( thanks to <a href=\"https://github.com/dmfilipenko\">@dmfilipenko</a> )</li>\n<li>fix <code>Vue.require</code> for building with Component v1.0+ ( thanks to <a href=\"https://github.com/kewah\">@kewah</a> )</li>\n<li>Allow template nodes to be passed as a template option ( thanks to <a href=\"https://github.com/jordangarcia\">@jordangarcia</a> )</li>\n<li><code>vm.$destroy()</code> now accepts an optional argument <code>noRemove</code>. When passed in as <code>true</code> it will leave the vm’s DOM node intact after the vm is destroyed.</li>\n</ul>\n<h2 id=\"Vue-next\"><a href=\"#Vue-next\" class=\"headerlink\" title=\"Vue-next\"></a>Vue-next</h2><p>Some of you might have noticed there is a <a href=\"https://github.com/yyx990803/vue/tree/next\">next</a> branch in the repo. And yes, I am re-writing Vue.js from scratch. There are two main reasons:</p>\n<ul>\n<li>Fix some issues that are caused by design flaws in the current version. Because these changes affect the design of some core modules, it is actually easier to rewrite than to apply on the current codebase.</li>\n<li>Improve general code quality (in particular, <code>compiler.js</code> as of now is a big pile of mess, and comments are not consistent across the codebase.)</li>\n</ul>\n<p>Take note that the <code>next</code> branch is still in <strong>very</strong> early stage. The internals will change a lot, and when it comes out it <strong>will</strong> break current applications. Despite that I will try to keep the API changes to a minimum. Major differences with current 0.10 branch are documented in <a href=\"https://github.com/yyx990803/vue/blob/next/changes.md\"><code>changes.md</code></a>. The list is obviously incomplete and subject to change, some of them are simply ideas, but it at least gives you a taste of what to expect, and I’d appreicate your feedback on any of the topics.</p>\n<p>Share your thoughts at <a href=\"https://github.com/vuejs/Discussion/issues\">vuejs/Discussion</a>.</p>"},{"title":"March 2016 Update","date":"2016-03-14T10:45:00.000Z","_content":"\n## Growing Community\n\nVue's growth in the past year has been nothing short of amazing. As of today we are at over 15,000 stars on GitHub, over 500k downloads from npm, and over 2,000 users in the Gitter channel. What's more exciting though, is that the community successfully organized the first [London Vue.js Meetup](http://www.meetup.com/London-Vue-js-Meetup/) and the first [Paris Vue.js Meetup](http://www.meetup.com/Vuejs-Paris/?scroll=true)! A big shoutout to the awesome organizers: [Jack](https://twitter.com/JackBarham), [James](https://twitter.com/onejamesbrowne/) and [Eduardo](https://twitter.com/posva/).\n\n<!-- more -->\n\nIf you are interested in connecting with Vue.js users near you and share your experiences in using Vue.js, joining a local Meetup is a great idea - even better, maybe you can organize one :)\n\n## Cool Things Being Built\n\nMore and more amazing things are being built with Vue. There are products like [PageKit](https://pagekit.com/), Laravel Spark (coming soon) and [Statamic](https://v2.statamic.com/), sleek apps like [Koel](http://koel.phanan.net/) and [Gokotta](https://github.com/Zhangdroid/Gokotta), UI components like [VueStrap](http://yuche.github.io/vue-strap/) and [Vue-MDL](http://posva.net/vue-mdl/), and smooth, interactive experiences like [YouTube Adblitz](https://adblitz.withyoutube.com) and even the [Facebook NewsFeed Marketing Site](https://newsfeed.fb.com/)!\n\nThere are many other great projects - too many to be listed here - but you can check them all out in [awesome-vue](https://github.com/vuejs/awesome-vue). If you've built great things with Vue, you should also add them to the list!\n\n## A New Vision For the Project\n\nSome of you may have noticed that the development on the Vue.js core repo has slowed down lately - in the meanwhile, a lot of efforts went into other sub projects, namely [Vuex](https://github.com/vuejs/vuex), [vue-devtools](https://github.com/vuejs/vue-devtools) and the official [Webpack project boilerplate](https://github.com/vuejs-templates/webpack). The next step is a new release for [vue-router](https://github.com/vuejs/vue-router), and better documentation/examples demonstrating how Vue.js core, Vuex and vue-router work together in a large single page application.\n\nAll this adds together towards a new vision for the Vue.js project: a progressive framework that can adapt to different complexity levels. Vue.js core will remain \"just the view layer\" - you can still drop it on whatever existing page to replace jQuery, but the Vue.js project also includes other pieces like vue-router, Vuex, vue-loader/vueify and vue-cli that works together as a more complete, opinionated framework for single page applications. More on this in a later post.\n\n## Vue.js needs your help!\n\nOpen source is awesome, and I'm proud that Vue.js is helping people build real products all over the world. However, as the scope of the project grows, pushing new features while maintaining everything becomes a very demanding job. The good news is you can help!\n\n### Looking for collaborators\n\nThere are already users who frequently helps out in various ways, but this is an invitation to make things official. I'm looking for contributors to join the \"team\", which is currently mostly just me. If that sounds interesting to you, take a look at the application [here](https://docs.google.com/forms/d/1SgDgKZqyivEf5xl0EOWNfs68Xy3f4oBzLXIlwlS0BIs/viewform).\n\n### Looking for sponsors\n\nAnother way to help making Vue development sustainable is providing direct financial support. The more financial support I receive, the more time I get to spend on making Vue even better.\n\nIf you run a business and is using Vue in a revenue-generating product, it would make business sense to sponsor Vue development: it ensures the project that your product relies on stays healthy and actively maintained. It can also help your exposure in the Vue community and makes it easier to attract Vue developers.\n\nIf you are an individual user and have enjoyed the productivity of using Vue, consider donating as a sign of appreciation - like buying me coffee once in a while :)\n\nIn either case, you can provide recurring funding through Vue's [Patreon campaign](https://www.patreon.com/evanyou), or provide one-time donations via [PayPal](https://www.paypal.me/evanyou). There are many ideas for Vue that I have lined up but haven't had the time to embark on, and I would love to be able to work on them full time - I hope you can help me make that happen!\n","source":"_posts/march-update.md","raw":"---\ntitle: March 2016 Update\ndate: 2016-03-14 18:45:00\n---\n\n## Growing Community\n\nVue's growth in the past year has been nothing short of amazing. As of today we are at over 15,000 stars on GitHub, over 500k downloads from npm, and over 2,000 users in the Gitter channel. What's more exciting though, is that the community successfully organized the first [London Vue.js Meetup](http://www.meetup.com/London-Vue-js-Meetup/) and the first [Paris Vue.js Meetup](http://www.meetup.com/Vuejs-Paris/?scroll=true)! A big shoutout to the awesome organizers: [Jack](https://twitter.com/JackBarham), [James](https://twitter.com/onejamesbrowne/) and [Eduardo](https://twitter.com/posva/).\n\n<!-- more -->\n\nIf you are interested in connecting with Vue.js users near you and share your experiences in using Vue.js, joining a local Meetup is a great idea - even better, maybe you can organize one :)\n\n## Cool Things Being Built\n\nMore and more amazing things are being built with Vue. There are products like [PageKit](https://pagekit.com/), Laravel Spark (coming soon) and [Statamic](https://v2.statamic.com/), sleek apps like [Koel](http://koel.phanan.net/) and [Gokotta](https://github.com/Zhangdroid/Gokotta), UI components like [VueStrap](http://yuche.github.io/vue-strap/) and [Vue-MDL](http://posva.net/vue-mdl/), and smooth, interactive experiences like [YouTube Adblitz](https://adblitz.withyoutube.com) and even the [Facebook NewsFeed Marketing Site](https://newsfeed.fb.com/)!\n\nThere are many other great projects - too many to be listed here - but you can check them all out in [awesome-vue](https://github.com/vuejs/awesome-vue). If you've built great things with Vue, you should also add them to the list!\n\n## A New Vision For the Project\n\nSome of you may have noticed that the development on the Vue.js core repo has slowed down lately - in the meanwhile, a lot of efforts went into other sub projects, namely [Vuex](https://github.com/vuejs/vuex), [vue-devtools](https://github.com/vuejs/vue-devtools) and the official [Webpack project boilerplate](https://github.com/vuejs-templates/webpack). The next step is a new release for [vue-router](https://github.com/vuejs/vue-router), and better documentation/examples demonstrating how Vue.js core, Vuex and vue-router work together in a large single page application.\n\nAll this adds together towards a new vision for the Vue.js project: a progressive framework that can adapt to different complexity levels. Vue.js core will remain \"just the view layer\" - you can still drop it on whatever existing page to replace jQuery, but the Vue.js project also includes other pieces like vue-router, Vuex, vue-loader/vueify and vue-cli that works together as a more complete, opinionated framework for single page applications. More on this in a later post.\n\n## Vue.js needs your help!\n\nOpen source is awesome, and I'm proud that Vue.js is helping people build real products all over the world. However, as the scope of the project grows, pushing new features while maintaining everything becomes a very demanding job. The good news is you can help!\n\n### Looking for collaborators\n\nThere are already users who frequently helps out in various ways, but this is an invitation to make things official. I'm looking for contributors to join the \"team\", which is currently mostly just me. If that sounds interesting to you, take a look at the application [here](https://docs.google.com/forms/d/1SgDgKZqyivEf5xl0EOWNfs68Xy3f4oBzLXIlwlS0BIs/viewform).\n\n### Looking for sponsors\n\nAnother way to help making Vue development sustainable is providing direct financial support. The more financial support I receive, the more time I get to spend on making Vue even better.\n\nIf you run a business and is using Vue in a revenue-generating product, it would make business sense to sponsor Vue development: it ensures the project that your product relies on stays healthy and actively maintained. It can also help your exposure in the Vue community and makes it easier to attract Vue developers.\n\nIf you are an individual user and have enjoyed the productivity of using Vue, consider donating as a sign of appreciation - like buying me coffee once in a while :)\n\nIn either case, you can provide recurring funding through Vue's [Patreon campaign](https://www.patreon.com/evanyou), or provide one-time donations via [PayPal](https://www.paypal.me/evanyou). There are many ideas for Vue that I have lined up but haven't had the time to embark on, and I would love to be able to work on them full time - I hope you can help me make that happen!\n","slug":"march-update","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajuwz000cjl2d1tw20yh3","content":"<h2 id=\"Growing-Community\"><a href=\"#Growing-Community\" class=\"headerlink\" title=\"Growing Community\"></a>Growing Community</h2><p>Vue’s growth in the past year has been nothing short of amazing. As of today we are at over 15,000 stars on GitHub, over 500k downloads from npm, and over 2,000 users in the Gitter channel. What’s more exciting though, is that the community successfully organized the first <a href=\"http://www.meetup.com/London-Vue-js-Meetup/\" target=\"_blank\" rel=\"external\">London Vue.js Meetup</a> and the first <a href=\"http://www.meetup.com/Vuejs-Paris/?scroll=true\" target=\"_blank\" rel=\"external\">Paris Vue.js Meetup</a>! A big shoutout to the awesome organizers: <a href=\"https://twitter.com/JackBarham\" target=\"_blank\" rel=\"external\">Jack</a>, <a href=\"https://twitter.com/onejamesbrowne/\" target=\"_blank\" rel=\"external\">James</a> and <a href=\"https://twitter.com/posva/\" target=\"_blank\" rel=\"external\">Eduardo</a>.</p>\n<a id=\"more\"></a>\n<p>If you are interested in connecting with Vue.js users near you and share your experiences in using Vue.js, joining a local Meetup is a great idea - even better, maybe you can organize one :)</p>\n<h2 id=\"Cool-Things-Being-Built\"><a href=\"#Cool-Things-Being-Built\" class=\"headerlink\" title=\"Cool Things Being Built\"></a>Cool Things Being Built</h2><p>More and more amazing things are being built with Vue. There are products like <a href=\"https://pagekit.com/\" target=\"_blank\" rel=\"external\">PageKit</a>, Laravel Spark (coming soon) and <a href=\"https://v2.statamic.com/\" target=\"_blank\" rel=\"external\">Statamic</a>, sleek apps like <a href=\"http://koel.phanan.net/\" target=\"_blank\" rel=\"external\">Koel</a> and <a href=\"https://github.com/Zhangdroid/Gokotta\" target=\"_blank\" rel=\"external\">Gokotta</a>, UI components like <a href=\"http://yuche.github.io/vue-strap/\" target=\"_blank\" rel=\"external\">VueStrap</a> and <a href=\"http://posva.net/vue-mdl/\" target=\"_blank\" rel=\"external\">Vue-MDL</a>, and smooth, interactive experiences like <a href=\"https://adblitz.withyoutube.com\" target=\"_blank\" rel=\"external\">YouTube Adblitz</a> and even the <a href=\"https://newsfeed.fb.com/\" target=\"_blank\" rel=\"external\">Facebook NewsFeed Marketing Site</a>!</p>\n<p>There are many other great projects - too many to be listed here - but you can check them all out in <a href=\"https://github.com/vuejs/awesome-vue\" target=\"_blank\" rel=\"external\">awesome-vue</a>. If you’ve built great things with Vue, you should also add them to the list!</p>\n<h2 id=\"A-New-Vision-For-the-Project\"><a href=\"#A-New-Vision-For-the-Project\" class=\"headerlink\" title=\"A New Vision For the Project\"></a>A New Vision For the Project</h2><p>Some of you may have noticed that the development on the Vue.js core repo has slowed down lately - in the meanwhile, a lot of efforts went into other sub projects, namely <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">Vuex</a>, <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"external\">vue-devtools</a> and the official <a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"external\">Webpack project boilerplate</a>. The next step is a new release for <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"external\">vue-router</a>, and better documentation/examples demonstrating how Vue.js core, Vuex and vue-router work together in a large single page application.</p>\n<p>All this adds together towards a new vision for the Vue.js project: a progressive framework that can adapt to different complexity levels. Vue.js core will remain “just the view layer” - you can still drop it on whatever existing page to replace jQuery, but the Vue.js project also includes other pieces like vue-router, Vuex, vue-loader/vueify and vue-cli that works together as a more complete, opinionated framework for single page applications. More on this in a later post.</p>\n<h2 id=\"Vue-js-needs-your-help\"><a href=\"#Vue-js-needs-your-help\" class=\"headerlink\" title=\"Vue.js needs your help!\"></a>Vue.js needs your help!</h2><p>Open source is awesome, and I’m proud that Vue.js is helping people build real products all over the world. However, as the scope of the project grows, pushing new features while maintaining everything becomes a very demanding job. The good news is you can help!</p>\n<h3 id=\"Looking-for-collaborators\"><a href=\"#Looking-for-collaborators\" class=\"headerlink\" title=\"Looking for collaborators\"></a>Looking for collaborators</h3><p>There are already users who frequently helps out in various ways, but this is an invitation to make things official. I’m looking for contributors to join the “team”, which is currently mostly just me. If that sounds interesting to you, take a look at the application <a href=\"https://docs.google.com/forms/d/1SgDgKZqyivEf5xl0EOWNfs68Xy3f4oBzLXIlwlS0BIs/viewform\" target=\"_blank\" rel=\"external\">here</a>.</p>\n<h3 id=\"Looking-for-sponsors\"><a href=\"#Looking-for-sponsors\" class=\"headerlink\" title=\"Looking for sponsors\"></a>Looking for sponsors</h3><p>Another way to help making Vue development sustainable is providing direct financial support. The more financial support I receive, the more time I get to spend on making Vue even better.</p>\n<p>If you run a business and is using Vue in a revenue-generating product, it would make business sense to sponsor Vue development: it ensures the project that your product relies on stays healthy and actively maintained. It can also help your exposure in the Vue community and makes it easier to attract Vue developers.</p>\n<p>If you are an individual user and have enjoyed the productivity of using Vue, consider donating as a sign of appreciation - like buying me coffee once in a while :)</p>\n<p>In either case, you can provide recurring funding through Vue’s <a href=\"https://www.patreon.com/evanyou\" target=\"_blank\" rel=\"external\">Patreon campaign</a>, or provide one-time donations via <a href=\"https://www.paypal.me/evanyou\" target=\"_blank\" rel=\"external\">PayPal</a>. There are many ideas for Vue that I have lined up but haven’t had the time to embark on, and I would love to be able to work on them full time - I hope you can help me make that happen!</p>\n","excerpt":"<h2 id=\"Growing-Community\"><a href=\"#Growing-Community\" class=\"headerlink\" title=\"Growing Community\"></a>Growing Community</h2><p>Vue’s growth in the past year has been nothing short of amazing. As of today we are at over 15,000 stars on GitHub, over 500k downloads from npm, and over 2,000 users in the Gitter channel. What’s more exciting though, is that the community successfully organized the first <a href=\"http://www.meetup.com/London-Vue-js-Meetup/\">London Vue.js Meetup</a> and the first <a href=\"http://www.meetup.com/Vuejs-Paris/?scroll=true\">Paris Vue.js Meetup</a>! A big shoutout to the awesome organizers: <a href=\"https://twitter.com/JackBarham\">Jack</a>, <a href=\"https://twitter.com/onejamesbrowne/\">James</a> and <a href=\"https://twitter.com/posva/\">Eduardo</a>.</p>","more":"<p>If you are interested in connecting with Vue.js users near you and share your experiences in using Vue.js, joining a local Meetup is a great idea - even better, maybe you can organize one :)</p>\n<h2 id=\"Cool-Things-Being-Built\"><a href=\"#Cool-Things-Being-Built\" class=\"headerlink\" title=\"Cool Things Being Built\"></a>Cool Things Being Built</h2><p>More and more amazing things are being built with Vue. There are products like <a href=\"https://pagekit.com/\">PageKit</a>, Laravel Spark (coming soon) and <a href=\"https://v2.statamic.com/\">Statamic</a>, sleek apps like <a href=\"http://koel.phanan.net/\">Koel</a> and <a href=\"https://github.com/Zhangdroid/Gokotta\">Gokotta</a>, UI components like <a href=\"http://yuche.github.io/vue-strap/\">VueStrap</a> and <a href=\"http://posva.net/vue-mdl/\">Vue-MDL</a>, and smooth, interactive experiences like <a href=\"https://adblitz.withyoutube.com\">YouTube Adblitz</a> and even the <a href=\"https://newsfeed.fb.com/\">Facebook NewsFeed Marketing Site</a>!</p>\n<p>There are many other great projects - too many to be listed here - but you can check them all out in <a href=\"https://github.com/vuejs/awesome-vue\">awesome-vue</a>. If you’ve built great things with Vue, you should also add them to the list!</p>\n<h2 id=\"A-New-Vision-For-the-Project\"><a href=\"#A-New-Vision-For-the-Project\" class=\"headerlink\" title=\"A New Vision For the Project\"></a>A New Vision For the Project</h2><p>Some of you may have noticed that the development on the Vue.js core repo has slowed down lately - in the meanwhile, a lot of efforts went into other sub projects, namely <a href=\"https://github.com/vuejs/vuex\">Vuex</a>, <a href=\"https://github.com/vuejs/vue-devtools\">vue-devtools</a> and the official <a href=\"https://github.com/vuejs-templates/webpack\">Webpack project boilerplate</a>. The next step is a new release for <a href=\"https://github.com/vuejs/vue-router\">vue-router</a>, and better documentation/examples demonstrating how Vue.js core, Vuex and vue-router work together in a large single page application.</p>\n<p>All this adds together towards a new vision for the Vue.js project: a progressive framework that can adapt to different complexity levels. Vue.js core will remain “just the view layer” - you can still drop it on whatever existing page to replace jQuery, but the Vue.js project also includes other pieces like vue-router, Vuex, vue-loader/vueify and vue-cli that works together as a more complete, opinionated framework for single page applications. More on this in a later post.</p>\n<h2 id=\"Vue-js-needs-your-help\"><a href=\"#Vue-js-needs-your-help\" class=\"headerlink\" title=\"Vue.js needs your help!\"></a>Vue.js needs your help!</h2><p>Open source is awesome, and I’m proud that Vue.js is helping people build real products all over the world. However, as the scope of the project grows, pushing new features while maintaining everything becomes a very demanding job. The good news is you can help!</p>\n<h3 id=\"Looking-for-collaborators\"><a href=\"#Looking-for-collaborators\" class=\"headerlink\" title=\"Looking for collaborators\"></a>Looking for collaborators</h3><p>There are already users who frequently helps out in various ways, but this is an invitation to make things official. I’m looking for contributors to join the “team”, which is currently mostly just me. If that sounds interesting to you, take a look at the application <a href=\"https://docs.google.com/forms/d/1SgDgKZqyivEf5xl0EOWNfs68Xy3f4oBzLXIlwlS0BIs/viewform\">here</a>.</p>\n<h3 id=\"Looking-for-sponsors\"><a href=\"#Looking-for-sponsors\" class=\"headerlink\" title=\"Looking for sponsors\"></a>Looking for sponsors</h3><p>Another way to help making Vue development sustainable is providing direct financial support. The more financial support I receive, the more time I get to spend on making Vue even better.</p>\n<p>If you run a business and is using Vue in a revenue-generating product, it would make business sense to sponsor Vue development: it ensures the project that your product relies on stays healthy and actively maintained. It can also help your exposure in the Vue community and makes it easier to attract Vue developers.</p>\n<p>If you are an individual user and have enjoyed the productivity of using Vue, consider donating as a sign of appreciation - like buying me coffee once in a while :)</p>\n<p>In either case, you can provide recurring funding through Vue’s <a href=\"https://www.patreon.com/evanyou\">Patreon campaign</a>, or provide one-time donations via <a href=\"https://www.paypal.me/evanyou\">PayPal</a>. There are many ideas for Vue that I have lined up but haven’t had the time to embark on, and I would love to be able to work on them full time - I hope you can help me make that happen!</p>"},{"title":"Why Vue.js doesn't support templateURL","date":"2015-10-28T02:56:00.000Z","_content":"\nA very common question from new Vue users, especially those who used Angular before, is \"can I have `templateURL`?\". I have answered this so many times and I figure it's better to write something about it.\n\n<!-- more -->\n\nIn Angular, `templateURL` or `ng-include` allows the user to dynamically load a remote template file at runtime. This seems pretty convenient as a built-in feature, but let's rethink what problem it solves.\n\nFirst, it allows us to write our template in a separate HTML file. This gives us proper syntax highlighting in editors, which is probably why many prefer to do so. But is splitting your JavaScript code and the template really the best way? For a Vue.js component, its template and its JavaScript is tightly coupled by nature - it's in fact much simpler if things are just in the same file. The context switching of jumping back and forth between two files actually makes the development experience much worse. Conceptually, components are the basic building block of a Vue.js app, not templates. Every Vue.js template is coupled to an accompanying JavaScript context - there's no point in splitting them further apart.\n\nSecond, because `templateURL` loads the template via Ajax at runtime, you don't need a build step in order to split up your files. This is convenient during development, but comes at a serious cost when you want to deploy it to production. Before HTTP/2 is universally supported, the number of HTTP requests is still probably the most critical factor in your app's initial load performance. Now imagine you use `templateURL` for every component in your app - the browser needs to perform dozens of HTTP requests before even being able to display anything! In case you don't know, most browsers limit the number of parallel requests it can perform to a single server. When you exceed that limit, your app's initial rendering will suffer for every extra round trip the browser has to wait for. Sure, there are build tools that can help you pre-register all those templates in `$templateCache` - but that shows us a build step is, in fact, inevitable for any serious frontend development.\n\nSo, without `templateURL`, how do we deal with the development experience problem? Writing templates as inline JavaScript strings is terrible, faking templates with `<script type=\"x/template\">` also feels like a hack. Well, maybe it's time to up the game a bit and use a proper module bundler like [Webpack](http://webpack.github.io/) or [Browserify](http://browserify.org/). It might seem daunting if you've never dealt with them before, but trust me it's worth it to take the leap. Proper modularization is a necessity if you want to build anything large and maintainable. More importantly, you get to write your [Vue components in a single file](http://vuejs.org/guide/single-file-components.html), with proper syntax highlighting and the extra benefits of custom pre-processors, hot-reloading, ES2015 by default, autoprefixing and scoped CSS, which makes the development experience 10 times better.\n\nFinally, Vue does allow you to [lazy load your components](http://vuejs.org/guide/components.html#Async-Components), and with Webpack it is trivially easy. Although this is only a concern when your initial bundle is so large that you are better off splitting it apart.\n\nThink in components, not templates.\n","source":"_posts/why-no-template-url.md","raw":"---\ntitle: \"Why Vue.js doesn't support templateURL\"\ndate: 2015-10-28 10:56:00\n---\n\nA very common question from new Vue users, especially those who used Angular before, is \"can I have `templateURL`?\". I have answered this so many times and I figure it's better to write something about it.\n\n<!-- more -->\n\nIn Angular, `templateURL` or `ng-include` allows the user to dynamically load a remote template file at runtime. This seems pretty convenient as a built-in feature, but let's rethink what problem it solves.\n\nFirst, it allows us to write our template in a separate HTML file. This gives us proper syntax highlighting in editors, which is probably why many prefer to do so. But is splitting your JavaScript code and the template really the best way? For a Vue.js component, its template and its JavaScript is tightly coupled by nature - it's in fact much simpler if things are just in the same file. The context switching of jumping back and forth between two files actually makes the development experience much worse. Conceptually, components are the basic building block of a Vue.js app, not templates. Every Vue.js template is coupled to an accompanying JavaScript context - there's no point in splitting them further apart.\n\nSecond, because `templateURL` loads the template via Ajax at runtime, you don't need a build step in order to split up your files. This is convenient during development, but comes at a serious cost when you want to deploy it to production. Before HTTP/2 is universally supported, the number of HTTP requests is still probably the most critical factor in your app's initial load performance. Now imagine you use `templateURL` for every component in your app - the browser needs to perform dozens of HTTP requests before even being able to display anything! In case you don't know, most browsers limit the number of parallel requests it can perform to a single server. When you exceed that limit, your app's initial rendering will suffer for every extra round trip the browser has to wait for. Sure, there are build tools that can help you pre-register all those templates in `$templateCache` - but that shows us a build step is, in fact, inevitable for any serious frontend development.\n\nSo, without `templateURL`, how do we deal with the development experience problem? Writing templates as inline JavaScript strings is terrible, faking templates with `<script type=\"x/template\">` also feels like a hack. Well, maybe it's time to up the game a bit and use a proper module bundler like [Webpack](http://webpack.github.io/) or [Browserify](http://browserify.org/). It might seem daunting if you've never dealt with them before, but trust me it's worth it to take the leap. Proper modularization is a necessity if you want to build anything large and maintainable. More importantly, you get to write your [Vue components in a single file](http://vuejs.org/guide/single-file-components.html), with proper syntax highlighting and the extra benefits of custom pre-processors, hot-reloading, ES2015 by default, autoprefixing and scoped CSS, which makes the development experience 10 times better.\n\nFinally, Vue does allow you to [lazy load your components](http://vuejs.org/guide/components.html#Async-Components), and with Webpack it is trivially easy. Although this is only a concern when your initial bundle is so large that you are better off splitting it apart.\n\nThink in components, not templates.\n","slug":"why-no-template-url","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajux0000djl2d3cvxfahc","content":"<p>A very common question from new Vue users, especially those who used Angular before, is “can I have <code>templateURL</code>?”. I have answered this so many times and I figure it’s better to write something about it.</p>\n<a id=\"more\"></a>\n<p>In Angular, <code>templateURL</code> or <code>ng-include</code> allows the user to dynamically load a remote template file at runtime. This seems pretty convenient as a built-in feature, but let’s rethink what problem it solves.</p>\n<p>First, it allows us to write our template in a separate HTML file. This gives us proper syntax highlighting in editors, which is probably why many prefer to do so. But is splitting your JavaScript code and the template really the best way? For a Vue.js component, its template and its JavaScript is tightly coupled by nature - it’s in fact much simpler if things are just in the same file. The context switching of jumping back and forth between two files actually makes the development experience much worse. Conceptually, components are the basic building block of a Vue.js app, not templates. Every Vue.js template is coupled to an accompanying JavaScript context - there’s no point in splitting them further apart.</p>\n<p>Second, because <code>templateURL</code> loads the template via Ajax at runtime, you don’t need a build step in order to split up your files. This is convenient during development, but comes at a serious cost when you want to deploy it to production. Before HTTP/2 is universally supported, the number of HTTP requests is still probably the most critical factor in your app’s initial load performance. Now imagine you use <code>templateURL</code> for every component in your app - the browser needs to perform dozens of HTTP requests before even being able to display anything! In case you don’t know, most browsers limit the number of parallel requests it can perform to a single server. When you exceed that limit, your app’s initial rendering will suffer for every extra round trip the browser has to wait for. Sure, there are build tools that can help you pre-register all those templates in <code>$templateCache</code> - but that shows us a build step is, in fact, inevitable for any serious frontend development.</p>\n<p>So, without <code>templateURL</code>, how do we deal with the development experience problem? Writing templates as inline JavaScript strings is terrible, faking templates with <code>&lt;script type=&quot;x/template&quot;&gt;</code> also feels like a hack. Well, maybe it’s time to up the game a bit and use a proper module bundler like <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"external\">Webpack</a> or <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"external\">Browserify</a>. It might seem daunting if you’ve never dealt with them before, but trust me it’s worth it to take the leap. Proper modularization is a necessity if you want to build anything large and maintainable. More importantly, you get to write your <a href=\"http://vuejs.org/guide/single-file-components.html\" target=\"_blank\" rel=\"external\">Vue components in a single file</a>, with proper syntax highlighting and the extra benefits of custom pre-processors, hot-reloading, ES2015 by default, autoprefixing and scoped CSS, which makes the development experience 10 times better.</p>\n<p>Finally, Vue does allow you to <a href=\"http://vuejs.org/guide/components.html#Async-Components\" target=\"_blank\" rel=\"external\">lazy load your components</a>, and with Webpack it is trivially easy. Although this is only a concern when your initial bundle is so large that you are better off splitting it apart.</p>\n<p>Think in components, not templates.</p>\n","excerpt":"<p>A very common question from new Vue users, especially those who used Angular before, is “can I have <code>templateURL</code>?”. I have answered this so many times and I figure it’s better to write something about it.</p>","more":"<p>In Angular, <code>templateURL</code> or <code>ng-include</code> allows the user to dynamically load a remote template file at runtime. This seems pretty convenient as a built-in feature, but let’s rethink what problem it solves.</p>\n<p>First, it allows us to write our template in a separate HTML file. This gives us proper syntax highlighting in editors, which is probably why many prefer to do so. But is splitting your JavaScript code and the template really the best way? For a Vue.js component, its template and its JavaScript is tightly coupled by nature - it’s in fact much simpler if things are just in the same file. The context switching of jumping back and forth between two files actually makes the development experience much worse. Conceptually, components are the basic building block of a Vue.js app, not templates. Every Vue.js template is coupled to an accompanying JavaScript context - there’s no point in splitting them further apart.</p>\n<p>Second, because <code>templateURL</code> loads the template via Ajax at runtime, you don’t need a build step in order to split up your files. This is convenient during development, but comes at a serious cost when you want to deploy it to production. Before HTTP/2 is universally supported, the number of HTTP requests is still probably the most critical factor in your app’s initial load performance. Now imagine you use <code>templateURL</code> for every component in your app - the browser needs to perform dozens of HTTP requests before even being able to display anything! In case you don’t know, most browsers limit the number of parallel requests it can perform to a single server. When you exceed that limit, your app’s initial rendering will suffer for every extra round trip the browser has to wait for. Sure, there are build tools that can help you pre-register all those templates in <code>$templateCache</code> - but that shows us a build step is, in fact, inevitable for any serious frontend development.</p>\n<p>So, without <code>templateURL</code>, how do we deal with the development experience problem? Writing templates as inline JavaScript strings is terrible, faking templates with <code>&lt;script type=&quot;x/template&quot;&gt;</code> also feels like a hack. Well, maybe it’s time to up the game a bit and use a proper module bundler like <a href=\"http://webpack.github.io/\">Webpack</a> or <a href=\"http://browserify.org/\">Browserify</a>. It might seem daunting if you’ve never dealt with them before, but trust me it’s worth it to take the leap. Proper modularization is a necessity if you want to build anything large and maintainable. More importantly, you get to write your <a href=\"http://vuejs.org/guide/single-file-components.html\">Vue components in a single file</a>, with proper syntax highlighting and the extra benefits of custom pre-processors, hot-reloading, ES2015 by default, autoprefixing and scoped CSS, which makes the development experience 10 times better.</p>\n<p>Finally, Vue does allow you to <a href=\"http://vuejs.org/guide/components.html#Async-Components\">lazy load your components</a>, and with Webpack it is trivially easy. Although this is only a concern when your initial bundle is so large that you are better off splitting it apart.</p>\n<p>Think in components, not templates.</p>"},{"title":"Vue.js 0.10 is here!","date":"2014-03-22T11:00:13.000Z","type":"{{type}}","yield":"{{>yield}}","_content":"\nVue.js 0.10.0 (Blade Runner) has been released! This release comes with many useful additions based on the suggestions from the users, notably interpolation in literal directives, dynamic components with the new `v-view` directive, array filters, and the option to configure interpolation delimiters. Internally, the codebase has received many refactoring and improvements which makes Vue.js [even faster](http://vuejs.org/perf/).\n\n<!-- more -->\n\nSee the [Installation](/guide/installation.html) page for the latest builds.\n\n### New\n\n- Literal directives can now contain interpolation tags. These tags will be evaluated only once at compile time. An example usage is conditionally decide which component to instantiate with `v-component=\"{{type}}\"`. [Doc](/guide/directives.html#Literal_Directives).\n- Attributes listed in the `paramAttributes` option now accept mustache interpolations too. They will also only be evaluated once.\n- `v-repeat` now accepts an argument which will be used as the identifier for the wrapped object. This allows more explicit property access in repeaters. [Doc](/guide/list.html#Using_an_Identifier).\n- Added `v-view` directive which binds to a string value and dynamically instantiate different components using that string as the component ID. [Doc](/api/directives.html#v-view).\n- Added `filterBy` and `orderBy` filters for `v-repeat`. [Doc](/api/filters.html#filterBy).\n- Custom filters that access properties on its `this` context will be considered **computed filters**. [Doc](/guide/custom-filter.html#Filter_Context).\n- You can now access the event in `v-on` handler expressions as `$event`. Example: `<a v-on=\"click:handle('hello', $event)\">Hello</a>`\n- Interpolation delimiters can now be customized via the `delimiters` global config option. Example: `Vue.config({ delimiters: [\"[\", \"]\"] })` will change the matched interpolation tags to `[[ ]]` for text bindings and `[[[ ]]]` for html bindings.\n\n### Changed\n\n- `{{yield}}` syntax has been deprecated. A Web Components spec compatible content insertion mechanism using `<content>` elements has been introduced. [Doc](/guide/components.html#Content_Insertion).\n- To use a component as a custom element, the component ID must now contain a hyphen (`-`). This is consistent with the current custom element spec draft.\n- `v-repeat` Arrays' augmented methods have been renamed from `set` to `$set(index, value)` and `remove` to `$remove(index | value)`. The prefix better differentiates them from native methods. The `replace` method has been removed.\n- When iterating over an Object with `v-repeat`, the object no longer gets a `$repeater` array. Instead, the object is now augmented with two methods: `$add(key, value)` and `$delete(key)`, which will trigger corresponding view updates.\n- `v-if` now creates and destroys a child ViewModel instance when the binding value changes, instead of simply removing/inserting the DOM node. In addition, it can no longer be used with `v-repeat`. Use `v-show` or the new built-in array filters instead.\n- `v-with` can no longer be used alone. It now must be used with either `v-component` or `v-view`. `v-component` can also be used as an empty directive just to create a child VM using the default `Vue` constructor.\n- Production build now strips all warnings and debug logs. To leverage `debug: true`, use the development version. The development version now has more detailed warning messages.\n\n### Fixed\n\n- `event.stopPropagation()` and `event.preventDefault()` inside `v-on` handlers now work as expected.\n- `parent` option now works properly when used in `Vue.extend`\n- Mustache bindings inside `<textarea>` are now properly interpolated before being set as value.\n\n### Internal\n\n- `v-component`, `v-with` and `v-if` have been re-written for a cleaner compile flow.\n- `v-repeat` has been re-written to use refined diff algorithm which triggers minimum DOM manipulations when the array is set to a different instance containing overlapping elements. This makes it efficient to pipe an Array through filters.\n- `template` option now directly clones native `<template>`'s content when available.\n- Overall performance improvements for both initialization and rendering.\n","source":"_posts/vuejs-010-release.md","raw":"---\ntitle: Vue.js 0.10 is here!\ndate: 2014-03-22 19:00:13\ntype: '{{type}}'\nyield: '{{>yield}}'\n---\n\nVue.js 0.10.0 (Blade Runner) has been released! This release comes with many useful additions based on the suggestions from the users, notably interpolation in literal directives, dynamic components with the new `v-view` directive, array filters, and the option to configure interpolation delimiters. Internally, the codebase has received many refactoring and improvements which makes Vue.js [even faster](http://vuejs.org/perf/).\n\n<!-- more -->\n\nSee the [Installation](/guide/installation.html) page for the latest builds.\n\n### New\n\n- Literal directives can now contain interpolation tags. These tags will be evaluated only once at compile time. An example usage is conditionally decide which component to instantiate with `v-component=\"{{type}}\"`. [Doc](/guide/directives.html#Literal_Directives).\n- Attributes listed in the `paramAttributes` option now accept mustache interpolations too. They will also only be evaluated once.\n- `v-repeat` now accepts an argument which will be used as the identifier for the wrapped object. This allows more explicit property access in repeaters. [Doc](/guide/list.html#Using_an_Identifier).\n- Added `v-view` directive which binds to a string value and dynamically instantiate different components using that string as the component ID. [Doc](/api/directives.html#v-view).\n- Added `filterBy` and `orderBy` filters for `v-repeat`. [Doc](/api/filters.html#filterBy).\n- Custom filters that access properties on its `this` context will be considered **computed filters**. [Doc](/guide/custom-filter.html#Filter_Context).\n- You can now access the event in `v-on` handler expressions as `$event`. Example: `<a v-on=\"click:handle('hello', $event)\">Hello</a>`\n- Interpolation delimiters can now be customized via the `delimiters` global config option. Example: `Vue.config({ delimiters: [\"[\", \"]\"] })` will change the matched interpolation tags to `[[ ]]` for text bindings and `[[[ ]]]` for html bindings.\n\n### Changed\n\n- `{{yield}}` syntax has been deprecated. A Web Components spec compatible content insertion mechanism using `<content>` elements has been introduced. [Doc](/guide/components.html#Content_Insertion).\n- To use a component as a custom element, the component ID must now contain a hyphen (`-`). This is consistent with the current custom element spec draft.\n- `v-repeat` Arrays' augmented methods have been renamed from `set` to `$set(index, value)` and `remove` to `$remove(index | value)`. The prefix better differentiates them from native methods. The `replace` method has been removed.\n- When iterating over an Object with `v-repeat`, the object no longer gets a `$repeater` array. Instead, the object is now augmented with two methods: `$add(key, value)` and `$delete(key)`, which will trigger corresponding view updates.\n- `v-if` now creates and destroys a child ViewModel instance when the binding value changes, instead of simply removing/inserting the DOM node. In addition, it can no longer be used with `v-repeat`. Use `v-show` or the new built-in array filters instead.\n- `v-with` can no longer be used alone. It now must be used with either `v-component` or `v-view`. `v-component` can also be used as an empty directive just to create a child VM using the default `Vue` constructor.\n- Production build now strips all warnings and debug logs. To leverage `debug: true`, use the development version. The development version now has more detailed warning messages.\n\n### Fixed\n\n- `event.stopPropagation()` and `event.preventDefault()` inside `v-on` handlers now work as expected.\n- `parent` option now works properly when used in `Vue.extend`\n- Mustache bindings inside `<textarea>` are now properly interpolated before being set as value.\n\n### Internal\n\n- `v-component`, `v-with` and `v-if` have been re-written for a cleaner compile flow.\n- `v-repeat` has been re-written to use refined diff algorithm which triggers minimum DOM manipulations when the array is set to a different instance containing overlapping elements. This makes it efficient to pipe an Array through filters.\n- `template` option now directly clones native `<template>`'s content when available.\n- Overall performance improvements for both initialization and rendering.\n","slug":"vuejs-010-release","published":1,"updated":"2016-12-11T12:20:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwnajux1000ejl2d6xvep541","content":"<p>Vue.js 0.10.0 (Blade Runner) has been released! This release comes with many useful additions based on the suggestions from the users, notably interpolation in literal directives, dynamic components with the new <code>v-view</code> directive, array filters, and the option to configure interpolation delimiters. Internally, the codebase has received many refactoring and improvements which makes Vue.js <a href=\"http://vuejs.org/perf/\" target=\"_blank\" rel=\"external\">even faster</a>.</p>\n<a id=\"more\"></a>\n<p>See the <a href=\"/guide/installation.html\">Installation</a> page for the latest builds.</p>\n<h3 id=\"New\"><a href=\"#New\" class=\"headerlink\" title=\"New\"></a>New</h3><ul>\n<li>Literal directives can now contain interpolation tags. These tags will be evaluated only once at compile time. An example usage is conditionally decide which component to instantiate with <code>v-component=&quot;{{type}}&quot;</code>. <a href=\"/guide/directives.html#Literal_Directives\">Doc</a>.</li>\n<li>Attributes listed in the <code>paramAttributes</code> option now accept mustache interpolations too. They will also only be evaluated once.</li>\n<li><code>v-repeat</code> now accepts an argument which will be used as the identifier for the wrapped object. This allows more explicit property access in repeaters. <a href=\"/guide/list.html#Using_an_Identifier\">Doc</a>.</li>\n<li>Added <code>v-view</code> directive which binds to a string value and dynamically instantiate different components using that string as the component ID. <a href=\"/api/directives.html#v-view\">Doc</a>.</li>\n<li>Added <code>filterBy</code> and <code>orderBy</code> filters for <code>v-repeat</code>. <a href=\"/api/filters.html#filterBy\">Doc</a>.</li>\n<li>Custom filters that access properties on its <code>this</code> context will be considered <strong>computed filters</strong>. <a href=\"/guide/custom-filter.html#Filter_Context\">Doc</a>.</li>\n<li>You can now access the event in <code>v-on</code> handler expressions as <code>$event</code>. Example: <code>&lt;a v-on=&quot;click:handle(&#39;hello&#39;, $event)&quot;&gt;Hello&lt;/a&gt;</code></li>\n<li>Interpolation delimiters can now be customized via the <code>delimiters</code> global config option. Example: <code>Vue.config({ delimiters: [&quot;[&quot;, &quot;]&quot;] })</code> will change the matched interpolation tags to <code>[[ ]]</code> for text bindings and <code>[[[ ]]]</code> for html bindings.</li>\n</ul>\n<h3 id=\"Changed\"><a href=\"#Changed\" class=\"headerlink\" title=\"Changed\"></a>Changed</h3><ul>\n<li><code>{{>yield}}</code> syntax has been deprecated. A Web Components spec compatible content insertion mechanism using <code>&lt;content&gt;</code> elements has been introduced. <a href=\"/guide/components.html#Content_Insertion\">Doc</a>.</li>\n<li>To use a component as a custom element, the component ID must now contain a hyphen (<code>-</code>). This is consistent with the current custom element spec draft.</li>\n<li><code>v-repeat</code> Arrays’ augmented methods have been renamed from <code>set</code> to <code>$set(index, value)</code> and <code>remove</code> to <code>$remove(index | value)</code>. The prefix better differentiates them from native methods. The <code>replace</code> method has been removed.</li>\n<li>When iterating over an Object with <code>v-repeat</code>, the object no longer gets a <code>$repeater</code> array. Instead, the object is now augmented with two methods: <code>$add(key, value)</code> and <code>$delete(key)</code>, which will trigger corresponding view updates.</li>\n<li><code>v-if</code> now creates and destroys a child ViewModel instance when the binding value changes, instead of simply removing/inserting the DOM node. In addition, it can no longer be used with <code>v-repeat</code>. Use <code>v-show</code> or the new built-in array filters instead.</li>\n<li><code>v-with</code> can no longer be used alone. It now must be used with either <code>v-component</code> or <code>v-view</code>. <code>v-component</code> can also be used as an empty directive just to create a child VM using the default <code>Vue</code> constructor.</li>\n<li>Production build now strips all warnings and debug logs. To leverage <code>debug: true</code>, use the development version. The development version now has more detailed warning messages.</li>\n</ul>\n<h3 id=\"Fixed\"><a href=\"#Fixed\" class=\"headerlink\" title=\"Fixed\"></a>Fixed</h3><ul>\n<li><code>event.stopPropagation()</code> and <code>event.preventDefault()</code> inside <code>v-on</code> handlers now work as expected.</li>\n<li><code>parent</code> option now works properly when used in <code>Vue.extend</code></li>\n<li>Mustache bindings inside <code>&lt;textarea&gt;</code> are now properly interpolated before being set as value.</li>\n</ul>\n<h3 id=\"Internal\"><a href=\"#Internal\" class=\"headerlink\" title=\"Internal\"></a>Internal</h3><ul>\n<li><code>v-component</code>, <code>v-with</code> and <code>v-if</code> have been re-written for a cleaner compile flow.</li>\n<li><code>v-repeat</code> has been re-written to use refined diff algorithm which triggers minimum DOM manipulations when the array is set to a different instance containing overlapping elements. This makes it efficient to pipe an Array through filters.</li>\n<li><code>template</code> option now directly clones native <code>&lt;template&gt;</code>‘s content when available.</li>\n<li>Overall performance improvements for both initialization and rendering.</li>\n</ul>\n","excerpt":"<p>Vue.js 0.10.0 (Blade Runner) has been released! This release comes with many useful additions based on the suggestions from the users, notably interpolation in literal directives, dynamic components with the new <code>v-view</code> directive, array filters, and the option to configure interpolation delimiters. Internally, the codebase has received many refactoring and improvements which makes Vue.js <a href=\"http://vuejs.org/perf/\">even faster</a>.</p>","more":"<p>See the <a href=\"/guide/installation.html\">Installation</a> page for the latest builds.</p>\n<h3 id=\"New\"><a href=\"#New\" class=\"headerlink\" title=\"New\"></a>New</h3><ul>\n<li>Literal directives can now contain interpolation tags. These tags will be evaluated only once at compile time. An example usage is conditionally decide which component to instantiate with <code>v-component=&quot;{{type}}&quot;</code>. <a href=\"/guide/directives.html#Literal_Directives\">Doc</a>.</li>\n<li>Attributes listed in the <code>paramAttributes</code> option now accept mustache interpolations too. They will also only be evaluated once.</li>\n<li><code>v-repeat</code> now accepts an argument which will be used as the identifier for the wrapped object. This allows more explicit property access in repeaters. <a href=\"/guide/list.html#Using_an_Identifier\">Doc</a>.</li>\n<li>Added <code>v-view</code> directive which binds to a string value and dynamically instantiate different components using that string as the component ID. <a href=\"/api/directives.html#v-view\">Doc</a>.</li>\n<li>Added <code>filterBy</code> and <code>orderBy</code> filters for <code>v-repeat</code>. <a href=\"/api/filters.html#filterBy\">Doc</a>.</li>\n<li>Custom filters that access properties on its <code>this</code> context will be considered <strong>computed filters</strong>. <a href=\"/guide/custom-filter.html#Filter_Context\">Doc</a>.</li>\n<li>You can now access the event in <code>v-on</code> handler expressions as <code>$event</code>. Example: <code>&lt;a v-on=&quot;click:handle(&#39;hello&#39;, $event)&quot;&gt;Hello&lt;/a&gt;</code></li>\n<li>Interpolation delimiters can now be customized via the <code>delimiters</code> global config option. Example: <code>Vue.config({ delimiters: [&quot;[&quot;, &quot;]&quot;] })</code> will change the matched interpolation tags to <code>[[ ]]</code> for text bindings and <code>[[[ ]]]</code> for html bindings.</li>\n</ul>\n<h3 id=\"Changed\"><a href=\"#Changed\" class=\"headerlink\" title=\"Changed\"></a>Changed</h3><ul>\n<li><code>{{>yield}}</code> syntax has been deprecated. A Web Components spec compatible content insertion mechanism using <code>&lt;content&gt;</code> elements has been introduced. <a href=\"/guide/components.html#Content_Insertion\">Doc</a>.</li>\n<li>To use a component as a custom element, the component ID must now contain a hyphen (<code>-</code>). This is consistent with the current custom element spec draft.</li>\n<li><code>v-repeat</code> Arrays’ augmented methods have been renamed from <code>set</code> to <code>$set(index, value)</code> and <code>remove</code> to <code>$remove(index | value)</code>. The prefix better differentiates them from native methods. The <code>replace</code> method has been removed.</li>\n<li>When iterating over an Object with <code>v-repeat</code>, the object no longer gets a <code>$repeater</code> array. Instead, the object is now augmented with two methods: <code>$add(key, value)</code> and <code>$delete(key)</code>, which will trigger corresponding view updates.</li>\n<li><code>v-if</code> now creates and destroys a child ViewModel instance when the binding value changes, instead of simply removing/inserting the DOM node. In addition, it can no longer be used with <code>v-repeat</code>. Use <code>v-show</code> or the new built-in array filters instead.</li>\n<li><code>v-with</code> can no longer be used alone. It now must be used with either <code>v-component</code> or <code>v-view</code>. <code>v-component</code> can also be used as an empty directive just to create a child VM using the default <code>Vue</code> constructor.</li>\n<li>Production build now strips all warnings and debug logs. To leverage <code>debug: true</code>, use the development version. The development version now has more detailed warning messages.</li>\n</ul>\n<h3 id=\"Fixed\"><a href=\"#Fixed\" class=\"headerlink\" title=\"Fixed\"></a>Fixed</h3><ul>\n<li><code>event.stopPropagation()</code> and <code>event.preventDefault()</code> inside <code>v-on</code> handlers now work as expected.</li>\n<li><code>parent</code> option now works properly when used in <code>Vue.extend</code></li>\n<li>Mustache bindings inside <code>&lt;textarea&gt;</code> are now properly interpolated before being set as value.</li>\n</ul>\n<h3 id=\"Internal\"><a href=\"#Internal\" class=\"headerlink\" title=\"Internal\"></a>Internal</h3><ul>\n<li><code>v-component</code>, <code>v-with</code> and <code>v-if</code> have been re-written for a cleaner compile flow.</li>\n<li><code>v-repeat</code> has been re-written to use refined diff algorithm which triggers minimum DOM manipulations when the array is set to a different instance containing overlapping elements. This makes it efficient to pipe an Array through filters.</li>\n<li><code>template</code> option now directly clones native <code>&lt;template&gt;</code>‘s content when available.</li>\n<li>Overall performance improvements for both initialization and rendering.</li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}